diff --color --strip-trailing-cr -NBbaur squashfs-tools/compressor.c squashfs-tools-patched/compressor.c
--- squashfs-tools/compressor.c	2014-03-09 13:31:58.000000000 +0800
+++ squashfs-tools-patched/compressor.c	2022-01-01 15:08:47.861171447 +0800
@@ -25,6 +25,9 @@
 #include "compressor.h"
 #include "squashfs_fs.h"
 
+// CJH: Added these includes
+#include "error.h"
+
 #ifndef GZIP_SUPPORT
 static struct compressor gzip_comp_ops =  {
 	ZLIB_COMPRESSION, "gzip"
@@ -65,6 +68,9 @@
 extern struct compressor xz_comp_ops;
 #endif
 
+extern struct compressor lzma_alt_comp_ops;
+extern struct compressor lzma_wrt_comp_ops;
+extern struct compressor lzma_adaptive_comp_ops;
 
 static struct compressor unknown_comp_ops = {
 	0, "unknown"
@@ -74,6 +80,10 @@
 struct compressor *compressor[] = {
 	&gzip_comp_ops,
 	&lzma_comp_ops,
+    // CJH: Added additional LZMA decompressors. Order is intentional.
+    &lzma_adaptive_comp_ops,
+    &lzma_alt_comp_ops,
+    &lzma_wrt_comp_ops,
 	&lzo_comp_ops,
 	&lz4_comp_ops,
 	&xz_comp_ops,
@@ -81,6 +91,19 @@
 };
 
 
+int lookup_compressor_index(char *name)
+{
+    int i;
+
+    for(i = 0; compressor[i]->id; i++)
+    {
+        if(strcmp(name, compressor[i]->name) == 0)
+            return i;
+    }
+
+    return -1;
+}
+
 struct compressor *lookup_compressor(char *name)
 {
 	int i;
@@ -135,3 +158,67 @@
 					compressor[i]->name, str);
 		}
 }
+
+// CJH: calls the currently selected decompressor, unless that fails, then tries the other decompressors
+int detected_compressor_index = 0;
+int compressor_uncompress(struct compressor *comp, void *dest, void *src, int size, int block_size, int *error)
+{
+    int i = 0, retval = -1, default_compressor_id = -1;
+
+    if(detected_compressor_index)
+    {
+        retval = compressor[detected_compressor_index]->uncompress(dest, src, size, block_size, error);
+    }
+
+    if(retval < 1 && comp->uncompress)
+    {
+        if(!detected_compressor_index) ERROR("Trying to decompress using default %s decompressor...\n", comp->name);
+        
+        retval = comp->uncompress(dest, src, size, block_size, error);
+        
+        if(!detected_compressor_index)
+        {
+            if(retval > 0)
+            {
+                ERROR("Successfully decompressed with default %s decompressor\n", comp->name);
+                detected_compressor_index = lookup_compressor_index(comp->name);
+            }
+            else
+            {
+                TRACE("Default %s decompressor failed! [%d %d]\n", comp->name, retval, *error);
+            }
+        }
+    }
+
+    if(retval < 1)
+    {
+        default_compressor_id = comp->id;
+
+        for(i=0; compressor[i]->id; i++)
+        {
+            comp = compressor[i];
+            
+            if(comp->id != default_compressor_id && 
+               comp->id != compressor[detected_compressor_index]->id && 
+               comp->uncompress)
+            {
+                ERROR("Trying to decompress with %s...\n", comp->name);
+                retval = comp->uncompress(dest, src, size, block_size, error);
+                if(retval > 0)
+                {
+                    //TRACE("%s decompressor succeeded!\n", comp->name);
+                    ERROR("Detected %s compression\n", comp->name);
+                    detected_compressor_index = i;
+                    break;
+                }
+                else
+                {
+                    TRACE("%s decompressor failed! [%d %d]\n", comp->name, retval, *error);
+                }
+            }
+        }
+    }
+
+    return retval;
+}
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/compressor.h squashfs-tools-patched/compressor.h
--- squashfs-tools/compressor.h	2014-05-10 12:54:13.000000000 +0800
+++ squashfs-tools-patched/compressor.h	2022-01-01 15:08:47.861171447 +0800
@@ -59,11 +59,14 @@
 }
 
 
+/* CJH: Needed more logic for compression auto-detection, no longer inlined
 static inline int compressor_uncompress(struct compressor *comp, void *dest,
 	void *src, int size, int block_size, int *error)
 {
 	return comp->uncompress(dest, src, size, block_size, error);
 }
+*/
+int compressor_uncompress(struct compressor *comp, void *dest, void *src, int size, int block_size, int *error);
 
 
 /*
diff --color --strip-trailing-cr -NBbaur squashfs-tools/error.h squashfs-tools-patched/error.h
--- squashfs-tools/error.h	2014-05-10 12:54:13.000000000 +0800
+++ squashfs-tools-patched/error.h	2022-01-01 15:09:54.537174190 +0800
@@ -30,14 +30,18 @@
 extern void progressbar_error(char *fmt, ...);
 extern void progressbar_info(char *fmt, ...);
 
-#ifdef SQUASHFS_TRACE
+// CJH: Updated so that TRACE prints if -verbose is specified on the command line
+extern int verbose;
+//#ifdef SQUASHFS_TRACE
 #define TRACE(s, args...) \
 		do { \
-			progressbar_info("squashfs: "s, ## args);\
+			if(verbose) progressbar_info("squashfs: "s, ## args);\
 		} while(0)
+/*
 #else
 #define TRACE(s, args...)
 #endif
+*/
 
 #define INFO(s, args...) \
 		do {\
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/COMMIT_EDITMSG squashfs-tools-patched/.git/COMMIT_EDITMSG
--- squashfs-tools/.git/COMMIT_EDITMSG	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/COMMIT_EDITMSG	2022-01-01 15:10:59.989176882 +0800
@@ -0,0 +1 @@
+after
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/config squashfs-tools-patched/.git/config
--- squashfs-tools/.git/config	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/config	2022-01-01 15:09:03.637172096 +0800
@@ -0,0 +1,5 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/description squashfs-tools-patched/.git/description
--- squashfs-tools/.git/description	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/description	2022-01-01 15:09:03.633172096 +0800
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/HEAD squashfs-tools-patched/.git/HEAD
--- squashfs-tools/.git/HEAD	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/HEAD	2022-01-01 15:09:03.633172096 +0800
@@ -0,0 +1 @@
+ref: refs/heads/master
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/hooks/applypatch-msg.sample squashfs-tools-patched/.git/hooks/applypatch-msg.sample
--- squashfs-tools/.git/hooks/applypatch-msg.sample	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/hooks/applypatch-msg.sample	2022-01-01 15:09:03.633172096 +0800
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
+test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
+:
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/hooks/commit-msg.sample squashfs-tools-patched/.git/hooks/commit-msg.sample
--- squashfs-tools/.git/hooks/commit-msg.sample	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/hooks/commit-msg.sample	2022-01-01 15:09:03.633172096 +0800
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/hooks/fsmonitor-watchman.sample squashfs-tools-patched/.git/hooks/fsmonitor-watchman.sample
--- squashfs-tools/.git/hooks/fsmonitor-watchman.sample	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/hooks/fsmonitor-watchman.sample	2022-01-01 15:09:03.633172096 +0800
@@ -0,0 +1,173 @@
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+use IPC::Open2;
+
+# An example hook script to integrate Watchman
+# (https://facebook.github.io/watchman/) with git to speed up detecting
+# new and modified files.
+#
+# The hook is passed a version (currently 2) and last update token
+# formatted as a string and outputs to stdout a new update token and
+# all files that have been modified since the update token. Paths must
+# be relative to the root of the working tree and separated by a single NUL.
+#
+# To enable this hook, rename this file to "query-watchman" and set
+# 'git config core.fsmonitor .git/hooks/query-watchman'
+#
+my ($version, $last_update_token) = @ARGV;
+
+# Uncomment for debugging
+# print STDERR "$0 $version $last_update_token\n";
+
+# Check the hook interface version
+if ($version ne 2) {
+	die "Unsupported query-fsmonitor hook version '$version'.\n" .
+	    "Falling back to scanning...\n";
+}
+
+my $git_work_tree = get_working_dir();
+
+my $retry = 1;
+
+my $json_pkg;
+eval {
+	require JSON::XS;
+	$json_pkg = "JSON::XS";
+	1;
+} or do {
+	require JSON::PP;
+	$json_pkg = "JSON::PP";
+};
+
+launch_watchman();
+
+sub launch_watchman {
+	my $o = watchman_query();
+	if (is_work_tree_watched($o)) {
+		output_result($o->{clock}, @{$o->{files}});
+	}
+}
+
+sub output_result {
+	my ($clockid, @files) = @_;
+
+	# Uncomment for debugging watchman output
+	# open (my $fh, ">", ".git/watchman-output.out");
+	# binmode $fh, ":utf8";
+	# print $fh "$clockid\n@files\n";
+	# close $fh;
+
+	binmode STDOUT, ":utf8";
+	print $clockid;
+	print "\0";
+	local $, = "\0";
+	print @files;
+}
+
+sub watchman_clock {
+	my $response = qx/watchman clock "$git_work_tree"/;
+	die "Failed to get clock id on '$git_work_tree'.\n" .
+		"Falling back to scanning...\n" if $? != 0;
+
+	return $json_pkg->new->utf8->decode($response);
+}
+
+sub watchman_query {
+	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
+	or die "open2() failed: $!\n" .
+	"Falling back to scanning...\n";
+
+	# In the query expression below we're asking for names of files that
+	# changed since $last_update_token but not from the .git folder.
+	#
+	# To accomplish this, we're using the "since" generator to use the
+	# recency index to select candidate nodes and "fields" to limit the
+	# output to file names only. Then we're using the "expression" term to
+	# further constrain the results.
+	if (substr($last_update_token, 0, 1) eq "c") {
+		$last_update_token = "\"$last_update_token\"";
+	}
+	my $query = <<"	END";
+		["query", "$git_work_tree", {
+			"since": $last_update_token,
+			"fields": ["name"],
+			"expression": ["not", ["dirname", ".git"]]
+		}]
+	END
+
+	# Uncomment for debugging the watchman query
+	# open (my $fh, ">", ".git/watchman-query.json");
+	# print $fh $query;
+	# close $fh;
+
+	print CHLD_IN $query;
+	close CHLD_IN;
+	my $response = do {local $/; <CHLD_OUT>};
+
+	# Uncomment for debugging the watch response
+	# open ($fh, ">", ".git/watchman-response.json");
+	# print $fh $response;
+	# close $fh;
+
+	die "Watchman: command returned no output.\n" .
+	"Falling back to scanning...\n" if $response eq "";
+	die "Watchman: command returned invalid output: $response\n" .
+	"Falling back to scanning...\n" unless $response =~ /^\{/;
+
+	return $json_pkg->new->utf8->decode($response);
+}
+
+sub is_work_tree_watched {
+	my ($output) = @_;
+	my $error = $output->{error};
+	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
+		$retry--;
+		my $response = qx/watchman watch "$git_work_tree"/;
+		die "Failed to make watchman watch '$git_work_tree'.\n" .
+		    "Falling back to scanning...\n" if $? != 0;
+		$output = $json_pkg->new->utf8->decode($response);
+		$error = $output->{error};
+		die "Watchman: $error.\n" .
+		"Falling back to scanning...\n" if $error;
+
+		# Uncomment for debugging watchman output
+		# open (my $fh, ">", ".git/watchman-output.out");
+		# close $fh;
+
+		# Watchman will always return all files on the first query so
+		# return the fast "everything is dirty" flag to git and do the
+		# Watchman query just to get it over with now so we won't pay
+		# the cost in git to look up each individual file.
+		my $o = watchman_clock();
+		$error = $output->{error};
+
+		die "Watchman: $error.\n" .
+		"Falling back to scanning...\n" if $error;
+
+		output_result($o->{clock}, ("/"));
+		$last_update_token = $o->{clock};
+
+		eval { launch_watchman() };
+		return 0;
+	}
+
+	die "Watchman: $error.\n" .
+	"Falling back to scanning...\n" if $error;
+
+	return 1;
+}
+
+sub get_working_dir {
+	my $working_dir;
+	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
+		$working_dir = Win32::GetCwd();
+		$working_dir =~ tr/\\/\//;
+	} else {
+		require Cwd;
+		$working_dir = Cwd::cwd();
+	}
+
+	return $working_dir;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/hooks/post-update.sample squashfs-tools-patched/.git/hooks/post-update.sample
--- squashfs-tools/.git/hooks/post-update.sample	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/hooks/post-update.sample	2022-01-01 15:09:03.633172096 +0800
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/hooks/pre-applypatch.sample squashfs-tools-patched/.git/hooks/pre-applypatch.sample
--- squashfs-tools/.git/hooks/pre-applypatch.sample	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/hooks/pre-applypatch.sample	2022-01-01 15:09:03.633172096 +0800
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+precommit="$(git rev-parse --git-path hooks/pre-commit)"
+test -x "$precommit" && exec "$precommit" ${1+"$@"}
+:
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/hooks/pre-commit.sample squashfs-tools-patched/.git/hooks/pre-commit.sample
--- squashfs-tools/.git/hooks/pre-commit.sample	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/hooks/pre-commit.sample	2022-01-01 15:09:03.633172096 +0800
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=$(git hash-object -t tree /dev/null)
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --type=bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/hooks/pre-merge-commit.sample squashfs-tools-patched/.git/hooks/pre-merge-commit.sample
--- squashfs-tools/.git/hooks/pre-merge-commit.sample	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/hooks/pre-merge-commit.sample	2022-01-01 15:09:03.633172096 +0800
@@ -0,0 +1,13 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git merge" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message to
+# stderr if it wants to stop the merge commit.
+#
+# To enable this hook, rename this file to "pre-merge-commit".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+        exec "$GIT_DIR/hooks/pre-commit"
+:
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/hooks/prepare-commit-msg.sample squashfs-tools-patched/.git/hooks/prepare-commit-msg.sample
--- squashfs-tools/.git/hooks/prepare-commit-msg.sample	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/hooks/prepare-commit-msg.sample	2022-01-01 15:09:03.633172096 +0800
@@ -0,0 +1,42 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples. The first one removes the
+# "# Please enter the commit message..." help message.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+COMMIT_MSG_FILE=$1
+COMMIT_SOURCE=$2
+SHA1=$3
+
+/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
+
+# case "$COMMIT_SOURCE,$SHA1" in
+#  ,|template,)
+#    /usr/bin/perl -i.bak -pe '
+#       print "\n" . `git diff --cached --name-status -r`
+# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
+#  *) ;;
+# esac
+
+# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
+# if test -z "$COMMIT_SOURCE"
+# then
+#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
+# fi
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/hooks/pre-push.sample squashfs-tools-patched/.git/hooks/pre-push.sample
--- squashfs-tools/.git/hooks/pre-push.sample	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/hooks/pre-push.sample	2022-01-01 15:09:03.633172096 +0800
@@ -0,0 +1,53 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local oid> <remote ref> <remote oid>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
+
+while read local_ref local_oid remote_ref remote_oid
+do
+	if test "$local_oid" = "$zero"
+	then
+		# Handle delete
+		:
+	else
+		if test "$remote_oid" = "$zero"
+		then
+			# New branch, examine all commits
+			range="$local_oid"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_oid..$local_oid"
+		fi
+
+		# Check for WIP commit
+		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
+		if test -n "$commit"
+		then
+			echo >&2 "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/hooks/pre-rebase.sample squashfs-tools-patched/.git/hooks/pre-rebase.sample
--- squashfs-tools/.git/hooks/pre-rebase.sample	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/hooks/pre-rebase.sample	2022-01-01 15:09:03.633172096 +0800
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up to date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+<<\DOC_END
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
+
+DOC_END
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/hooks/pre-receive.sample squashfs-tools-patched/.git/hooks/pre-receive.sample
--- squashfs-tools/.git/hooks/pre-receive.sample	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/hooks/pre-receive.sample	2022-01-01 15:09:03.633172096 +0800
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to make use of push options.
+# The example simply echoes all push options that start with 'echoback='
+# and rejects all pushes when the "reject" push option is used.
+#
+# To enable this hook, rename this file to "pre-receive".
+
+if test -n "$GIT_PUSH_OPTION_COUNT"
+then
+	i=0
+	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
+	do
+		eval "value=\$GIT_PUSH_OPTION_$i"
+		case "$value" in
+		echoback=*)
+			echo "echo from the pre-receive-hook: ${value#*=}" >&2
+			;;
+		reject)
+			exit 1
+		esac
+		i=$((i + 1))
+	done
+fi
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/hooks/push-to-checkout.sample squashfs-tools-patched/.git/hooks/push-to-checkout.sample
--- squashfs-tools/.git/hooks/push-to-checkout.sample	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/hooks/push-to-checkout.sample	2022-01-01 15:09:03.633172096 +0800
@@ -0,0 +1,78 @@
+#!/bin/sh
+
+# An example hook script to update a checked-out tree on a git push.
+#
+# This hook is invoked by git-receive-pack(1) when it reacts to git
+# push and updates reference(s) in its repository, and when the push
+# tries to update the branch that is currently checked out and the
+# receive.denyCurrentBranch configuration variable is set to
+# updateInstead.
+#
+# By default, such a push is refused if the working tree and the index
+# of the remote repository has any difference from the currently
+# checked out commit; when both the working tree and the index match
+# the current commit, they are updated to match the newly pushed tip
+# of the branch. This hook is to be used to override the default
+# behaviour; however the code below reimplements the default behaviour
+# as a starting point for convenient modification.
+#
+# The hook receives the commit with which the tip of the current
+# branch is going to be updated:
+commit=$1
+
+# It can exit with a non-zero status to refuse the push (when it does
+# so, it must not modify the index or the working tree).
+die () {
+	echo >&2 "$*"
+	exit 1
+}
+
+# Or it can make any necessary changes to the working tree and to the
+# index to bring them to the desired state when the tip of the current
+# branch is updated to the new commit, and exit with a zero status.
+#
+# For example, the hook can simply run git read-tree -u -m HEAD "$1"
+# in order to emulate git fetch that is run in the reverse direction
+# with git push, as the two-tree form of git read-tree -u -m is
+# essentially the same as git switch or git checkout that switches
+# branches while keeping the local changes in the working tree that do
+# not interfere with the difference between the branches.
+
+# The below is a more-or-less exact translation to shell of the C code
+# for the default behaviour for git's push-to-checkout hook defined in
+# the push_to_deploy() function in builtin/receive-pack.c.
+#
+# Note that the hook will be executed from the repository directory,
+# not from the working tree, so if you want to perform operations on
+# the working tree, you will have to adapt your code accordingly, e.g.
+# by adding "cd .." or using relative paths.
+
+if ! git update-index -q --ignore-submodules --refresh
+then
+	die "Up-to-date check failed"
+fi
+
+if ! git diff-files --quiet --ignore-submodules --
+then
+	die "Working directory has unstaged changes"
+fi
+
+# This is a rough translation of:
+#
+#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
+if git cat-file -e HEAD 2>/dev/null
+then
+	head=HEAD
+else
+	head=$(git hash-object -t tree --stdin </dev/null)
+fi
+
+if ! git diff-index --quiet --cached --ignore-submodules $head --
+then
+	die "Working directory has staged changes"
+fi
+
+if ! git read-tree -u -m "$commit"
+then
+	die "Could not update working tree to new HEAD"
+fi
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/hooks/update.sample squashfs-tools-patched/.git/hooks/update.sample
--- squashfs-tools/.git/hooks/update.sample	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/hooks/update.sample	2022-01-01 15:09:03.633172096 +0800
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to block unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --type=bool hooks.allowunannotated)
+allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
+allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
+allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/index squashfs-tools-patched/.git/index
--- squashfs-tools/.git/index	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/index	2022-01-01 15:10:59.989176882 +0800
@@ -0,0 +1,64 @@
+DIRC     1aÏıÿ3Tn÷aÏıÿ3Tn÷   %ê  ¤          F¬ÑYP‰M>£¹–\@X á LICENSE   aÏıÿ3Tn÷aÏıÿ3Tn÷   4c  ¤          Y]]×´G·Qté’ã¬ã!@—ıG LZMA/lzma465/7zC.txt      aÏıÿ3Tn÷aÏıÿ3Tn÷   4d  ¤          táÏs€ÒI‰ë ³z¢mâ-Xn LZMA/lzma465/7zFormat.txt aÏıÿ3Tn÷aÏıÿ3Tn÷   «  ¤          õçôâ¹"Æ¦ºA†‘{FÖ şš LZMA/lzma465/C/7zBuf.c    aÏıÿ3Tn÷aÏıÿ3Tn÷   ¬  ¤          DÅ½q‡œÊÜ¾Zs¤â”Èß#]L™ LZMA/lzma465/C/7zBuf.h    aÏıÿ3Tn÷aÏıÿ3Tn÷   £  ¤          EàÜø
+~-
+²9™È™Hd;f LZMA/lzma465/C/7zBuf2.c   aÏıÿ3Tn÷aÏıÿ3Tn÷   ­  ¤          «q–+,(ĞEbçŒ~æîÀÏ)	µLĞ LZMA/lzma465/C/7zCrc.c    aÏıÿ3Tn÷aÏıÿ3Tn÷   ®  ¤           Ü)ÎãÆx®'ş\ãŒ—v—X; LZMA/lzma465/C/7zCrc.h    aÏıÿ3Tn÷aÏıÿ3Tn÷   ¯  ¤          pšDÅšÀÉ÷PoÆtí&§{o]†Ö LZMA/lzma465/C/7zFile.c   aÏıÿ3Tn÷aÏıÿ3Tn÷   °  ¤          ûûïh7øi—¢o2ËdëÖ¡E´	æ LZMA/lzma465/C/7zFile.h   aÏıÿ3Tn÷aÏıÿ3Tn÷   ±  ¤          ‡†#*£Aû—\ÈË*Ã÷±ú†† LZMA/lzma465/C/7zStream.c aÏıÿ3Tn÷aÏıÿ3Tn÷   ²  ¤           ş·ë#UHöJ•lv	(ÒåËT;± LZMA/lzma465/C/7zVersion.h        aÏıÿ3‘w÷aÏıÿ3‘w÷   ³  ¤          
+|5Š{Re¿Fû@©„àé¡)†MwĞ LZMA/lzma465/C/Alloc.c    aÏıÿ3‘w÷aÏıÿ3‘w÷   ´  ¤          %ÿiÊØ×j2²ËÛÙcw•¸ç‰ LZMA/lzma465/C/Alloc.h    aÏıÿ3‘w÷aÏıÿ3‘w÷   "Ğ  ¤          ü–&°>F'¬ZšAyRÌô m[Ò  LZMA/lzma465/C/Archive/7z/7z.dsp  aÏıÿ3‘w÷aÏıÿ3‘w÷   "Ñ  ¤          ò„Ë	b÷/İæOø»~„İds  LZMA/lzma465/C/Archive/7z/7z.dsw  aÏıÿ3‘w÷aÏıÿ3‘w÷   "Ë  ¤          ˆKúô*„a™5Ü¶ËÇçf¦‹t #LZMA/lzma465/C/Archive/7z/7zAlloc.c       aÏıÿ3‘w÷aÏıÿ3‘w÷   "Ì  ¤          7çRï.*}1KF%Ş"Ğ®¿´Ã #LZMA/lzma465/C/Archive/7z/7zAlloc.h       aÏıÿ3‘w÷aÏıÿ3‘w÷   "Î  ¤          zRo |S1<¾[“teÙÆ $LZMA/lzma465/C/Archive/7z/7zDecode.c      aÏıÿ3‘w÷aÏıÿ3‘w÷   "Ï  ¤          GáŸã‡Ñ²úŞf†	ğ· 	Q‡û $LZMA/lzma465/C/Archive/7z/7zDecode.h      aÏıÿ3‘w÷aÏıÿ3‘w÷   "Ò  ¤          	£ÿy€+Æ#¡N½¯Î(_Á×ÿõ %LZMA/lzma465/C/Archive/7z/7zExtract.c     aÏıÿ3‘w÷aÏıÿ3‘w÷   "Ó  ¤          M_xA_l¥)Q !Zœ´ß6• %LZMA/lzma465/C/Archive/7z/7zExtract.h     aÏıÿ3‘w÷aÏıÿ3‘w÷   "Ô  ¤           «äªHT<"d˜B
+bYË)™ $LZMA/lzma465/C/Archive/7z/7zHeader.c      aÏıÿ3‘w÷aÏıÿ3‘w÷   "Õ  ¤          *™A¶÷øm#vm¸jX+÷à&†¶@ $LZMA/lzma465/C/Archive/7z/7zHeader.h      aÏıÿ3‘w÷aÏıÿ3‘w÷   "Ö  ¤          usö?ƒ|è™÷.æ÷—LÕ€HÛÕ  LZMA/lzma465/C/Archive/7z/7zIn.c  aÏıÿ3‘w÷aÏıÿ3‘w÷   "×  ¤          |ÈC
+{“ä’fÚÜ¨W¶#èQR—ş  LZMA/lzma465/C/Archive/7z/7zIn.h  aÏıÿ3‘w÷aÏıÿ3‘w÷   "Ø  ¤          
+OÛDW»ı~êıúìK! "LZMA/lzma465/C/Archive/7z/7zItem.c        aÏıÿ3‘w÷aÏıÿ3‘w÷   "Ù  ¤          İŸfÍ´ÏRéÈïôù£@«|°uŸ< "LZMA/lzma465/C/Archive/7z/7zItem.h        aÏıÿ3‘w÷aÏıÿ3‘w÷   "Ú  ¤          í èÃ¦”-<XÌÁa­´ó²” "LZMA/lzma465/C/Archive/7z/7zMain.c        aÏıÿ3‘w÷aÏıÿ3‘w÷   "Û  ¤          àÇ»½I9¦Q.·#šZìÌ%130 "LZMA/lzma465/C/Archive/7z/makefile        aÏıÿ3‘w÷aÏıÿ3‘w÷   "Ü  ¤          l"ßÁC©û–Y‡L²5„Á¯çt &LZMA/lzma465/C/Archive/7z/makefile.gcc    aÏıÿ3‘w÷aÏıÿ3‘w÷   µ  ¤          b œåe˜tò)ÂFtûİ‹:şÂ LZMA/lzma465/C/Bcj2.c     aÏıÿ3‘w÷aÏıÿ3‘w÷   ¶  ¤          ~2ÔP³¹•\ß eOAêg$(§t LZMA/lzma465/C/Bcj2.h     aÏıÿ3‘w÷aÏıÿ3‘w÷   ¸  ¤          D^TiY-·#·ÇÈc-ı	e%9Ô. LZMA/lzma465/C/Bra.c      aÏıÿ3Î€÷aÏıÿ3Î€÷   ¹  ¤          &Eâ1èIivÏïµ"«<7¹AêÜÎ LZMA/lzma465/C/Bra.h      aÏıÿ3‘w÷aÏıÿ3‘w÷   ·  ¤          ˆàç	¸‡q·ğbúwúØ†¡§#C LZMA/lzma465/C/Bra86.c    aÏıÿ3Î€÷aÏıÿ3Î€÷   º  ¤          ÔNè[Çh*…%yÜ¶°îô¶ƒ LZMA/lzma465/C/BraIA64.c  aÏıÿ3Î€÷aÏıÿ3Î€÷   »  ¤          s„°Ã*éÄĞ¶ßñ³³ARó^`™Ô LZMA/lzma465/C/CpuArch.h  aÏıÿ3Î€÷aÏıÿ3Î€÷   ¼  ¤          L%4ôğ¥‚‹á~Xº†â‘ˆqtr LZMA/lzma465/C/LzFind.c   aÏıÿ3Î€÷aÏıÿ3Î€÷   ½  ¤          ”[œëıÿäş+~ÈÜãZ82ı| LZMA/lzma465/C/LzFind.h   aÏıÿ3Î€÷aÏıÿ3Î€÷   ¾  ¤          Vq´œ×k)M¤ç#ş¡ÒİtÏÀ÷ LZMA/lzma465/C/LzFindMt.c aÏıÿ3Î€÷aÏıÿ3Î€÷   ¿  ¤          	@,~F-Y'P³Zch=cm©WÎÍäÁ LZMA/lzma465/C/LzFindMt.h aÏıÿ3Î€÷aÏıÿ3Î€÷   À  ¤          ªŸAsçã2ò²Ñ™Œ1ŸuÆ•k LZMA/lzma465/C/LzHash.h   aÏıÿ3Î€÷aÏıÿ3Î€÷   Á  ¤          kØ~±‘N¤ñŠKÉzvA.N”‚Fì LZMA/lzma465/C/LzmaDec.c  aÏıÿ3Î€÷aÏıÿ3Î€÷   Â  ¤          Š˜Í¾””•İL³ükèh“øóTÒ LZMA/lzma465/C/LzmaDec.h  aÏıÿ4‰÷aÏıÿ4‰÷   Ã  ¤          õ‘:,®İŸW/ÉÌ¬Ó	æèÛÿÍ LZMA/lzma465/C/LzmaEnc.c  aÏıÿ4‰÷aÏıÿ4‰÷   Ä  ¤          ¿¼}+œ5»ÔÈUBvîzeÖVJ! LZMA/lzma465/C/LzmaEnc.h  aÏıÿ4‰÷aÏıÿ4‰÷   Å  ¤          Æ¥…|˜Š{¦ÕÌiH‡Í’Nù LZMA/lzma465/C/LzmaLib.c  aÏıÿ4‰÷aÏıÿ4‰÷   Æ  ¤          \îÇ<¢J®@0¶Ù¡$Ú!zØ LZMA/lzma465/C/LzmaLib.h  aÏıÿ4‰÷aÏıÿ4‰÷   "Ş  ¤           )‹Æ­Ù2†—K×†w7È#ypÿå[u "LZMA/lzma465/C/LzmaLib/LzmaLib.def        aÏıÿ4‰÷aÏıÿ4‰÷   "ß  ¤          ®;¦ÒTëx’`IîBuÅôa˜òìB "LZMA/lzma465/C/LzmaLib/LzmaLib.dsp        aÏıÿ4‰÷aÏıÿ4‰÷   "à  ¤          üo¯36^HPÈ»[Û8I?ÈIïñÌK "LZMA/lzma465/C/LzmaLib/LzmaLib.dsw        aÏıÿ4‰÷aÏıÿ4‰÷   "á  ¤          !„UEÛšcaTäU6•8y¢2ğ 'LZMA/lzma465/C/LzmaLib/LzmaLibExports.c   aÏıÿ4‰÷aÏıÿ4‰÷   "â  ¤          =k@Ì³H¢½ë¤È1ì8ÈŸY LZMA/lzma465/C/LzmaLib/makefile   aÏıÿ4‰÷aÏıÿ4‰÷   "ã  ¤           YH‘a«âË¤šÚÄ–005¼šÄ8 "LZMA/lzma465/C/LzmaLib/resource.rc        aÏıÿ4‰÷aÏıÿ4‰÷   $+ª  ¤          ø¸İ®,Qàêñ2fÖ¦!äúù #LZMA/lzma465/C/LzmaUtil/Lzma86Dec.c       aÏıÿ4‰÷aÏıÿ4‰÷   $+«  ¤          ë÷‚¡Ñ:[KÙ£
+al€Ó #LZMA/lzma465/C/LzmaUtil/Lzma86Dec.h       aÏıÿ4‰÷aÏıÿ4‰÷   $+¬  ¤          CïÈ£\…™}ÍÊi×5Üuí6¶ #LZMA/lzma465/C/LzmaUtil/Lzma86Enc.c       aÏıÿ4‰÷aÏıÿ4‰÷   $+­  ¤          •¾×Ş£òOº°@(§9¯¤ƒ #LZMA/lzma465/C/LzmaUtil/Lzma86Enc.h       aÏıÿ4‰÷aÏıÿ4‰÷   $+Ò  ¤          Ìm{
+ƒÌ‚‡à)Ésµ¾ô´ "LZMA/lzma465/C/LzmaUtil/LzmaUtil.c        aÏıÿ4‰÷aÏıÿ4‰÷   $+Ó  ¤          ú¬.n™FŸHò3VU¶®Z‰UF $LZMA/lzma465/C/LzmaUtil/LzmaUtil.dsp      aÏıÿ4‰÷aÏıÿ4‰÷   $+Ô  ¤          şÅ.¯m¤Å=X•÷2syÇ·Ñ $LZMA/lzma465/C/LzmaUtil/LzmaUtil.dsw      aÏıÿ4‰÷aÏıÿ4‰÷   $+Õ  ¤          Ÿû¹‹„æwT°F è6Š¢Uşæ¬  LZMA/lzma465/C/LzmaUtil/makefile  aÏıÿ4‰÷aÏıÿ4‰÷   $+Ö  ¤          ™ŸÍêÛ¯-Mø…³)U?ó`‹E¨ $LZMA/lzma465/C/LzmaUtil/makefile.gcc      aÏıÿ4‰÷aÏıÿ4‰÷   Ç  ¤          †Oİi°ÕÀ”y~”i¾Şó§­œV LZMA/lzma465/C/Threads.c  aÏıÿ4‰÷aÏıÿ4‰÷   È  ¤          ™¨#åxX ´¡ÜÇBø¨éq6A¯ LZMA/lzma465/C/Threads.h  aÏıÿ4‰÷aÏıÿ4‰÷   É  ¤          9õÏÄØhq@<ây£³•«©ºˆ LZMA/lzma465/C/Types.h    aÏıÿ4H’øaÏıÿ4H’ø   4g  ¤          	â[\¹1¥å•Aö±N>É2bèm<V LZMA/lzma465/Methods.txt  aÏıÿ4‰÷aÏıÿ4‰÷   4e  ¤          zA†q}¬÷Ÿ€…ázş„7	çÆ» LZMA/lzma465/history.txt  aÏıÿ4‰÷aÏıÿ4‰÷   4f  ¤          LÇqW’ÖÁvâìá™xÓu¬O²·hø LZMA/lzma465/lzma.txt     aÏıÿ4H’øaÏıÿ4H’ø   $+Ø  ¤          <ºÂ—ü÷Ä®uµë+ºgKÌ,f LZMA/lzmadaptive/7zC.txt  aÏıÿ4H’øaÏıÿ4H’ø   $+Ù  ¤          zVÿ|g“Æ¼ÌCéào§s9ìèğ LZMA/lzmadaptive/7zFormat.txt     aÏıÿ4H’øaÏıÿ4H’ø   $+Ş  ¤          ı!»0ÇÂ4Ÿ	µ’ê€æzU%gè¼ .LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zAlloc.c    aÏıÿ4H’øaÏıÿ4H’ø   $+ß  ¤          OL¤¥²Ù¹¬´¶·SõÚ”ÎT .LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zAlloc.h    aÏıÿ4H’øaÏıÿ4H’ø   $+à  ¤          Q<KqèıÄ'Uâ.&eõ;·zC /LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zBuffer.c   aÏıÿ4H’øaÏıÿ4H’ø   $+á  ¤          ¢å`ñ”ª0ÂCˆkşIy±º›É /LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zBuffer.h   aÏıÿ4H’øaÏıÿ4H’ø   $+ä  ¤          ‹—s„'0Ñbq«¾Hœ§3òS@ ,LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zCrc.c      aÏıÿ4H’øaÏıÿ4H’ø   $+å  ¤          F­ÌV:øëÌ>3 ˜½¼õ~D‰ ,LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zCrc.h      aÏıÿ4H’øaÏıÿ4H’ø   $+æ  ¤          ş´/ù'wFht>âû»ŸìiX‹nº /LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zDecode.c   aÏıÿ4H’øaÏıÿ4H’ø   $+ç  ¤          œt»İÉ»­ğ6yû6`üzGÃt /LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zDecode.h   aÏıÿ4H’øaÏıÿ4H’ø   $+è  ¤          nørÃi‡kÅBoÿ\æè às½ 0LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zExtract.c  aÏıÿ4H’øaÏıÿ4H’ø   $+é  ¤          é¤ûN=šì}ÇIïC†Í¿Ïv 0LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zExtract.h  aÏıÿ4H’øaÏıÿ4H’ø   $+ê  ¤           t;ä¼'ê¬[öï/(Í–ó‘73j4 /LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zHeader.c   aÏıÿ4H’øaÏıÿ4H’ø   $+ë  ¤          ùVª¦½ÄBvÒÕQ„ØÏO‡ÿr
+ /LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zHeader.h   aÏıÿ4H’øaÏıÿ4H’ø   $+ì  ¤          }w.êW.Ü•D­ï_ey=ZN +LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zIn.c       aÏıÿ4H’øaÏıÿ4H’ø   $+í  ¤          kkú*p“W7s!H§'Î3mÁ… +LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zIn.h       aÏıÿ4H’øaÏıÿ4H’ø   $+î  ¤          ‘*@€Pşª–hSu½Èé:òn -LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zItem.c     aÏıÿ4H’øaÏıÿ4H’ø   $+ï  ¤          ÷‡e9©Š 4Rx\¼•^Û^qøŸ -LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zItem.h     aÏıÿ4…›øaÏıÿ4H’ø   $+ğ  ¤          ÏÕÅí‘í<ed¢µØ./(ği!Ò -LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zMain.c     aÏıÿ4…›øaÏıÿ4…›ø   $+ñ  ¤           ùPG5Ÿ7^;ü¨(Š´Â×Ä¥¸c 1LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zMethodID.c aÏıÿ4…›øaÏıÿ4…›ø   $+ò  ¤          /Íº0±maë,ÅRaÒy¥ 1LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zMethodID.h aÏıÿ4…›øaÏıÿ4…›ø   $+ó  ¤          ıïXíöÃ©¾2‚rfÌ%Œ .LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zTypes.h    aÏıÿ4H’øaÏıÿ4H’ø   $+â  ¤          è‡ ££Ì¸ÎY‰¬†TÑ•Ö›> -LZMA/lzmadaptive/C/7zip/Archive/7z_C/7z_C.dsp     aÏıÿ4H’øaÏıÿ4H’ø   $+ã  ¤          öoÓ–!&…¥ë·š¸|ïÁ—Ş” -LZMA/lzmadaptive/C/7zip/Archive/7z_C/7z_C.dsw     aÏıÿ4…›øaÏıÿ4…›ø   $+ô  ¤          œâÃFÙÛÃp(=)åWºÁ¢Bô -LZMA/lzmadaptive/C/7zip/Archive/7z_C/makefile     aÏıÿ4…›øaÏıÿ4…›ø   $+õ  ¤          ‡!·ßG_2¤(Ûy"F¦ñSíŞY 1LZMA/lzmadaptive/C/7zip/Archive/7z_C/makefile.gcc aÏıÿ4…›øaÏıÿ4…›ø   $+÷  ¤          ¿Š N½\±Š«J`ÆnqÚˆÉ .LZMA/lzmadaptive/C/7zip/Common/FileStreams.cpp    aÏıÿ4…›øaÏıÿ4…›ø   $+ø  ¤          ò“&7*UH®x’^@
+²¶3­³‡ ,LZMA/lzmadaptive/C/7zip/Common/FileStreams.h      aÏıÿ4…›øaÏıÿ4…›ø   $+ù  ¤          ôò­ú·êBš[zjJ½ÉjHEï +LZMA/lzmadaptive/C/7zip/Common/InBuffer.cpp       aÏıÿ4…›øaÏıÿ4…›ø   $+ú  ¤          ş|ªY3¤íù¾†¯º›Ú )LZMA/lzmadaptive/C/7zip/Common/InBuffer.h aÏıÿ4…›øaÏıÿ4…›ø   $+û  ¤          —ôì0Ëœå2w|.‘‚\m ,LZMA/lzmadaptive/C/7zip/Common/OutBuffer.cpp      aÏıÿ4…›øaÏıÿ4…›ø   $+ü  ¤          ÒåN!æ!* lu…uïÀµ}a *LZMA/lzmadaptive/C/7zip/Common/OutBuffer.h        aÏıÿ4…›øaÏıÿ4…›ø   $+ı  ¤           †'§{K±€v,û]¤[¿ ©i  'LZMA/lzmadaptive/C/7zip/Common/StdAfx.h   aÏıÿ4…›øaÏıÿ4…›ø   $+ş  ¤          e¥Ù¬ğ´|ÜÒ 5ÏõÄİ¡¯›1 .LZMA/lzmadaptive/C/7zip/Common/StreamUtils.cpp    aÏıÿ4…›øaÏıÿ4…›ø   $+ÿ  ¤          .Yø‡3ö…¥E9ûb ÎNú ¯§÷ ,LZMA/lzmadaptive/C/7zip/Common/StreamUtils.h      aÏıÿ4…›øaÏıÿ4…›ø   $,  ¤          /KÕáƒ”V¡¯—!íqusÆ‹= /LZMA/lzmadaptive/C/7zip/Compress/Branch/ARM.cpp   aÏıÿ4…›øaÏıÿ4…›ø   $,  ¤           gUa)›Ï¾XÜç_HÀwÆmÎ­î -LZMA/lzmadaptive/C/7zip/Compress/Branch/ARM.h     aÏıÿ4…›øaÏıÿ4…›ø   $,  ¤          RûÒWj‚@Ä	ãv¢Î0Ç[Aõ¦½ 4LZMA/lzmadaptive/C/7zip/Compress/Branch/ARMThumb.cpp      aÏıÿ4…›øaÏıÿ4…›ø   $,  ¤           {`@¿Ìàu¼°>¬p°; ÈvÕ@ 2LZMA/lzmadaptive/C/7zip/Compress/Branch/ARMThumb.h        aÏıÿ4…›øaÏıÿ4…›ø   $,  ¤          .~¿‹E˜ğbfGááô¢ç¼h 3LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARM.c       aÏıÿ4…›øaÏıÿ4…›ø   $,  ¤           ¬Q@¡xá•i] dh È £Àok÷ 3LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARM.h       aÏıÿ4…›øaÏıÿ4…›ø   $,  ¤          ÓuÁ(/ÇÓR½÷PCè“Œ‰ 8LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARMThumb.c  aÏıÿ4…›øaÏıÿ4…›ø   $,	  ¤           Â{lÃ¶ıÊ¯HŠÃ»^ŸÀà 8LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARMThumb.h  aÏıÿ4…›øaÏıÿ4…›ø   $,
+  ¤          N%ğÕÏ¾r|7ß¤V¿08¹ 7LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchCoder.cpp   aÏıÿ4…›øaÏıÿ4…›ø   $,  ¤          ÚKS¶ËªU#¦•‰¥Í®SÒ€$b 5LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchCoder.h     aÏıÿ4…›øaÏıÿ4…›ø   $,  ¤          ÜUÀ?¤¨¤(‚¢äéPúoaã` 4LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchIA64.c      aÏıÿ4…›øaÏıÿ4…›ø   $,  ¤           °
+Ù‹¨;z°m¹ ÉAX~j€h¬¼G 4LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchIA64.h      aÏıÿ4…›øaÏıÿ4…›ø   $,  ¤          #ë:¯´!AíLÜşn––]cvh 3LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchPPC.c       aÏıÿ4…›øaÏıÿ4…›ø   $,  ¤           ®MÊJ'ƒ´ƒ´Ùà.‰/ß¹à 3LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchPPC.h       aÏıÿ4…›øaÏıÿ4…›ø   $,  ¤          ƒ¨ÓôÜ
+$£ŒpiÁ˜¹=ÑZí  5LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchSPARC.c     aÏıÿ4…›øaÏıÿ4…›ø   $,  ¤           ¶Úú@ÕZ1Æê¯€šÍÃ{ªd 5LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchSPARC.h     aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,  ¤          î,oi¥=HDäU9Í`Ç±e™†¡¶ 3LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchX86.c       aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,  ¤          x·!~Ø_f’‚ŞÂ¢+§ÃLt„§ 3LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchX86.h       aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,  ¤          6ußÜº22n^5b‡¡+£Bu„ 0LZMA/lzmadaptive/C/7zip/Compress/Branch/IA64.cpp  aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,  ¤           kçíØòÉ­åÉ	“7ñWœ°+ .LZMA/lzmadaptive/C/7zip/Compress/Branch/IA64.h    aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,  ¤          QzXS²a·‡;‹ŠàÙÎã: /LZMA/lzmadaptive/C/7zip/Compress/Branch/PPC.cpp   aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,  ¤           i ã4Dä…ÅÊ¢)!ÂWÀ9ÔZûå¯ -LZMA/lzmadaptive/C/7zip/Compress/Branch/PPC.h     aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,  ¤          WĞTê¯añöîàq1¬´vH>Ox 1LZMA/lzmadaptive/C/7zip/Compress/Branch/SPARC.cpp aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,  ¤           oà¦‚ïÕ¾T‡PØ3ï^¦Q††b¬ /LZMA/lzmadaptive/C/7zip/Compress/Branch/SPARC.h   aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,  ¤           cçûi†Ò¦ŞkêJ¦†y
+²Wû 0LZMA/lzmadaptive/C/7zip/Compress/Branch/StdAfx.h  aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,  ¤          z>B¶«KƒlNo1œ×jÜu×š /LZMA/lzmadaptive/C/7zip/Compress/Branch/x86.cpp   aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,  ¤          1Ğ9‚à^¼¨3LıÎ±ñªéZa3 -LZMA/lzmadaptive/C/7zip/Compress/Branch/x86.h     aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,  ¤          *T{ÿ!ršbÅÙøR5ØèÌ§Y 1LZMA/lzmadaptive/C/7zip/Compress/Branch/x86_2.cpp aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,  ¤          •=4ëşÅLÔ=[6Ã…°Ö0h /LZMA/lzmadaptive/C/7zip/Compress/Branch/x86_2.h   aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,&  ¤          ¼Ş¡§4Pš¤çšá¨ºÇRñ„­Á³ 5LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree.h     aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,!  ¤           Ÿ¬‚d*sô_iœt˜ï®ÉLNo÷D 6LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree2.h    aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,"  ¤           ÊöbÀæyÓ±Ñ¢ò!º²ÜÓÁ 6LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree3.h    aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,#  ¤           Æ`¥.‰dwÊæ‘S0ÉËF7—v 7LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree3Z.h   aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,%  ¤           ó~ÜÀ~ß=ë~{ç¿•Ç¨Ú" 6LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree4.h    aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,$  ¤          ?T4Ës=­pàä	a½ÓöÇ	Œ 7LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree4b.h   aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,'  ¤          *€!º|ÛäßM>şkõ®”M¦CÇÙİ 9LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTreeMain.h aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,-  ¤          ¨9;¸¯ê}`'Ÿ¬ÈŠš_6*3È 2LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC.h        aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,)  ¤           ‹éò.ÑêÑgªÚûøóşU‰÷ 3LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC2.h       aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,*  ¤           ²©¯ÒQ‹Ÿ”™7|°Ú…»©V 3LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC3.h       aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,,  ¤           Û¨ˆ(Õ‰ºT´yÍÏ;…°µ(± 3LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC4.h       aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,+  ¤          âß>ô¥ïŸs¶Ïß$@1¯E 4LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC4b.h      aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,.  ¤          !¦şgäõ¡hV-×´ê¼Ê5(Ğ– 6LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HCMain.h    aÏıÿ4Â¤øaÏıÿ4Â¤ø   $,/  ¤          ˆ»Bö
+ê­v´ìH8§œŒ/`UŞ“ 2LZMA/lzmadaptive/C/7zip/Compress/LZ/IMatchFinder.h        aÏıÿ4ÿ­øaÏıÿ4ÿ­ø   $,0  ¤          	©d’ˆbá o/ù¯Õ[{Ìó€À 2LZMA/lzmadaptive/C/7zip/Compress/LZ/LZInWindow.cpp        aÏıÿ4ÿ­øaÏıÿ4ÿ­ø   $,1  ¤          	|©Ës F6¼€ƒsZö„àº¸<Ó?… 0LZMA/lzmadaptive/C/7zip/Compress/LZ/LZInWindow.h  aÏıÿ4ÿ­øaÏıÿ4ÿ­ø   $,2  ¤           êâÖ«¡ãf´ÌƒãAÂ?Z+ìÍ 3LZMA/lzmadaptive/C/7zip/Compress/LZ/LZOutWindow.cpp       aÏıÿ4ÿ­øaÏıÿ4ÿ­ø   $,3  ¤          ŠS‡ı¸*<›í]´N(±MıFñ1 1LZMA/lzmadaptive/C/7zip/Compress/LZ/LZOutWindow.h aÏıÿ4ÿ­øaÏıÿ4ÿ­ø   $,:  ¤          õòêàAã††u‘î>·ˆÑ¡H 2LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat.h        aÏıÿ4ÿ­øaÏıÿ4ÿ­ø   $,5  ¤          %#³Êê0{~¨Ít$¼IÛe9ï 3LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat2.h       aÏıÿ4ÿ­øaÏıÿ4ÿ­ø   $,6  ¤          Jİ9cßWp%²*šÅ\nbÉ‹ 4LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat2H.h      aÏıÿ4ÿ­øaÏıÿ4ÿ­ø   $,7  ¤           ÿÒÒ‘Èîóí'ƒñ™äóF&´¾s 4LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat2R.h      aÏıÿ4ÿ­øaÏıÿ4ÿ­ø   $,8  ¤          Jj«xÈ482“I§Ô}Eµ 4LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat3H.h      aÏıÿ4ÿ­øaÏıÿ4ÿ­ø   $,9  ¤          JÇ™ÿïóõ<J³¸(ïÕ°Ös 4LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat4H.h      aÏıÿ4ÿ­øaÏıÿ4ÿ­ø   $,;  ¤          jƒñAømCnV`äI,Ñîåõ 6LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/PatMain.h    aÏıÿ4ÿ­øaÏıÿ4ÿ­ø   $,<  ¤           <?öØ¢Ÿîö…àr,i¾Ê–’Î ,LZMA/lzmadaptive/C/7zip/Compress/LZ/StdAfx.h      aÏıÿ5<¶øaÏıÿ4ÿ­ø   $,B  ¤          Ô{ÄÄ8¯<âH–^¥a.ƒ¨5ök ,LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMA.h      aÏıÿ4ÿ­øaÏıÿ4ÿ­ø   $,>  ¤          "SjJ2çåÑ×Ÿ«0áí¬[İ”Á 5LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMADecoder.cpp     aÏıÿ4ÿ­øaÏıÿ4ÿ­ø   $,?  ¤          Oî’õRïYFLZqW#{’Õv¸õGI 3LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMADecoder.h       aÏıÿ4ÿ­øaÏıÿ4ÿ­ø   $,@  ¤          ¤~ÓËUÔïf8á©xL,‹rqd›e£ 5LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMAEncoder.cpp     aÏıÿ4ÿ­øaÏıÿ4ÿ­ø   $,A  ¤          +ãL_\äîÜ¯%JuÁ·|çÄJl 3LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMAEncoder.h       aÏıÿ5<¶øaÏıÿ5<¶ø   $,C  ¤           cçûi†Ò¦ŞkêJ¦†y
+²Wû .LZMA/lzmadaptive/C/7zip/Compress/LZMA/StdAfx.h    aÏıÿ5<¶øaÏıÿ5<¶ø   $,E  ¤          9Vùóëiq‚EûÀWÎTüx2±$ 9LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsp aÏıÿ5<¶øaÏıÿ5<¶ø   $,F  ¤           ×H-ŠeW÷Wš Z{…	n•4¸ 9LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsw aÏıÿ5<¶øaÏıÿ5<¶ø   $,G  ¤          6På¡‘HÄE‡XAÜıd|áŞeìş 9LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaAlone.cpp aÏıÿ5<¶øaÏıÿ5<¶ø   $,H  ¤          1M!âxI~§ú÷B8$ñ.½ Ìß{ 9LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaBench.cpp aÏıÿ5<¶øaÏıÿ5<¶ø   $,I  ¤           Ñ¿>
+,ÍàZ/![ú1 ¬[Uç 7LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaBench.h   aÏıÿ5<¶øaÏıÿ5<¶ø   $,J  ¤          `	sØm]LoÇ9zeÅ°Íê¡. 7LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRam.cpp   aÏıÿ5<¶øaÏıÿ5<¶ø   $,M  ¤          vDÜ†\ö4æ1ò ‡¦Ìb2a 5LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRam.h     aÏıÿ5<¶øaÏıÿ5<¶ø   $,K  ¤          Íí„ÖÑX™8³ÈñS,×Õ® ;LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.c       aÏıÿ5<¶øaÏıÿ5<¶ø   $,L  ¤          b~dU9Ñ/Á UÔ‰ntµyK‹ ;LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.h       aÏıÿ5<¶øaÏıÿ5<¶ø   $,P  ¤           #Ğşê…Ç¼% Öz®—
+51n” 6LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/StdAfx.cpp    aÏıÿ5<¶øaÏıÿ5<¶ø   $,Q  ¤           cçûi†Ò¦ŞkêJ¦†y
+²Wû 4LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/StdAfx.h      aÏıÿ5<¶øaÏıÿ5<¶ø   $,N  ¤          \c¦:ä„·«Å(‰ÉX 3(Ş³Ñ 4LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/makefile      aÏıÿ5<¶øaÏıÿ5<¶ø   $,O  ¤          
+#B>Xù
+v„+\]Û}$-sT 8LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/makefile.gcc  aÏıÿ5<¶øaÏıÿ5<¶ø   $,S  ¤          =Ï!¿@½àeZl¡3óÊQ¶Hd®‚ÿ 4LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaDecode.c      aÏıÿ5<¶øaÏıÿ5<¶ø   $,T  ¤          Ú!0b¯ÃC­s²mû	zò; 4LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaDecode.h      aÏıÿ5<¶øaÏıÿ5<¶ø   $,U  ¤          G=½²ıÅÀ2#| e×†àY 8LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaDecodeSize.c  aÏıÿ5y¿øaÏıÿ5y¿ø   $,V  ¤          :\Íïá˜IÌ+öB6Ûí¡ 9LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaStateDecode.c aÏıÿ5y¿øaÏıÿ5y¿ø   $,W  ¤          ô'*±‰Ğaö! Lšº³ë ï 9LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaStateDecode.h aÏıÿ5y¿øaÏıÿ5y¿ø   $,X  ¤          ÿ]ôä8gPôã:Sê±g^Ko—·# 7LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaStateTest.c   aÏıÿ5y¿øaÏıÿ5y¿ø   $,Y  ¤           –ùZu;	Ö¦‹¯@ƒJ'ÆÍE‚¨ 2LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaTest.c        aÏıÿ5y¿øaÏıÿ5y¿ø   $,Z  ¤          Ï}j“¾o©rÑšœ2jèÃ—ôÍå; 0LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/makefile  aÏıÿ5y¿øaÏıÿ5y¿ø   $,[  ¤          ]›œ3¢®u'J6êƒëkWëÅy° 4LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/makefile.gcc      aÏıÿ5y¿øaÏıÿ5y¿ø   $,_  ¤          13õ©?ï“´V.9FI-Z…ZêfNO 2LZMA/lzmadaptive/C/7zip/Compress/LZMA_Lib/ZLib.cpp        aÏıÿ5y¿øaÏıÿ5y¿ø   $,]  ¤          Û+)
+€ #öß	e-Ñßd 7LZMA/lzmadaptive/C/7zip/Compress/LZMA_Lib/lzmadaptive.h   aÏıÿ5y¿øaÏıÿ5y¿ø   $,^  ¤          B™a³“Ÿ×ÁíZ²T >‚(şÔ 2LZMA/lzmadaptive/C/7zip/Compress/LZMA_Lib/makefile        aÏıÿ5y¿øaÏıÿ5y¿ø   $,d  ¤          «»²º‚ÓÁKÅM	`ìiõ>ëzñÊ 8LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoder.h  aÏıÿ5y¿øaÏıÿ5y¿ø   $,a  ¤          LM:õÄÆõx‹ğëÕ¿R =LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderBit.cpp     aÏıÿ5y¿øaÏıÿ5y¿ø   $,b  ¤          —bOˆ|”j´‡sYéd˜Hu3À ;LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderBit.h       aÏıÿ5y¿øaÏıÿ5y¿ø   $,c  ¤          ÄOx´éÜ¤ûûõòĞ{ÉÑr ?LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderBitTree.h   aÏıÿ5y¿øaÏıÿ5y¿ø   $,e  ¤          ¹f‹š[
+ U»¥‹PÉéîÒ¬Äs3 ;LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderOpt.h       aÏıÿ5y¿øaÏıÿ5y¿ø   $,f  ¤           ;¶7ı@Vƒvb¾Í<ÖĞOÑ ò0 4LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/StdAfx.h      aÏıÿ5y¿øaÏıÿ5y¿ø   $,g  ¤          UoÜ@k¸-œ€¦:*v ¦l=  LZMA/lzmadaptive/C/7zip/ICoder.h  aÏıÿ5y¿øaÏıÿ5y¿ø   $,h  ¤          ­»¢1X;×M¾ÈmŞ¶ğ9Õº?Ğ !LZMA/lzmadaptive/C/7zip/IStream.h aÏıÿ5y¿øaÏıÿ5y¿ø   $,j  ¤          	«â¸ÃÒ‰ãôƒPU
+;àà¸ƒÏÈ #LZMA/lzmadaptive/C/Common/Alloc.cpp       aÏıÿ5y¿øaÏıÿ5y¿ø   $,k  ¤          ÔDö1“ãÁJx:×N*ÿ !LZMA/lzmadaptive/C/Common/Alloc.h aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,q  ¤          5á¡‡Qp{’c$¨,áùBQLìE !LZMA/lzmadaptive/C/Common/CRC.cpp aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,r  ¤          kOykkYxäÛ<ñ;×_/–_ LZMA/lzmadaptive/C/Common/CRC.h   aÏıÿ5y¿øaÏıÿ5y¿ø   $,l  ¤          U} Ğ†*>±¢é#òfBÉ &LZMA/lzmadaptive/C/Common/C_FileIO.cpp    aÏıÿ5y¿øaÏıÿ5y¿ø   $,m  ¤          *Ğqg€{ñí‰N	k½8X> $LZMA/lzmadaptive/C/Common/C_FileIO.h      aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,p  ¤          „QS6/'97ÖÙÿ•»!àË!Ø‰ˆ "LZMA/lzmadaptive/C/Common/ComTry.h        aÏıÿ5y¿øaÏıÿ5y¿ø   $,n  ¤          u'£Ó…ªZYbÒtÑ`›Š>|’ /LZMA/lzmadaptive/C/Common/CommandLineParser.cpp   aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,o  ¤          ÂáşCD96­q®FÇ¿âï+… -LZMA/lzmadaptive/C/Common/CommandLineParser.h     aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,s  ¤          ¹ÚÓ®Ñ…À]¼)‰Ò›C\‹£  LZMA/lzmadaptive/C/Common/Defs.h  aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,t  ¤          ´éI0¡^ÁM½±ÂOD9!·dŞ !LZMA/lzmadaptive/C/Common/MyCom.h aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,u  ¤          :,•Oêé¢ÿ?Ã
+)Ï$ †&6m %LZMA/lzmadaptive/C/Common/MyGuidDef.h     aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,v  ¤           ¶[ßîÕdÌ¢w#à²…Hó€ÆJÏ &LZMA/lzmadaptive/C/Common/MyInitGuid.h    aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,w  ¤          "Ò…BV=_vùq¶¯°¢.,‰ %LZMA/lzmadaptive/C/Common/MyUnknown.h     aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,x  ¤          ğmğoŒ%C•¾Á¥
+<Û–£Ö %LZMA/lzmadaptive/C/Common/MyWindows.h     aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,y  ¤          ’™”)|ÌÖz‰ı<v‡óTU=Åj… (LZMA/lzmadaptive/C/Common/NewHandler.cpp  aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,z  ¤           ¿‘­4ÂÄ·IÊv«°ë÷CÅ« &LZMA/lzmadaptive/C/Common/NewHandler.h    aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,{  ¤           ohé5n­ÂùNêXLÏíÛ>) "LZMA/lzmadaptive/C/Common/StdAfx.h        aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,~  ¤          »y!şA£«k§X'H÷àMk]EµÙ $LZMA/lzmadaptive/C/Common/String.cpp      aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,  ¤          8ãÄ'|#YñJ:éäî_ÉP”Âà0 "LZMA/lzmadaptive/C/Common/String.h        aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,|  ¤          	ÖĞ]lı\…™bw m:Áğ>•‰- +LZMA/lzmadaptive/C/Common/StringConvert.cpp       aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,}  ¤          „dŒ (-•êíCŒ+†©îje )LZMA/lzmadaptive/C/Common/StringConvert.h aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,€  ¤          R¨ï!„ÕCZRKÑô‰x/¹Ù )LZMA/lzmadaptive/C/Common/StringToInt.cpp aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,  ¤          »—bsıx‘ó¿©wsgâµNÖí 'LZMA/lzmadaptive/C/Common/StringToInt.h   aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,‚  ¤          gönk•áU§j\â’`ç5L !LZMA/lzmadaptive/C/Common/Types.h aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,ƒ  ¤          †Ë=‡RmZ…¬1Ë	¥ÍR Ëàx¦ $LZMA/lzmadaptive/C/Common/Vector.cpp      aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,„  ¤          3˜OİÁ«mÍº^”VnlyçüeTıx "LZMA/lzmadaptive/C/Common/Vector.h        aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,†  ¤          ›Àa‡f¬NÜäØ;<ÿS¿ !LZMA/lzmadaptive/C/Windows/Defs.h aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,‡  ¤          + =èC$ãîñÌ•çƒ1éÔËú %LZMA/lzmadaptive/C/Windows/FileIO.cpp     aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,ˆ  ¤          HDÌÂÌQçæÊÑDF
+­& #LZMA/lzmadaptive/C/Windows/FileIO.h       aÏıÿ5¶ÈùaÏıÿ5¶Èù   $,‰  ¤           €ç’LÊ[7ñ’Ö-…ÖÕ*ô—Yš #LZMA/lzmadaptive/C/Windows/StdAfx.h       aÏıÿ5óÑùaÏıÿ5óÑù   $,Š  ¤          :yê$¼x&¥‘èíûöşª@#1½ LZMA/lzmadaptive/CPL.html aÏıÿ5óÑùaÏıÿ5óÑù   $,Œ  ¤          gLL8}CïÍcƒ¼Åì×§\/åä LZMA/lzmadaptive/LGPL.txt aÏıÿ5óÑùaÏıÿ5óÑù   $,  ¤          ±4á¥©#¸\¥Ã~ÄCVù€‹»g LZMA/lzmadaptive/Methods.txt      aÏıÿ5óÑùaÏıÿ5óÑù   $,‹  ¤          "¬9qP˜V1%¤uÁ¿DÊıä\6 LZMA/lzmadaptive/history.txt      aÏıÿ5óÑùaÏıÿ5óÑù   $,  ¤          UœG"C‰¢º…š‡éN,!j LZMA/lzmadaptive/lzma.txt aÏıÿ5óÑùaÏıÿ5óÑù   $,  ¤          N‡ t{áÕEğ‘’0‘á¸0 LZMA/lzmalt/7zlzma.c      aÏıÿ5óÑùaÏıÿ5óÑù   $,‘  ¤          ‘ÎÜ•ÛtùyšØ ># oÇì² LZMA/lzmalt/AriBitCoder.h aÏıÿ5óÑùaÏıÿ5óÑù   $,’  ¤          MŒf>m`a*&êYü›hãÔc“ë© LZMA/lzmalt/BitTreeCoder.h        aÏıÿ5óÑùaÏıÿ5óÑù   $,“  ¤          ŸÀ€ğ’÷÷xXÃ8Vç"0 v LZMA/lzmalt/IInOutStreams.c       aÏıÿ5óÑùaÏıÿ5óÑù   $,”  ¤          üi«ó—üQ`.šOşN©ËFÇ LZMA/lzmalt/IInOutStreams.h       aÏıÿ5óÑùaÏıÿ5óÑù   $,™  ¤          ˜6ƒ(Æ~ƒ`¡%3ù¦_Œöl6¦³ LZMA/lzmalt/LZMA.h        aÏıÿ5óÑùaÏıÿ5óÑù   $,—  ¤          6Êá. W]w©2pôi–H:	yyÕ LZMA/lzmalt/LZMADecoder.c aÏıÿ5óÑùaÏıÿ5óÑù   $,˜  ¤          dvúSk—}jÒ;w‘ÑCÆ¥ LZMA/lzmalt/LZMADecoder.h aÏıÿ5óÑùaÏıÿ5óÑù   $,•  ¤          è@U+…uŒx×	9=^Ì4wêÍ- LZMA/lzmalt/LenCoder.h    aÏıÿ5óÑùaÏıÿ5óÑù   $,–  ¤          d+pÙ’[R’¢Ÿz{Ò•Bú¢–}~ LZMA/lzmalt/LiteralCoder.h        aÏıÿ5óÑùaÏıÿ5óÑù   $,›  ¤           £~wr‚ƒÎµîè”	UD^©¾× LZMA/lzmalt/Makefile      aÏıÿ5óÑùaÏıÿ5óÑù   $,œ  ¤          “i0»Øªè)D½¤¢TÌå3ƒ© LZMA/lzmalt/Portable.h    aÏıÿ5óÑùaÏıÿ5óÑù   $,  ¤          Iò`«B¯Õ¥ÓGšf]tˆH0ÅF LZMA/lzmalt/RCDefs.h      aÏıÿ5óÑùaÏıÿ5óÑù   $,  ¤          ä®o—GÜ[ğÈ\¦
+ÆÇµöjĞßS? LZMA/lzmalt/RangeCoder.h  aÏıÿ5óÑùaÏıÿ5óÑù   $,   ¤          \²}Ù‹ d5Ş²#3Í.ÃD LZMA/lzmalt/WindowOut.h   aÏıÿ5óÑùaÏıÿ5óÑù   $,š  ¤           òŞ\µë‰5ï9]a
+m¦¬õ´ LZMA/lzmalt/lzmalt.h      aÏıÿ5óÑùaÏıÿ5óÑù   $,Ÿ  ¤          !ä~å{ò†²¤½h‡Œ,4£äß‚^v LZMA/lzmalt/vxTypesOld.h  aÏş}#Õ:,aÏş}#Õ:,   %Ö  ¤  è  è  %‰Ñ– ˆUM[Fm0|ıl´(mkNÏY Makefile  aÏıÿ60ÚùaÏıÿ60Úù   %å  ¤          3\˜J##áZ nO ©J¡y™ 	README.md aÏıû#[GSm°õ       %ä  ¤  è  è  Å×5ªs?1yhA{Ùå¯ÃsC action.c  aÏıû#˜HSm°õ       %í  ¤  è  è  °Y-£÷‚Èõ®ûgWÆËÜÄ… action.h  aÏıû#˜HSm°õ       %ü  ¤  è  è  =ÜzÕNáW„Ÿœ)´«#=õ¨•Û caches-queues-lists.c     aÏıû#[GSm°õ       %Ù  ¤  è  è  ñÄÜòƒ‘o–7Uæÿ@ÄÔ+ñ caches-queues-lists.h     aÏıÿ3Tn÷aÏıÿ3Tn÷   &  ¤  è  è  Ï>Ç¥CX
+ÖÅ0W³Qw>Yf compressor.c      aÏıÿ3Tn÷aÏıÿ3Tn÷   %Û  ¤  è  è  jDÒrø˜!l¸¶óÁ›W+¢¢‹ compressor.h      aÏşB  ®aÏşB  ®   &  ¤  è  è  íˆ˜F³gúàË¤^ŒZÔêÃ error.h   aÏıû#[GSp;A       %Ú  ¤  è  è  2TjXrg~0e5ØTÒ%"&q8 gzip_wrapper.c    aÏıû#˜HSpÙ       %ù  ¤  è  è   F>ŸGaVÀ’}²óˆ}ßá†OÔ gzip_wrapper.h    aÏıû#[GSm°õ       %è  ¤  è  è  ™yhÇyk,œfs›]M/ûfş’ info.c    aÏıû#˜HSm°õ       &  ¤  è  è  õ¼ğ:!6™‘ÏÜÊ¨imo±,£ info.h    aÏıû#˜HSüÎ       %î  ¤  è  è  å¸|ş¿rš„Ş2šN¤^ZFP¦ lz4_wrapper.c     aÏıû#˜HSüÎ       %õ  ¤  è  è  ÖcŠZÀ¿÷kM£}B“/µ”Êš´ lz4_wrapper.h     aÏıÿ60ÚùaÏıÿ60Úù   &  ¤  è  è  7ÑæÂ¶$½Gİ²*…%r²04_ lzma_wrapper.c    aÏıû#[GSüÏ       %Ó  ¤  è  è  ‡U¦2ç#ûpR¸¡ë©1OKæt lzma_xz_wrapper.c aÏıû#[GSüÏ       %Ü  ¤  è  è  /Œ›ùWcò§gyìçáşüC¾í lzo_wrapper.c     aÏıû#˜HSüÏ       %û  ¤  è  è  Ğ€NSÀ_+Ëå¾a–ét¬Uü1 lzo_wrapper.h     aÏıû#[GSqH¬       %Ş  ¤  è  è P§†ø+¹(UÃ/ú
+Û^ş‰Â…… mksquashfs.c      aÏıû#˜HSm°õ       &   ¤  è  è  ’9~Ày¼kë%¢HÆX]Tw mksquashfs.h      aÏıÿ60ÚùaÏıÿ60Úù   %á  ¤  è  è  'õy+)9¶[«I|Û?Æ~gÇÈ
+] process_fragments.c       aÏıû#˜HSm°õ       %ò  ¤  è  è  øokß-òj{òéCFÖ?4Ã<Eƒšú process_fragments.h       aÏıû#[GSm°õ       %â  ¤  è  è   ˜zE±`ƒÓZ,hº­óíòûµS progressbar.c     aÏıû#[GSm°õ       %İ  ¤  è  è  ³³;6{/Ó>0ÚÚLy`XH¢ progressbar.h     aÏıû#˜HSm°õ       %ö  ¤  è  è  ,¼ø_æàë¬{RëV	vê¯ğÛ pseudo.c  aÏıû#˜HSm°õ       %ı  ¤  è  è  sÀÙöô‹(‘4Ò¦Ğ pseudo.h  aÏıû#˜HSüÏ       %ô  ¤  è  è  ƒ"pZ 7Œ]şüyÌs}67§ Æ read_file.c       aÏıÿ60ÚùaÏıÿ60Úù   %ú  ¤  è  è  q‘ûğ‡òëÌjÔ¥+ÈX¯D×8 	read_fs.c aÏıû#˜HSüÏ       %ñ  ¤  è  è  †šÓ,b©È;Ó²bbj
+Ä¹§ƒ 	read_fs.h aÏıû#˜HSüÏ       %ó  ¤  è  è  (@BoVÑ}t€d½óë³m¨#>¾ read_xattrs.c     aÏıû#[GSm°õ       %Ñ  ¤  è  è  $^3k5Rs0¾ëŠÊ	ÿ a,Ñ; 	restore.c aÏıû#˜HSm°õ       %ÿ  ¤  è  è  Ç5Ÿ	kÜYªlP:+N 	restore.h aÏıû#˜HSm°õ       &  ¤  è  è  %,‰ßC…·¸ØÏ‰a‡4µÉ7lî( sort.c    aÏıû#˜HSüÏ       %ø  ¤  è  è  ¿˜ÛbÄù+&-UyßÃZˆüÿÄG sort.h    aÏıû#[GSm°õ       %æ  ¤  è  è  fóƒ°'ÍD%xN… s«7%^Ëq squashfs_compat.h aÏıÿ60ÚùaÏıÿ60Úù   &  ¤  è  è  6l)ÔÄ^
+Ùû¬k½Ksxï™ŠÛ squashfs_fs.h     aÏıû#˜HSm°õ       %ş  ¤  è  è  Oéñ¾ÏÎôWÒ ¬ÇÕ>å8€½y%ò~ squashfs_swap.h   aÏıû#[GSüÏ       %ã  ¤  è  è  	¿EÈËÁe0©[GTcv<)° swap.c    aÏıû#˜HSüÏ       %ï  ¤  è  è  &ÀÂçÓŠ2"bf¨Òuf"å€½ unsquash-1.c      aÏıû#[GSüÏ       %Õ  ¤  è  è  ü+ş†HëÚ…Ã`†Ù‰œ·Å€>* unsquash-2.c      aÏıû#˜HSüÏ       %ğ  ¤  è  è  ,’Õ¯W¡ç=9º fvÀn8Ç˜…Òæ unsquash-3.c      aÏıû#[GSüÏ       %ë  ¤  è  è  ,ìÚ¬yo	†<º[½P,‹¡ÌÔÆ unsquash-4.c      aÏşR%CiDaÏşR%CiD   &  ¤  è  è 5Éçù0 Ñ˜{±^Kì£™FÊIQ unsquashfs.c      aÏıÿ60ÚùSqH»       %ì  ¤  è  è Z#İo,¹Êï„²FÍ¦M	<ø unsquashfs.c.orig aÏıû#[GSm°õ       %à  ¤  è  è  ìĞ»FŞhâí´}ªN`9Œ @w·æ unsquashfs.h      aÏıû#[GSüÏ       %ß  ¤  è  è  [Èâ¹²Ë§o»ó3®$ã”d unsquashfs_info.c aÏıû#[GSm°õ       %Ò  ¤  è  è  ø^ı|Ê=E¥×½Æ]Lï6\» unsquashfs_info.h aÏıû#[GSüÏ       %é  ¤  è  è  ¢Yôªà¨¦ãıÑî9Y©b luU unsquashfs_xattr.c        aÏıû#[GSm°õ       %Ô  ¤  è  è  I´ePÎÌ„1ÆÁuÓé[ã xattr.c   aÏıû#[GSm°õ       %×  ¤  è  è  )’`%TKs¸=ò¥\¼ëLnï½ù;– xattr.h   aÏıû#[GSüÏ       %ç  ¤  è  è  5®ç~Å–’ÁQæ,RûV]…©âíX xz_wrapper.c      aÏıû#[GSüÏ       %Ø  ¤  è  è  YÎ%EÂ)ØP|9
+ÁşãÊQvï&é xz_wrapper.h      TREE  x 305 1
+ñ1ü‰æ´DÁ6Q±Ìô~n“¤lLZMA 251 3
+½²zÃ‚¹ˆC»£)x)s5^#*ŠËlzmalt 17 0
+ö(b™®Pv?ZÌwğºq5HLWlzma465 69 1
+<†ß5Â,°ãBÌÔ°¦N,ëºiøC 64 3
+şÊ·Â.SÖWÃ`(¼V	!¹ Archive 17 1
+5v5;‡îšŸïG¡:š’„—[7z 17 0
+5\šoİ5W…¼ËÆáúŸCŠLzmaLib 6 0
+¿—j¶™’-¥êş„òáä¦Ÿ¹%/LzmaUtil 9 0
+ÕhUö9®Ä'.à(	ùíÀ÷¼lzmadaptive 165 1
+gÓóKlœİıĞrùÿ€Ubn¯ÔC 158 3
+_ñöÅµUï­ô<m†P[êÕCL7zip 127 3
+-/ú]gIğŞº¤¥)åxiCommon 9 0
+Zél3—±ÉşL ÎöıFpñArchive 24 1
+q[²8fjJ÷¿Cie§Y7šìªr7z_C 24 0
+nú7Õh°¿ƒXì¨0¿’ÖÆõ¥TCompress 92 7
+¼Eãd1¨«½±W-™Ë¥êš²>Ã<LZ 26 3
+”Úúö3"º9}„’š{qêH·BinTree 7 0
+&›I­d•?Ç²$eIÖbB¬ıPatricia 7 0
+wñ9óâ¬Õb1S/vë¬ì3³o,HashChain 6 0
+P<>ÎĞsøxìÎ??å›¦ïhÊ³ôLZMA 6 0
+åÉä[/J"öRÊò²ÍV_/ÿMBranch 29 0
+İ%ëN·¡üİøgÖüiwÚ©K|6LZMA_C 9 0
+>R‚Œ\m†ÈZ¥?¸m9LZMA_Lib 3 0
+HÔÅÛœHğ®_‡wÎÑÆ½ıMÕLZMA_Alone 13 0
+Ê¶i`¹wn%¶İ­v@™ˆ¿RangeCoder 6 0
+	=ù™Ú¯lhŒŞË„+î ¤öCommon 27 0
+ƒøõ*Ã^¦š€:TüÅTÍ@ö_äWindows 4 0
+«¨¤™Z3	a“ËöÉQù&òœD+©`4ºeù/IB·ºCw
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/info/exclude squashfs-tools-patched/.git/info/exclude
--- squashfs-tools/.git/info/exclude	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/info/exclude	2022-01-01 15:09:03.633172096 +0800
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/logs/HEAD squashfs-tools-patched/.git/logs/HEAD
--- squashfs-tools/.git/logs/HEAD	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/logs/HEAD	2022-01-01 15:10:59.989176882 +0800
@@ -0,0 +1,3 @@
+0000000000000000000000000000000000000000 f35fc649caa663f20768b1bc6a979d59b26f733a river-li <lizic0228@gmail.com> 1641020980 +0800	commit (initial): before
+f35fc649caa663f20768b1bc6a979d59b26f733a ba91dd0078ae6c323ba5e91c5ab4a76e20ccf058 river-li <lizic0228@gmail.com> 1641021024 +0800	commit: after
+ba91dd0078ae6c323ba5e91c5ab4a76e20ccf058 5ef72270f72986e27fbe07a7a34c5ab685d83d18 river-li <lizic0228@gmail.com> 1641021059 +0800	commit: after
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/logs/refs/heads/master squashfs-tools-patched/.git/logs/refs/heads/master
--- squashfs-tools/.git/logs/refs/heads/master	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/logs/refs/heads/master	2022-01-01 15:10:59.989176882 +0800
@@ -0,0 +1,3 @@
+0000000000000000000000000000000000000000 f35fc649caa663f20768b1bc6a979d59b26f733a river-li <lizic0228@gmail.com> 1641020980 +0800	commit (initial): before
+f35fc649caa663f20768b1bc6a979d59b26f733a ba91dd0078ae6c323ba5e91c5ab4a76e20ccf058 river-li <lizic0228@gmail.com> 1641021024 +0800	commit: after
+ba91dd0078ae6c323ba5e91c5ab4a76e20ccf058 5ef72270f72986e27fbe07a7a34c5ab685d83d18 river-li <lizic0228@gmail.com> 1641021059 +0800	commit: after
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/00/dc29cee3c678ae27fe5ce38c10977697583b13 squashfs-tools-patched/.git/objects/00/dc29cee3c678ae27fe5ce38c10977697583b13
--- squashfs-tools/.git/objects/00/dc29cee3c678ae27fe5ce38c10977697583b13	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/00/dc29cee3c678ae27fe5ce38c10977697583b13	2022-01-01 15:09:15.593172588 +0800
@@ -0,0 +1 @@
+x…Q]kÂ0İs~ÅEa´bµZ†ƒ¡«ÕÜnhHÓ¨.‘6Šó×/íêĞÁX^.¹çƒs¸qªb¸ñ:WíôAÆZp^¯Œ¦l—R-”D]×½u\Ïéx(Z«&tŸª=šìâT0HÔm„êb%¾BzoÄøGT7!ùùÊĞ$Kw	‡û\'omú…¶ZÖğç–ç­M!~Ğ<“0‹¤6‘ÖÄdÄ4Nùûâ¡½	<ÍÉĞŸbøã1xÄ%Ï¨æ%Í*(¶¡B‘¢ç“WîaX½|b2ˆFá[,c6XßcyÆ·/³ÉÀÇ!y˜ã° 6!6¢³¬?VlÛp]ú,`y2î÷áÖ¶ªJş.4Û&¦U¡¥?S2×PÖo6!GNt9Lİ?œsQë?-ªs™ˆú¤ü£‚
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/01/3e42b6ab4b836c8e4e6f311f9cd76adc75d79a squashfs-tools-patched/.git/objects/01/3e42b6ab4b836c8e4e6f311f9cd76adc75d79a
--- squashfs-tools/.git/objects/01/3e42b6ab4b836c8e4e6f311f9cd76adc75d79a	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/01/3e42b6ab4b836c8e4e6f311f9cd76adc75d79a	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,4 @@
+x½Á
+‚@E[ÏW<
+¢B²*l•VPµu(ÉŒÌŒfEÿZÔ¾İã¼s/×‹¹ÆdÚĞuÈ§ã¾Ÿ$„´"æÇ)Ehîy?lÖX© F£ü"õòëe	—ùá©l."‡5SÆlËŞ8E³d>§(LsŸz«(V(:ÖU!ô¨«\ŞºŒnØ%w P¥‚i–a›³…ê¼ÜRÒÀñÒ @±ãRƒ¶“Ì¶®<î
+»3òø²ÀÿOTS0zA
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/01/4186717dacf79f801c85e17afe843709e7c6bb squashfs-tools-patched/.git/objects/01/4186717dacf79f801c85e17afe843709e7c6bb
--- squashfs-tools/.git/objects/01/4186717dacf79f801c85e17afe843709e7c6bb	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/01/4186717dacf79f801c85e17afe843709e7c6bb	2022-01-01 15:09:15.609172588 +0800
@@ -0,0 +1,6 @@
+xµXínÛÈío=ÅEÅÚˆ)K´lÙ*º€-ÛYm;°´İ?E¬iøÕ!iÙ^ìCözîR¢(™I[”0”ˆâ\ŞsÏ=3³0™Ñ‰{rò‡Ÿ'ÓûÛ»¿S2§|¡èã¯ŸÎizù—³ûêtİ“cZ_n¯wæô\§wôÖÇé84M"E‘Csı¬²:ZÛ!:uú®sÔÿ/õi¦rÏZ³†úÛîÑ=¢¤c:¿™Nœ±ıRùI -½L<F6;™“Šù—€²Ü(/’üÄ˜"ÍUp@A¹ÎOŠ0 Ï÷U–Q¤¢Ä¼XHŠ<ÓâD{a˜ø–‘ñâGÕ­òã/økVsiøJ•C:Î•™{°ËÏWu"QânÀ«¸‚i1µOAy:îÚ<÷šéáTŸıGy¶–ÏvYú¾D72*\INû>÷²œü$J2§“˜"d7¶ÓYË¤d¶‘N6–1ÜŒg`ÀË8c·ãÓ-çŞqkŞ‚†QK£ó\Áo@:K
+¤¹ô«—Ã{)R}q)gAÇ~X0”òdUH.êøı{ûFq²äêş£@^–ÆKS 2yÂGi–*nöÑû¨ï¶6İv™÷¯Ê…v]bpFH1Uèä€k®M”"Ø™uşBK/lŞÇ‡ÿªCeÊäÈ:=üµ'¿ø—Á–îØf$Ç&'§¬HÓÄä]Œ!/ø_}¢W2Çgñ3š,ôÌ#’™£çh@.ºo=şî##ó¯(·¢{©w°¯Ğãœ1U•NªÆwÙoÏøı„÷¬ ?2I” in’ˆ†Î«N™!Ş£wĞ Ë§‡¿A{‘ÿÇÂ•ov7á…×;ıöÒmBÀê.l²deMentN<xÔ@GçôÛ¬‘xi-#X:šğy:ÛdqFeù³°%uSòLœ0£ü<|YU«³˜± ÿy< ÈË}0æÙ±çDó…?Ø_E6Ü$°Î Õk-İ5OIN–í¥@àÏŠãÅA`Ô?§‡›Û‡«¿¯>ßOno¦x à
+ĞÂ’Şã-'0¸[¨Ò»¢îÊ¡f7Úóÿ;+%–Áf,€Šë¸ÃÖXÆµÎ³|Í|QNh£şYh£"ƒK¸…ë}ºT ;p6Æ~¦‚jø2=ûà"ÃL_ü·„lDÀÆ]Ü»üqÄ[ŒFK¡Ÿ ¡Ú'ò/Ş“·…_Hµæ°Ö{›ëC½ïK&¯áfÍ‚­0sD\8+3™ÂáÑÌ [[áÌg”aD I8q+Ş~òÂ8/R…îJ‚*ĞÁÀğõaL{Ã×IÜõ÷7›y’sæ:g-uxm”¢yû2{-³z>Gåâ¼*rš$!¦AŒrÇ ²G!'fòe²ñØiLİÄ|•ØWœÀTÏN„ã2Ê]£AéBâeÎJ üÀršöÆ?to®î«úÙ`* Es‡´÷%Xî³Iœ9îwˆá_&—ÙáZV=*°µC;@Ô“©èÖîBfèd
+Ä#7Ú'±ıe4ºS^ åáÀ3‚RI0çøîgÏäHŒ¬–İyµÎÎF®ëÆB¹-+¹gßú²ñB´‚²…¯‘gYfª_U×ßDƒ0 úÃäæa|!RàA¾ß~¹¸»:¿$IGI‰Ëæ0ŞUkqûdíuY¸İ>üVÜ-øÚf®áîU–w}.tî“NŠ¬‚+Öºì³M5†ØW •'yâïõöÉ¨¼0qF=›†, lN·Iìp–}XvÒÚÛb&Øë·sGÍµÑßÊú´µÔ“ÕöFø·.ËáB{k0-—øF¯İ¨%yA ™¼°Ê*ú]¶D­¾†zæ„ú+³{¹¹²û+Ôjš£íË»F´dó¾ß¼ov½µškèí,F%ıí jO#gA={Q‚1ÇîÎ?9?á£>Ğ6eèˆåh¡÷¢¢÷¬z–ÕÏ§'X¨ızZî¼h#üİOÓZ"pgGÚÖw«¤9sØ/§;"é]õlØßn¼£o»â‹½RGíí(Ë¾¤€·øMÊ VŒ!”‚>l=àpmY~cçÚØ´ò`Ùªo¡w¤óÁÑ3ì†ÁK”ı³2¢9oA#o(´jW‰áÊ’Vğlkeibhhr-ë|~‘…úqÁò8cJ’@qW¶Qëu]Ÿã‘İ‡ÕZõ½1s ®’¶x¶ºéçó»1BŞäJ¢«EvM5`­±ùÚˆn{“h§p¹Ç–Nê5°õC«v¯°gŸİŞqcàHNµ«tÿ˜ƒšCÖˆ„š¤(KyRrQ;Š€¹õ…a‡N·İ¡iRŸE?ÒV³³j}z@“sçbóüî“|8÷‹"šq9yö|N0ÿ>×I­´ë.9ï³GtB„ÌŸö¬®ÜóÛ$Ö.ó$„ÏCÇm§£O­çõSûŠÆ0ã]Ò·ïİZryæë;DEí
+5]‚NŒP“§Jü³=]‚R+ó²fb–oë}A¶H–™aÜ¶"UZã<Ì ±K\(iá™`ÉÇLÊ˜¤:êè5F¨¢}„r+HO”ˆ:´MÉ4‚rK»ã8‘³ÉçŞ,Te ìº³¾œ½Ğ‡ñ›ú¨ãâÙõ3NáŒè[ˆÃ)Z rl‡ù@ ƒ<õà’œzò-N´ŠÙ–˜¸ê@‡tÇše(¬#/^rvœ¨Ë—üï7ù$2óÓÕsn<~&£?SÿOÕ/"x¨÷|}moınÁÒØåØˆÚÏ"o~Ôy içÀµã4|—jch ŞSõNGPÅVñÛİcu¦WÛá&Ê¸¤ÀúõU©”!ÈË‡jIå´xj7Xİ?;ƒÒƒğàR=©0IÙ.“<¸r u*aUy°<‰U6êT±€€z£í¥«^b¦:¿jôx7´èZœÕæ<$Ğ(ù0ÀŠNç
+ÉJü‚ıìü‘"ó
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/01/6d7b04010a830fcc8287e02903c973b5bef4b4 squashfs-tools-patched/.git/objects/01/6d7b04010a830fcc8287e02903c973b5bef4b4
--- squashfs-tools/.git/objects/01/6d7b04010a830fcc8287e02903c973b5bef4b4	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/01/6d7b04010a830fcc8287e02903c973b5bef4b4	2022-01-01 15:09:15.605172588 +0800
@@ -0,0 +1,16 @@
+x•XmSÛÊîg~Å¹tl0„—4õÂbLâ	ØŒm’IhF#ì5h®-¹’œ–ş{ŸsÎ®´2¦éÍLy÷¼>çUº™&7ôúàUó//7éüÇ,¼Ê£éÎˆ¶·ih²œÂù|Â<Jbš$)½8¡Q2›§&Ëp¸¶¿»ÛÜŞÛÛŞ? 7Ô¹Éeø}š|Ç¯ËÅxiœÌÂ(¦Í—kk›I
+Zıa0h·®úí Û>Ÿô»îû¢x4]Œeù8Jvî«GÓèfù,â[>+	×wv^L§Éhçn½zúgÑÔ¬8şdRöæÉ#rj
+âóv,çk£$P£»0¥Í?Zaœ÷M8¾ <á­¡·´#Š“œRSÏ9M`ÅúáSÎÏi”›¬ÿæsJùÿb—Ã•ü!£+š™Y’Ş/«>ó°¦Iê©æ32|êµ,G
+Œè{isğCTÕô×¼AYôÃ¹üW§šÃëù!üÍiL÷JÍDõCz¬Èü8K)%©Èp<æôòd]Ü»ğÄt¬5tˆè~ {ÖÀóÑ#\Ñ—È–üƒ™Îk¯›ÅdbÒúÚÃQ–§À¨¦GZÿg,ÉÎå÷´N_‚Oíş Óë­Şå—~çı‡apz2l3í:$ğ<^qäßM‘$td~5ìœ{6ˆüXò('4ØL<JP œ"«(Æohl|ŠúáÚãÚÜ"qNâXñ®z-3t¦‰ùœËÂş†Ö!õ	"uÅ ,6è{+Œê.f7&]2mĞ7}§Ö9Çgbc@[“©‰íïºE,„Kc`õ·ÿ@oƒj‹8‹nc3®³$6oµW™IŸâ£ª-‡‡a‘D$MÍEÌfa<fW¹ëfnğîê,t¾¶©¶GGG´÷º^Üö®†«®] h1ğg¿Ö²ı†6¹àLƒ:ó¯Ş"äh3ÚDĞG½éÄî"²OÉÂ«Nœ¿~E‹xşpİI‚säw&5ŒQ) Î‘Ğoø©Œõšğ×·÷Ëw÷hQün1¹ö<ıÆ0ËŒâ;ßO¹´]!Š/“ºvbõâ\öœY¿ƒNå5ñ]TóÄ©ÖAñ EªYo­8¾t×TªğLeü§ßéö>‚]AÛ>æ>]üdëàFƒ^¨•u1€Ù
+TÎcEŸ„ÍÊé`‡Ì’&#TšÃsëö¶JªR2©"m[G›Q:‹â(»»ĞQ<¾•ÁœuºÁ‡à¤û¥Â3@2-2ÿçnJ?^¼u…1Ç•üa J”©JŠÌ¿ëe:9-„FöŒ•íî©£RL‰l €'`s9¡Å1LMIüBĞ,BĞ|µØ^	)È$„Úì†gn›¥˜oqì
+g¬Í\\úJİm	m¯¦°N2ş É¨I,&ûÇÛÇ²”tÎuW?u.[5¨Q´¿Á× İï÷úÁç~gØv0[GPšîÊ3c ÙÑûH?VRÅsó-”ÊmõJÂê¡IÌFËIçËz°ŒãRªÂ[ÈC:O†W›ÿíÓàsgø!¸8é,{Š
+F÷‰ó¼¸õ×¬ä¹İ³Jì@^Ã®ıÙö¬}øI{f#¸9Güà:
+·L¬-DÅP`ŒaW¿Có2éú;İ ?g”Lt7Ÿ§ÉÜ¤y„#L*j–×Œ1İÛÑ•¸9óJNˆ¤ÎNİ`Uìµ€zÙï]t¬mQ=ÔĞÌmSdÏÃ43ÖYï]‹ÅĞêØ.,5Y•¯+c2©éÏ:7[1¥˜F6)e DEtDÍCŠ¶¶4¨^
+¢İìzÖèOæZD›ÔTu®Á´x=J£¼&m [*lÑaáHdµú–¢a½nhö•@¡“Ø=Tç‡v27ŞU¼Ô®–½ŒD™í¯¢D¿Ó,{¯c,„³…~¥-¥'^M0 ştz6È¦&/ŸÜÑ±:ÊkMšiæJ*Bø¤vY¬ª~Æò³£@×œgÄÉˆÃÆrGOõl¶½CTĞÂjÃÀ:ÜX
+¼P­Å:[t´‹ö…Èe˜ EÔéöğB”
+†Š¾%	†Gí<cÉˆ“#³ê„Öö;Î¯üµÎ³)Å5ÁT\LxÿQ:Æİã¶T&†Ú"¦ªqÒçÙ<­]µQÂÖR²ø…¡Ê‹Ñ3uAÖë’kkëLªñºV¯¹àÒñ1Õš(‡Èí:•‘´bö8{JÁ2¼Ÿâ§&‡»–7~Ì43B¤øj¨—±gL=™SZbWŒM¿~ºWççeù•O1mãºiBVpŠ¯iro“Á&ß×R…qôøSÆ>–ÆœâÅì$½ÍªoW!N®¿=)~İóš"š½Ö?gE‹/{nàa^ŞIõI±FÀÄü€o|ò.I¦´ÈX
+ôg!p–YRmËíÓ0¼™¢èœ!“^3t—;\€š˜¤°uIVaùJaÅ­'óÍÂÈëÀ^Ywå{:Z»X´;ÙUĞî4s÷ğ’â~Ó+ş‰óÛ£eï›äªè(„‰šò­PtA2·'Ët½+5^âÍu„û·´a6X‡>·7ÄJvè7ëÍˆw”ñ¯:ú|º¡óËf×36<ˆÓ¶³ä¯ –Ÿ12¹Eì[PÜ}³zÿú•½gƒÀ¼ÉMÕ_EAß‹Säózù¾«ºÍFƒ¾ãèwbI™Ş ©$ñm(~û
+º]}‡=uîûz_Œä.>qÁ…¥(ÓA™"•|¦©Í
+[VÍ<kÙAÅ²g¡¨ØA¾q¼â‹
+ÍÍ+[’
+ï3qåˆ”Rº³4y5çŞ÷&?7ñm~÷ã\˜<ol´µí¶µSò+‘v’µ~8¶&²°:GàæJÒ½¥V•äáş»/|¹[y6r%±‚"µ¦I†ŞSÚÇöŸ½¢û0vlrXŞKJôÜê²˜:XTésÑ•µn³³Ÿ>-’ETO(¿3üBêò×Ô_‰”éø™üYÙÿ8ü+™ıöÉéÿ!’—óªãOj´«_í¸1 ÑËÙbéĞÑx"áãhë´İ:—	ù«©Û¤L·4»nîîòzò€÷ÁGÎ{;ëp¤ÓÖvu­Ü"gçú©Ğf°µ&²Eÿm:“4
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/02/526f0e207c538d313c8f17be5b93747f65d9c6 squashfs-tools-patched/.git/objects/02/526f0e207c538d313c8f17be5b93747f65d9c6
--- squashfs-tools/.git/objects/02/526f0e207c538d313c8f17be5b93747f65d9c6	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/02/526f0e207c538d313c8f17be5b93747f65d9c6	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1,13 @@
+xÅYûoIŞŸù+êv%k @xd³Ñ9Fò+.¶Aku‹,„‡!3ÌX3ƒ/koş÷ûª«»§g€ØûÖ›M »ºú«¯]İ¾YÆ7ôÓoŞ~÷ºF?=~<š>5¤>‡ÑgZ$ñ
+s´ˆ—ó ©tZ­wv»ÑéÒ?©ÿ9Nh8{XÆø6\ß,CŸæñjFT{]©üFşr=è}š%PÖ¼í9ƒß7›¯ñçÈÿo§yû}.lÆ“Ù¶á³ÇÕàŠS;ôT~˜‹0
+ènzßÿJ-gàì—óCj}é¶Ú­¶3|tüoŒ¶ºø¯İê':v¦}T©¤Ù,ƒ£Ë ¥‘&ŒyÇ£Çc—ô£EL5æ1©ÓU?ÊŞ¾¡0…Aúgq|×FYÌVTÃ°úT¯~~ÍªÅëìh½Xğb^3&èÅ£ÇÃå2ö©6ãÎÁqµò„¥ÇšblÁ>FºhôËtği¿‚A-N"8cígŞZPå—ı‹Á'Ïˆ¨} k˜Ä7©«“²©ÑÃà}ÚœÏ²Y¼u”†Ÿ£`^-L¦ÊÚ¦ÚBmÖœƒ¼6J¬ä½í†ØT™çO<k0õ£ĞAŒ‰BÏÛß¯âãş7†Ô@ÅÅÕÙ¯‡~hšf´÷³Û`6Ç¤×¦÷ï©ıN#
+äåÓ=í/ÖÌ?ùŠ²ªxTôÑÆ™;ÙóâpN5“©U÷Ä:íYÅVöí6àár§|hL…‹aÔ@á?HÓ@Y¥«VmÀö0æ0°ã« &:ejGˆ™uªæ×vF,2ÌKUÇ'¡ocÁF¥±ÅAR'Î²é‡şEôqzzqSyÿuªít)m¸FhB/í˜„·¶ÑD¤‰·±S]³éÀ¡Á„Úo¿‘ç@g™ííYâœ%`®j<ò¤CCBÇîb´Âš ÂÖìØFìbª0Â˜S´Æ‡ã«‘fïôdúsüqz~xù	°
+µÏÊÏÿstZ\>¸+>ï+>Fy8½¼\NOÇ‡†ı‘_õ¶²Ât£7ºï·Ä¹C§õ7ûâY—ñ>_İJõ!	J%(/)Œ5	²u±%û,d7”K3 Ş«p¹Kuıßm¸8H8¹¨G­¼àHŠ«ê¤8¿N”ğÖ:c&ËUÆŒo¯1RŸsî_\c´ÚªSbìNˆFĞšJı‹!‚ætğA[+DÚ²]GÒ"Øq&ˆ©Z»§WfJä	­WÈpÙ¬!evQÛp˜äpùpƒïÍ‘ßM¯.FWÃáàrŒä9?œx«*yürL÷Hq;ÀiWİ¥áxprzéùP°]µß<²ÛxŞ?©r®ûÍ‹õª¯k¾Jê¶à$WgŒ¶¼LÑƒ¨}r‚—{“?­¹³Kug»î7vxuEuÇ·7ZßßÇIÌ?¨ŞĞó¹µ tBòjÉ!NÿE£jT‹”Î^Ş 0Ö£7¹s¥49å¨ae%_ˆ“ MÔOZ×ºÔ½@UÊ;ÏïöpcßiğÎ0ödwqy×f…Ñ|8åí‰V2®Ú\Åä2ÎN'Ñ1”ÓĞ¾æ˜Äzùflüà;¦”ÖLâ•î¼Äúf?êGóà‹»CaQeşznT =)p/ˆ–MÏÄV§Hªå½Ã®ã¯kâÏuçÖ`v}ë¸€yãtùu¦µ‡8wwI´U8¾ı†DGI”½èîÒµ!íî‚,¶®dœİÒv²?BS£0_ˆƒŠÚ…€Rµ© ó®¢²Mù‚"F^D„yW‘Ê1Ngêˆ+À’dí7áÌÒmÉ¿‚l´^éÚ©Çj³å:HåÙíà´E2I-Õéz…¶¾Å{ñËğgu)
+Õ…(³já>…¯^Imåe8›Eı$¼æ5'¦ÔQZ¸ÚâÜP5İàºçBˆFĞ6‹½:ä2»ë¦knÄèÕ’õ¾úº³`undr3>|EƒK(ØÄô=Q«®ş|eû‹"]C«ÜÇµn=
+iiY¶òBÂ­–ñ„¯]ßëçÜFqÌà"¿ù„ 0{¢ÖŸ½¦ä¹¶é{·iBø£[ÄöÖIiwx?ÙÕP*`•jÄÓE¼X¤AÆ4ñéæÌ ûpq¼N 9v¯÷¼N(Æ0°2üÅ(Qg­
+ ‡ ¶F79Z‹±âî;vëÔSI¹”÷´h×‘‰Z@3d^ÙÁt¢•%üZ )£º0£èfGÚ²à‚2ï0Æ(ÖY0ÚSDTsD®$ëw¤QZs9É^ƒ±\YÎOÏ]EFxâ˜j_=çLÕß½AÕdª¯6Ê†hàvr“=­Eş(X‹ÌëTš´©Àg¯•¹âïÌPêÈä»ç&š)Q°LÕr¦ìò›”s‰KœVZ%<{úÜÉR˜ñƒ¥á€ÿ-[6<¼<Ü ÆqipÍ”ÏxÁ£WÖŸ°Ø¼å8
+¬Óµ¶<O¾2EğeèM¦Pl¥ä7LĞÇIø4´õõí€ìô$•ÃƒuèÇCçms:
+‚»qÌ·fıúe
+>H‘-u™äõ*±øÁ´ÑÛ¬c&òŸ¬},®!Gòøø†7Ë„_;¿yÍUO¢Ÿ¯¹Æ ëbs•Î9ä Ôèr”E¥ü–&µZéDŒoÕí&el®–·Çç±¿;\…:I·	ê±Ê¤’b>T]ºáy3ğ·DÏ—woùù!H²©z˜UZm¸8Óî›v•:zåíõ¢š¤K¯k“=¤¶qÛ‚ÒgWÚåÜ‚lÊmÕq$š‡óM~º¿‹Ÿ?œ‚œvM:
+¹œ‚Ü…fŠF:‘f^$v#uÎ	^Ê=“lğÌIáîcùäØqµèÓÂ•åÀrÎ‹r:pôk¤ş…ŠJA1ÆM“|7BˆÆêª´D½)(ãß)MåáÚ³…Cˆå’]·w¥‘ÌygRZ×¹@Êß6ULÚ|Û"Ó)Èà›#c	›óÛŒb\yjèåeK	Êò¹ˆ~ +tõOSŸ"ïğ{[ú»~¡Uè¼·uìa”ÉuÇä+<nÊwÇ³‰]×İCæ2®pÜ ÓÌâ³åW‚¡<T¾buë•nµøáÚí´Là†×Jƒv~·ş?T
+•Q
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/02/a511857c988a7b05a6d5cc69164887cd924ef9 squashfs-tools-patched/.git/objects/02/a511857c988a7b05a6d5cc69164887cd924ef9
--- squashfs-tools/.git/objects/02/a511857c988a7b05a6d5cc69164887cd924ef9	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/02/a511857c988a7b05a6d5cc69164887cd924ef9	2022-01-01 15:09:15.605172588 +0800
@@ -0,0 +1,7 @@
+x­TKÚ0î9¿b´•V!
+,ĞRö¥F)»‡í%ÊÃ°‘B9	+@ü÷zì$vÓJ½!şfÆó’,€Ñä~öåÎ ç|ğ8„Ğïƒós½‚$¨OOğIı<'T³†ÃY¿SÍŞg¶ş1ÉÚ¶
+’8„(;øq
+Æ¦}Ó0©"7hô97ğ‰tÀU’d¨ySÖŠÒ/™“cG`¸gÎÖÅ)7¡ˆÏÄ+ù_.Ãò9PRV4…õI°‘Ô›Ãõ7[îù…"-	“~QRŠ­õ‰óšÅŒ]¿ö÷Ã|_ ÆL& \çš¶~÷Ü×§ÕÖæ©~Ì9úĞ«´ˆ÷)‰ üğ))Ê6 qtHjB˜¥E	rACÉedjĞeeU¹¥Y^´T£A\–TˆÓr$‰	¬†°XŠ#
+ßLˆÈÎ¯’’E6Åú*¢8,¹Ô«
+úØô€õ‡>ò &ğãĞ°ÑìÈšÁúA˜ãîY$­ï3Õñ*«xKÍ‘:Q©C…š’šP-…ºcT4;EÖs­û±jxlÉ7¤Õáõƒ?*Pg„áZ*—S{Ú…%ë±^È±s«¨g§q©ßò»^riÀKÂ²Îÿ%Ü¦qÙfT^&!*„
+€Óä`y`ãH€‹K@	n	òÀzš¡ª_ŸED‹¿¼QEOŠ^’	MÃIItÍ»?›7Ç1á¶!)±l\µîì¼¥áŸCÏ_GW¤ ~ÂD‰Ÿ1.[QU¸©*^ázÿà[wÿJUí İ½Ö‡É×±÷bol÷»·Ú¼³ô/<ıÑ8
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/02/f2adfab7ea429a5b7a6a4abdc90d6a481c45ef squashfs-tools-patched/.git/objects/02/f2adfab7ea429a5b7a6a4abdc90d6a481c45ef
--- squashfs-tools/.git/objects/02/f2adfab7ea429a5b7a6a4abdc90d6a481c45ef	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/02/f2adfab7ea429a5b7a6a4abdc90d6a481c45ef	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1,3 @@
+xT]oÚ0İs~Å¥H(
+”m/l™ThQ?¨šVÚ[GX6sœ•­ÚŸ¿’8@¥Iy°}¯Ï=÷Üãlrº«ÏÓOÆcÈ¼Ì2ÄFÉ~ï8]L’¼L\„<½Î£í…}X'·G£±øt·£d|ç4Q÷UúlV/]o@´QEİ‰7´¶·x‡ùÑÙ<.P}Tp†âÜ6!ş#œ·¿³¡4‡º–(+Ò9rŸÂ?NA×”ù"[ $”Lğå“¹`ş"ãàÃÕ‘3p›[ğZYÈ UÜjÅ+Ó¬ì:>L ×«ĞÅ|Dƒ2ÄKF€³I”CÈõäÊ`’7+¦êøàÎs}o6»Ã©ŠÕŠÂ2EÜc~"(´üEqjk©9(á¤Ú[Wmz†Âä,Pˆx¨ç„èg‰Çq}}=c=¡Ho„°zq/ Â4&Ïh‚Š¥F Á ÖL Xt­€²]U‘×¸Xa‚‹-JE$‹óB¢‹³eİ¯£åÅòá)Xß‡¢Ä’1ÊT<Âh}#1ºˆ¤8“RÛòÅ©òš¡ıª´_ƒ,¬#¡[iˆébÚ²‘Åş|zÔj ìb´K[%5TóBH¹{¨ä•Ş*d“ß—áóí0T”9—"êI]~“MV ÒÃ
+Wf½8Uë=)|SKK,æ"XH¡ƒ–J|Ëèkcâå!A{)1Éºb¥\%ÀÚpÒÂë¸'Ià‹€*]=ÀNk`ÊäêñZ²Ú2Sãœ¹úĞõZcV+IÅà÷Mgƒ„şÆ9âº
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/03/56aaa6bdc4104276d2d55184d8cf4f87ff720a squashfs-tools-patched/.git/objects/03/56aaa6bdc4104276d2d55184d8cf4f87ff720a
--- squashfs-tools/.git/objects/03/56aaa6bdc4104276d2d55184d8cf4f87ff720a	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/03/56aaa6bdc4104276d2d55184d8cf4f87ff720a	2022-01-01 15:09:15.617172589 +0800
@@ -0,0 +1,3 @@
+xm’QOÂ0Ç}î§hà@ØƒOs@"„0”Dc–n½IekIÛÀøİm766ğiíïşwÿİ]£TDØİİzØ9N€Pıîê²„SHp:oáÄwŸüe8A]ƒ‡jÄ<Ns
+¸ãW‡¨ş¦cJœÄ[ç°ONt.!`GÀ#{’ãÇƒÜ¿7/VûñĞª3#_B¾‚TLp<l…M¤.[(L†û{# gØŸRß|ÑÂÖÍŞè­9c\2¯Í\oØ7,¤ØÔÔE˜R¦Ío4ĞH¦¦<VR8Ìãÿñ1K¡VVâ‰·­ì~…‚<º¨WeÛnk_oéÙs‹Ô¬´I<a€*Z™ó<;Ñ¢fŸíô¡t¯
+f»©‰Ë5kfÍIvzfDvZ+Ö€ÏDi7A©+¼–LC‹®wµ–,Êu¹ŠbÎÈ2àºéëóØôHÏ+­†Q¼…Pè×>*à”%èõñš
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/03/ac82642a73f45f699c7498efaec94c4e6ff744 squashfs-tools-patched/.git/objects/03/ac82642a73f45f699c7498efaec94c4e6ff744
--- squashfs-tools/.git/objects/03/ac82642a73f45f699c7498efaec94c4e6ff744	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/03/ac82642a73f45f699c7498efaec94c4e6ff744	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,2 @@
+xKÊÉOR04µdĞ×WpÊÌ)JM5ÒËàâRÎLËKIMSˆwòô	ru5Š÷àRŠdæ¥¢
+r)—‚U:…Äû9úº8:»ÂU"*ø9…LÎKÎ)MIUP‚Ú§—¡„)è›˜™’àRNÍKÉLã 'Ä1¢
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/05/7caa16593381a4ed1ef9be86af19ba129e9bda squashfs-tools-patched/.git/objects/05/7caa16593381a4ed1ef9be86af19ba129e9bda
--- squashfs-tools/.git/objects/05/7caa16593381a4ed1ef9be86af19ba129e9bda	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/05/7caa16593381a4ed1ef9be86af19ba129e9bda	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1,4 @@
+x•T]oÚ@ì³Å6HÑZh“´!ä‰¥” j¥ª²Œ}§š»Ô>·Mıíİû²1¤•*³{»³3{·ÊÄ
+Ş¾;¿xÑëAÀ‡ešÒ¼»ö¼KyBSÃ`:\N&ãyxëµaœ6ALåqV&Nºİ^°96İõIÇĞHl6‚÷><á¯{LïÃñ§ÑxöÜO^œEE#Çfü3¦’	îm½Çr•±øÒ¸Ë»ç¹ÈG"¡}Ï—G]YŸ!5
+Û·ë{-Ê–z‡°5ÀğIRh‡+­‘j× îØ†É#t†™z&ó«`A¿•”Ke7b]CXhÕÔñeÀåûsÓ¢ É‚ıÒ%Tàül‡®„È üÆY±¦IßÃ"Ó(f"şJüŠW…)pOOô[Ûİ´â/:;•ö7=~W¶0É)Å ì*N#\I‰ÅH©FÑ¿–¸38~4² ÒèDÑÚFºº@À™4lôé9Í(š`+(VVì®4	jĞh¢Í=]ùÈb‹_ –«=\œÚu•c3^VßÁ 9•eÎ!2³hªUêt”=U–ÌKí÷AM¢¢ô?\lËŠö{¯‹ÛcÓ\õ²jáÎàøÑÛI$£Wz'qõ
+4ªúsÚXĞšZ*rÒá¤oúĞ„®t­´ÓqŠ±ˆQR9AŒm_‘ñ?7*}9RYi©Æ©¯À¿Æ©yÛ•lT7¾8ıbÔ024õöUÎ?ĞÓêÅÌŞğ*gûwoL,x!qC­yÍ7 :P-àk·ê}ÑÌü±~©·ÿL HøŞ¹ï®±âĞ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/07/6a5872677e306535d854d2257f8d1a22267138 squashfs-tools-patched/.git/objects/07/6a5872677e306535d854d2257f8d1a22267138
--- squashfs-tools/.git/objects/07/6a5872677e306535d854d2257f8d1a22267138	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/07/6a5872677e306535d854d2257f8d1a22267138	2022-01-01 15:09:15.657172590 +0800
@@ -0,0 +1,18 @@
+xí[ksÇrÍWğWŒ˜²P øğuE¢HŞĞi¡B‘¼YU¨0 Vvqw¢a[ÿıÓóØY¤äÜ¤’q©$rg¦§»§ûôcÆ½IÚS;»OŸşå_¶6ÖÔ†z‘ÎY<ªŞo¨İíígMü½³-ÿ ÿ…ó.ÆñdÏÔi:u¦ögæÃ¿çŸGùx˜·ÒlÔš:ÄdÎ¿Ç¹šeé(‹¦
+?3­U‹Û(ÓÏÕ"«~”¨Lâ¼ÈâŞ¼Ğ*.T”¶ÒŒ¦é .øm°a1ÖªĞÙ4WéP~ùùìZı¬Eu1ïMâ¾:û:É5—GØó±¨ŞBVœ‡åA¤ qš<W:ùL}ÖYßÕn“$ÒLÕ£‚¬f*qbü-Ô$nn39yYŞR¬ŠÙ~œÎ Â$!Ô-Ô©zZÍs=œOd?è@½i_½:¿¾RGgoÕ›£ËË£³«·Ï1¹§ÕŸµ!Og“‚A™Y”è„L¼>¾|ñ
+K~jŸ¶¯ŞR‚“öÕÙq§£NÎ/Õ‘º8º¼j¿¸>=ºT×—çã–Rhâ“Àı:UC›¦™V]Dñ$w‚¿ÅIæàn2Pãè³Æ‰öuü¼EªÛúÆÓš¤ÉHÄ'¥á<WñP%iÑT·Y)RQdåÉvy”Mõã3u¥¡­.&Q_«MÕ™sí?À¦Jó"Mšêõ‘ÚŞİÙÙÙÜùaûßšêºsäÄıÏº·Y4›é¬ÕqÒïÌg³4+DïNÛ?A²é,Ó¹Ë¸(f{[[···­ß&q¯•èk¶ÖÖş5Nú“ù@«ı¼Äik|Xù”ÅÉhùÛ€*ó„$¾”K×Çuátãõ` Â{eÄñ›f\±–°û¾‚ãÍûÿEş‡÷Ôú}­ö»Zèa4ŸëMõ®ûòøäèúôªÛ¹º<º:şùmSm«/M™6Œ'ğ	=y'íÓ«ãËã—Áøx>N£¤›&“…Ìyu}ròúè¬{~vÒÉæIw¢“Q1îê¤Ÿ,ÅËÓã€Ø0şÕïôK¸ÍÙõé)æÉÔµ/Ï½œqR
+ÙíÃíÈ·ñ­X³X9Ñ	ülÂ#´zâz§A  8äøúù]ûÂkåÅùë‹KxZûü¬{züŸÇ§Uú·q2HoUÿ¦—(›‘®Œ,Ñ|Ó>{yş¦Ûi¿;j´Ešá<éˆ¬ıh2)1Î À/”Á§¨DĞô“3±jº§hA´Í_¼|ğrCÂ9Du¿Ló,É÷ÀIíğ`[Õ“ù´4&GƒAL ÇQ62èACË|ŞïÃ[¸hs‡>M07Û Âr <P#%q®M –LÜ]11œF¸L	Û·X¦zq–•Bœ™j^¨ºnZøş9šÄ
+M5µyø£ÎÒBïÄñÍu‘cfQwìPA7·¤:'.‘Æ,ÊsìŞÿ$Bà.>F¹S>1ÏêbkgšjÆ™j%Î;˜Og]{„õ†òL•Çl‚No¤‹@d™”"bÔ!&èE=  q›èIc°ø	oÕù"/ô”»WÌ\¸pôÇQ¦6p˜ŸßhR'<Ø~cĞë€ştV—ámŒ¯oşâ´+Ø'Yo¨¸ZƒhÂ5\¯öÕ®ùPÎ ‚I!Âg Áí÷Ô
+Bjm!Â:ÕjëÁNJvºIÖÏ9ö'h"[r6€!ï¨Ã•¨ıõÌ“¥PÏK¸Å—5ü0àñ *ÒØècçƒ0‰ïÎÛÇüá-«”CõìÏëÅÚ6çŸÆxµÚt_”ÀVŸ¯ªMBÕõdşL-6Ú³¨‘¼×ı½ÇÚ~9ôKW›™èÀvÕ…3öÕSUøéPíüøµS
+¸qØ³ú|zcÛùñA¶¿õ€\(¯œqãĞGë¥Çˆ&Ê]dæ¬è‰v(Öùƒp{„LA‹dä„®óûûíêÑúşfû{§Ú4«Ç¤Ë¤$şĞTüä‰&Â$˜&6’$“yoçD ğp(!\‘DóÑ¦BnoêñcğÆÿk	r!Ã,Á(aÚ4¿o8n,*zr=Ñı±¹ÄÀZMÕj!›åq?ÙÙ›\åÉjÿ}1ÿpsõ EÍy&Ô_ZO -{*±ó{™>™Ÿe©üeÛ³(ÄÀS''Æ½.çøªÄk¡ŞŞjK(€	ˆÚ3LÑşº	 Z38»W~Ü}¾ÄE®f"%kÉ»ÙO4dM†LÈ¦¹)Fz“ä9	´mØ>Ò¤Œ…ä@(6Q¦2=axA²ÂÜÄ¡¶Ï†¸ãd¹Äá_
+¹[$½L”şufdE>%ém¢†m’cR­"J¼¿+ˆQ@„ºÌ–P
+{¬¢-{.7ª1ÂLMI–îá]ÊW§Ë÷&iÿ“à^¿Å\F| ãyü¸tí-gœÆ2Üñ»L¡cæ‹ç"–”G‹©_?D”éeš*„tHÎÃ!õ¶âdİ~KÚsÏêa¬QºÚ½ÌŒÕ.F¦Sô( ©É‚Œ¡ÑFò9JDQkƒ¶ÅÁ•¹2˜›¥8Ø§Í¿œLàm®Eµ£CBH:Æˆ,uôDD	Œ‹š€x«Íah¨À½f@•4,aÃ™7Ï)òà»¹fÕDL²·!2Û«Ö‹²š20SEıá~‚5HpñğŠ˜`,a­ï­©öpeÁå”á÷˜(Èä‘{ÄPƒÑuÁØ_6OäT["‹iò=‹@60Ø˜(Ëw··? U—SnLC¡Œ,Ún\Œå &zõÑšb—aªÓ<É¡„’pwlS¬Á…[ĞËªD°ûp	wÈóåEA‰è¦¯Pøp K¤gøG]ğpˆ-}›çø‡Y72¨ı}“Mx+hÊõ™ño°•rEE¾0ÛªÌrb™pONÀ%éüíú¨óê¤ÓmŸuŞ]tY‰wÏ/®:õÇ~dk51h.‡#¥æDÄ„™&ØT®x°"5Ö¸¿Êûñ0f¾“'2°yŸEU®4æJXC¿­§™Í3@3òl’T¡æÃ”XUvZPØ1°ä4D(‹a,H[w'ˆ·rYmD‘á±„¡UÊà¹AßÕ¤,˜åLG¤6¦%!ñ~'€ÊB?E«9†€KGÒ½E‚Ô4›e ƒdx3zDØåx%(#‚³› Ÿ…Çb©e„vßmÈu\îØQ%›N/l4MÃÕô+îm©zË˜—ä¼ÜÃ¶gØÂT)´&Ñ®uì‚„?DØ¥ÉA0eN¦v\e9q+‹[«TÇ&5Dmô-Ù'&èñ8¨ƒj©O¯Ş0ê‚34êj'&²¤hŠofñ` $}(Ê¹Ô‰3ı+rqÓ£0zf	âèÑ|=±ë}3d9@™@ÖC_Q£qÀÑ ZI[s)LmPç&b ‰Ãu.`˜{õK»b}_ø¥Ó·Mûˆæ+‹ÿ‡¡[Õª0W™ 8g:¨«fZ¢˜u1³·Ú&6¦ñJ‹‚æsH
+#B”2½G“Z°yÍO66‰äûKM57*YüChë,`ö^Œ5Úbşs`êlJõÓí¼"Á8>üÔÍCşh;ì6Š˜¾	*#Çªi¾‹rOÃFa@Üt˜ÿII[i,9ñ
+u¥ME%,k‚•˜'²‚Kkq¼¡q˜¶Ã’¤á„²	ñ€f9õR¼pïƒò@7ƒŠ´Òn¿šh¸æ ôÊ¬Æ%ux¨â†z¬vluêXâû$¥İfyS9›V8¼´Ö8ÊÒÒÁÊ*ôKå…»®hÀªÑfêÎ
+ÊÀ€kÏt*–µ^†˜GÆŒü~,{Y	¤™Ô<Îg“hA]  åõÿN°k¢dVæÿcê—Ş©şW0ÄöÂ×o
+gG8{Sş¨ï°™fèyÁƒ8º¶Î°Nx'šîleşÂ”R\Ã¦t•W!"z8ñ†,5&ƒ‹¯NØÕÂİñ“'4 •oÂÌ³¾Á¸W«9q1Á¡Vck¼2rStÌ¶,‘í¹énıw9În™?CÑîÁJÚÁÈ£€Gçİl†bƒ“åÑ¯‘{‡5ğyß_ûŸC¶/µ¯öëî´zâWT¸¥CMd“sgá)ò»Æ±— ®ÆXËÅgë›²R6ĞšÒ*ø¦ì“ÜXÔİÀÁMM†YöĞÌïx=‚+6ôÕLKùTÜT›¨KŒx».€Ÿ5ŞÁşµÑÿ‘_ÏK†G6IŸo¹qİšBÖ´/)**WK§†/S7|YÚL5ÄÄ`Kvw×æ¥W2|0S6-¦s#&¹4²@³¾eg-ÀØİgLOÍ%Òïğ›‡„@éâ¶³š¡+~›TS=EÙdå÷Â-äÀÃ{
+WÕá©­ÖS•?™ ÔG¿ıÜáî&|wDÂäÄÀP?Mp{;Çíå
+&Q
+óşcå<*d¬ T÷øhs¨e)¤aJ¢ò Jc7HUª¼º·[gï¸UÅ¼Ğ¾Ç¹{øh2‚\­&âDÁ¿­ßÄÆÅ¦L“*äS&È#2ÚÜêñtı}Î[&dtD<v¼2oÃ¡wë¡`GP+U†}çrŠ./ñ´%¬Ùšê© ¸#`¢MàÔ´Ì}q›õ®{ş<¿ÀÓ 
+6¡€'`Ì°‚%w²Î]4AıìÀL»¾¹-_Ş@Ÿ:¹cá4"s0d*˜‚_} °»ô3xìâKgêÆâ Ùn*“‰¢ac~ ¦ºÒûD‚7mHª"$ˆ‚)Ğ»r€’ËsDã Q­&p*uI?RÎ0•dºN¡ğÄ‡*µÈkn[ëM`/´#c1®4!0ÏŞÛÜ%jìbÙæÄ™îZIh&B)ˆ¦Ÿ ÒE»^By9}Æã;Œx°b†¬çÂ²»yh4´b¶¡g¦—8 |yàõ(ÀX‚ÔbKE|p“/«€~µ¢‡R¦HôB´µÂ©*nE˜5UµgWxäIû¬İy%D¡_9¹ÍCóŞÌ(Æù6•Z¤E4éB	¤oO!ôß¿½îŸ½´2cğ‘7J„r÷³§}èÑß}"2àKKvüˆ0şµ`IÕJ|ªèÈ(/Zx…r>/f8nëlâ'é-ºÏ—ò‚KñpÑ²ãùO%e!Û["QpGŞ9p/„×şlQ,O	¿ıBéêx!ÙÖ˜˜à¡É^ñ>é`fn:sdV|~&oqĞ#Æ³PvUÙË,“E¹ªqmy³£æœÁ"{'c~Á¹CÉĞúWĞWÎ¶#eñğ~„j™\@\‚?³×<ÉãQ‚&½<{í-
+»Î(Š8ì‰İË<h@^š¥	7V£bYÙäIÏï8±%™C¡aMÕ&Ä<Fº.À}§T¸)ÔÊWZûNI¾tuÏqV¸)VLwo‰å)V«¥©ºëÀ²A·şİ !¥p¥}zçí%]|Åd:¬6W½Z±Œ«àÌæ¹3X|ªÀ"î ¿Ç Åû w<`ì4İ§İf«Õò¿Ùro%»/¬©šG_§%š•;px×C„y3Ğ§¼¹¢×õt^yÛzhíƒ”<I´!pì¹öz“W0¸"ç]p¾nŞ$7Åò…åÇÁ,è°ÏÍÆ4`g^á½8ŸÍ -B·‚#´XàáGâÏˆIşâÒ}w$8Vº¢-¿pÜµŠ-IwßQÈK·ÖË7®Ÿ}º9á7ÎYºqÓ–>µj÷ĞÍÄÿ‘69S\ÜË/üŠsxæ.7©öM3Ìc!óJsx¿„wñ 2ô/øâú‡`–
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/08/94dafaf6338f22ba397d84929a7b711cea48b7 squashfs-tools-patched/.git/objects/08/94dafaf6338f22ba397d84929a7b711cea48b7
--- squashfs-tools/.git/objects/08/94dafaf6338f22ba397d84929a7b711cea48b7	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/08/94dafaf6338f22ba397d84929a7b711cea48b7	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1 @@
+x+)JMU06±d01 §Ì¼ ƒ°ÚlÏµ)S¹íoRIõ”½–ä´æ/D…Gbq†sFbfC€İ¹Å?*Şœ³·:{ÙûŒS›¿˜™˜(xú&–$g¸eæ¥¤ée0ìvúÆõJ|mÙ–7Ëçôè'„Ş›Uéå™T—_®—\PÀ2©ƒ-é!C¾şÏõrW£«Ï|n8Ğ‡©2ƒaåéb7³=ÍÅQßZìÚasÙ¾®Î¿´ÉÈG×V/|œ&½åLócÇCì£8´ßœÅ¢4ƒ!¸ıï-›Ùoc·øiÈlôıë6÷£!ÄÏ‰%E™É™‰å¬-??Zs5É0X¿ìõš7Æ›óu f—¤8¦U =kÿíÆ¢ù‚ï¾µ>h,ÒÉÜwjÚ$s ¨2“r
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/09/0d73d86d5d4c6fc7397a0165c5b0cdeaa12e05 squashfs-tools-patched/.git/objects/09/0d73d86d5d4c6fc7397a0165c5b0cdeaa12e05
--- squashfs-tools/.git/objects/09/0d73d86d5d4c6fc7397a0165c5b0cdeaa12e05	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/09/0d73d86d5d4c6fc7397a0165c5b0cdeaa12e05	2022-01-01 15:09:15.637172590 +0800
@@ -0,0 +1,10 @@
+x­XyOÛXß¿ı)¦ U6„p”²(@V4	ªÕ(	ô@(2ÉËbáØYÛ¡¥”ï¾3ó	l[mˆóŞ¼9s¼ÜÑ¼İÿsïímhŸy}oVÏç–µî‡ã`1°6H'§ÓoÕÛµÜZµº-ßh6‹ÂíáÃ\$K$í/Ómú×ãh"âç	Zá
+­J¶Ä·TÄ!¬5Ö¬Ç¢ïb/ßnËO‡$äÉ²Æ—$ĞpÃAo†vÕÀ˜/nî@ü³aê{¦¨d»ÎÃExF_Cw6Gy ã(LRx÷
+Øhz©w„k‰ÿ]ŒRàGîëy”YRJ‰:ŸGİİŞÇîÈíœãÂ}äOÀıÔÎóœ ÏŠæHŒ$%Á $N€(H°@\ *¹€"ñû}yÂ¿Á°Ùiß÷šv_xÇf‰RÂ…¦oöølÔ—yE’ˆ	™âYOG–e˜ ÖE/Öˆë¯2e'*y±˜y~ˆ“8Øö€?›l‚:H
+rô2ÒÊ%2qÅ`+V>Û>Kw€¿¹)Ù¶–Cv;Wş5R’'¯ÈY›à_+~Î<éOí‚+àÕ	t/ÚmÉ±è&d§‹tĞŒzĞwÈVc¯·Hÿ|†äEô‘$ƒ´[+á¨¼yEôîE<¢¯dk†;yLâAq¦ßD)è’©$JrKˆ5âÀ¢ó(ÉÄhíòçdLNˆPÃy)ƒŞ÷[ƒ‹ö>Æ~*Èê›Œ3A	¥B]bLÆïU¢WNl/T
+Œ£Øºm’-“Iæ¡fs“0t#·
+1/§+æ¨üş²Ï€„ŠX¹ÿó|údçR)‰àõkNŒcYÙ²”Òé#aê—I3âú‹yÄšPÈ|J¸"Wk)T„¶BD8×'bê‡_dPÁŞu¬übïbØ;ë´:½şg°÷–öF½ËVÿ¬İûöÇ²ü0ÕRv+›A’¯â~øn1ŠØTr?`fU¨ñ€êÑ"-áŠ¤"Ó1I6ÔÂ¹.Ëê¼ªyœúQèÅòTkğıÌ°;v°ÅÂÔ<:íu¢`ÔíZŸ­ó¡ÛëPŸ4~€GRl]„jáÓ’`Ä;wi£RïÎå>{»ìâµlÔ{nHòv™¤ã‡M‘°ÉH ¹mÂ]ñì&J,­üEş.wXfµ;ÆÃiBFG»8›ÌcllµZ—†Z­¡ÆØrŞÌÅ•Å×¨‰NÈí<]ÍµAM'ä’ã‰+Y¿wî6[ÊÜm&WT=p•}ÎÊáqr•Û¬ÕîNƒ¿#,g·3êK»ÍRÈ%Ğ¾<‹îbvæ%)Ä„¸`×Ñ!èŞá>GÕ HFÜìH3¶K+W;×8H.OûîiwÈfˆ8õEreXq%ûÔÆÎuõ>Eş—ÃÑ…»Or›»/mî½´‰lÁ¥ gÕø½eæe’b”èQ^™ş F©å"¹UÇf-í¤)WÉ™WÉìP£i €PNäßèå¦™r< æ X !ÅI'J‚!ff=¹\=£S9ÌfÓ®‘^ÃıjI>¬Çbì9°u,'›ó%?Yk‹d¿«¢–\ÍÔR?´® ñV'j\Óµ•¶åã%÷mÕ³Ùagu¸”?sEÅ¡€fSF‡Ñìg9¯ğVæÄÑsõ±|-Êó•}ığH·ñG4xò?ØÊUÎ¨ƒ}ÇFk‡­T(sÏ[m§Ôë`ÂøS²6ëÈ+J3ŞÏt?”ï0T;nòüºH„lm¤gÖÙ8¿¾ŒÎÜö°ÕÇÆf‚lèÉ;ÒR+Ø2:¥rFnáøÃÍ2'[_:§A‹>‘^)Ÿ1LÉ¯Ån¤‡JzÍŞ•ï…²D‹­ ¶5j1 !F†
+ol#ìd÷/¹“ÌÔ,À«ˆ¹øíğ`ÔˆBúÓçƒ9T‘ç‘’}#]RG×X©Lv*ğ:ÇI>#«
+ì27¶Œ¢3yL]†±óàe\Ğ-5Æ,“&Œ§8Œ9ğ¼š,78)¸‰˜àysÃ Ætì‹dyR¡Î†#T’z1İ;pÙd#UN+rVyğ5*–…àcöğfºKÓ1Ì83£¶äê«¢®2AÈøëƒ
+ZI}5RºªÈ°ÙãOs«-—84X7)pcÓ_q:»êü¤IZÿç™1<1Ú¦3¨*¼|â¯r¦ÕÃ<óÔ¼€~ÒáUuw«Nå–“ÅV²ø2P«;Ê‘Ìj!Ò{yÖ'PhÒğG>9›‡ØŠ&K)šñ“Í¸êJvàÇLEA8>•(%q&{J`1IâÊ9±äpYdı UJ¼ô¥J‡x•¹ÆG&
+¼×ó’s\aÊyÖ_ÙuzÙQ¤áªKGI_e;YR´]€Ô²~âØŠ	ÏÍhM†H²ÎÃY,ÊÅ—±¢ªvæò¾Ÿ½;=ÁØKÇ·vµZup ¦êóqêvõdıˆ£
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/09/3df999daaf6c68118cdecb0d842bee00a4f606 squashfs-tools-patched/.git/objects/09/3df999daaf6c68118cdecb0d842bee00a4f606
--- squashfs-tools/.git/objects/09/3df999daaf6c68118cdecb0d842bee00a4f606	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/09/3df999daaf6c68118cdecb0d842bee00a4f606	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1 @@
+x+)JMU025a040031QJÌKOuÎOI-ÒË`Ø½iWÓåƒŞG}9Şd~µë]õñ†:§Ì½ä‚†>_«y_ûÚXÑıá5ÇÕırAXg0$ùwÔLÉÚÒ^ù2e†G©1G/ÇlJC€:ÃŸ§bËÜ¾—w–üşıõÓ¼Õ'/N(ÂPî_PTšÖ=+škAèî¥İ¼'_¾»´æH±1TipIŠcZPÍ6ó¿ìa¢ÍeIûÎÚ\»à‘á“ £Àl®
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/0a/d98ba83b7ab06db900c941587e6a8068acbc47 squashfs-tools-patched/.git/objects/0a/d98ba83b7ab06db900c941587e6a8068acbc47
--- squashfs-tools/.git/objects/0a/d98ba83b7ab06db900c941587e6a8068acbc47	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/0a/d98ba83b7ab06db900c941587e6a8068acbc47	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,2 @@
+xe=‚@D­ïWl QC ~
++¸cŒÖà¹vœüõÆØXÎ{™ÉTW°JâYA6”T·EoÃVß4¤±¥²cº—¹z•ßACøÇ]êî¦<É}Ï¦+aë	q.ÈnÖğYLwì<›,ÂR—¶àëGóÄ_ ~xÀ¤šµ¡Ëbç~!iÓˆçŞ86
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/0b/4ee85bc768042a852579dcb68d13b0eef4b683 squashfs-tools-patched/.git/objects/0b/4ee85bc768042a852579dcb68d13b0eef4b683
--- squashfs-tools/.git/objects/0b/4ee85bc768042a852579dcb68d13b0eef4b683	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/0b/4ee85bc768042a852579dcb68d13b0eef4b683	2022-01-01 15:09:15.601172588 +0800
@@ -0,0 +1,6 @@
+xTïo›0İgşŠS'E&%Ù"u“*åËTmİ§*šq[§*pªl]÷·ïÎ6†Lû!-"s÷î½{g³.ª5„“xúêlïêly‘Ä§9ø>¼¯Ê'^K^ÃmUÃòÂObÈ«wÆA0õÃÀbxË;^eOEõ„««ıº9lª]&J9ÎkQæÅ~Ãá‹ŸŞŸ8N#3‰9yU6Ş}•0Tæ÷×Ùºà7Ñx©óì Şo¯¿FbğJÔ¥ñ&btD¿ë—™ã|ßø5v˜Ä_LÓLén2™y Ã&yğyYÊhâÑQJà%:"Ê;W	Ö‰b†lâ!`aââ€šË}]B@aòSŒÑŠüeRŒ€yªÂô8¢B“`ÉÑ¸úšï‹ÍKTŞˆ 8„—TĞ¦î²æ3}øê(}-äUÕ à\¿¦›¢’z¥dÒR+UOsˆf*e4òÀÀQuêŸ•+gÓF•ù‘7º¬âæRÂö¹UIî6òCUïÚ’²µt—1ÕÜb¡è]ì>t!E53™€[LŠrÏ[˜¡GùÌHEtäÚ°(
+£&H~NÚ`Oœjß4¦<ÙjC¶8ìdÛÑ¨“Ğ‡¡/ŒöO»zd0‚-ş¬ÌçÀ¦0„-J2õ[¡_
+u£È…´ß³ÙÔ×„<	—Ú•Ã9˜ÓOy£30±ïÛ³¡¶Skêé•ôhì—#Ãr‰?ë¤…nxc6Íƒ
+}ÇJ¶T_L”˜¢cuH`Õz‡#nGÒ‹QûİYÔ@º?Y÷ˆ6·¬x¬HIW…·,Ct>Ë#h¯C‹P‹Å„™mƒ~èÆqü,8LÉ0œv‹vb¬%Ö(ÊWjšÿ…
+ú)2%ØÖ8p{œ¶"¯õ	$Á,$yz£¹ˆ
+e¶™¤ÔÊî ]ò¿	z®>a¿¬KßaWUoÙpk›Cb;xQĞşæ;+fÎ‹ó`„¼É
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/0b/f66e086b95e155a76a5ce2926012e7354c1b0d squashfs-tools-patched/.git/objects/0b/f66e086b95e155a76a5ce2926012e7354c1b0d
--- squashfs-tools/.git/objects/0b/f66e086b95e155a76a5ce2926012e7354c1b0d	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/0b/f66e086b95e155a76a5ce2926012e7354c1b0d	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1 @@
+xu]‚0†»Ş¯xŸ”&Dw‰Pf¤]Ì£ô,œ]øïÛMúºÙ`Ïû¼ç°¼9õË‰ëÒP´­@7n §5!/±€’2&qœìXvŞG)ÛG½r„o@zåjå’W½Ö—®‡V–ÉZt=İb?ÆG+<éñs4†7ÿah¦óª•ÍÆq²St°3S©À×SÿGÇ‹ëp ‘`íF`EÍ¡Zşv¼§Æ&,x©>Ìı Åòz{
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/0c/20e8c3a6942d3c11580e1eccc161adb4f3b294 squashfs-tools-patched/.git/objects/0c/20e8c3a6942d3c11580e1eccc161adb4f3b294
--- squashfs-tools/.git/objects/0c/20e8c3a6942d3c11580e1eccc161adb4f3b294	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/0c/20e8c3a6942d3c11580e1eccc161adb4f3b294	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1,12 @@
+xµXysÚÖûSœÒÁ˜Å±ó¼u\Œ[æyLÒi“#¤‹ÑXHŒ$Hì$ßııÎ]¤+pšv:eb"İ{öı0	¢	t_·ÿ³W£ÃçkÇ›.5h$’”œÅ"ğ]'õ£¦QŒ{ºnä‰x«Ój½n´ÛN—hğ€Ë;gD+¼İ-'À"/šƒÕö¶¶~ôC7Xz‚N’ÔüIsvV<ó£õ£Øø,‡+5›{øwøÜ‹İæ¬ôÂÅ¥ˆ—oŞŠ8|iá>ŸA´Fìğ¹ÿ)7-R:|(ô$…=\ZE¾G½(\‰8½YÎ'"E÷)K]y3Óƒ}Z9ÁRÔÉ91Õ’êÖç-R/©˜/Şu;qà‡)-¢„N©Å¯^„/$’P¸Úİı€Û
+“©VvZ;´K`U+’>•©İªV—GÚ;Å|ÅßÇlBöp‘ ’Aªİ]Ğ–œğ’"i–êLÃ×XÀ÷­ã­¯0 '¦~(è®?Ü^Œ÷©²O5ê¼‚híêúu»Õ¢JZ£Î+D×&Ø¾Æ(5ÚWä¶^08;zäÏEfòŞM:MÌ)Õ¦éšİ—aâ?„Â£'áÄušGa<ç©N³hÉï>Şá²ÕŒ÷àÁSš¦³«è#}¡Švk•~õftrBİ4çÏO© yòõ™ºí:u^×åÿİÖÚÿ¸+ÑWfšÉÇ¾0Rt;´âçD‘NmÉAVğª4`Êt Ü«d@·¿
+ÊÆx	¶³/ÕÔd;ûÇ[,C²±`ÜÈ3¶n‘@û Õ†W´—…‹rnK‹JåSëFRa©Xèˆ)Œ?¥Š<¥ı*äQ¼.HJ²«b±,iIjdG:$å4S‹TB~Zl:¯
+|ØŒäÙj“²Åé²Nÿ;j¬+ )h¥ºe¤Ì)Rœ¶·©¢O8•8íéËe áˆÁªJÄm›·ó_fÀU¾‚ôÀAû˜ó„NğÔ‘»»ŒñVÀre 	†DZË¢¬¶¢BÕc`¢I,œG¦Ïq$üÌõ	Iy ¯8éù2Y –¦ÓJR§R¹µï5Ê­ú"~:Ê¾Jõï$5ÂEKÖë;¦Ùã(–õğYÕeÍ¬ô>ì‡·Ã#*'ïCPÆ½Ä]ÿ>î]ô{WÄmK0…Ë¹?@BUãùùİE°ÇÅh¢#gNNìÎü•Po¬]ï*ŠGÑP8x´nîŸÏãş'ò&w?	ÅBšk€nWäğ÷@Õ‰âá™#/€š«„®}~s?hôLó¦+ó¶?¼ÜŞŒ{·w¿¿ü:_œú”²Ór¼ dçkÒxçŞ$Îƒ8Âx€é€NÜh>wBïŒN´ŞãĞ™‹³÷!(œ“Jpœˆî¾4…šÆQf¾dpDW>F7
+S¦	EScæ\z¤FøK<Ä~úT”šLœ.ãPõ`KN{£;Ê|®ºA%5Q—…+»eÔd#ô¹AÈ!1¾]ˆ°²]ˆ&«Z‡ôŸÎ™–Ÿ¥lf®R¥SÃb™J}“%Ø!8î!SñväL±Æ_Ú È5Ğ<<ëté‰à Ÿ_4A;Ğ¡~JkÊÉØµ¨B?­lçÈ b&¦›*ÄOI;'AvwjqÿÌ9šúuT>ÎĞL„‚ L”¿ˆPÄ°2J¥âXIìM¤âHF)'©v¦7©“¥PaÛÈl5I‚ƒK’*Œoÿ—G—ª#:šÀF†DVTQq„¼Î\c¸H1¦„^­3¶
+Á$İù¢¢é£°¥ªjk„eä"ám™
+ˆi†Xà»ˆ"CÜ¸™¤–ª…¨„PÓæ"_)¥û•Ï¶8&Ç›4ñ9‚3Õ´Ø†ÜÂõ sÌŠ@VXı'#®çõ„‡u˜ÚÌìLD^œı§³{ÿÙœHW+Pv8.®yd½³³§´R×š³/µÛ¼-jìi(…Í¾Y<U0ñ–ÔAá›ëClZB9¡r»•érÀEÌ‚ÛêtÆ‰ë jÒV$ØîÆHQtâ·\¥Ø«éØã)ZR(0»;ƒ¹–ˆ´t&ğİÅû\¦’faÀPÄ¡Ğtº¼—¢ûƒWÇ¹óhh
+ä$¤ÖC
+Û¨²š\i‚Vú8=ñ‰cèÓ¥ş¶a…tgÎJ>éõj"0#	ß˜»òëØ”¢eúór:<ş¶ª¼ô*6r5¨níù&³Ù&IÃ,}4m­™SMbcôÃ”CNåÀ?—[nbÍ4‹9şİd3²N§‰HMÚb¾ËT`áïâÈI"¼à¯'©N¯AráÇv^pŒ&ÅO”«¢BZëÊ®ÒÀv|ÿd]cÌ¡Ôb½lé¨xÓW5—6ÃY†Ir=»TEÆéšØy•ÊdÊ&2R¨J˜yüp‰hNT®ò[ŞŸÆZ¬ÊöÊ¯g¸Œµç:VWö3»i)’>U@/®ÁıY3dîÊ,9V•¬%ª›Âî`@°Ü”{Ü6N®«¹¥²È[˜cÉí{Õ„§Àârˆ´Ò®³a½<×^aÃB“Æ»M/ëuL¿©d/F.½ÑM“xgày«â&½³·S¶ÕeäM‰ÑË4[v†µö1~åOBüfE§×­2£x´QÔÚHz•dD»ÏòÛ]¾r•
+3,ˆ¬±ÏÃŒå26¾<\Øß¾àX¸Œ
+Ái“bİ8>Æ¿a5À\œi†]Ïw±0péB˜(WÍ^m™Š…/ 1Ì:Û‹E¾d«,ÓøwŒ• DIn€¿éP—‘ÿ-!sßšŠj÷$s;8ç­xÌó=Ö½!×Y&åGİÄx6BûÛ–ÿæZ÷'ÉdùOoJ
+Yv(j“±¦M½¹JÙ#/o¹ú}üêü”Î¸ù	İ>æyi‘Í©©|zssÿæîîv8ê_¨X´µ÷Ôïûø%Z$áNJÉr±ˆâÃ8i‘U—Ë¶ƒuú×ıëMº&÷¥=°gÑ\ÌÑ’¿Cª7ìm’Â!	ş'G–9hÙ‡Ä¡ËSçr"-«mƒ=ãëÖÿV(ê»
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/0c/e54e21e61a21132aa06c758575efc0b57d610c squashfs-tools-patched/.git/objects/0c/e54e21e61a21132aa06c758575efc0b57d610c
--- squashfs-tools/.git/objects/0c/e54e21e61a21132aa06c758575efc0b57d610c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/0c/e54e21e61a21132aa06c758575efc0b57d610c	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1,4 @@
+xmS]oÚ@ì³Å*¼AJ¢>„Ğ‡¸¦AJÂ TŠ"ËkqªñÑó9jŠèoïŞMâ¼{»3;³2ÁçÑåÕ§áæ¥º-Óå`ã8æ	¦óõêv=zËàÎéPˆçø.J—ó8+„³Á`8ó•Äp;ØœÆ)åŠíVäÃ‡7:è|ƒò8¼®·XÍæ¾S(YÆ
+Ü##ïwŒ;ÅEîì€»¥ç¯ïWàI)¤+SğƒË¬¾ˆõÅîuSÄš(ìÎaìt0Oxê8qE«!î¤P+L®	êöM!ô‚Èˆ¥±×³\] Ø‰¢ı˜ñ-W‹ÓFâ¼ÚN>ÿc'1ú,”¼™ùø«Ä\ñ0#)¬®_!°=j¤/W,EŒEIİÃP<ré»‘âå7«±C¡ZŸiV›E(ëê›¯‚'`bO\mÜÆ?ubWFµ ´f7N]kúS«Ú¶ˆ‘•~ì¢{n”³;›=[YFô øÛxÌ(S‰HÄ@çèktI^…¬r¤¶5˜­Òó›A}T¸µâ2k­-ÓÉLÀ-Z]XU}äôì(ğ,ç•À'º·4_b†aUW_›=¨RvÜšú“ä
+5eË;êRbO?*³lŸõJöû/š¾v€§LÇ`2 ŞO]¦?ÿ[F[3í«`±ÈeÅë%¡
+Ï¡ Õ”ùk8¤B«2œ\ŒÃ¹D§~¿†=vf¬jm]èêŞİgşb$<hÃ´­´ïßQ-ÚOÛ`8õ[\¿Æÿ 2„:
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/0d/06f14101f89d6d436e5660e48f492cd1eee5f5 squashfs-tools-patched/.git/objects/0d/06f14101f89d6d436e5660e48f492cd1eee5f5
--- squashfs-tools/.git/objects/0d/06f14101f89d6d436e5660e48f492cd1eee5f5	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/0d/06f14101f89d6d436e5660e48f492cd1eee5f5	2022-01-01 15:09:15.633172589 +0800
@@ -0,0 +1,13 @@
+xí]{OI’¿¿ù9;:ÔÍÃÆÌŞì$xŒÖ`d<³7kyQCv‹~pİÇÎ~öûEDFfdVVÓ€-­V‹lÓ]•ïWf•Ïú£3·ş§õÿô»ãÎô°Ó>ú°°ğ}oxŞ¿îVî=vGƒÁhøx¯º˜<úğ‡ÙƒvúıÑ9ZvÕäªs^¹ã7§G;‡û'Ç;»ûîfaáäÍŞáş›¯öİ.Ö÷Î{“jºÛé÷Ï:ç—­ƒÃÎôüÃóŞ°[õ¢[:÷·Û7ÎNÃ-§·6qc\M¯ÇCwrúêÏ›¿/,|õºv¡gÕÅh\>VÏ€îeKÀõ.\+‚l]bu[fí~èß÷†ïŸ]_\TããÑ¤Õ¦%w_şõ`ø ;ú´±Qƒ_ÄbçbZïŠOš‡:£p>N¦î—ƒáô‡uwÉ,>™vÆÓ_;ıëjİm¹õÍ…tÌ^59¯†İÎpº?¸š~	ë“Wİ“æÉ“£Ñô`Ø›öú½ÿ«º´Òe2C]t«wzúbçäÅé“igÚ;w)nG×ƒÉ‡g_¦ÕØ,£1'XC¸§O]ë'·ä.ídH°<ÕZ×%À"&´Äzã2‹ç«EEL&±ï«ş¤šß<è5bÇ“çDnñv{ÆrÃÇV{ƒ“Š´ÖÚ+¸‹•ì‹YW
+¥Ã*4âhÔ­ÂàôÍàê]€€q‡µ76ş>{“~>®ªÃj0!+-x;€}Êáº? ë`!¡_¡DÄç`å½÷~,cèòçâ¨Œ'~|v5ÌÌy•-™³Í@[7ÜàÿÄhc`~/|şıòî¸êL«–wz“)Jú´\IU]ít»âÅû­8€t:`@Şü°óùe5,Obw%~ØÊ„˜ßNÙ\Ÿõ¦“ƒ!Lò¡…¾€¸	°]´võÒ›/WUæıO„C'sªO|êàÿ]«eÃ´ÃßNŸıöfÿôäà¯ûm·ûBt›GV»-‘ÂÇœıÓƒ£_w^ìí¼ş™œº¬~ïığ°3¹î-úäÇ¶c§xõ‰£ÈëjR?z«5<'Âj#–áOèâˆÅ-÷V#ÂOq;ì“E=~ÿÍªEÁ±¶ìSÄ;I8Qä’aEAÂúıÈ,£µ¾KÖk aƒ[v—Jƒú–dM[©ñ0ã«_Ş¼z~¸øêõoŒÔ)©ÚÑ}Ï BäœÚ·ìòtW¼\j–­İøİ-µáL8wj]’e³Ø—‚vÇ‘í ŒL¸&’Àş:—[QÈŠöOÒœƒ[œÏ5“ÎÎÂZ" ÌH­²ïÔGİñà¿à½;İékÈî×}\¶w|>Áaåz ¾ÚÚ’HzÉıÑ=v?árb” fé½¯àÈq?zO‹ĞWÄ‘TŠˆÒ‰Ï™%w>›™­õ¤ÍÉÊæ ™õgv•ä~ŒZ…™Ëä$·)MĞf¸:F	å„×¬+Ä_è6‡JÑnVÖW„h°¨÷]@<i€!É¼ğô¼M‚¿FÁ¥öáORbûËàe$ÊGÃİ˜G< ©¼¾i*¨(ãnœTÿ{]§½Nÿ`x2E,¸¥|€ûúàèÕŸ[‰Ãå™:èƒ$Ûj0©¦a–´¬¸µÏÏŸ¯¸‚ïª}»ö¤Lú›%ùÎ¡*sÊà4hmÓõ‚';äñ}yY”P [?ò¶÷îÑ!ùıãR†j ¦ÈÈ*²!5âYËW~m"‹^V\I)èí’5‡$?:ª>OÉ%³I ‘°`® «$UÓ+0:f€åSêÖØ’~™T]¯ä”—Fš§'Wªêşk¤¿QëÂ·ÜEµ„éµ—˜¥c§-ª¨Û¶¤~]õ«Î¤µòÙ74&Qªl'äs5¢Lî”~!¨Ã=¸¹*YÀİ‹ë~÷z<†¿ìzS=·_¦°" ÛÄpÍô1Zëp]]½ìLĞ©*~ >\øŠ¹xïÜŒv–ÏuC	Í>—Ø/îšhDOC¨¡/QqOÏ¸½ ”±Íğ‹¯/GnÕõù/Ëœá ÿf«!cÅ7¹noÒ9ëWîSg<DÛÂ.ÜÏ»»€¸Kz£+E?½ë}[7ÛÀèrœø-ùÓ‡^¿jMÇ×UÌ?"Âš›#Zfu"ÖkD2ü‹Ókˆ9œÇh&C÷0”?uf‚8„8ÜÙ›nËÚ¹²$-[à<²Ğ•ÇiIçšåİn%£â (“‚”——ãÀAğÉÖ!›RHQFH3Ú,éím¦LÙ¦ĞRXB}:F 	ÓO·|DŠŒœÿtÅ"ö²df	 ´¥K,ºË“ë3Ò¬	•G1!GÖ—`˜àÍElp™ä9 ‚CX¡ ‰Oµ›D=·¾<Ãïİ£DnÕòµà$‚™Ì‚ x+ƒ±ü|GÏ/é*ñg`Yxó.“¯Æ>ûUo~¡!²±ñs5}9¾¯2ç¶1íÏ«Iâİr·KH’z7ä<Oá½'œX …Ë§ƒiv
+Aól¸i@ÂŸÒ²4‰}E8R?„õ>„!‹ÀLâğ­»!/ñóÈ®s  ÍõÑ¡å]õ[B©%Ù?µİß½?ş„¥o @lÃÜukK¯Eu¢¹ 0?^š¼¥éŒ%Ï†Åd‹¦Ù´À¤[¦[cÂm àˆ,c©ŠºQ!ç íS·È©èóçkYËIåÚç'óIZzÙqf™$yêg²„İ¥™…¢LËÑÜÈï”›MSefĞlVlüŒø­Z‚ôß9ä%Vİlá­Öqm©û“2ü4s%?ÒŒ0¼µ­À­ö†e¹–d—}vÆ\ã†}lÉÌéZIn)÷M!N„Õœ)µ÷N~#€…ï¤·ÄÿxÏXğr©WÎ©$¥¨ëÛîFİQroMı©MÍDF÷/åæ¯U ÁŒCyAeƒ«Y„‚ÊŒ!Ô7 ¦’kww¿œ÷y÷ÆÛ+Ã»°_”ÈÔ‚›ÌHõyòNò•¬]l&4k2À”03 %,¬É“º%B½mÔ:xŸ è½ß,æ<Ä'„ˆJ*Ú@lÌ9QójyC•¶ª!iÔ„«n‹Yå•9ËhÁ=ò2ÁßzÅ®Í6<&-*JZÓ¨,m¶š‚,—i¢†@"Ô·ÜÓ,1Ü×éQeì.íi¯í9¨­\s¦@‹SÎS_¤„¶1"Ñ÷İÄ_Ò¶ÇšDÕ=vgØH{]uúàœ	 zPğ®ÓLÇÔ Åoc˜ÎNê÷%ƒ¤á.³æ4¶Ï@ßcZ©BWğÍ5¡h¼V7F&âÉ`šÑA­mªØ´RîséµäËs„ª¼Pç.–l+IûIUÆ›¡¡¬¶çb¾¼ìÙ©ÔP@QôÈçXuÅbía¾#rÎ’ŒÜE—W”ÄKzQr“â­yç¾ƒ6ÈµµuO§m½MW=y§˜›úGÅ#İ‹L6àüí!©9¸Ê»z/àßÙ]­0ä•”9‚.sØƒ"ÛS  ËºB¾ÜÎtĞ¤47´éd™[Z)ÚÓã4Ú6ù JŠ>Û©“÷ë¡í§=ìˆ`"‚h¦Ä/h*¦––Ü*ÆË!ÂOĞ
+Tä½Ìx‹ÊA_µ„ĞÔ_…¦iÍŸÄáIŒ“ÜdM%`Ê„XiÈÒ2»Ø3à=
+çØ„ÏéªO ºÈUK¼·Ã_õ»³†Of¢!… ¥ø ‚¥WÊ¡i{Lw¢e7Ù\è²EÃ'¸BIK‰*wS`o‚¨à¡DPÓPD!LV-}FCÎ3´.ø‹gf±Õ‚±¸Mk5Ü¶LğN7iäˆ2yKI–ìûÛÆ@]“<MµŠMQ¥Õ °Sñİ‘šÉ†T­è‘d›ÀTgîÎÕ¶³|8 ÕF.…ã(Z4êœéœùÌ•ğø·¿¶ËE†["ú=ü¸w ¢Ú¦0­5Ó% ²oœ{-å¤Qİ(Ó¡Ú I¨Y8şÎ® 7şêâÛ[0ÔÓnPšËx^öGŸ¥3E¡š”h»V½:'£ X²,[ŞB¡!Æq2S•R½1@"¢±Ñ>õ(¤ŞßTË‰xB~R”ÿ,ƒ‘ TÒÎ&õŒ)ÖÅyVMnFïe)Š/dÚÔL¦lÛÚ¥%{àú‘˜¯™GA³İd^ÙD–³‰\s®‡|˜øQBYp®ÈÊˆFĞ»kô¤9‚I´N¿M™ìÎ Âˆ:ÄÚ+‹KP§±BD•<:_óHÌ{œVq‹$(aÁP5÷ªvfVØ>‘£4X³%‚$D¸a\mSŠñ&ñıÏ«×P[K*âÄ›,×61V©c³½­Û:ÄÌ–Åª™„Ñ#'F*ÿÄ#$Ã°áº"QD÷è"¢{…¦Õo‚®9Üq:¸;ı#¸}ö$+LB8İ&Œ×P:ài.+äø‚(iĞ·±d‚¬šU««nµQÖ£ ïæmÃ;ÛrÊáûØ³ZãÃ,Z¡4Ú´82z¿å²$Z‘láŠº*ßJRnrVX©*M˜¤;·¿¤SLS'ıÍÍk£r‰ä%)¨X£Gµ:Œk¾€vàf:Ù^4»¯etfÁÜä¾•Á)”ÇÜ”öº›™ ÷ª”ë•T}J»ÁäåS¨‹õ@™-œvï«A'zÈEJ’¼UJ“d¼¬Q4:ÎÕ8ØÊŒFKÛ4qS^4ÕSÀŠˆÓÃC»‚oBˆÜ|#	£B¦9°˜ƒw\òÄšavÊñmTÔêT¨\q—î§r3D0³5{G¦‘¥ğpb@ÚX­4"¿áÛJ:ßœUÚRÖ Ú
+â†yGJ€Ó,ñá“ècEÉŠæ*Ä45ã$Öq+™Ÿ©‘ÕkáˆùËŸ`ù‰_‰Èü6}*Î'#ÿ¶6Å¹Y^XÌğiÎì^V‹#8ŸÕyœÍ9€¬¸Ì†ğş-ä¥ù€	cÔ„O|;ñ‚7Xl]MìË×¤°¬™·ŠÄ¨3›êE&œ6Í6µŸ`g=­Õq›–—D…ÍğÉ›‹XÔ@fÕ?År³FX¨7Ï$#‡É)|J}r.aB4ë_BmÈØ#›¼·Y­»FÏ¤¯ç½°.h—öÅ•H8ß¢ä½ ÌiØ¡âìƒˆocõô`|ãî]_’ã^rº½îäj<Û] X:q»:Ç“ö‘;¤M™……)¼¢g6Ù'îÊ½½Î´ó—Ñ-ïôÑG~¢‹NV§Ã†ÏĞf¬­ÄÃôP LÏ‰â1zPÔvçjçzeF4<ë0ø»ğ‹Ñ.!Ñd[À^£ÖşÚ.`™’\gML&i‰.r[ê±CÌ¾v\MÑªôAõÈœËKc}xÆ:Ğ«+¶2hJ!aç#&mÕÁ]]ñÉşpüßïtäã¹Å|HÖh:ñ”Zí‹yB L7×ä˜‹ã¹ÕJÑnu@­‹ğ 'ÌˆcvŒ«)ëñóeÓÖà“M/çá|~LŸ^0RÑ#…r)ÕàšÊò©!¯´åÃC™¡|åó‰¤
+56G.ÇKg‰ÈX Ëó0Ç¡!sLCı -[êÍ:±İl÷–‡h„GqSNDÕk“³ƒÑ\ÉIã—@7-Z	_±±Ìq…#ÿ#T·ü`~m`[O—bHs¼ö«%YxÎQ#€ğOş—o	Àƒ ú\ <¹ÿ~M¦ÄR)¢èŠECš±Ôe›ÃôÒ¤QÚ–7˜B?‘@MŸ<
+±E“À9ó†ÀãwşI¨A¦˜¬-Ğ#IÃQ¼F2f­´ãjb®ò“õm­Z®¹	â©3¥LG’™t¬7“ê?BŞ.…š¹ã9>Ï¬) fÁÕl\øÁ?°“”Y#¤Gé>[Ã}[H:¿ØvQ³L)…˜±Bƒé]!ÒN¯ª÷ìpIØpÒªµ¼jœ¡"	O30Àhu;:öÉÛñ‰kFİìšÅämÖâõßbsd1ê•9QU¯a`è~r:P¶+/2ãçš°0öi¡NdĞ¥R„I)Q€Î„.ƒÁu[IÁ.c\¢Ú¢ôø_¬=âX{Z¾€\3å•kØô¹°tôx.òJŞ#ÒyÃ>¥y¿èá	ÇyDhj€­İRq¥V5pÆ÷ª+ÌU%’Y3{£ìr{uı±¹ÖÅÓÌqÉ¼»Ê<Åƒ\’á<1oòş\X…ı½È§mœÆ¡ºNbAûgæ e¤-¶Äœ¢H¥g"xo8?HŸœïQñİêÚJ"Lóâ6×¢î&İh¢^D™]äCšÉy!>°€%–W@¥_ ğIÏ³a`<Á&j¿ã¦Îb”ûÖz‚Q°gˆÇ>ëaÚ„kn±©¤¼gëéU&=Ú[ÊL|ƒh#|BzH¸®ü”K<# ´&šÀ!"˜ÅÁ„…ã#¹p™$ap¤†„¶o©ß@ï!CºSu‘V#½ìM^ìSá² ó)º˜×S‡çƒß÷>Âcéã®4q4¤G^7ü~@é…‹'#÷©r×8ˆ—vnú©w^mĞ Ú­-ïõm
+t@˜šCqQh ·ÂÌÁ5^´uVA"½!PîéEkxÉÚã¥ì[G£ñ C¯Åâ'ø¹ª×zÌ¿³![…ØªdM5ü²óäµôx%ç•ôìóßô3àîÛ+å¾G7î-']R‘p$§ğ‚‚°§²‡¡Èr²Çä±²¶"öñDÊÚìi“‡ø	eÿĞ#5j²ŠŞ¾ç2ğ;C<°ï%.K¡ôŠ/rĞ…[şA}2=ñ;ñ½ve6×Ú_htúÉ{\£Û/gš\ŸÉÃ3üV,bB4«>ÏÆq8Õ‡¾eÓU§x>x.İ0§8®È.{p–É/m2áVòxì>lv!]í'¯JŒæ5öBk€¢íJ Š•÷÷Ò‹É(oQ>+;@rC“.{ãB÷ú¼’s“–NæUÁÄ ²ú–=&Y¢šË ñ§ô5tI’V/H¡3êÄ’yAıÂx_šA^$™b%jxf²µ;>Ê­*Rúi8rSz4ğ="\ßÉ[:Sˆ–LM”ºƒ5‹,0’ÉŒl‡^ Š›ioˆgEïnPš¼)Øt'U`ò$eo6øHµŠW¤²tåm'Q¸Æ!ÍäÍÈÕš—–W¢Æ,j®):G?i.FZƒoêÓ{@ldKãÎ@ÓÙëÁ.Ş[Ñåj‡8î¯ŸÓE-SæÍâüÜùÊ¡úè­˜o!ÊjÔzî‚¹¨Fİ©O<ñÈ¥Ÿ|XbØòŒ–áxÎ8èä:”2+^‚‡¦ÑºWPÂh-ÌèvÂåĞ¨ÖCŠk`)¤¢®„V"¾
+èûÎ©³MßMB•Aè•É—€¬¹ôğU®yoªm¹DÔl¸"ìS iñç›Å{AÖåµ(r»èwI€œêøØODpİbˆR=6AyBkr­^–EX	å¼™A|IP˜ë›ÇÌâ-)=2†_Ótpu•w=ó÷ÇlPİeß–Æ¹PÙßğ fnC°¡ş¤Üù:ş  !!²3‘¡Ï= ø,»¹ë9¦tnVF£%ü´>ğîRıô!‰ˆ®…WkdB¨y"cwet²‹|‘õùW¹5tòË%WúLŒ¢›lPVp·¾5Ò$RùI#NİÓ¨4¢+µYI4£ÁÚè[ƒÍF’ûº«‘‰>7E_ly·ü±©•
+AIÂ›ü›–¡ZÓW)XsÍ@''¤ÆvÙG$!6Gƒ&C{@.)º‹úpV)ª“‘˜mßÂĞ'¨ªd03Ş+Û”k³UD¤iT#ú½ÈÓfµ éÌ^Î—‘.ç)‚³ıº¯é[˜•¦I‡Šğ«UùÂÜ»±6QÈ,§4,M†%zÛt'­‡bJ&æ\äE,Ÿ¯qd÷Q+æz~×İ_ILéŸ¦p¸Us"ÁëÑYe-
+ñ©³2i5ªÀœ˜ì'|ñ©>)<ı%E	Sğì¤Ùâà´äİÛ”äçÜ¢p¡“ñKğéÁ¼â½<şİ1=¤á¦È!÷=WÎõ”ÌnbİÜ][`_3»œ¯"ÿƒÆÿŞ#³^œÊ«ÚîÛœ‹:bÕc/æ]3RĞ¾M‚÷ì˜õÏ“Š%hb¶÷ˆ‰!ñàÿcä^Â{Å·c:ò9«ªÿ'EØşKO;ÓˆäåÃÉ‰[<¾Š÷–›‚İïš$–œÌ±Ü	HÍÍ—âD‘ŞBcV
+ÕŞn¾0Ò¥l@"Àb°‡ÉÓeŞÜ¡³°ó±ÓëÓ{~‰7Ze7¬Y^XÊ´É9 ş}´«'ĞnY²8ı}áÿ§H`°
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/0d/1c870014747be1d545f0919230911be1b80e30 squashfs-tools-patched/.git/objects/0d/1c870014747be1d545f0919230911be1b80e30
--- squashfs-tools/.git/objects/0d/1c870014747be1d545f0919230911be1b80e30	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/0d/1c870014747be1d545f0919230911be1b80e30	2022-01-01 15:09:15.649172590 +0800
@@ -0,0 +1,2 @@
+x“QOÛ0Ç÷ŠH(a-†¶‡ª#ëCEKPÊ¤m/Vj;`Éµ™ã0©hß}¾$nÓjCä%öùîwÿ»³WÊ¬àââüòİ±ÔLÕ\À‘Ú¬åÎÙ+Ç¥A[ßd¥~8´q%W±óŸ‹/_3\Øæ„T®p’ÁÜ'êì ÀØ˜Ì–âW-´“…šé¥³¢XHM«f¹wÕ®s0µÛ:Hí€ûTë'+ªŠb)ÔC­+ù öXØSdòÂ >ó¾m
+ñ6ç–šŞ © 3¼¢+3eY	—À¢¨ß>l^(=ótL¢o³ÛûOWMÿ<œ*€IØìNCn<°²Å…AÌ´tq×·­’AÀ;e>.ÊÂ`š€û§	’Û†„‰w’{¥¤Fûi×ÌŸ0Ö÷’%Äqz=ÿ\<Å«ugÍ“°NŠª‰Kàı–4»I¶Y^HYáj«›ş„ä¼hD÷ DÊ NºáSå×A:U¯Ó‡—»izÛ\ã3¼L¨.àş©pøqÄ¢Ğ6°e™gaKe~Cœñß<¼ÚÃ…>œ‰8]çéÖ†ËR2ÿ6öï¼ä¢Jo¦ùítN)™~¿Ëò{ºü±¸Îæñá+û¼ñ£:Ú#üåù!?Ÿ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/0f/177b6cc3b6fdcaaf0c488ac3bb5e9fc0e00d18 squashfs-tools-patched/.git/objects/0f/177b6cc3b6fdcaaf0c488ac3bb5e9fc0e00d18
--- squashfs-tools/.git/objects/0f/177b6cc3b6fdcaaf0c488ac3bb5e9fc0e00d18	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/0f/177b6cc3b6fdcaaf0c488ac3bb5e9fc0e00d18	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1,2 @@
+xm=‚0Eû+^`QC ~,Ä‰²à€1æèÃ6WEƒ¿ŞêäxsîÉ½MoØÅÇUkjURä¥š‡&TŒùº#‰Á‹ä’fÂAQfUÎEÆ|G4áèTjûY"x©CQ¹Üq
+•ÇXu&{ØÃwH¤†8Ú5_,ÂVÖ¶àÓ™ôÌój¦ 4Y@jÔtÛœÜK$©;öıh?¤
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/0f/1d6aab788dc8341b0c3832189349a7d47d45b5 squashfs-tools-patched/.git/objects/0f/1d6aab788dc8341b0c3832189349a7d47d45b5
--- squashfs-tools/.git/objects/0f/1d6aab788dc8341b0c3832189349a7d47d45b5	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/0f/1d6aab788dc8341b0c3832189349a7d47d45b5	2022-01-01 15:09:15.629172589 +0800
@@ -0,0 +1,2 @@
+x]Ñ
+ƒ …wíSHİ×À'på0˜³íö§RI£ŞÖÈÖ.ı8çÿİøê0!çSšâºO„bkœÒÔ´!€£Ø¿­Ó¿ÅóšòÈn²ÈC(¼rÈD;õÃÕúø{•xÅŞ-©`²¦;ôÅåV	è£©àÎDõÜ; e•3 p).ùéTr ËŸ\?ÎJãÈŸK†èDkİ·] ÇwìŸbƒÁ ²¡ìPe
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/0f/2bfe861948ebda85c36086d9899cb7c5803e2a squashfs-tools-patched/.git/objects/0f/2bfe861948ebda85c36086d9899cb7c5803e2a
--- squashfs-tools/.git/objects/0f/2bfe861948ebda85c36086d9899cb7c5803e2a	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/0f/2bfe861948ebda85c36086d9899cb7c5803e2a	2022-01-01 15:09:15.665172591 +0800
@@ -0,0 +1,6 @@
+xÍYûoÛÈî¯Ò_1ç">É–?PbŸs•m9¢Ø®—¸¹€ ¥•D˜"Y’r¬¶ùßûÍ,—/Sy‡k?Dî¼ç›ÙÙÕëßÑO/ÿô|§N;4ö¢¬ìhA6é³ˆf«¢u«e›h´p"ÂMg¾p×4ñ—A¨¢HM)Tö”|Ï]³¤ùÍ¹¬C0ÅÔ˜4épÿEöåïSÜ,×uêû«ùB…ôs _üÕØÒöÃy{uÿ2‘(Æ¡?í%5•¢ÈŸÅŸìPĞÚ_ÑÄö`×Ô‰âĞ¹[ÅŠœ˜loúÜYáÒŸ:³5¿[yS(ŒŠb.#ògòğêjL¯”§BÛ¥›ÕëL¨ïL”)f·#
+øe´€÷wká¸d†‰téC°;¾wBÊøTá™[,Â©aÇljH~À„MØ·&×††¶½ÁßÌ­)9¨_ø\X@$œú„pÒ¢U¤f+Wô!ô®7z}=Qçê–ŞuƒÎÕèöÄñÂÇªzPZ”³\!˜¡íÅkÄ„-~Ûœ¿Kç¬×ïnÙƒËŞèª;Òåõ€:tÓŒzçã~g@7ãÁÍõ°Ü¸Ï6Ç”f¶ôCESÛÇo‘ÉÖ¹SZØ
+(ç¶ÙÀ_À–‰ó›%³^Ûõ½¹¸	b %Î	93òü¸EŸB ‰}‘UÈ#³g©lÑ_^ĞH!<Šn\{¢h†+æ=:šÏü(ö½½íĞşáÁÁÁŞÁÑşO-;ÆURe{‡í	D?¯×ÿìxw5U´eÖfQ{±•{oJÀâ‚³c^¬G1 5I+Õš…ö|©¼ØÂo¸¶i'}Ûw®:©×|Gªuçú“{à­Ã´:su¼˜v²¥MvhŞqØ
+!ˆšõÕk£Aç¼ÛØâÚÏ‰<&MBÏ¦¿y[­ä©	jÎ¬}²ƒ&¹VĞez?hö' Yªå$X7r«‰<KìIíPäüSù³‚+Mh¬Õ†w†¯/‡Öğ]çÆê]†ÖQ#ÓÕ¢§¢#füLÊE¡§äYôço2às½^ç°JˆŠ	Aä”òggê ×±ÌI¶Å©„X3G=Œâ‡»u¬":¥Ô±ËAçÕÛîÕÈ:»u‡¹÷í¨m´‰;Ìé Í=nàí]]tßoä.dÊÈM©ÙÈYEâc@Z>qTÔeîmjåb¿5ı%í?>sİGRÙ5F¤8Õui1±uÆ)øJ¡¡ÓSÚ×h¬Ê Âü¡¯PÅ«Ğ£Ñ`ÜeĞÀ{ãV	KÛEµ5$oŒ,Ô@™æ”®Æı~òºï{#k|¥“›TV‘ú˜fè¨Vô*‘ŒÍ‚8X-Y!`©ÛiÍa¯Ë{d86æ²†1Ú4~#K¼hÌ¦¨›b(óÑædd…—âS0¶¥ÂUiGÃ&¦œÒe§?ìê¤ÕºƒÁõà«qbëSÜé`Õ¶$H?:T0:I§h`¥Ÿñ›št¢7R1UAÜìL
+YöJwé†lœ«lşŸ†YJÇÀ¶m™~6¥‡İ]nîbê1@£şO	Ä»tĞ¤N-ı’õÅ·İQç¢3êXÃŞß»tÌ˜¬Õt÷Ü¦FšÕ"Ùä	Ú ÉUŞ<^ğKÓäWÅîƒó±%E,‰76¶¨ÑĞ{h3…Ÿ.”&,‡ù;lUµ)zûJvØAÀ¹bZg¢u—|l›“×k6Ú«4i7îşÎ&f~©À8ó…¹ vRÃÍH“vNæÅ<ZJı(ÊÁ&‹p±„±in±a6¶SÁM‰X­±ê–`#½:f IÓú”I79Ïäj±É”²ÑA­M‡c²aC*féíwŸ‡¥Â^	¹y/e*M{æ=€Ãó±EdÇÔóœøvØî'Ÿá=N·qóÆ~æ«×6:T%Ï(¸rP ör'gHÍ’{÷^æV…–WQáõIc„³ájÂ³‘|G¶9ù\‹sr[ÅMÔŸÍ"Kx@Ä3ùÊã3^ê°–·@	«s¹ş ã²‹p˜™`X3ğ,½´K9ı`Í‚®ïß¯í#ÏºÀYût2ÿÔJÃ<ÔåˆÑtkÜÅyŠıpÊ	#!§<à‰ŒòHMŸM?ê‘õ4%Â¨y­3ØŞÁ¦á'‘¯åŸ‹!n87â˜Íª¸—&Ş WİSîìH¡hm+ÍH$ÏğØT÷¶~S8j$µ«™Ú,¦ê€qÖvqÊ¸¾èZ¯»‹î 8ÚÎñ´ÈÈkõ©%EJ…q¢¤|)JÌGªD,Úv‡ÈyºÙô®~íô{ÖûÎh4`HµW8bSÅ?+n’üãƒã‡œùLÃEè´çBœ_šNÃ«qïbˆYKæØÈfR½„ók-w3\¶	´ãuP´Bç_¤'%)i3£ØÇ‹70ãÒÎ’)’š[ŞÏ"+Æ+YÓ¤Şjy‡‹S(úqwWºnL&‹Fµx=¬L ‘,Ü½5º½éË°—uCœûÊpÜíPkÒÖ)3pv|ØåºvWÉ0ı¨†œd›+m™lıTƒGonµÙ2OdççL},fĞwr†g¿àŠ®„Œ„í—Û¸B³Mö^òÕ¢ÅÔÈÒÖİ*[O»/J7ÈÖäQ·¢„›­/“ücLÄFpÏ4| (&²¿)“nE¤’‰¾œË*1ÿU2YPu6Å…éd®ïË§p|%¡Æ–ÿËŒ^öúİÊÚÕü«µ	š/ç³BÈ÷¥SSWgrĞ}U®Kiß–AMšK¹FÓ°ıÖÜTD\Aé+ƒ¬ÈÌÀÆW/O6#>]3Fj¿íÓ±PrEOÏL¿Ö›^®drS®ä:ä[:…ˆã‹‰	4š«”MVÒ/bgÃÑı	š¾ÉìÂÅ0Î¦/_
+]aÕõçì›æÜ@ıÕvˆ}†Íº¸Òi ï²Ï°OwØ$µBœu¹x‹mnxû¶ß»zSYÑzé:Ş}umt*›Í+!şr‘l¨¡ˆ±¥Ù,Èï!Æ¹„¾ºVŒG¥Æ'	ŠlÚÃâ,°˜¯óq²šI\B’@Í‹J=f”û¸ ”òd‚ÕW‚"+¨u$W[µ-#ˆ÷Îôì£Ç—é©\iWÃT;“ÆVÑ—ÌÉ!¹Ê!¸Tî…1E§?"&?ş¶ÿcØüş^¢,¡´Ne”õß\tÕ ­×¨„áó×ƒtµ<v©‡ğÍæ.õğeØNŸJù]!ËÖÿAp-e!„kÅèWŒB—½ËkûRè‡×çoº£t³X¢@·©´óLÕÌ^¹±ÜÎ•î¾ÇŞ½çòtG&™çñ=¾ê”ËîšşÖ©ÌÌ1°¶a0‡K˜è’‹’m‡¯ ş÷›İ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/10/be1cd7dea3f24fbab04028a73908afa4128317 squashfs-tools-patched/.git/objects/10/be1cd7dea3f24fbab04028a73908afa4128317
--- squashfs-tools/.git/objects/10/be1cd7dea3f24fbab04028a73908afa4128317	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/10/be1cd7dea3f24fbab04028a73908afa4128317	2022-01-01 15:09:15.605172588 +0800
@@ -0,0 +1,3 @@
+x}UmS"9¾Ïù]úáÀTÖİ“«Âo]E,Ä»_¨Àd$u™v’Añjÿû=Œ¼yu•Ê¤_ÒİÏÓ‰É&Ôj~úøÛáİ¾&ò¬İK§Õëtû£ß¥ôrÖ¦ÊÅ—oUºÒÆ©œ E*­££³:ÿOÅõS–Ó½\˜l!î‹‰ÑSŠ²Dê”…Ø×q©˜Æcv‰î¾Œ¿Š}éTíœB9š"R´×h–se³=!Äµûİ’LI½ÈdnÅ¸s#Æ2ºÂª†ø4…*>¨a|Z0s*µ:Kk¤cZBã9×N‘›IGÖåJ&ä2Šµƒ7£™’H•dYÊ,6ÚÁ‡44Y²qS™F2ÂE,Şy¨4O¼…­~Dƒ8¶ÊÑƒ~UD—ÊNs=g·ñBM^:ø¨Sê£Bék^Î‚ò×Zİ#„°¡àåŞ2Ø›iÌE‹h>!À¡<v×.ñÊ-ïé„×HO¨b´s(°J#-Óª×k{½3^øHæ¹²VEd9…]!•Æ*¢¾ùF-”AØo^7ù³ÏÈö¼ö¼ùT8ŠÀYGiŠ€úWß#mé´!„XE^§ Æ(_†ğ7ƒe^šÈIéNÛUM›­3ê_ æ•&ŸSëc5˜y¢·êTÎZÙ0N­m6mÚ'ïm||[	!‰f{ëâ“ÒIÍßÊÕáL=¾r…ê% €ƒÌs_ªuæÖğmdşã3¥º¹`2G^ƒ»d¢Ğ,fZéàNÚ² wUB‡U¹Ø3Ò¶Œá
+‚‰r<6QÌ%ê¾æQRXÇÎÿì€zÌ,`xÚÇ á> zø1¾º¾õ†ã»>=ÙC'ïˆ¿÷XÌÓè?åİÇÑ r`är­,M27#ÉM‘"ªN¸W•QSÉº2_R^Ê©FÏÚ_ÏgLs	ÛìJ™Zå9=ÏTJëæy¶Ğ_ÿ®:»¾¹ŞrÁYş¯²³B´ÈÏdS féR:‰Ø‘sÙåSŠÑ§ÜÀlØíÓPı,t®Àg=¯VÀ¥OœİP&¾ù;íã¨Ùlœâ!h£9>”Å¿À³8P‰§&*Í°ú„v”v Å<
+Ö23ËevÅæ±CåŠ<¥àip|¯Ö:nà¢Şp8û½ş›¬N}•d˜e)y©<Ïx”®ôï»\Aÿ«Ó5Æ_şs @.TKwğ8º{ƒ+°1+Ü¼ ßŠ8F«d˜±É7]¾{İËÒµ¿ØòœN0ğ &¥H§Ok,©’¥féñë¯¦QUğ+«RµŞÃk¨=C!ş	7­èÉïÇV¥·¸¶â×B<Á¨­^¹à×î Ìv5?	Æ.|İ*¼§S°ÌQP±9Şf@{–ãV†Ó…É^£ÇëÔ·Vsï1dkUÁ>¿=±ø²—ü
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/10/d03982e05e1dbca8334cfdceb1f1aae95a6133 squashfs-tools-patched/.git/objects/10/d03982e05e1dbca8334cfdceb1f1aae95a6133
--- squashfs-tools/.git/objects/10/d03982e05e1dbca8334cfdceb1f1aae95a6133	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/10/d03982e05e1dbca8334cfdceb1f1aae95a6133	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1 @@
+xePÁŠÂ0õ<_1èÅBĞj±zk.« ‹à-´MJƒ%Y’´(â¿ïÔ‚»ìŞŞ{3ï½aªÎV˜Ä»Ùz·,]µ İ©â’¥âD´QoN¦îz©p^¸ÒÔ-·R¹U;ÿ7 ÿ(ƒ®¯òi=Káˆç½	ÉÅ—SÃ±ô×üv²~”«åxÙŞè°Œğ1bÁ­”â%¾ØFÆ(Ç'<s€ãw¥÷Å²àAN†ñ-Ş0LØÏ5Èz¨I»Ğ—İÔøÙW¿'L©ıG©ø—¯_
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/12/44dc865cf61434e61031f20087a617cc623261 squashfs-tools-patched/.git/objects/12/44dc865cf61434e61031f20087a617cc623261
--- squashfs-tools/.git/objects/12/44dc865cf61434e61031f20087a617cc623261	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/12/44dc865cf61434e61031f20087a617cc623261	2022-01-01 15:09:15.637172590 +0800
@@ -0,0 +1,3 @@
+x}SaoÚ0İgÿŠ§öKËÒPèVmİ¨•Ø L@7­_PB.ÅZbSÛYG§ı÷“ĞªMB‘y¾;¿w÷.ÎtŒVëUûE³‰áCM¢<\
+±/S•PŠù¼çK±Ï€T´…q ZdEBxo]’É8\?a{aØ¬~:ÏµjÎÖ+²árOˆfCÔ•ûj¡:Cïâ#^bx3êbÒó¯Y+Õm(…%‹0cHµÉ# .¤Ã½‘ï4ó‹’D:©U”!^;‚Ó›™Ñ™ Ïp¥‘ÊÌ‘a åŸoN˜Ãa‡BÌ4VFÿ¬.&ëØhñHä¢|É¬§òÖÅ„ó¤ò€ØÖˆ(Ëô"ò<?D.Â½tKŒÖ]6{ò¶< -TYÔ†Â·`Bw…4”“rÖ“ç•ouvoàmøš;x:êñ÷²ÔÖãÊßËpÎÄ3°ƒã 2õm­âÑé 2Kÿ¯d=Ïq¦`±L\a7ŠZ–8æÆ?•Ç¯•]ÑB¦’ôÑ¾ù@›oF”k³Ştˆçz¼?ñE
+·âIÇEš’ÁøKr9bb­¯ Ó›ùå`8ëOæİëÙ9“à–¤@¥Å7<ËÊĞ6´Á	V‘eCy¦íúŒ{_—¹oæoÙ ½ò·BNÛ”ØJûÖŸş?¯Ñ‚T‘£?}¨ú>b®¿¸â“ˆ«q°õŸËn^¥øıN©Üfw«e:àD0WÅ¦íùhHÕ+;À²/ç¼2¥A”‘UŒ.ÜN#Ş<Iølô‚·’’:ÿz ÜI{ÇÁ¼jÛ¼ÒCæ¼O*‘©øPsj
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/13/23dd6f2cb9ca7fef841db246cda64d09103cf8 squashfs-tools-patched/.git/objects/13/23dd6f2cb9ca7fef841db246cda64d09103cf8
--- squashfs-tools/.git/objects/13/23dd6f2cb9ca7fef841db246cda64d09103cf8	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/13/23dd6f2cb9ca7fef841db246cda64d09103cf8	2022-01-01 15:09:15.669172591 +0800
@@ -0,0 +1,88 @@
+xí½w[Ç‘6¸ÿRŸâš9’A‰¤~9“Œe+CK”ÍDê%©XÚ$A#à  $“ıìû<OUu÷½¸ ¨8Éîyw=
+÷ŞîêîêêªêªêêÃáø°úÃÃß?üêÿ¸÷Vu·z3šş÷eozVõ*ûq2­NÃşôj:ëŸ¯WÕşÙ`Záÿ{ÕÙàôlxUÏ/&ıé´\Mú½ãj<^RQ|ól|q5A¥YÕ9Z©=xğh•ëïWúû{ıı7ııƒşşQÿ>Ğß‡«†GU¨ê¿â»×gƒáppQ½_õ'Õ7öâ?b(ëãÉéúå»§Ş!åb2>ôÎ9¦“I¿_MÇ'³½IÿIu5¾¬z#ëx0M‡—³~5˜U½Ññıñ„'W|w9:Fƒ³³~5ëOÎ§ÕøDßo¿©¾ïú“Ş°z}y8U/GıÑ´Ïê½iuÁ—Ó3 ïğJ5^°{Ş‡êÅ€{³Áxô¤ê ~R½ïO¦x®	ãIÕéÍØÕI5¾`ÁôïªöĞ(»¾`¼yXÇÕ`¤æÏÆÂ@bP€Îê°_]Nû'—CµT?níÿ°óf¿ÚØş©úqcwwc{ÿ§'(<;ãkÿ}ß@Î/†ÈœôF³+à„ƒ~µ¹ûìTÙønëåÖşOFğbk{so¯z±³[mT¯7v÷·½y¹±[½~³ûzgod·¬`ø°§Õ	€'ıê¸?ë†ÓøO˜É)z7<®Îzïû˜Ñ£şà=úÖù^°gübÈš­áxtªa¢0¨Å	çI58©FãÙjõa2 ÌÆ‚U›GVÏS¹Zışß«ı>ĞÓ¯^{Gıj­Ú»dİÇAâß§³ñhµzµQ=xôğáÃµ‡`-¼ÙÛˆá\ú"=™®ôı[·~7/ûÕrñíl¹xK ;ıĞ»XoÿÄ¥Ü›Õ?ÆòOêï?öf³Æ«Ütw0:×ËOgÇ=,>4œ;õ¸Ê}üÏJ?m|˜]]ô§ëgs¯çıù·à@XG/ÃÁù`Ö€qD¸pkúòh†%~„e{÷dÒ;=ïf]=¯Vw±îzöğ$Šş÷eÿEgã.Y]‚Røîs¹Ùƒˆ€N&ãó®==¹u1;cîô¬ÚxÒµ7¹Ğ9øÌÇîl)õH/Üºuÿ.—b,ô)èëôh<šMÆÃê¢&3ìƒ›ˆ_,£©ôÜy<™VßVkÅ‡=½¼èOº‡ÃñÑ»júİğ)Î2í‚LdZñašÆŸ‰¡ºËß€Æ6¯f}‚ñ’ºVÅû»Gà]3{{<˜”Ó«óâñÖÒqÿ}ñŒÚ'ãüüäÖÑYoBtûİYï«æÛjûÍË—À! ÷fãÉUíCêï$™}ébf'W5(]~=ø·ßÿşñ¿ı2ªüúD£<9~r$>8qpØw/˜QvÕOÓC£”Èé¸ËÉD¿÷ş×›½^ìu·¶ÿ²ñrëy÷ÅîÆ÷1Ä4á$½ôÒ·[¾°ßµh»ÓÁÿôÛ‡áøÔ†0œR:£/6^îm®b'ãüî	^”>‚aNfİ!'v÷Í¦A ıöOû£\tóî|Ö?ÆjÀ<YáÉx<ë:Ú›£ñğò|‚"ş&ãj ĞƒyÚŸ\ÔuÊwB>¥áİY5ş‹˜ZÎÁqîQ73´24:wµ7ÒOØø*X6‹¨ã*Ò@âÑ¥¯ÿÈŞ5.Ï±¿­°®øv4îŠ/²àÛııİîóÍö‰7ş}õÇãw—]²¥ƒ_Pñ×[KVo-D^<ßÚõ_»›ßû¯—Ûö_ß½Œ_Ï~ˆr[/vüëŞÎ³øü[ÁÜú[fXé³JDıµbW_í¯ê_5K¤~9ı²úúRÿÌŞëë°í+G¤¯‡m_9}=nûJèëQÛWâE_/Š¯»oöP½·ÑéIñùÇøl?áó‡âóî÷»¯­¶~@­×Ï?ê4Ûzíı¬¶~@À×kÇçõZp­ö[t­ú+»¾÷fë¹à4_A/®MAó{ªË‚{Å¸Z
+òÕjÅ‚Ë‚˜wâûèDã4ùz'ßÙ	ÕeÁZ'æ¾Å«ÕŠk ~¼Ùk˜h¼ÂæáËYÙïÆwvBuYpÿú‚o5,˜:Z÷ÿÿ›Êûñà83§ÃŞ¤#ÅQÀJ&D«U~uŞûHFLA.Ş¸‚µö»ãşÉ`Ô‡
+ø¶ûrk{³zøoÿøÕ­[ºÑíÌ:+·~½õ·[ş‚é´À3®Ññ°?Ñ×%öøBé íUÿ¢‰¥ÁIg0>š; ûı­gßÿ¸µ½÷Ÿ«Õ/³R}K…a…üH…¡WÌ®:{ûÏ¡ûw_l½ÜÜŞYYÁ·¥ÍİİİÎrR	pu¼¼
+eü¤w9œ =C9şãƒj™µ––}À?–1æ¥%ü#ÂÒßªşÛ¤ò½÷lıÃêÁğImì½áä¼>ô$^:şë^…ÑÜ®¾²ŠDyïø¸;Æ†êd8şĞÑ›ŠCbviÒŸ]NFUgk{¿‹™€–Ş[©¾©sıéÙàdÖ
+A_Z¡<}Š­ª„<æ¯’ì8'Š.†W­àüã ?i…y¿*
+$¸¡é¹Öª å@8*éAÀœDÊR˜ƒs(“ã£KO:e™R()Âj€J¨Œ‘6ßníwßl›ÓYŞÁn;«ó>¶dØ$ªÜ›sA©Í›[å4ıõ¯¢‘y¤ˆŒ1“P5­kZwWDŠì¡HnŒİğä[÷¶¨OkO©TÍÚAcó&<T$ ’jŒ=ªıxûÖ·›A#şÛ†ôÌµ¡à3—Hì*lÃ ™½ãåôjÕf¦(‰Í54@Ä6tvu“‚° S¹´8Ô\±õÜ½¸œÕH¦º«÷«•a”Èé‘Gı3n$£á¾$uR£Ù}€E§ßé¨°`4¸öÔÑâ+Üq@œŠ‹ù³PI:¼	z6l›Ü¬C`Çü·5I…Íò˜°4C>°zkÜ>ô†i`Â>I*ºdSy9j~âõ†Îîi¿ÍBmÆôôVØ·–µ%®(j£½yNJóØóÅÕ‚DMÉ/èa½Ù4¯FıóÓZŒI“Ø@+§ñÆXM´ló˜||y~ÑU¿ÚhYH®ÏÚ¼^L@æ'åW½¶¾oC&j½ß>¾='\$ëåy[*­¡ä›ÆLTŠJNokñl(ûšìÓ!8Ø¼{QÜªCOÒV¿9óho¹êl¾z½ÿÓÊr%èÏ_|ÕŸØ- zA‰8Õ2eÿg?L Ïhæ€YöFYÚÌ~£…SõaâƒåCÔ]§l6Ä<ºÅÇ=.ÛôfY‹"¬óg/i–Üßìş€=|GeÖj‹­AøµÇÅ*ºö4wá€?Iğ¾ À D	ö÷øDA‹/?åG¶Å•Ù|çíz]Kòş$N ½ß÷+ëfšæ;ï°ã®9¢Ä5BZìjX½njÀ¢Iu-àş~<¨%ù–°Kt×d³÷¹àTLßDÆ½ÄñE@0Ãà'…-³…ˆO:No	ŒéõŞq½­“l*´ÇøôÎÇ×„·ö4}ek>{Ér–?Q£X¶+Ğ¤ÙDQª­Ã-CÕ+´}Ûß·*’ş.Î’EÂ.©ê¯±®²š‰ZV­HäzK¾eÁ¸Rà˜>QkAÃ®îÜimB8ĞŠÌ…òvX%÷5Zm™	çTÅtš\30Z ·o­sôš5 ªµbğuÅ4¯H>eã%sIe<Ö væ;îì—Üi†-´ˆ'­ÿË-¸uîMR+W«/á¼1;¼<9­RÛv£°tíåT"©¥6ºÖºaÓ Ó†MOAcbc¿4·aSõ,6l±¢Kj:uñ"Å0P¤xÊE’‡ ¿‚™”†\în*
+Oò;Ê)T_/…«1Ä[Ş±ªL0Äìädï§nèµ©şÃ8Uä†ïÆ§‹şè˜–‹üµ®ôÙfÊI	I›¤¤Ô»®Z«ğı°åÏªàıIu’ö*È¶+	$Æ®ÏåA/’üÈö(é3FxD¥(±Kô¼öa2©T ¢«×İ¦‚í–yQíû`:úRŠ«[%nU„·2£1Ï0T™z^S*Ÿ4]é“ûÕğd28èév'–ã¬ŒON*x±ß©üq?üSpƒ+TÁ[®N'ãSøègƒ!Ö	ˆ•ªúÔ;4%4Qhåã bwã#˜ê¦ÌlS®ĞÈQoÂN[]M|ËàˆD7 h$b½Kæ—
+j()DJl›.±³yÍØ¶BçÚÓ¼=^ŒÓ£ÿ˜W…«œÆ‘F G˜ó¹BA!?ÈÃ&âÈzIvx4ÁKˆ!¹X	)¡rNN« ¤Xeçì¨£rS(ÜQ—#!L@Lİ$•ĞšPl"ô'Ê`î·Ã#Y·~PF×?C±ÎÆª×ë{÷€|ÊLi¸‰Ï_Y5Dq~ $ùRT¬óØ²7æÆÍ˜RXa£AºìÎ+ƒoÑ‘8˜Ğ¿{L¥2ÁÑE6ê°‰P!¡·dLô›˜÷‚3ûcÂã2meÜ•râ¦’‰°æ†@ö½¿7î}.¤\L˜•ÏªÎohZÅŠĞT…â€å+W\wI
+€aØ¨¥Ph–È5i>]½Q­Ä	ù}ç|¹uÅÇŸh-!Y’Z,…’ù^¡.NÌlåğ¬|ˆ6·´tÇ¿—À+Ò±ÍK`ÅqÁ¾Şp-ÄrÉü¥m½ !a½kã ‡ú.9lskÅìÑ2âò*®£ªjÅ2×Šƒmê»ıIl»: G“+E®CZE›tòáŞÑ1>à/`D Ru¸ŞÆø3q¾
+—CÖøù˜&4Ìš%ç’dé½‡+C‘Œ02‡í*š'a™NÇ“²ú“ş¡­Ø88õNaÎQ­m"ÛßË:c–ßâ­F-¿r*ØŸLĞxÖC@ÖP‚TæÂJÉÒœ8Ô)ı‰	“ˆì‡BØşñGNç`K@mçı G&mcÏØ«MWàü	¡,fnS–9õÍ˜¨Ù¦dV.bo„@ò¨Ôá¬Ñ;iAKfÒ@Mà+hçª¶UíHÕLéšK­ç¼7yçÂFÅ¶wØ§öÁ‘ûŒü!ø†èé0fÓiorµ‚¡‚ª2ºj‡ıâä.şµªj¤NÃ¤÷X1ÇŠgÃQ²qMœ `edàúI´Â(š"¦!ƒ}ˆCÎbuXë‡1~0£Øõuk
+d[ŸÓ;4üµ§N;‰±øëL‡İ„«Ij¤4Œxb/Å¼¢2"©N9~è÷TÇ°`=¢/TÀóúm•€pÁ‘*†:N[ şgÀ»[6c’±>œò{¹ÊRâ'ãŞñQV˜;-µÁº> Ë¨-duCI¨×Drg(ÃeI³ìÖb’-é”%E1R`Ã•=¬e›x›wD*ö‚vœf…ÊL·%=Í“,‘„{¡N+7˜‡àiÈÂgSÇ¢æ¯˜òó¥Æ,¦Å1âß=5…—ËfLªîêŸrfàË·_·YƒV‹éIÛÚöà§4©„éÁ¦dZıO2†>lë—âÔo[±ÀB?°T\’&İ Dj#ÌªŞƒD0 ½#2¦ƒèœuÛîÄâêPÚ[0ev?=i Ã~b”Q¼\½ÃÁ	VWP4úa½ú;8H2 H­­¥çåk’0iğsæĞ’
+J	W¾÷} !‚®ä?BÛ™	;Ò›¶ ÜÜÇVF1 M5\”ah(ÕòÄLÓ×’õ$&|CŞÃAÄ†…2ñï¢p¹½ÔçÛqKÈºwÁ´t{…¢FÏ×3	›iòá—Ê¼a@¯£¬ØË@W3£¿Gz"qp¡ûÇ¬Wÿ©ª–_ĞªãMË×´=6;c¼®!)zÀP\#k¶0T„ü#nÒ±'ür^7ÜïŸ.¤m¬VËké?ówaÕt˜êO<–nğËúyvŒ/ônpïQ	–A‡-VwêåäÖ¶(<Ô„²p‰ÖÁïĞèAz}1‚DÇ#ú¨ÓKB««L¨cŒ¨£ı}xº~ØØİ«ªG¿WpŠ&³ËÉQï¼ïƒG¬ø“÷AA‘c+dIìÓÃ‡±e_<|?ñ÷“ê>ÌÌƒSM{`*”,†^L/¶Ã@ñ]Xp./ÔSYT. …Œ@R™QÜ½éô|¬’ßªš×ÎogçÃæ½åjø¢u¿lŒP‹ÊÃ›ÁÅÅ†€X°È‹ˆıEL0F38fi@¶¾“Õş´VÔš¼%á/.\¾}Wpá°Æ70`p~Û ã¡VÜ¸4fj%öãá ´§ØX<<à¾,k‡$h¹Ã1	¸>–f¶Ú?|h¡Şì	$ †ÌCd‚<ô2!f¿¿üùÁ—0Ù­+ìÓ!åÆÃæ¢â0iÀÂòİe *¼zÅa…x0'Ôá¯µ§º¤<Ö†«ÜfYsq:9ÍsŸ>^â&“™˜›ô¿ãlÄÂšŸâ‹æãQ9!ÅGı\{z:ñ)Kõˆ‡ÛS°ôûøº¾©åìDÎw+«šR½ ˜4¬k(KGg±¬œ	"T‘Æ¶V¡†ã¤^ 6š	éqÂµg†$×^ ¸öŒ d>/W.
+¸Fç*Ÿ4~®Tk,LÆÃ·µNFŒıî¡xú´z€(Šôø5¢FÇ‘AÃ—øLZ‹!¶¹ÖaÄIÿ:ÃÇT@uÙëéíÇÇ«øß§ºpeë?£	W‚oÉ|‡G,Ï¿¿£ñ>øxrR(Ù)£% Iôh[èwî8Rø jHh=^»ıà‘ı©øëkş™Ó³µ§³óîU§E1ôï•k¯Î±Áv×_÷óf¿q,Æßpîªdú”¿±BÂ4ÎŸ 2Òè^µöÔúâ•pÒe8½ãp£H0äd²€@aÎ·~Œ†”æÊW¶³…­"¿9€$Í›é¬7™aŒ”2:‘“ôY×æü*Ï)A3Üù–ì—å\©Çf¹œl¾OP`±!İæÜ‘	9ál[{ªA”ô/Æ6_"+éßÖnÎUSĞNóÊ¯GÔ9~®ã·Ìæ?e©{6{]H8Œš…€,ü×|[«j8X{J®³`5+¤IòY’"âÊÕ|YŸ¦´Zx„-0LFçÕT†ì¦:Á6"¯¾7õ\%"ü”ê¿0ï!NäÑ‡?Êb€ÉMÃ$øıİg›eµ%0_£€Yûä¢
+-»zğñöpˆX~Â†Djä;z)NŒ 6£ÿ®Ã¾¢mYØÜüswobL%"î=¨ş%‹†z#Núï“(–dRëàïhlîÇcXàÈY9ßfRĞŞÂ~"Œ‡ö¸±áŞ·µÉUjˆ|ì«‹Ä¸§ï»lpköHæ‘u"?*/0–pºÅ	]À¤ã4oÌN,-oî¼>A-vfM4èN`R#ç¦iAú»Öğ;ğéæÒ†“„İ†Î…k)¦«@×
+qíè7£ULeşo¡QãÚÑŞåÚqSôÇœn´.{¸´dQ½î“ı›8¨mLu¤¥€şŒA[°¢b*¡Ñ:IÇIı(q9ƒƒ}oúIúùu>«øjsãùÆşFwoë?7Qğ±qÂIOC8H-y%’²}\hûõJÔ-ºÔ‚?c‡`'D qÉÊ +ÿEÇ ªN¼¸ƒ†u[}ó> ŠAPàoj¿±ÊiÑøÚ½UÿËú6µ[5ZÙ6@4Ÿt>ÛyõzçØ7ŸQŞq(¸-%â£"bq&fFvŠËQñ"˜FòÃæ³?w9Û]Ÿ®Ón5Õˆ4çÉº2 6×OİŒN ›	ÿ-Åj£!\·ßïÓÅ@\™-Çö
+Lƒ‰RG.˜¡7’e™–şr\V§Có>â¢ç¿NT-‘#,lÜ‡m?¨„q( a’”¯=,GÑg¼oxŠØ,?V›a¸Z)É1ÁûZ¨\Ğğé …F cµJ>¶·€ÈÕE‚Á[Ç}~€ÄgÀMí ê’ËI½U¬6ÄFğ>j†\VægUG`T2Eà"ˆmYs¢¼n¬Rr9mÉeÎøldql7ÃgS¨
+†Fæ
+>czÅÒ’˜$P©E˜æ…bÊ+$"…‘7hZ>ı°ªƒdIŒ"xlÁ$uŞ‹[ÑHÎ#œ‚ˆ6azÍXÊ`¡Fè{ ÃÄá-à;ˆÔ˜öq.®ÄC5ÿ_Ç„EòmeîC\:Hø5‘Ã˜ç³8è|9	J
+54“[–-ü"Rø@S|áë®•ˆOt¿{‰í¶ÎK‰FKõ)wèæÜ5VZ_*šâù„XWıc;¡€\Å+õ$ô	@ŸiÑ#æ:¡ö9ë°j«]Óà1 ÿÏ®xCCd[2€ë`Éè‰šíulQğ­
+TÜº8Jú±)LAÍTIX+¨ÂUğ$¨ş'6î–Õa~Õä­¢BÓæÌ#8`n0íŠ¯/™º^Q€şÚ9vĞ• ¬â¯¼²õNk§²ŒÏ}Ã’‰@Õìš·ùM–ï5mÍJcé‚ß§à):ÜY¼õI÷¾•4Hk¤‹ò’\¸¨—¶ïÀä¼lnë.æVÔ³#¿s†z´é¥´×/[Ó1”¤[æ=U)·E	Ú¹8«»ãÿbRŠ@VD}Iò&oYJ\ÔjçÌi«2/.mãWÙşŠšI
+³A4‡ü†2Œ¤<"° Çeg=º3}ERÌ‹0¾K”Á_ëZ4®öI£ı”âqUÛcn‰?00–V~î&“äBÉ,ƒ:ˆÁ=„_&EX³±„ã1!¼!KTÿŸÆa+R1·VµwÂ”Tl^‚z2ê†àäB€,å\à©}@NÑ'¨¿Œ(ğ~ğÜ–)†ÍñtvºPP2
+è—!º\höµe µM.²´ÄÿÍÏ9uË¶ÌÜŒÊ’ 3#lİºL±¤¬cÓ9e1mâ°3	ÿ®VpSà'3Ñ@Õåüƒ©‰{¥(AÅØ;J@s2Çóà»/Q
+®`PûÕ éoÅ” K:<hYM:a6]­_ÌsK ıâã>ÃÒ0oê¨¸\iÜÆ²m·a›	"ÌÛ÷ÜxÛ.¾®#‰¿PtÙiS=Bpá¨è®ák=•mq—¡LÊŠŠÒÀÌÀ"¢ZnD²:åµ"hÊU=³9„ƒÌü#ßVÿ×ƒ?<x[ û§/8O~dXYá:;:ÃÇb°*Ò…1_”ğYSäãUcÿ )ª-¡Plâ´L“1ÅWlÅ
+c_’Î`&…5ïï3†©ÕÏ±†ÔM	5z4^d¦úQiã@Øá1”‡Ö±Ø ¥‡]ÌıÒ­äôA)ø%©ËÅ^Jeì"²‰)¼ÔÊà#%ŸÂ‹–iÛgû9›t¹K«O
+&GcÑ1¦¬8™.K_±ljAØV'C,ø?ÓÊœª8É¶ŞáP,MdÛâÂŸdvÖèZqcë³7»ÆÀuDÎâjezÕ
+…S<k—²¿ö¯8Aâ	;BMÛ--Õûâ‰²\…ÁÄw¼×¡şò`_YEË°@ré &átŠoqÂK‚U[¬b æ¼p»9ç?)f©ä¦Òıœ--+¼,ëI•ñ3V©}­*š&QĞ±—Ÿ$d
+
+Bd	 eI‡sKŒ4¤ÁÈò}¿x!*f%E_k_•<Ğë"~fÀ”,„c6âfVÈkß–Õ\gX* ¡*ø´h›È¢?ò°Âß!z$z1RG)Mç’ˆ¾ÀQÑ€MÉÒ’±ÍOÖ.‘_”¯Lİ‰Ô
+İLL¦Ÿ‡BÕ¤vT›ÂB]öqÍ×£·`'FÈª%ZN^ïÿ°»¹ñ¼ûêÍşæ[$©ÛÚßBšºÿÜÜÍ)ÚŒæÕ”ò¡¨ölgûy½'P- ö•ÙaÍ¶g9¤TG;¯7·•U©vv¿ßÚF¼H„ÃªºÎÙ˜ê™û†7wjP5Óz[èš°ä‡ÁóTŠ1w­Š•ì©² ¶$aHµZnç‹:|#¬:FÅï¨\Š7µãUGoS,¦'j‘­*é4
+Š”\åW¯Å•ê”À…Ì/Æ
+–HüXòpŒL¤îbV?â[ÈAWîş~tƒ°s55$D6•J)Rn8Ğ4cPÌZû$Çòum×vXwõëïSVLcûú»Àç]+o«ÙtÃÉ{ù54r1ÕÏKIÒG¾µD88®ÃÓ±ü	Îj÷—|v+„úo‰‰ÒwießB4bÃ€cƒø›>A1@ÿ‚‡ôškú€‡ôAŠxúÂ§ô)´pTò//QÚZ_“ğ6ıùÃEÔ=&Á4f_!b&W!µçW›Üc=â£¡—‘Ú88"ş
+½„=)‰İ
+!—è¡8à“rşËéßœ,¤ø–}ÆQ½u¾õûÄ„>›n½/_ûdœÏë˜U¿éŒÇ› äP"FÄá¡¥¡f¹iVj»YÖ”h`€µ/wMÀû7¶¥²4<$š–6ÔĞD²kÆŠTXÔWİĞ»Î8ÓKøÁÔ„»vgf¾ùƒm} Óè‡ø¤SqµÚé>ƒ`Ş‡Gt§ûãîÎöËŸ*¦Hë@Â™å?á-lÛÏRç<i'çÍˆàAıÃşÀMÆQÔ²É+Gõ`Kïª¡ü£öày*0f? ZCÌ\äj8Í_Îa0Ö²úBöZf½
+‚“Uºãõl³Œ+¹%î\Ä¥ìÕ……ç7SÍ¤ûGi
+Sûtƒ&ícâ5L<^ä—ˆÁ‚Ê†s7È};8TT-ÓØÇÉÊìù¤3dåù(u«	@Gaã®x¢Ñ xÓÓ>SEÛñ½IîË>N½Ãp‡CBR£1DYñ¿’s“dÛ‰«{¢gnü„#ãÚNÕ¼Ä—iè¾££*'>ÉO–¾†İIÿƒ_H¿a¡+Àª²…	É	Çx.Hê ¬ A­m ¢ùZÚ!ÄØ,	ÒÚÓä|×~Û_†XfCŞ‹c,WG‹XÍÊúâÛ ¦?ÔŞÃ†M rôX$	< l°YuÉhã±}©7n{ %4+
+üW@[j–Ğl+?ûIĞÍtÎòV!×$`qHÛvòÜhCc”Ò¹jÕ¨Šb,€,í3YÄˆ<÷ÿ}ó^p‹Xrå¸˜¥ şzÃ!şÅD
+o‹QPêè,k&Bs$Ú3ñã ƒèš‹|zvd¤$M7[nµÅ™H@zğ¿Eš“>BnKF»ˆ,ë}ŸÕ"ÍŠP¬´ç?¬=È®§ŞF¶¼_ŒrZ#æã~ô.–*%%¦vçÜ’Ş%v¦I›zûév‹PáRŒ†q¸>Ì9IÊ®±!üĞúZ[ßu6¾únŞ-0µÉÑúŠØyD#«¸áÇÂã#ı<ó÷v÷z½INSÿôñôéS¨5õÁÔ±5‘œ¹3c<&MBß±=	$…§Ì3Q)¾–mgP Us¤mƒïò=a‡'"iö{ï§WÈ•üçÔõÆ¨šŸÛGæÛ0·Xä¶ñäpÎj¢0 ²H£’K&(èš-Å2®ƒÊ©‰Dé5ê¹!ù8”dÇ›7º§•e.…ñ	™"ä© 5zÎ¥ƒnK'/ 0¢y÷‰^›TÅBóıeaÁwâÕ‰«X)æDqã÷Ò27)<­,oJÃ’
+ùò	äúàÛGOYe"]GQ'0$k©Ó]<ßüKXÕøŠCùë\İ—×WÆy»\ÛLÙ2v!ç3?‹\Ê¤”¬,å*dìíêpXˆ2‚j.ê$¼`2Ê^@Ú¤„sø€K7Ò‘uúO: qaOÂ£Lî¯´´t»º„³BÙ¢=-Ä3
+Å7üÊñ@ƒOÒndÎ)Èšõ{Ü½´`÷ü¥~/Óô!ı‰Â1%
+İ%ÌCBÅ©GyÊøk€É+JÚè«îÊÍ 0BnÌ4\#†¼ë%wÜú¡Å‡<í¸‡ƒKÿa0u®hyúÖº¬`uÄ$†Ør;Ë-˜ÁR_b7ÂòÃeİÃów_ˆˆÚÑecXvœ%d½N¨¡İ»¾¶^àPV¬¬Æ§—µoídÎ;cLÆ³7dÊMÂ%•ÚEbkEhÁ§ŒÖØQW ¬!ÑÓÄ°5i!Ÿ„"#Ó9ÉF°ñ{1é×ëÔù]sJxnnsÑ¤4¾¶OË~™"'T+­É¹±‘MÀì#¬áø]Ú9´7#Æ ŒlKU‰K"’›ØR¬Xì“7aˆª‘SC«¢T°º×i`Ê˜Á†‘s¦,ƒ¬`å]E7.³`Å”¹Zß]Ö ÿ¯0k4ì`ĞŠ2k|ù¬H³F]Š?¹;?m–¸~âc+PøĞú4„†7¿rğY£¿5 ­î3‚Ğ5K‡.i¶›4´ä´‘IÏ1BúÍ‘h©#ÿ4ü¢¶·
+e¤Ü¾nFôq.×ÓlnÚ"Ò¼´
+Hì&õoQPÚÜÜK³¯miiJK’)ÖY"èGqÉfÉ¢VXçñSş‘°Ìßµƒ¥Õ¶º+;ˆÅ£¯6.R3F#$í®ö®æxí äJÁE\fíĞü1-h«¶Şç[8$€ã`DQrzP‡òËºç(»vmùbÀÑİd‡YÜB2Íh4×çpµŞÇŠ":MG>W&'mšùeQ±9²ºÈœ“zÈÉ7øÍ™µ $² *Ï/`T…[ö=¼N³ÊG¢L`­–0ÂZœò]«A>ıåı/9)şÂ†¡Ò@‚½DOêµó‰Zñ	8|ÃtM@úîÓ)<¢p>ªÏ8Û®g±ÙÊ‚¾9õD×ˆ!™ÈêR	ä†fRİå/KÉÌ½Ú€MaÇ‰]hıV	;WS3~ŸÈè4µ/0æ®;(¡Ü^Q9Òlş_5/üİ·ñ	é°OOá—&¿­+·‚V}~…ÖNI’!8¹‘@5'w)?ù´ eAP†ëx‚¶`/
+òâ‚DëB1ââ­EL»½/šúš9…é4ùy€eD53[¤¹÷Ä76«ÚOĞaæí5,¶Ñªˆ'ğY×=„@@hMªˆ°#¹s ˆç†«!ï%¤3qçªL £‚œĞ¬<Å;¼r¿&èSD€è¦íèÜ|ô%İ¶ŠDR¶Å©øÎ3ë=_íûÑáH!™ÁÄµ"	±m4k9`Êšâpµb0/Ò‹‚L(}	Î‘»D uáœæ›åL4ÔqnKSÇŠÌÏT‚ê—P£è—¡†c,Œ?¹.%ô˜g„øÂ®Ù®ÍôuØ¬u‰
+ubÂ;^k"ÖJÙóù™C#."PM‘õ·µIÁ¶–4o¾İßÜ~¾ùü¯|ØŞÙ{óV
+À¡‚èƒ´$N ²ƒ‡}µ ÓëArŸ¦­ğ-#å©|!$k¬9‘ƒ‘åÌÚ´›D®Ì¸Ãôº=y,uäàöãf4g)F/â¬çæÍ¥©ÆX€c#ä¡éeÇ>èËÅ•½H¤w¢1Š–’Ğ%*Ì}×?åLj%'LÒr#Ll,‘­)oá’¬c¾¹0Ÿ°'_Z 9ˆ¾C.2´À	1QœüŒuÒ£#,÷­¯sIŠ@1`‚ÚûPÛÙ¥‘!eÛôòpê‹í‘º’™€Ïû½ÏšgN€Sg8oö†ª¿–:bÁÀ ôôÇ¼"öQ §'·\¯ÀC¡¢[UY¯pQ÷…×Ô· İ×J¶‘MÃ]L2|7'½D–iK=­d]S¤œà®yÂfûLTËÔµŒ	€eÏ»íàÉC§W±ÏHÄv#…dnU46Û&ÓHoN²‰6Ûèf­‚Ô\¡S-St±¤-Uœé)SÆáöà€º³Ôù"aMÖÜ,%ùUÙÌ‘?%jŠÖMĞ/ ¶9qq6ïèñ4»åªXg9p{¯ñ¢ÓVkõvõzcÿ‡½îÆKãÕ^S D§*	dÔ¤³Ùsê¢˜|Ø]©î‘€ê-Ü›ka¡D{ÄÕ.ÑÑÏ–å†Ç/µ#/ÿ9(Ç~ï%òMÆ»¾a±RÎ¯Ç¶Ğ:§"S{“DàøÂi²-G=7eÀ&Î¼°9ãfcµ‘ŸÎ¡EÅ¢…¼p"²İ£Tx/P`Gì™ÛA^ÊQŞ¾ˆ4ğæŞ=“ì99î I
+³#eWhÙÍï†¤Ú9€‘4%»+NªÁÇş‘h¨Ø.AìÂ”ÎšóÔ’çS3†Ğj®ğ=Œ»AuIKåÅö«.I{ãÕæ_õ°¹»µó\?¡ï¼ÚØöAªŠÔoâŞz+Ç\tÏø_æ~ì“bØÈ€GÙz¦$9Í<àWw!í&™XéÃ`8¬H7>8Ìx]ƒù!|HfJ`¡f¶ü‡šOB˜"#d&\	şMlİN¨TŸ$œÓVTÒ˜u£Ï£ñhM
+LÙïc:f¯¢éúYFÉj]a^šÅåpÉ
+Ò!ˆM¢3Së²“mÁòøÆôÅöÅ4|ÃŠ‰ê°àJâ­ÜÓh¥hˆÀg	¥ÔaØ,ïšÁu&Ip63&-g»!]ËÓO¢·djš<Ì»ï;µàíq¼‰İ¬2°OİB”¼˜Mº¨Ã:YuĞ{M‰—]
+(Yv$ =¢`Í¢xJHT?‹wÉB'©¹şGæÿ³òÚM$-h«7uÔÔz¼˜%Š\—’bx•¶’N6,‡²ü¸¥±~ÌÕéˆ+—­MwaÌ©™-İ*—Y3&²ÁÿÀ›A\ù}Ä<å7XĞ²‚¿YÌX²Ü1Ô—ÊG­Ëa½3Sù Ø)‡KÓğÃ%k´.ì²(;†q6@tÜIÀe^­1ô¢ã€7ğCê¥S
+üvãKÌÈ×¶ÉgJ1%u¶æô“9g¬wEy¥C+[3×=é|áTmjDpı;\ÏbS87ƒ¼³—Ø‰3Ü(õ¦mñN€éu™ŠT	9ºa'B¿ğ H¥@Ííe€Œ£Ø É¢Çd¤Ag5FÌT²Ò#©<¨‚øÂPŠ>´¢€Ã#Ö#o/Ø¦¡­µÖh/Íu(…wÅ.¶§JR‡óµôIİÑŒÜÄ9ZÛÎÁ³Ø8ûeĞ[£øì–N Ş—7RŠrüøo6õ†F¿SF›¦¨i—¬aÁŠr" Ç"OâŒãSƒÂ]|€bÀ ÙõOú`MˆşãÙqÇŒ$İ.h‡%Ó
+L¦xP0–˜WËÿÇ™—H×÷’9_&>øn_åİàârËL¦™bíˆ$ƒJ±Å¢Àm<#hH8i‹äÆ\wb9{y zÀ¸%6cõêjÁ+*q‡ñ—¥xóÖ#Å‡Õ“_ãR…1L¬‡JõEŠ„05Ÿ²@¾ÖŒDx5õÏ¡Kh[o7aÈÍYï½ß©£x¼û}¨ÀHE_@²ûíhóòw2øØÇ½<È Â*h»<‚X~¾¦zâ¼+ÿü†WçGƒÙ}³·ûWüû£ÿûÿ
+ÙÀof“Æ‡LKDs{˜¨Y8.)àâ˜ˆÄÕÈ=’­Ğô¨q1¨ˆ2{$Œ:k›Ø;ïí£§ŞaÍ‹÷u7j:O¯bÁÉ®¡+Fœ}#]-ŒÒÉ¬™íë°A²NFM¼ıïK\ë‡ì£Ï‰$á3±Ë	Iûvµô	æ‡()Æªd¦Ê$7HR8¥Ä-vª„z5îAsnÛÓÄ¤¤yŒ¾[8¡@lUL©F|[úx¤Úû=jÈ¬->(Rs˜uı£Ø˜ÚJÀ-–ÿgi18–Íÿ&jŒ­ù@™t²k¹™ÙgB3ÌÉÀÌ¼jsyğÔ>”…“qjA|˜¼¹¶B‚k•-!b:MØ„¹@İ–±d©K!=Tœ1wTpKå¯Œ9OY[Á—eÉµ(5e=Ğ[Ü7ÛQ›Jª”Û*Ç;5’^‰şÀôÕY>^¿™'Ü,„T›’V“ÊC_Œ )ªó€Å¯p´"~•'èßMò7æ®cïV*Ï]š¾aqÚjÕpÆ~LŸÊ°¿Ãêv¿ûi³»ƒé]"Ï[pKm?ßÚØÎ™Ö_p+‹ù…nOC'ÇäkD*œUZ¢åZwÃ;6í÷ş,à¿bvA†3ç-3de>ìmğp@÷‡½Á>ÈR³:”òZ&6g%$@ †ÿ¯ètÙ?0k£ì$‡^>Ïu=uEVûgÔïy·0¦4f½îl-m“¶]iZÿdôÀfçrö}Ã¯
+n¬Ø/’¦¤“PÕíõG'ÕŸ-dª£‡Wzà]'Ôõz×…=ñ¸º/¿á:'[¾¡F‡nÅu\PâåhrÖÊ©Ï¢hÁ”èÛ3ø{ w©üÁÍÈÈıdÆ(AáÊëò|cwçõş^#u¯qUÑ¿Ù;HUja^¿€ÔSV°nÙ‘qOàéÙKÑÙöè·6Ã|NûcÛ@Yb<÷‹DqZØ-¦‘vÖAá„$óœpĞn,Ã¦Ø2k¿Àu˜@+n5b"s?¾ ¥¦
+§Ø	:Æı—*ãÄ«®WŠ¸Ê©ëÉÅU‚Àùw<Xä¤à9m±åm «Eñ‚| YŞšSX™xÚö‹=§›„òÍ·¯wv÷7¾{¹YŸ¦`ËŠŠ/ÛØâ8\k]üö4Fh‘ÌsŒÚ)ù2Ò¤ì<ßl[¸éÔcxÎ„€êıÏ§‡n€n#ï§Œ® Û®‘ìöN÷ÅîÆ÷¯6·ç¨–Ó=|´<ğhH ‚àµ`nÍa>yÚ^£m‹· ;î0¨á/÷ocø¡w5åİ¬kqÊ§¥E­†Xwš¦I+ZßxùãÆO{‹ĞàTAd,eÊˆ`)¬ş…L¤ä@óÛııİAHŒ½åÒ¿Áå„…?·m}hC¬k¡}S}Uëğ3¥ZæQ#Ã1Y%h„^tn÷d‡ÑØW`óg²œ·b{1»ç—ô@«ŒUj×~‹mi>óúåÖ³ı¶¥©…™¿	îE-dø ÿtpûòü{wæKKÉÏN:–Ó{Œåzn¾ªW²—º@İ†Öù
+ë€Fã.’r-§¥<_§˜êõP‹ïX­¥ä+›Aq¦%Qy’˜Û™‹Å(we ,Ï´-*Ã¦ë` Ë–1æ@¡«¬µä\’y¢f½©˜²ÖNÑ7¦·,»°-]ßVoËï›ÑM15Zš/¹ Ñ‡$B½)æ¥ m4å'f¡V€SĞ@Œ´ ÀAù˜ƒ¶’X„#•õ,èUú2×’Ü‚Jù“ÚÔÎ‡J–’È+^Úµ¿ğê‡|†.t—¿“Çå\§ÁÆ†äß¨í‰¥|Á&°G¼¼` “Øÿ
+Ô…––õfˆ=ª>ISƒFç±…OÉ€±™ ¤` ÜHÍ–äSWkSÏÓõŞcJ¦¸'ıkTšCÅËh™v–mÙ>»£èàrw_ãn©TR³vÑBœ ò3»01O,¯„>*¿'EKnZjcƒjë™Òóy¼Í7f3gJB–`D}h¹~i/$W‚Zô	6U¤bë°­ÔÊ¸7GÑ˜ÛyJ=øfXQ}™ÎèÔÇ•gC–®5ê‰ÃƒS\Øİ
+ÁoÂ>‡ñ´UŞwt‚F¸ZL‹º«o©n\»q½_ÊıgnĞÆÜ®!ÈñÆ›†‚*BÂê¡= ïlÖwÎ|ò6 v4y3‘"ª§æ®“’UÀ4…%#:.a³5¤t‹İuq×J¸„ÛŠY¡¯¨8}»X{§^µç†d˜²I‚“‰)c‘úM$IOÙÛßØİÃ­ÅA·µÏh€¥;ÄMW¡³2bÀå§ë4Pœ"T°–o{ãû­gTjkk{ïÇ×İ½7¯7w='O(Âj@ƒàH•_ue’aåîÌ_ âerñg»·”êô.ğ‘­äÔÒ7…äEYC¢+Uš$š+nr®	İHŒYÄ¢B~ÓåE™eW¤¶D9Óašğ¨ó˜æåòë1ò±ò:a¡Ie4{yúmvÁrÑ´|à¦}—ÜˆFJ2ŸZt… X^¸D•Màr¡x‰ºâè¾8‹`2´§,U`€`¤­äac~§ù˜¾
+KˆJØ3(²À–Ä+ÊÅzÊ=ô¨àĞ8sÃ?k}„·FÍÅú-–ÆcáÎ¨aÎ²ÂcD4¥ìª5ïK‰âË÷yİÇ‹WTÚ[kòrÁ¹ÅÒåj³ÒÙÍTëx5=¾#™…¬ß£'.^IÄ]–#S÷³ˆsß—¥"—tOæÈr+Ô\ôİÇ ?4ôGœ¡|IšİÇü¨2Á™Ú1oUÊXí
+™Â\f<Ó-'ÙqÓ@2É˜å6ÔÛ¥rÅ1Hä@·ä°!Mœ´ƒ÷93L3‚Qy	­VJŸ2{Îß“e:I¯r©,r±ü.—U4˜^åRÎiÆ<wàİJ¯r)åuÍ%ô˜¿&ãv@ğµ,ğŞJğE.¡œ!BH.”ßårÒÌ›€åw¹œ@Õö©øÜ§\«u‹–;Ôú9×ô¶7Ûö5×ßEåfç¿E=ßç¢ş¢ø®p­€ŞD‰¼YIøI¯¢LŞ¶d8ù]”š®·m®P#Vl”Aúççù6ı¥*¯6şÏ]Üˆû
+†ÌİÊ·
+ˆ…3MÓP"4\9NÏıüëGÆèüC&ŒÜñüÎE+Sr.—^Åò s¹ü®(8]Ÿ#²\cîS­b+åÊ­Ÿ ¸§ËÚUÁü9Òézæj~×µ|ÿÀ6šõZg €ĞPBCs¢¼Ğ‚º•70¯\]«3ÍÕr.Õ®4Í•ÎÑsio6se0ã‹Õ&•.¬ÁÓÛ1DŒ¨$x[	›0Wë~ÒbL©é‹¥Â˜¾Hùœ+o*é\­kÑ;Wº½sen€Şd‡i¥ãÇ¾¶E97A·Rm˜˜ÃÁ¢‚×Rd³Ò§1Vl(ZÖ„÷I|Ô›âdv0U†ƒüÓğËÑ&gz²«9P\f¥èšUt vBpÂ@a…æç|x®·¨ÒÒrÄÄ8ÒÈÚ´¦Â2óp?Zÿ(•ü1şÍqá$,$§ÿƒ°bË¶‡EÎ2k¨íÚÆÂ3T˜æ7±ôXyôèV#‡P&cä±vı›âıæÛØY•8rÎŞ+ …Á
+Œ­î*­ziš{µñ¶‹¼‚›<{¼à«.¥¤åh'óT–eYhX&üœC¹gÄ²g•õã ŸĞ'ÛÃ0dîfò­Èd. *BÄOà\ŸvØ¬¥¸S¢’ùÂ|3€‚ÌÍˆM„]¸ø¡êÚ'QléË·U‚>Áğ=ÓrÖ—?”¼{R¦áìÃì†£
+ÌĞ`ûÏf”õËTfŒ°À¼®“üŸ;O„ç39fÇ®ü&D‹º„×"ŠJoĞî&#(zk£ˆònÿœW±·(¡èÒ¢F3ö€
+ÊÃªäFZ¡ĞváÇJ¡›¸‰­FY†ZX›Ãè!aªCËáÛz‹°ä!!¿R°ÒáÑºè!,Rq5‡`T¾Â™F·³yrò\"œŒ+’şZM‡±›™õÄ)hûw6{µ{T—ñM¶F ô†Õa° ;¸L–ÕŞ¡ÄeˆŠ	ğc,Ñ}ë90/~§„”z¯DZîĞÏ?[DÈ–TÄÇ#ò’½õƒŸ}²ç82†gÈ°Ãk¸˜Ûù{¶„)§
+@ˆeS;‰„cˆ-rI®nhÄZ"Ş«;vé-Dç
+>wuŸwr—dw¤…ênÑ8Ã£@½c-şPè00åIÉoÂÊøƒ±)üø
+óƒÁÈ YïaŞ•"wåâ²*,ƒu¼¿o§sîZ»¢R#H+p–mp@{0	İµ¾µÖ5(	¤©Ì—u[¨êz:Y‰Ä´o)Â,xg¹Û,½<²ü,ù:¨[£a´”İ7[BÑÚ!;Æ R(‡N.‡ˆBJ¥gp]… ¨‘B“Ã*6äÏ åşär‚"¸6$Ê@µ0t…­®¹ÙÁğ¢PàQ¨r´ÙÿÜÚ=Ctyë€{ØCïÃ¯q¾¼4'rObHWdĞøHãq0îk=å¦İ´ÑĞÊ€Å…0.« °É^bŒwxe^)ÃHu?.˜P Î€ëx¸Ni£¤gÊ„”A&óDVHÒŸ)mÄëUGc_­¾Àœ“{Î(^qó‘x?(>“ºÄ‡Ê\Cğ–—E;­om4(; Ãn#ı¤«ı»úÛ }ª	%(±»^–r>tİ\e^D…|y]º¼’U5äK”—¡w˜ÍbA™§‡Òí(’ÿÔÃÈ8v¹ı’]D£+Ó„‚a3E§ñpbÎØÙ`ñnqŞfjÔz»^ r¤Ú7¨ØZéÒy<Qª}a¨hÔY£L—ªpÙ:taØâ’ùÁ3×g¶#àÀ]Ë6)×ßèaàE¤FTæ»ÑÃ¾Q·äëzz²_aÆDg2;l–¼@0E÷ùÊ›H(xù’ë ’à€I*ª.‚ùŠkĞä İuÆV^‡ŒR„`hÒ[ÃS4Sµå©ËKj-/èĞÚSQ©øèR"cs.IoòZ‰<?ühLæ[¿.FÍÅ½&ğø1J0Æíi†íÀ˜‰ƒşÈÁÚåqAEv¯Bî¸7W¿p0ğA!>0{[
+~RÅÑGŒËñØ2%²Ó­sĞ8ì yÉø¸\kC3@"p½×³€ wbfÑL½ïIp'#ˆå4áªU5()ÆÜ)¹ğK¡I bŞ	&qC©K;´ëŞ¸‘p‹+Y§-ƒ¸Ø¢Ü’(DK	Êö’.şĞ[Ô²,mmS¾P‚â~•¥Ú86Œ¸­T¥ßaØ¼Ô#+û¹M—Ü£e÷dpz†0Ó¿–`²Ù²ÛØD²˜LË??À†ş¡Ó˜ê‹@üNÅà*Ì„¿@É§ˆËÑî'p––3±Å~(Š¹O—S’Æğ¾àè`-#ÆÆåÎ:Ã"“ºTŸª°3[¸ ªIóŞ-õ&N	§¹WóbŸD¶Rhíê91;]7Wp‚Œ%¢qÆÍú~b%[–mûöYä„£ä)è-æäE
+g°…Ş<ª(É-S¿ ŞK_±˜)Şİò-½GÉº–S„°˜&šNş€Ud¼¿¡Ñ›jjµ
+-ŞôJH¨º/‹Èìüâ@ó(š@‚v%çÓú½+¯xÒTt¯¶ä\°GÖI=F=qÍ×¯• )´©ì‹´?,¦ÏºwL©yp5õ@Ì‰ÜoÃÄ5
+ÛV½\Ô&^2yµƒ ¶Pã-İ½¦¾›àZÁÖ™Ã2eíŠ=×Ôxéï®Ë×Ôøbº¡šƒ†ÒÎı@,PÛ«kvù¼~¡µû–¥E_§Àµò÷+t¿”Z5u=#7éìFlPÏOñg…t]Vƒ}÷H=±Ú¡·ãP¹©~¸íÁ1âo/‹Åy‚ó?°ãø¯üñÃ  ÿƒô/§3?Í†péı­gßÿˆÈ—ÿ„GÛËˆC‡Äbá)Ôİ«ÎŞşó7ûº½t{Çì-N2H%ÀN5L+rÒ»j¿yöÇa³:/Ïóù	„&ğGÅÈEºüŞ{¶şQÇCçAzÃÎŞ;ÿìlÇ§(tt†ÜÕ£ãa_–â\hãåî+•é'çE #P¶YÀáe}ö©b\/iÿ#0<ú=®!W\D	k]Óq ²Hx½5ÚÁµ´¯Š„ñ­îNê‰e—t3†SG½Áùo£²×~zmÿF.%º…s4ûı‹Î:t$‘ º@rJ´N›Ø¢aİÜÚŞß•FÛ0%àÁ^`aŒUáÏd(Ö Ç'¤¾d8®‡6.Jå²DÜN0Æ=¿âCÇöÕvØCş‘|
+h3]-Aî‡mÌÉ8ÿUykBK3È1‚#Û*k¯(ÃGÁHdÀèæDë­Û·‹‡»‹í½ÔÑ¨fcrkã Ù4­ú÷ma±]&è$p6_ÈV»Å[Ù¤œ9LtqÅ°lXIµÎ{ÍqàÒˆË‰*³NÏ{SÄ¾Œ‡Çˆ™›"ü†}ndÁrû_o¶öÉ2+üşáÍk çŒ1£<d+/li4Ñ$Û÷Á ­Ô9heíKø	“cùÊ³5tÍg´Í¯$Ç±ƒ$O0Kctb8fî7MSØ È¬å ÄxÄ\„¹šñ·˜%¥ ƒğAŠø˜z“ìa¦ZfÚ>.¢Ê¯kà¹ÌÃ5Ÿ]ğæáP0ìj–Cº…óÒTÄjdúLÃ³’)œ{%ùÜba^ƒÚıÍİWŸƒÛ;A+!8şÁ6@k#£¯Ón
+GdG04í_~D“¤íóÁáÁ#åd£Ğ=»cÈİ^àP0<Ô`i&0­í¿ìşğ#N©Nñ‡»ÙØzùìõ/?Ï·åët U0âë6*ğ‹Ÿ%q"÷%-Z‚G™»€t.KÜÙ6Ñk¦KõËà˜î3"ĞÃ†Êøç*¤ëóšÔ}˜¶#¹mÆââ\.ÙdB0nÃé¾ÑI§»÷¬»ızwçÙæŞŞÎî^÷±ns>@íc0DúàWšœÇ
+¯Vğ‹ÿ•··.S¸âä|1ğOÓq¶8A¾”‘˜r£±J_ç>&[,Bç3)…eç1 çA­p=×†ñ¨ºĞ[YOìYŸmaŠ¹Ù]¦ğ¥Å‰ĞØ^8ÿºïX+µŸp–qmZÙ˜êœVyr
+ˆÃâÉ·fsçïƒHŸc~9rq_™Æp³ÌÔSSÈ$Oû»N¯’ôHã†x“ê²ók½3ºC.Æ8ÜÙÊÂ1á:3ÓH“×¤8ƒÀÉéÒŞo‘ÕwÙ{€Óí½Œá²è/èŒqm«¾O¥u^ûõçĞ°j­+©<j~ö±KÈKÿ'ğS€ÀNÒâ#XÍšl¥ÜÖØB››Èí.K‚©jÒŠkÚAÊª;Â ªe°ôl>›A `.‘ù„^O¦Å£:Yu’?ƒô¡ÓîÓçSÆ¥<¯~8cˆ€lœ_›3]îui 4È|À±œwï!töˆHw´^Ô… êøÑÔ„À$íZàÑ©¤+²dÂÒª<ÛPlb\öÛt&&ş©Në+WÔ¥¾z`Xıa#©ÍáÖ‡ƒwp¸v€L ~Ì§%ŠD£`]±ôApU‰.P52+c_„U‹ƒN=è0˜vvÑÔ 0¤ˆ4t‡	04tDˆ[vdÔ'#íM®ĞÖr”¥ë	“<>|?_šÒ	~"§ÿŒ£/£DTîé\oZ¦‚4˜@íÆq6 2cV ’êbm ç|€sáhÅMÌ>r £â–4ÃÀ¦Z`®³€1rÍ§~Ç ÉÔòÀ:\¬Lbà¸­X†¯¬nÃ·ÉêqºÀJÇÓÁ H~GŞó#º†=}úˆk§L]­f°ÕmG;×Dƒƒ‰	ò(®ñÍ•¡ñVV¼“oØâHòhÛø²Ì_ã‰Î]2›À‰Ç$[0ä'¹°Öt£ÿêE&£0ÿÂË$“­2v8éã'¼(‚‹€ÊÑ(—’‰Ñï b°™¢ÉÆ’oÂŞœÎêRóç$‡ãæğ
+ğ-ä^UÕE»	,ì²¿Û6dô·Û#,™úVêe¼¿ìœ?´“œˆé&TÌ¦…âl1B¨Ü€êêH0_1¦d$p È/îhgõü" 2aò·±bSe»uh‡¶Ïëì¾Üzµµë
+çÅ½:ø€éòeş+)™®cº“:¦V³æNä‹ªZ Mğ:ÿt±Wv}’†mÄÜtêß`	`¯eıbk{kÿ'3û‡Ùşu°¯×›Û²,u_mì~¿µŠëC &ø°ì0+¼­8yƒ‰ÉmòÓéy(³cÄjè_ØLTs{®s÷¨mÒ¼9óıûæÛ¹æe´À®Wùr'§l€a`­!%İ?”vÓ¡V'ãgl³ñ¡“µ¹&¡‹š«‚;¢îiÎiÖgò€“e^hv	î9…p,pUb±f?ƒz«ÜÑ"©³Û ´rÔ•[ñ’:Õ…B%À÷ Rº‡®B‚Âyf”Ü "ëå³8qJ’×,öE~Á…KlYÕ/"@;8âÊ¶7çrR•Ä·TmiKÇWÓ1ƒ ûPŞ¤ÌûK8<Š€Ğá –Åkwl\Ğ÷'B‘É¤3`Up©	{$„7š¸
++imd,RÎh·Ó¤j±)Òõ{iCtMù#7·¾ÅÒ~³m€Îòs2“;E@ßÜ¾iE=Î4¨²ØS”³ïB»f>-²^hãŸ]Ñ¥Ë‚zÎ‚F‹ÀanæAŒŞ­©¨={sÃ¢© ÏQÿ‹ñG’† · ¬Záu\ZnAn³‡ÀqÀ*ûÓ2ÜÖ±4ÁA>4PğOÇ"™kı:ÂXT¸šeEâä€`uE”NdŠQ%üšf‡ÓÒŠ—QKåóõ–Ê•vQ4!ÊøDİ9êA½0MXŠ¼Nìçüœ`—X´ ÂÃTÁcÕ)¢Tx”*ÀœQ:rM«uÌëœs¤Rıh«ıNÂ†^¦šÀv=J'[L£c¢šö7Û‘wcôÆÜÊÍƒÔÉøâm€I‚™@øÚíZ‹N¶o`pi¢Ñ-V¤†H¾òWU‡ı!DD—}Ü´äñ·a¾ËP\‹ÏS…Q¥Ï²>ôä:Õò”Áê·h¦‹ñãÓì+òŞ&îCØû3”¨°oÆ˜ş	fädü7G7Í5İ²çGmZÛ	©–{J°€âÕa,pF¤ …’Ÿ€îgõ„8r­¹mÒÛkü1Ø¤¶ûbHJuw˜2½3¦]çŠ	BJ´•=CYqIA×ŸÂT	#êÊGî‰NÎ¡®¯¯kúŞ÷º:Hß» ÉÕhL£Ë&
+T^´†ó3aEÊÔéÁ¿ÆÉŞ7K«S½}ëa{qŒÒZõ.}Î˜Åy:q÷Ÿ4äúäaTm#õB¿y€òÒÇœŠêsHªÂ‚G˜Öü
+ŠyáÂñÇS6ÂÆ¤‰ü®œöú~­¾üë—«¼üÖøqşÕß0Kr]@?œf0œq‡ƒ0`RB1¦E–†Cms€µ†NĞ1"&k‡ˆHeÔ9$ÊÂ<^?Ÿ>|ÀâH£> Ê¶ğ¹(k
+ÚC~´.àsÇGIàyïqü…uè>k³ê(J×K  Áqf›`=e=êÃM˜¸”çT<RcpC@khz‚Ò_ „É/G[2äÔ1#\`0¡¼aJ^
+•óKŞ¿Æ+g°…Ş<âu4:M&+¶İğiÀ¨7ªÎ.OıøpköM˜2Òn³“F{i7‘ğ»†t“BñL,µÅhS=¾œ!†êWÿu	#%¶èFR²âLqÜáŒë±­Mí€b€¨ñš3t	ëáhT•RöçÉ‰DETŸşµ5BL&Éºóå·_Ãğç’Ìí÷/ún‘N•ƒ˜€–O:Ë¿T·ï‡Ç÷õáƒ™±}³Ö_cè{ğ…êöcT¿}U­LrúÀ(“%ON†—Ó3¤¯¢™ /(æ¸’Ø5Ã§³mê°³vï­ñ¶C€¹™çÒg“ÙxØQ…;pğ=| còlÏI³îgÀCyŠ)Á…pÇCØYé¡Ş=$MÄŠ~A%)‘NfBç§»1P±…$-Â‡,=J²¦)Yòùª›²¬*I°ì’ºGéåÎö÷]œl×İ6ŞÚÆÛ¬üÚ,ƒN`ÇÇÎ_¾&Û1Ã²Ls6½K!wˆ¶Íä2…îÀUt9˜¡ö¥Ó#ÙÉ ©Ü¹ÅO&òlŸªÔ.‚r‹Œ­İ“-?ísÑó+¤¼LûóNLÎ·¹6øKóíÆ[Rt×°Æş¬é0àŸ‚À(e•`|ç:æÜKÍƒ±é‚©@ÄbœÂ{iª²a¡ñi×<l`sİ#-bÙZ—@ˆŞuğhRòïàµ†çªúËæîŞÖÎvg¥ú9/¬1Gú‚ê«õÇUçÑƒ‡_İğûû1¥ğÊ“¢ÊÑøâÊ¢€;ÏV*¬^ã¶Í!NÏ½_òÍ2Š/-sa¯ÿ#”òõñätıòİÓŸ™N0+ü—Öé>iA¢µwNR•o:>™}ÀNûIu5¾tû?	h2 ‰Á'(;ÖıñÄZlvA¯ƒ“+–Òªk¤s/yk¾ß~S}ß§¾¾<„Q¼z9 9Nûí 1Û,Ù›Lç/hÜó~VÊ¸Ä‘#_u•G«Í^bvà`Á #yğ
+)×.ÇšMH[ˆ°Œš¥4Ø3XÑğĞÙéZÔì`õâ|Ö\gh³ÿqkÿDóUÛ?U?nìînlïÿôÕggà•Ò»ÑX¦»Ø€ÌÏQé0.´cqjÏ~ ï¶^ÂÆKÆôbkÕäÍØÀuˆ»û[ÏŞ¼ÜØ­^¿Ù}½³·)Ã¡\;í Oœœ’Îpº‚½N™Ô¬×Ô¨ÁHáRàÊG4şáøÖ]ü~ğ‹ôp{S2sZ-Ù®1¥Ë2ÖA @Š*CÆc”Ñ`5-áEq;!´²æ}›ÌfUšæ¤‹ısÖKš94 {;iÿ^X3Ø7OYÜıîÍ‹ˆ|¾ùbãÍË}¯Ô4c Âóı¹ÂÍíˆl)µPºd0XRê¬`ú8.ƒ>BÍÁp¨}²]•Ü¿²Ùã¥vÔKÃnoxû´<NRİÒ`s5°sÕkvÖïä^"t`›×ykFiuX^óÕ³l}ˆC-å¼„;H¼ıZZŠüm:?Ìƒâç“í¢=ÂgàËó‰¥û®æAa”2dX¶Knz4^‹mÍ'ÛÀzJŠ´SF+±C¾fhF'Ó>=Q ‘d²„AVïFƒ¹aËq”-Ü` T~n:”ËhÇâ·Xu~4µ!¦\GhäSŸœ«ãzÛX$÷î8{\]NíóVƒÛÓ¯«5ñA]ë•FZ3µÓ‡KZe¨Îc~–"`Ö¡¿u¶Æ¹¨¯E¾¿n,ÎoñÉ!U†QŸa#ª	z´ôEM¦`ß–Š`;lRÕÛtÈƒÏ‚gñO@ÄV¨zq¤'•rå‹Ø!fß#tpbĞáTm
+6—N-h~
+©‹»Ì!¸²–èá¦ÓpÎ)Öäöià|‰»‚#=î}í7ÁzSì´â>wì:ÜgçÖ±Şl{î‹æKÜë†Î@L~‰OLùu“@áİ>	ósp‚*Ÿ ı›ÌA›¾Ğ:¹oÿĞyhkÑ\]øÌº5ÖBË,Ä$×PY‚xÙM­ñ“°ƒûIæzæTƒ›èI90†7§,Ç“Yw˜TÛO±m/n ì“¶ã,»®ï|v«ı“O"2¦ÑYûçˆ=ÄxÇÿl¡çYRœ¿7ò0ñ£K‡I‡ë®÷î‡‚²XİKÄÅş|Tk$¿)«•çŠÆ¬Ò°¤8@dr"IuèºüˆY‹À÷t¶P	’ê¹¹‚’/	ÑJÄäˆD=¼D\à¤§;±©wwŠY ö±‰Lí©šç½PÄ¥ÌšØCLc3S‡2Ê”a#ªñr¤zÈ¤‘¦¨{¹¡üàÍ®ß“VC¼•)Î<îı„ëÛ¯™;şÀ?ÿb¦\‹:ˆâ’xPü£b—=ÓÍ/óRÊşÏ³µ÷f™ûåçÙÏ3.cO	o`2F0Ñ³œM0œ6ÄßÒŞ ø¦rd°ÇP©¾‰ÃÀO…Á‡ãü[%Ç§íx ÒJÕv¿?»)cä=ƒ:~,«4Ì¼ÒHö‡4“ÜÒÍÑøÀUéL$rµ®F?Àa·½óIu÷öwÛº÷ñ@wÅä€¨p™Õ†zyÕ}THd@¥B_å~úX‹îÂÁ‰åÿm*®á#W…Ü	^Ş ´ çâ y¬1—fåãL"¢+bú€oî¬íÄÇwWX:ci¦T˜‡n½r(…3„|d¾ÖÚà „'L½r¸2‡Â4„Ğ\8G|\Aqıpİ§•f@Fö7 #K”¨a¾c6œ"K‡ÑÀ$ÚÚĞ¹„4‹ÎnL}0òÃª"4™²&w‹Gø¸æ_.„“ûhiöqœ¥Öõ¶îÌW\;9 Z¢ÁÔ,BÄÙVO\E*7Lní³5OË³âMZ M ¶8jbagì0TÎ3—°ëRÿà$ë†€@ÈB9Hïf|´XK;8Ì¼g-}?î¡ó¦[£QFÁ¡1†#RÁ÷Ø8pAÇ‚¨ì=˜=´U§Ùm&~ÙG4e[àƒY“ŸLB¿¯÷!”à›ö#sÛÇŞÉÔ–¾f_&Ô4™È‘›pÌ÷õZº°¼n½„@“¸Ä¥xÍıFq‚©XÀ†™âÊgÅÂÒ:¬¦r(d˜ zp‚@) ÷tÌ©êœÇ‡­;_ £çŸ¸ceÉi3]GX^²B‹D¶PPù¡­q%g Ow5JöÆÑ½{Òƒ ¬á37)=uá©+o#XµÇ™/*„2Z*¸6wº»Ïq(î'l­`n‰`PÎÏ´§ç=ZŠs¿*ØZ€“k›‹Áß¸~¹>ôë»«}PÃ2%qD©‚4¿Ø\˜‚Â1"³TÚ¿jÉ>ë*ãra%Dƒ,”Bù¢‰n,FfkÆ²x´æ’ [¼ñ¯
+ÿæ^ñkWî3µcvÄÚ=¢¼ÔI)…Ï<·…+¶Åtåù„?Î»lÎÕ¢Os¶;ÇÓËÖeâŒĞ¼‹î¶}¹ó=QÜˆ`ûN'Ãì$ÿhôprP®kY,WÕ‹¬ÚĞõ…dD“Ë‹™{.’ªmƒ+zM•0ƒ…xt–E9¸;«o¾É…5]‹»[ìĞ‚ÿ™]6§3Ï§ÏÕY8òÈ™õĞlÉª¯iTßíÖ=oı}1Ûª›«­1ÛéÙàd–Ÿ_.Ctq:÷âT¦Û÷ÂOÁÔ3s-Ë8¥­Ì’FÔò˜˜F›v¬›tïyy†ÿ…]kB_Ô-,Kd=-¾#…İYG]¤¸oåW0 œ Äê°¬^b”]àirOáæs*Ä¨˜ZUÓĞ.ÖY÷Smæ2ŸÕ^Tã.ÌB‰¯˜õásà³FÃb¿Ë|;	}Îf=E:Ôl^M]”6ê~NjU£/HâƒÓ'u°«Õ¸I-sÿâŞ˜Ê)õsîps&ÉÕàSy²Qã>.P¬”>:„19Ë¨LçN(™W~ßÜ¨u1¹°1Ê×DUsMJúj¬8î*^Y ¦©œfo ~'³ÏéÀ·w¦;:Ôx]vªùé3q“ªÏõ'ùÖ($}èÚî6¯?\|ïF(8¶Kîê  ”¾wºÍYwA­ãD8Í-‚8SŒ&‘ê©àÌu”ªiDüE3¨Âç‘ƒS ıR| fèïõjáb¨ì¶5¨Ìİ)«vèCÊ¿?Én<æ]"1ùºåãmÜyñ‘æmeÕš%ÙüûW <Ï` á†Áê8YÄÍaŸ¡ÏÊÆoÂ†¸ö½"ÖÏåü7¤ìò"sq ¶˜¤YñìâƒÉ¿}Ò>ºL*™N¯åû+d™ Ö|k¼Kì/Ì°ê¤äŒÆ ò%°ÎNyFA[j!T
+G°GŠĞN±>EÙXf07ª-5i¯­a‡üÎJ§,G‹J#õ:Ò -*ÌX|+š£òY–{…@÷·[ÿ7Ñ¤Ğ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/13/269b49ad64950b3fc7b22465491dd66242acfd squashfs-tools-patched/.git/objects/13/269b49ad64950b3fc7b22465491dd66242acfd
--- squashfs-tools/.git/objects/13/269b49ad64950b3fc7b22465491dd66242acfd	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/13/269b49ad64950b3fc7b22465491dd66242acfd	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1,2 @@
+x+)JMU027`040031QpÊÌ
+ée0Ü[¸Ü$`Ö’ç³®Øu<HîcËÚƒ›QU1¯iJÑ*şŸ9§dÆûu'}üò¿» ª2ªú–tà™xåå	~RÜµéÎe±ƒhª¢€Ê–êu¦ğ—ËŸz61Øàäi7óée¨ÊL€ªêî¨»oûš½N°zÂóıS¯¸¥„¦*	¨Ì>Äät±íÚ‚O8÷Ö_şvœS¾U™obfP¡â.ÙšÛOîûÚıËşºnŠï2çã7ï kq
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/14/88984615b367fae01817cba40e5e8c5ad4eac3 squashfs-tools-patched/.git/objects/14/88984615b367fae01817cba40e5e8c5ad4eac3
--- squashfs-tools/.git/objects/14/88984615b367fae01817cba40e5e8c5ad4eac3	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/14/88984615b367fae01817cba40e5e8c5ad4eac3	2022-01-01 15:10:16.089175076 +0800
@@ -0,0 +1,3 @@
+x•UkâFÌWó+: HfÅòÚœ’,Q/ƒ„Wl£ËJ'YãÑ™gÆfEûßÓ3Æ,pÒI1¯êªîêf•ˆt»?¿û®Æ"Ò®;wƒQ¥†Æéqİº«Àô%%êßœ¨8R±„ª½Êè¶	àÇL~Äl'{X‹m*©R4|‚àÉ^ãœ¼Â¥Aé^â£ìuºíN·¡¿Ì÷úÆ"fIÂR˜ˆ|S	¿¦ÅÆï%—¦›fşé·¢!“J±‘d«IE’RP"Ê^ˆ¤=Ø‹Ö„#¯©L²UÂX„‡-!uÀ­Y´×{9¦FBSÈ¨Ü*‘Y¼Ÿ-á=åT’ù*ak˜°5åŠêçDAª7UŒêW{ób¨9x0L2&x(Cx	;*®¡ÛĞB‚M2MU‚HõÅ:òÛC‚E8ŞmŞĞû&+ÆMøX¤(!FHõ‚é„…\Ñ(OL<Ì|û£ùÒgö×ufşs/g±ÀSº£Û¦	Ca˜LIx¶ÇœhÆÓÛáçi<ûÏZÁpìÏÃ¹,×÷—Ç…ÅÒ]Ì½úÆÃ¬ |p;§!ØVH
+!ÍKT)ü+©]BLv+º¦l‡Üú/ÕÌŒøÛÈ:.Iß™xİr0NX\dx‘’	ƒuVGıü­”x÷øÓCa‘5…{ğrıöá¡İ€'¡2Á0u İít:÷‡öOXzN)‡J)d3FÔV¥B?c¥9ÖSÿ™eà9ïv‚…È–¦¾`×{å›ÃúpEdñĞ^ÇDÂ]´EIÍfó+×ÄåíJ«ı?G°LÑº˜d¥3‚ò]§?@"Hg@÷hå•PØS
+TJ×,ÒvAkë6Â¹°ÅFƒGLÉWk<¼éaHzy/o4ôƒKfe«¹QZ|¬XV(à?óÃb‘}Àª¥<äÀˆª–ãªQ«”zOC¼Âj·ëy5š`3—³ğ"(sœ]©òÒx6œ_%¦Ñ-ÌŒı½Â <«›Ëí”İWƒ˜)};Ê)¦±‹¾z”i2t¢ó5ğ|lÑ«ØEjq®UBƒ2H€ŞBÛ‡‘1@d«'¦lÀ7Äü3¾Öä	eŸu@½,µõeÌêG^-ùX5˜şUÚèHôtiob\ğ¶,ÊoË~½Ó/ã››Ú¨FÖiãšÓÄ/kôäü|sõ«CÇw&Åùcµ(Šnœ2K—IÒ\®ZDËYÎŠt™äŒX­fàßºb:˜h›N-õ—zOgTa98¾·çşìTkÛ(¬†İdYAå|%W…œè8ôëÿnº.
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/14/e7f4e2b92215c6a6ba4186917b4602d620fe9a squashfs-tools-patched/.git/objects/14/e7f4e2b92215c6a6ba4186917b4602d620fe9a
--- squashfs-tools/.git/objects/14/e7f4e2b92215c6a6ba4186917b4602d620fe9a	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/14/e7f4e2b92215c6a6ba4186917b4602d620fe9a	2022-01-01 15:09:15.593172588 +0800
@@ -0,0 +1 @@
+xm]KÃ0†½Î¯x7mY\7âÀ„Şü#mÓ-›Ó‚•ıwóÕ)nWÉçœç9§”ªÄc>¿™exÖ]s_R¬¿‡M×d‘çKš?ĞÅ’{¥±e½T=Ùv¥jõÁD‹lFÈh+ÙÕ“0é0!¤W¢vƒvE+L²±?dÇ”|àHW53/ÈŸCüñDˆhoÜhÎ[§pE;ãŸ)Š÷áUJU!cî9şˆIÈ–”Z’ƒ_àÍM§[ÌÌ)E¿ÄŸ#K=ƒ®<1ñ!è¤®ÅaÆ•nÿ“¢{\í%,Âí%ìêç£½işgó«ËF'_•¢…·®ù¨o
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/16/2fcd15ba30b16d61eb2c12c552611115d279a5 squashfs-tools-patched/.git/objects/16/2fcd15ba30b16d61eb2c12c552611115d279a5
--- squashfs-tools/.git/objects/16/2fcd15ba30b16d61eb2c12c552611115d279a5	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/16/2fcd15ba30b16d61eb2c12c552611115d279a5	2022-01-01 15:09:15.617172589 +0800
@@ -0,0 +1 @@
+xeM‚@E[¿_ñĞMI(åÂU5‚.¤E­ŠÊyâŒ¥ã"£ÿŞD_DË÷Î¹÷Êê€ştÜóº”tQ‰„¹:€-s%(GÎƒO£u¼d<a<Û|¥¢`"*+[Ahİúr¢Æ-,Sôòï•ìG@m¬ÇH£ë6ÓÈo®Ï/š0aÛŸä.ü’GS7üÄB ©4Îjz5Ñ¹İ—ıGg?~usú“±I	™ÃKSÚ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/17/e59060f194aa30c243886bfe4979b1ba9b03c9 squashfs-tools-patched/.git/objects/17/e59060f194aa30c243886bfe4979b1ba9b03c9
--- squashfs-tools/.git/objects/17/e59060f194aa30c243886bfe4979b1ba9b03c9	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/17/e59060f194aa30c243886bfe4979b1ba9b03c9	2022-01-01 15:09:15.609172588 +0800
@@ -0,0 +1,2 @@
+xuOO„0Å½:Ÿb²\ Ù°11Áã"q¯ş¹xi€NC,4`üîX£¬ÚË4/¿yïMQ7^^\íFcÒkMmX¡ØxF[E¥Œeò”e·÷ò<'K'ªƒmY÷Šğºcå°ºùÖ6Ñø8¨« »ßdÛqÛ—Œ2}“i‰†wtÎ;3’dLóC^b@œ {¦—.†ÕVğÚ…?öÖ°¿¢PóyAÆò
+N[Ê™şÆ·x,céí«Ïç<¾Èëº)³Ş–ä¦¸_•²–şÍ˜a_h‡,fKÀäYe4|äÉw
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/18/014844ccc202cc5107e7e60dcad144460aad26 squashfs-tools-patched/.git/objects/18/014844ccc202cc5107e7e60dcad144460aad26
--- squashfs-tools/.git/objects/18/014844ccc202cc5107e7e60dcad144460aad26	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/18/014844ccc202cc5107e7e60dcad144460aad26	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1,7 @@
+xÅVßoÚ0Şsş
+k•ªP¡"uÕ4í]#QR6´'dâK±šØ(6í:ÄşöíÄ¤mX·iÒx"öıøîî»;/2¹ 'NOßt:dÆ“ªsÁ3ˆâãeğT0HÉ|>‹Æƒx6™_D£aÏ/ƒ<çš®PM$Ùšy{|ÜéË<—¢3}\:^¾AsP+š —É¦~hÜ?=‰bü”.Ö‰&ıóÇK*X¦He°!!ƒY|3 øëi]ğÅZƒêšsx]I¿ ª¹SÃÓ›Uº—$ Tóİ¬àü•wôEfë&Ppš×ù
+kös$ôûS2áß¡[Gæ„âtÄÅçe],¾¡‰m7’Œ*Eúæøœ*6ÁªìM.¤ÌÈ<5uRñ
+„qsÙFC2_Úä˜+eÃ†ptİŸN¦7ÄèŒ± í2a/€¹ğÛ¨d~.Dµ¤\Iæe“2ƒ®VRq“Ìv%œfôVõÛe¿e x}Gıx0|‰jö?P`<‚Õz‘ñÄ$Ôg:lÕ¦4SĞÚ`M¹ç…^ÓŒü¨Ic­v.á™TbôU¬Ÿ@_—é
+Ë‚Vùk‘D
+¥}µPvâV/½df?½\etp:¦1®4	Lå•¼÷ÅÊñÿè¥dmRyğP!ñKšX{¥\®YÑ’ÜFjt¦òn¹ÀxM³Õ‡‚ùê~­\%Šá:æ§²Èmw†/Ú›Zc£{Ìµ‰„1pF\)wu4ã«ka™>ÙÛ¿Çu×{¨¾ßÉ/;¡‚ÕØÿÖ'–k…²t7@Ù5-tx/9#GŒjêHğî„(gşãÇ‘˜ÀÌ”³–lüÆÀŸ+×ê¯-#J.)Wƒ|^óÚ0êÖJ’ıÒ–iéFù°3ìM‡óñpVvøşVóò_W¤q(7Ú]Š÷tŞªB/{ 
+u°ÑöàÿG¼*—¿æÒ¶İŒy&FYtäÈmù;m‚´	Ã]UcJèXÔ •	Ù4†|$*]²}İ£QÖ%l½â¤äeo4ë}8óG¿O0,ó	íæØ½o*hæ²íöJíµGNó½èìØ†ÎÌóÈß¼ğjìúÛ=²£ÄÁüÛbí”NÿÖÆ€Û(NÍ¦0‹Ùï©g»¶\µ]ûÛn·øşu¬ú	Xv¢	
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/19/7a8e581153b261b7873b8b0b068ae0d9cee33a squashfs-tools-patched/.git/objects/19/7a8e581153b261b7873b8b0b068ae0d9cee33a
--- squashfs-tools/.git/objects/19/7a8e581153b261b7873b8b0b068ae0d9cee33a	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/19/7a8e581153b261b7873b8b0b068ae0d9cee33a	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,3 @@
+xµÍ
+‚@E[ÏS|ØFC´rØªÑ‚v‚DKqœOdFÆ±_z÷üiaĞ¶íáÜ{X%xŞfæºE“Õ5!óRdUËŒXó]~s
+cÂz­r.—×Æ1o¾]ªR‘Ãq·8…öÖĞ éPB“½È$GåûqËe¥Q™ô®<Õ©¿)h‘'P¨[%À÷Çy Å•6G»×lHX›ç¨"ÙØ°²¶äõ#â_³Ë!ûsly
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/1a/f5cfc4d86871403ce279a3b395aba9ba811588 squashfs-tools-patched/.git/objects/1a/f5cfc4d86871403ce279a3b395aba9ba811588
--- squashfs-tools/.git/objects/1a/f5cfc4d86871403ce279a3b395aba9ba811588	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/1a/f5cfc4d86871403ce279a3b395aba9ba811588	2022-01-01 15:09:15.609172588 +0800
@@ -0,0 +1,4 @@
+x½WëoÚH¿ÏüSEj
+)”öò’8­È6‰šÓieÌ’X1^Îpéã¿™õú8•"İİ—$×Îşfæ7›™/fpÔí~øí}ìç Ù„'ò\ˆIPë´ZŸšív³sÇ`Ü‹&Î“/ğk’Ì|´›‹¥ãĞx_«íy‹`ÎÀØÇ;fèûRÛC‰ğM!š®ŸÌ9œFñ-Î¥¿t¿5F‡’ÉÚæbÙ×öx0÷hª¢Zwl|­nšc“zvÚeÃT~­_/üSqßìÃá®x:²¦“ÉØ´õíª'=³wvÆh2µ™>¾„î®r<µ3íÇ]­©÷ğiW~k¶¿ï*&æø³©[´[»ÊË1„vöyP»S]Ïì1nthW$?³\ı±V£6¡¢yA–É£“í2fƒÛ±9€[i²Çıˆo¸frU]ÕH¦1_åw’_Úßuø.Oc,äQâÇŒÁ ø¼h%é›3hÕ!äqØ~™õ	üÌÛ(K.	"ï>àspœ.c~’§=ˆ0#ˆÛİB˜;¤Ú©RÓÈŞ]÷ØÔÙ‡fXl:>ç}ÜSÀÃNE@©¤x¤İê%7ñ/¼re28$X5L†uj5vÕü¬¬Ø'øE‚+–+Ïç!6‚w1DÉjEtš3/&ğù=£ƒ ŒÆ¶nƒ%–q ×ïÃZ„hçŠ0änì?ãß?81¸NÄßH²È ÏÀèı
+Ò*4cuƒ¹Æ®­>»ÑÍ:üøQÙÅØöFƒ>cõuÆ0ñî_yV¦'É`{™¦üQ^Œ±iUDRõÈÈ«Ü$Xë«eë×Ì2îtfçù¦ÕËûÆííl"2¸L—ÆÏ ¥/„ğÑKUÚ^"ÃKçX3ïW£@*œŸAû°U°Êõ×´‘†ÆHÇ‰šs×VÜÕá>’|]–[¶G•BAå„Êş@ï1K‘òdQaÙÖïI‡ûÁuüíeÏ²Suù ´]8Q,óVÙ:«êŒ²,LÍ–¦Kób?pXß¸‰îeÿ‡Çå$ãÂ£VNè,yŒSãD°B<èÏX@‡‰‹Ä7š>•Ö¾ãi‚Ö0¹3¯kOÂ›Ccµé³d±ªÖú]?¡™L‰¸ÎVI¬¥
+ ¶ƒ·oA$qIz&9pÉ ¼4äÎR/ÅÒ6Nñz…¼}±FnÄÿ‹ÿe–Œ#I™ĞTÏ"¥¤µØ€è'/Yòdt]­i^UWW7¯ÒyU”ın†"´qs!•Qi¼˜TĞÀÊ o>«¥zªriÛĞ‹y©¤®°Ov»YWS®«èñ¤åMäMA²œa?‰8ØLXgXcø˜0Ã|R*–ÕTn§²mê *O÷-ê7Nâ¼€gp<"íÇ;féúş°q¯¶ö©E•¨?5QÔ.‹ôÑ ElİúfqşXÊ+›\vx„óDÃTî’ãcjºI>8th	eIŞ8B"ÚÏRz÷^€õ’íËKı›]¿T@•ëPˆrÜ´nT÷ÿ{"Ïw'2q6•’^;ÆxŞªê]±XD<.¸&ı†e‚ı;Ã'ûÙÉ`[ZT–¢.¯%4$¥ysO=´µ? 5"¾àaı Œø]ÿMSPö¥¦P–1úH)«,şget½‹ÖšQ)}3à¤«Ã¦Ğ<yl8Ã°{%‹ÔX}F5½ÄåŠ·Ë¢_ ¨-ß°ägÊ]L/åƒ´6œBû¨^É¦›7Àÿ.€ø ah 8~Æf-K2UıL¿èSR7öÓyüIìĞ/Èc¦BÂúxTÌolgæs­d*6½¹|¼ó€·ÃÑÙv6/Şrza”ùÒSYnŞs¶¸k²ÈRÎ[çrLøß<›ê¹q¶,ğ&Zòl’¿|¶âİI(îq‰E%ZR3ár_ş›ƒïx$ú.hjku€¦–!>p…¯²u8ÃB>æ ÇÇÇ±–R×ä©7Ûøàe©šXğDæj™öñ_%J6Kºzû¥ó¦5zørK÷*µ§¼…´Ó—!/¿Rog>—¨œĞãO}Èwr+[íßä	˜Dö 7¤€ÉŸ>+éÄ:h«zó<•áŸJºíCY‹£ìå·4wpTÕëørÔ8
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/1c/4dca7f4a8d152783b483b4d9e02e892fdfb9e0 squashfs-tools-patched/.git/objects/1c/4dca7f4a8d152783b483b4d9e02e892fdfb9e0
--- squashfs-tools/.git/objects/1c/4dca7f4a8d152783b483b4d9e02e892fdfb9e0	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/1c/4dca7f4a8d152783b483b4d9e02e892fdfb9e0	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,2 @@
+x]½
+Â0Fó—vQ)-ş@'“¥.RDçĞ676ĞŞ+mTêÓA¿Ã9ğÕ×°Ê·³,9TÔ´e©ÒVˆØY2hAkyÚU¡×…ˆs„ÿ8èÔtwƒ)î{¦ì<İpLÛHˆËüfŸ^jÅôÀÁÏåä–¦òU_at/üâgÉc< 5l]»pÉ8+Şîo8‘
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/1e/1807423e58f90a76842b5c8f5ddb7d242d7354 squashfs-tools-patched/.git/objects/1e/1807423e58f90a76842b5c8f5ddb7d242d7354
--- squashfs-tools/.git/objects/1e/1807423e58f90a76842b5c8f5ddb7d242d7354	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/1e/1807423e58f90a76842b5c8f5ddb7d242d7354	2022-01-01 15:09:15.637172590 +0800
@@ -0,0 +1,6 @@
+x•–ÛjÛ@†{›y
+]ø"&È†@Jkè…¥4AEÆAiS
+F‘eW°ÚŠÓÒ>}fÏ»:¸
+¬ıçŸoVÚÃä‘°ÇàòêãÕ»»l}|
+È¿:‡x³ÁÇÃÅE®/ƒğ!'„kÛ˜«Eá¨i¡’²>4uî!¾I—·÷\GkÌfsù°¾pı'AŠ…–„ÑrÆÌ8*iñËgyí®Ë‚íÜOˆšó7Şë¤«¥44ò™r†UúPÑûc,ë—£§d9=”1Ï‰ª£r%4zÙïS¼ñMEÊûcSæõ³J£oÇŠheI+T4ŞòŒd­‡¬®sºK+ZŞåÍ³)g±ÅUôàbF— ÖCÃW–P­|/‹#“¯€+º&ç|Ñ§ ê+|…¦p69Çõ!Ó&üM¯ÅºNµ‹KI„éÎR.œu-y*Ùšy\äªe—¹r0œkã"Wl™É‡ótTgécr•P¨9ocş¢î¬‘`<‚b¸¿SÜlÛxÎ_Ï¸ägôIVp6ï‚9V?|O÷O¬ß	|6r¸â‚Ç1I-÷*5½SÍÑñ‰Zş?Ñu"Ñ=Ä²F;AkÛåZË²âi˜ïƒÖ<«Íí#¿ÉÖÖ“öxüì1zFç&0ğ‚s	µ˜62ê›Á»ÊZ\76‚Ü¶ƒw)¶Ønl»mu½jªıh2p
+Ùç{Ew‘&6êÙ¯{ë²ï©Ğ1,Õ›¢‘ôTÁş2’«œ°ú+{%vµ.ÏÇQ}?ß¢ÉuÁ*2ê˜Ò´Ê!²6¼¥€›£ê¨ö;TE†ßRÃf€nç]¸ŠŒã:f(H™Óœ…“ólÅ»Ÿø÷@·{€WQÓöé
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/1e/489161abe2cba49a1ddac496303035bc9ac438 squashfs-tools-patched/.git/objects/1e/489161abe2cba49a1ddac496303035bc9ac438
--- squashfs-tools/.git/objects/1e/489161abe2cba49a1ddac496303035bc9ac438	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/1e/489161abe2cba49a1ddac496303035bc9ac438	2022-01-01 15:09:15.605172588 +0800
@@ -0,0 +1 @@
+xKÊÉOR°°dPÎÌKÎ)MIUPÒÓÓ"ç€ }óªÌ}ßÊ°Ô¢âÌü<Ï¼´|½¢d%..ßÈø0× `O¿xO?7ÿx%Ÿ(_G…œÌ¤¢Ä¢J%0_I“‹  s
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/1e/6b40ccb3481fa2bdeba4c83116ec38c8129f59 squashfs-tools-patched/.git/objects/1e/6b40ccb3481fa2bdeba4c83116ec38c8129f59
--- squashfs-tools/.git/objects/1e/6b40ccb3481fa2bdeba4c83116ec38c8129f59	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/1e/6b40ccb3481fa2bdeba4c83116ec38c8129f59	2022-01-01 15:09:15.605172588 +0800
@@ -0,0 +1,2 @@
+xmQ]kƒ0İkó+²Ò3hÊZÆ@èƒZíÜâ”êËF!ø‘1·Ø«0öëw£¶tí@ğæäœ{OÎÍ¤Êğİıâ*xáqb%¾Ã™ÿü´¼E1óm¼Ä{öXT–Š6á€î\HÙ"+y ln'†„V®Ç=Ÿ¹šúS¥¬Ìh!Şã1kk®Ñ—oÆÓ•ÑÆcx<H DĞ§'ê‚`%EÚ6‹ygB_òĞ~Ô­‡ÉÃ÷ûKÕÍªìC7qÎX–”*.™WîŠK$hşbUºgÂ*uw~h?»kŸ¼×"-vN-‡7ô@ ×ánk±Wm
+B×å.—m!ğ˜Ò|NÍì¶”­ÒÏ1B}ğzÄ„8 _=‹ ìOUÛ˜'ŒÃ-ü»pµüèäÆMhFà	ÖÂx8'Àü™ÆÿKù\íš
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/1e/871520a3a3ccb8ce5989ac8654d195d69b3e11 squashfs-tools-patched/.git/objects/1e/871520a3a3ccb8ce5989ac8654d195d69b3e11
--- squashfs-tools/.git/objects/1e/871520a3a3ccb8ce5989ac8654d195d69b3e11	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/1e/871520a3a3ccb8ce5989ac8654d195d69b3e11	2022-01-01 15:09:15.617172589 +0800
@@ -0,0 +1,4 @@
+xíXmOãFîçüŠÁí8]cH8¸¢¦Rb;ity½‚¢=I\l¯åüúÎ®í8$€uRû	ÄìË<óÌìúÙ]¦.ŸÂ—ú—ÚO?Cß±BñY:Ş£ËÁŒÛá0
+ù?hÅĞv\„_aÀ<l(çOM¡ÖˆYwl0|ğ1lü~úGe/Vi‹Ñ†Vâ¸¶Äümz,†¿0ŒîÃYõø˜`>}}ƒá½;¦f…:ÇÍËÎøzd€òİñë58\~=;û'vÍ p‹Å„¢Àñòøä¸^©híNCĞ%¶©Ód^9è¦Ùì0^8ĞÏc`pÏ\ÇİáŒò­Â˜ÃTRÅ´ «E9şıæ7ãs”DñÁX<Œ¡Ÿ€Å=ù6ˆß0ñ‡Â’P Î@V¶Jñ•j1ZX×<‹ùh9³G"lqæÌªª¨İÃ}Ã_ñ+|§`SVrHĞô­9Py€EGÎÓu|ÊœVpÉ¼ÀÅ‹¤°¶P`éŞØ,¶RxÖˆG‘3¥U³Ü±0‚ÜÌ†…ÛCË"­B\¢‹,B§ôÇÙ¼º;
+›`rs”…;´…sÇÏ?j.‡#hº.aH•KÇ }}Ë¡¬ÅV—sLËšˆoM|` (ëİ=n1wÄâ…è×F£†åVq‰•KSk„–4+İ6€òË!-Á‘Fº“^IP”áZMÓ€«'ı¶VXõÊ:LzÎ4dáM9c˜ÄAOt'%/ÿp×1ôĞvècß3mÌÂ9f8«Œ_;ùì£ò:‹îÜç!NÒ/V¤[”â9·¦®ƒL TŸ»|ÎAı^µó7¨Ã¨:í»î ^S¤9ĞÖU'µ'Úp`{FÖê·4“Ìkòkë ZT:¾	|º¼¶d;0™ônúÍ	­t+ç“öt­µ%¶ÌŒö¨.)çéÉo Ú dQ3~;‡[¦V¯5¦‘%tSnÇ4!	*ó‚eH›}½îàù“ìÜ=wN‡àCİz­êÒ
+‘Ì†™9·Ìzpü(àÜ•3HÈlw0ûù´hnC'F6…,–ÄY#I[¢p{jåÈ´‚¬ñ¿"³ÚˆQ2£½ÒPyª$ğ’ò‹nıëYVøz¾²¸o­'¨<‰/rñSÏŸt”B¬T*FÏ4ö«qzÊ”ÕâZÌBÃ×0Ã]~©[&=×:‰ş&^qÙMã5?Fƒ½T.oº¤Åös-¼Y‹;7»ôXıË ëÈ?R—×yl×æ,ò.mÎ‡?´YœÿÉA±OKlñ‰5°§ñc€ñ‡`§‡ık§ñ»‹,u[jàšj?«=iø@'	/.ô©BŠvz?ßxQ®]·Œ®ô6}tB ˆû™Të8c‰Oè‘MçôúŸN7yZ(_Ê•Š9¼ºÔŒFµzK?÷‚£èV^õ´ÛŞ“Çèâ6VÅÒ ×æºsş4Yï{3àb+ !Ó¡Ñ=loÏŸÄÈz?­•çöøûc¶’ÙÃRA3×2Q5z½»ü”§ğ+¯ìŠSÈÌµLTc‡ÌŠKešû–‰û'2»äšf®e¢vıR‰’[©ht‰/O8–‰ØgN¹û/¸İÕKÑ]9—¡<¦s2Ú‘¬¥L¯SÌş…YùËç_×
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/1e/d56855f639aec4272ee0280913f9edc007f7bc squashfs-tools-patched/.git/objects/1e/d56855f639aec4272ee0280913f9edc007f7bc
--- squashfs-tools/.git/objects/1e/d56855f639aec4272ee0280913f9edc007f7bc	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/1e/d56855f639aec4272ee0280913f9edc007f7bc	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1 @@
+x+)JMU065`040031Qğ©ÊM´0sIMÖKfØÁxWfNàƒWÒ®-S|ò«ï§†²†ï‚M’/ZEs{Ì»¹˜+1§á²Š2×<iïOÈ-‘kY{öTæuÓywJßšmÃP–Á °Oæú½ÅŸüwmpĞXnÉ±~‰P³8’²Ğ’Ì aŒ¹Õ,Œ\ÍügšÚh2Ÿ,ŞºïËtU)Å¿ÖèåõÎt›ï!ôÉ8,tÛº¨ÎP7LuåGõÖçr/9j1õ;³QqåñíLÙ¡êr³SÓ2sR~ïìnyV"¼ÁMá…Y×¢y¡ÿ­AS£—œÌ0ÿì«Ûëu}´JlÖµÿœ Ùíº X6Ší
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/1e/e0e709b88771b7f00662fa77fad886a1a72343 squashfs-tools-patched/.git/objects/1e/e0e709b88771b7f00662fa77fad886a1a72343
--- squashfs-tools/.git/objects/1e/e0e709b88771b7f00662fa77fad886a1a72343	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/1e/e0e709b88771b7f00662fa77fad886a1a72343	2022-01-01 15:09:15.601172588 +0800
@@ -0,0 +1,6 @@
+x…UmOÛ@Şçü
+Ã$t×6,iKQÊ´"˜Ä„D÷©ê¦¤½²ˆ’DIÚu+ì·Ï¾·$¬l(¤‰Ï~Îıø­Òº~Ğó®ã<Çsp]¸H“ÈK‘Ã2Ía`.°ñÅ'ît=/p}Ïõúp
+×÷èpnVéßn×Ñ*Ã"}ãZïçmœÌWkŒ=Døãï‡hYˆeœ˜ˆ¢7wãŸ¥`F·Ñ<xzó¼½ºâ3O“¢r„‡›°x˜¤W«ô‡XÜ•a¹.¦ÁF°ó; .O>à®çáğq\~^?F"×¡*¢Û¼zöÂPç.ş%&Toº&L¦ÑZ„eØµZ O¾\'e¯qf[¦‡+qR‚H°‚qrÏ:.Z/—"¿MÌ3Èr±Á—É4™ˆ0:(08oû<â%0ÚÎà„ã;@.Êu€'W3hà„,b0™/÷À¹ì.)~'1¹}‰ ´ÁæHP zĞZÅqYùÈ4\è+RB†‰I?|l·U†*kÖÊ$«KÕïíe`–¢\„
+Èn]eÎ2L2ãÊ…ŠÁùHídPj5òœkkRCÑÅ‡sèœZõeQÄª²;yWÅÕbÖıìÅŒMçvw¬7çUï¨’2uÓŞ€ÙÕ@ëbGÈ>›ö‘·–~¥]³ál¦xØƒ½Cb½i¾^ŸÙÛÈ€Ê±Å«vj’o°÷5WO$4…FwÓn×Í8ßeœ¬Ee{ÖAêWİm5GT±*fƒVlÆ«†Ò#UäsÒS¯œÖíS²5sOšıÁsWšƒV¦i'w§›¡£&BNÁ$dlÜq²Ûš	^®şŸxÄ8è`ÈØòr4"Ñ
+Æ
+·Mµp_Å¨¢Z¥#ºÒKcb	\æ™½®VhAPa“¾å™Ê™ät~¬Kr—@ÜÖU5ù ÑåH·X‘ª=T£%æWl¬O]fx@[d|ò-¼œÔƒÍè7c6+RÈFÈ0—MQ(Öß0@Ù†Ù%ó—CP[÷«uŠ7¶™ö$PYÚfîöœBÿDl†Péß€![c¦ÄôWùÈ}ès%OLø€ßíSm•â?AÕVıÁ²ùgç‹B;
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/1f/a8ef2184d5435a524bd11a02f48978082fb9d9 squashfs-tools-patched/.git/objects/1f/a8ef2184d5435a524bd11a02f48978082fb9d9
--- squashfs-tools/.git/objects/1f/a8ef2184d5435a524bd11a02f48978082fb9d9	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/1f/a8ef2184d5435a524bd11a02f48978082fb9d9	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1 @@
+xÕSMKÃ@ô¼¿b¬‡|õ+(±+ˆ'¡ØCíYìvké¦d7V°ùïîË&Z¥B=%;;3ïñvŞ,Ífˆãşà¨×ÃM¶Zeª71y¢î³[eºb½fì$Q"-æ­‰™_/^ºËÖgğƒO7S+œY7õ,sÓ¸9Ô™Òbù˜#ÔmìC©æ{e@íK]¤ıKn–I*}“2°'¢ÁùË5Q€d_`¯ïa»…À¼Äql)sÜMG#wIjÀzÕV@.M‘+û¡6œY9Õ…qÕQ«V#Nå;T>pEôS²òë`ÆâÌæü·f3rœº4›CR³¡Ø<˜à¼#?ÈN£ı7ña{÷ª[+ZPƒsxúİëˆwüÊ&Ø¿³â6h=éEkÍ7Ü†W²7E/Œ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/20/199ce5659874f229c24674fbdd8b9d3a15fec2 squashfs-tools-patched/.git/objects/20/199ce5659874f229c24674fbdd8b9d3a15fec2
--- squashfs-tools/.git/objects/20/199ce5659874f229c24674fbdd8b9d3a15fec2	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/20/199ce5659874f229c24674fbdd8b9d3a15fec2	2022-01-01 15:09:15.601172588 +0800
@@ -0,0 +1,10 @@
+x­WkOãVíçüŠé®„ì„Û	lZÃV	)»@¢­T(ŠòpX—`G‰Òşû¹s¯í¤ÙªU‹´`ÏóÌ™™{½ãy<¦šûÎùî L­ÉïŞªVé4ÖÁ2	–4‹—ôÔ8¢I<Èj~ğì’ç8ªëT:ıD{XôFëy¼Æ[/ÏÃ	MãÇQQù TzF“y
+ç7*üç7,šMƒ/n.›Ã^¿Ûªy¥·„Q@§½%}êD	ƒù*Ø¡r Š¦á±´_gõa2±ÆÎ>]›,<ÙtrBÎ“sN{{,€xïçFÑpì¢wÑ×Ë¶ÑnĞËmd°óÌWéã ^´ÂdE^=ù Ù/£y
+Ö,)Çvéø˜
+æ[Aá,Ïq2š«p®›‡ÛĞ’•ÅÚ³W^§ºŒ×Šu˜#îŸûíæÙ°õë MVyœÎfÁ²RÉa0h_è™ÂY¢g6åé"|´i$é2¢ë›a»ßïö‡gÍAÓ§×/Bt®:Oği9ŠîâœëŸ~+g‰
+}5kVÈ>…tL‡øX0Ğ€|ÍRã66½°6«^óJ¯ºıËæEç¦­
+ hiÍFh­=>¡Æ?Ë“§éœ[ÁĞ±6%I‚
+Êxôi§Ño–Ä~ÿ^uÿ¯£2»¡Z°-•‰kŞ‘O=Ü–†GİW©8‡ÚÛâüÌÜÃFªr›436@fùYót6—ë‘lU4Ÿ‹ÑÌä¯\èVö*)ŸªÄ=çaxpÉĞŞhñŸI@<–ØæëğK0 ~;û»LÜ¢‰»ÓÄ+šx;MjE“š˜Š8MZéÌ¨ñÆ€ìÒ3°ÈQµ¸õÀ¸wçC&pÃ¨¯À
+ğÃC?û%è·
+ÄŞí«Jñ€µârVíûjŞYªÀ,–ÁZ=ğ†p´4Z…÷Q0Õ	×Åbââ÷è@‘ÈÏ·ÎÚÎ›¢Åmx¬[ó‚î¹*‡Ù~^şCĞÂI++*¶Òš½gx<Îš1uK¾üäè~Tfßgí³B¤js.Cry[Aš™Fe¢%¼AœÕ4a>†¼Šjv0ÿª)£¬jZtLÊC@’¼Àİ`ì$ÂŸÃ9NvÉñ=ú!nÏ*¿n×XrnUf5Œ[éìV£RaîuiÂîËt·™m ùe0zü0å«TÌ«ñ(FSèªU1Á©ÈÙ¹tÍPó½&@¸AºT“P§Sn›µ µ¦šÃA‡POí†qäfÇ[a`	¾Îãòã¬Sn­ù,DôßéÜù©‹|èYÛçÇe¦Â çë£	Uæê#ƒ¹É¼Õ×Mƒ&Š›{»6Âü˜,dÙÉˆ‰L´–¡ÀnI`éÏ(ntª>X™/JáŠÍÜ°z.UN¨G’(8›3™H”•˜™Añò ŒƒxÿŠ·ŠG» 0«àÀÊ¾ŠÖ8øÃÈ«ó]^»JìAœUMEO¨O€‚[íÎ¶±î™DÏwäšJ!Ú^A‹»Ør&ã›»±µŒßh©rq˜6²äÿo\Ğcªúë!ddØÑÉÁãÄÿôdî ‡~æOÂîGüW`óÓ°ôZú
+Ÿgl
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/20/3de84324e3eef1cc01951019e78331e9d4cbfa squashfs-tools-patched/.git/objects/20/3de84324e3eef1cc01951019e78331e9d4cbfa
--- squashfs-tools/.git/objects/20/3de84324e3eef1cc01951019e78331e9d4cbfa	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/20/3de84324e3eef1cc01951019e78331e9d4cbfa	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1,11 @@
+xÕYmoÛFîgıŠId¢Úi¤€R_!ÉŒCT¦\Qª/ŸZ\ZSK—¤ürAî·wfw¹\J”‘¤× g …–;³;ïóìä2Ë/áçW¯şîè.¸Hò»òè-Ï˜?=\ŞÜôzO¹Xf›„Á÷a•ÓûÃÕ÷öGMŠÂ––Dö”§"a)D‹ÀOO<‹äğğhœ¯×¹8
+«‚‹«q.nYQI.&Ò[Üì¾b…€Ë<Ïà*òË`ş¦÷T‹xÍÊ›xÉ ĞJÀ‡õ‘Älñ§¸îic—l0ø¯ùí¸ğÆY^2Ç}{=y¥ÙÆ‹+æLÎÇóp>ƒÏP€>œ\Lg'°’,.—¬,û=À?µQ®â‚å‰¡\ÒA<'¼¼ÉKN?ëCÒ,¾*‡"Vh ËMÅJ·÷ÏªåÂŸÑ*	êuµH¤ÓˆÓ¬ë¥P ¨Bè3ş>Îç3´˜{¡,&“>t
+§w¥ëƒónœL<ˆİ}ƒ”«6è1'"‘ürzÃ
+ëÔr?9?øc8ñO"Åábá¹È‹Fßñÿ~/\|u/ğƒ.êI~iyfŸo.¾!çü÷ f…á×Ù°|‰¡­òyŸm²Š0Mšx†£Şğr„>fÚ¯0>†ãsĞ©w6>wû º?|;Cs7&e Õ%b'|T‚Ë¤â©óÄ
+Rò©Q¯*6Œ‚Yò¬D½0ˆGÓéd°9˜|tÔ;™ŒupSc´ÿ‰â¶2£şĞQcNYu®K‚³ğEõúÔ5Â…e.ÊJŠ®s,dìÚyÑ‡·şÄ‹0£g^0ïƒaµm¼bÂÄUµ2dri¯ÿ{Ç¯V$zóe’ßÉÚƒçSC$ªÕïÃA©y¤!ĞÀ´–Çğâş­şS–ÆİÁ€¤‰ËÊ+Š¼À¸ÀâL#o6›Î‘qHg¥ôˆ’–*Š£5pÍ¥ğË/ğÓKƒ¾×²ºòh‡Í¥•­^V±X2äüÖÔë5ş>cÕ*OúP;E°»ÚQ¶á&ÃÙ©ùÁÜ;õfpg*ŠäÃß7qrHí‹HJE‚¦ÒƒA¨|s-°±q‹M®Öä(bíC#®v8-8ş|_¨ÔÜu†eÔJ]S«ùÉ¶×6­Ã¶ÛÈ;aßËèy§~ĞK Yvº8yS˜]qá¨Şª¯·8-Éë³v;×‰I+›eGú:i½àä„Ö¹æ‹4/Ö;8ãÑƒª=”„´²ìà/; Gïë.+­äo§³³áÜŸpÇEÍK
+S5”ùXÔ7Õ÷4x`qº­ªi’´å°2ßarG÷4Û$‚á’ÍaÑœ¯	èØ|ieo¶¸¨(øÕÉ×ŞŞá¼(xÅö2šİßy¶Y³<Î‚Íú’[ÒîhI‰dÔ±8"CSÈlE¥sˆ‚2Ûm*[Ë†GK2%Í4pq]n	%Z›-6ò‰ğışq±$É–\;²K"-—îW¦íûëáƒdìKµj®VƒÉ½èÛB¹ªUu‚µÕĞ+jà*ãË0§^àÍüq4ó†˜¬ÖMwtœn='U†rÉˆ!Õ¥PQ™¾á»áÌÓrLÏ½ òşí‡s?8ÕÀ ù( 4G<N™=˜z[”N<miûe×–2ÿŒ]kˆ‰;cqB©ˆA–
+¹J7bI¯»¸¨ŸÙ°ŠoŒ§
+u?…‡|#ù!/+¼~u6¢Õ:/87E~_f°æ"Jcm
+¼Á•”? äùm„˜çGèÌ´È×GU«îòâZ–›>ğJÇw	^a„Dáûpîa<…ÓÅlì…’İñE¹IS¾äLTP>”[#k™o
+|Ù»GŒxü2_ßd¬bP­îÿ¹aH™@ÉŠ[¾dîa¯‡XªâK	™~z	×ãÕF\SA;‹eyù‘jÚËWØNu“®’¬IPÆ¹ÍyÏ’¸Š&ÀSHq³8@ÛĞk›%t¬êæôF“ÖùWûFÕ§äÎq{‡
+ ŠmsÜ$_¢u_ĞNı Àuı×.oÚ¢’S	ØH†GõÕÛX¢1sILE–ĞBVóééZ]0Ñîˆ·ôEÆ1·èÛ¥†INeÿƒÚU†Ì²CËÆC¶Î6—ÔÀ|’÷=?n>h5	v€CO$å£¸AŠÂ$%B×l‘×Ï5 ’ˆìªbÇuœ(ù•ÀÈ\â¹’àyK--¹~Ø’^½w+Jï:²^HÏkjÓ|/ÕÁ®—_±­QIRC¯½îgBŞ—·8ğ\d\0S]åuíy—#ÓJöO6ÌîâéÓûì`ã{Ñpr1|âÀ@-ïÂê«ŸfNyn[’Ïêüv^õö6²‹=ÄÇ­±…öXÔ¶Î!:¿.´F Rµºe=‹ü_¶ş/Š=ªHİóÈÇ1Ö§©×áËÏŠ…nÉ$Lë†a{ƒaËúÿT0è¡ù–8e G#gKr4÷Ï<xV›‡6q*L“'k7k=µº÷Í“©eÖVÕ#)€7huóöM´nN¶'õÆíx*½õÕní3¨û™¾S›CÃÕÿÛä]EG^%!‹2Ô·\¤¬”_¹ßÈÛµC¾ÄJüMÓxìÛ…0v,!QË¯gvN·¦©ú·2¶º!Ò­›Ñîqí1´BËIY÷H&Tr§HÛs3µL="‹5†£ñr}õ–mj½ÆĞ(HŸĞ?~ìıj»x
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/21/3062af12c34319ad900473b2186dfb097af23b squashfs-tools-patched/.git/objects/21/3062af12c34319ad900473b2186dfb097af23b
--- squashfs-tools/.git/objects/21/3062af12c34319ad900473b2186dfb097af23b	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/21/3062af12c34319ad900473b2186dfb097af23b	2022-01-01 15:09:15.637172590 +0800
@@ -0,0 +1,11 @@
+x}VÛnâHİg¾¢¤<,°@’É\2;+kˆ‹´3«•åK½c·-w;,åß÷tû‚!Ì>Awuª:uºÚ^{tsusûËe›DãçÈ1?Xo«—ß¾(_§Ä…béÚõY£´,FŸé¶×¿¦aœìS¾Ù*jú-º~ÿş}·uõ†ìMœÒÌ}
+ã'jêîÕ]÷ê] [¥’——»İ®÷¶ûÌ“^œn.¹¤ûLHP&–’ÚÅå–ü Œë=NV4fRÂúÈKİf™?ç¾Ô4GgcµßB®Q‹W§†ù[QÄ\!Im]Eû8#ß$YÈ|E±`¯ab’%C®4}ë8ã¥YÈd~ E=]ÜbfíÁ˜¬?‡ÖliO'ºŒKruhFn¦¶àÎDº#bÿ&)j÷”°4âJšU¬CKå*î»!ŒğöÂŠeÈÅw}05(Ô„ÙãÈ×Û±@‡HÕâ"{D^óÑ#›L‘Ì¼@›PC£;:»
+d ŒÀ«N¨lBbOQğ5ÒS<Õ0»AÀó²0ù¡;´wì‰¥`&eee°1Úªİuµ×hCD|½¬Éq´€GÖp:²œ?ØãháÉvÒ¯LÚÁ±'Îğ€Ë
+­Ö´z®ÿıÕ× «\}âµótµtæÖ`TóO™Ğ:`ÊÓ  óÿQfóéÃM¿À€(µ
+¹ğ„|dÂÀ: d1ºéw=®ÀÁJvtÉC~‹âtO™t7º}aH£ ÆÕ€'¹¼}v¶ˆñtèLgË"¾%\øQƒˆ2x¢xÄŸ‹r!9$`tpoñu±´¾8û›å”¨šY¹—ŠE¿J’ü™9ªG_‹—Áˆ¢ –¿»5Uês8%Iœjêhe»W¶P7}½4Í7­\Ù“åMß±Îj<<VÈÏb®H¾ $ŒÅ¦qÁBÉ~z—'”[şT‘Èjyø¨b˜„f è£T²ëm?UqŒsAÀI
+¹©¬ëUìC™¹\*Èá,Å\¯üêUå¦ªn‰)S•UùêæÖb5^:ÓÏtuÖ0,5ŸOçtmšpHÇ\ †Ú'LïI•f˜­_[‹ÛÔø‘Oj¶ç¸ ­æSÌjÇfÄt &!Õ¡AşÖM©İö²õZƒœ™b©­ûÆD¸?4
+yè«o
+{,,#Eº~w{w\ÛØ^æ¦·wïPTİÏ¬ùÒ¶ù‰7Wu…àãYq&«
+Cÿ¾¨5LÊ‰§ÿ‰µØ/ô9âff¸é^×hr¼œ„ºo4 ÏÚû}È¢yr”Ú	2”s†qq–dcaÀu0)0ôsvd ÆG¦&Y„l"µ¨yBğoÅNEëÇÔ¬{t?…>áT[I«Õ:°ÿ]³:ÁÈ³Wv@ÍnÖSu™*‹o•CfØ?­ıG“™_†¶©´#W1'éÁQƒœå07yTëÙ)~­İÕ}Ìe~h»v/´0wÅÆH XñêÖÌŸY,kûøÄsÃã½Çç‚ğòãªvvÎù×íßzGwŞĞX.æ,r¹3¡7ó]²(9„/ ŠQùB¯¦ÏË¾ºnèwÑIİòæ“lÑÒ?İOUô;ã^ª|ò+PµŸd…ü¤åø(;VÔæÕà*üÌc¡Î
+€‹…Âk•£
+kÜ£r4½„ğ|ıñ”æuÑ˜Ç·ñ½p§7êxÅºÄ8,¹øŠÏe
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/21/b7df475f183281a428db792246a6f153edde59 squashfs-tools-patched/.git/objects/21/b7df475f183281a428db792246a6f153edde59
--- squashfs-tools/.git/objects/21/b7df475f183281a428db792246a6f153edde59	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/21/b7df475f183281a428db792246a6f153edde59	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1 @@
+x’AOÂ@…½2¿b=Ğ‚Ñ±‰Ú*Ö´àAâÅ”eQ“–5¥&†_ïÌtwá°$&„¾÷¾éÎ¦Öqw}{µ\-æâ^L™’®×¨?F#(ò¬Jüní },fó<FRD‹½Vu°H©8=ÎêZË±F•üìvªe™¶}	›ë­âÒÃo×V²cı¤ª­Iæ{®äjX”ÕW_)U÷©·y†ÕâØT® ş~,‚!MAúO!‚!ÎŠHÛ>‹ŒÇmŠJy‚¸ v³H×;ÌÆ$vPBŒö3ÎDˆ_	$üñŞÁ¬–âFû	g"ä^0QöàÇN.rö23ÚO9!º6ğé³AA¾X’ºî-Œ÷×OqVş¸±(î–„{º€l8_©XŒÇü¤ºùnÕá0)ŞÊÙ{:9Ëøşµªö1¢`¸*iûxkíüÎVüP
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/21/ba1d7cdbe4df4d3efe6bf5ae944da643c7d9dd squashfs-tools-patched/.git/objects/21/ba1d7cdbe4df4d3efe6bf5ae944da643c7d9dd
--- squashfs-tools/.git/objects/21/ba1d7cdbe4df4d3efe6bf5ae944da643c7d9dd	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/21/ba1d7cdbe4df4d3efe6bf5ae944da643c7d9dd	2022-01-01 15:09:15.629172589 +0800
@@ -0,0 +1,15 @@
+xíıOãFö~Î_ñ®+mK>¶¶§Â• 
+i«-¢‘I&‹Ebs±Ã.Çîıí÷>fì±3Ğê¤ëİ¡Õ&ñ¼ï¯yoÆ×³èõú_¶·á ‡¥ú~¾¹©T^áx¶œ(øæÍ›íô_'šÏ£pûPMã77ß¬ê:OÂ´g³hLP•ĞŸ«øÎ+8NÛıîÅy»Ó…G’d:QS8n_ÚƒAûÃ¨Yˆ?	Æ0Â8ŸzaÒjÂí±ß4/‚(xØßGíöv•BŸ–Ğ8]Î‰Ìa°Pãäà!Q1c2ëè[âXJ„[9ùvÚ–ğ ÷~=›@³¥	¨Y¬^€¦z¥ÂI0E¼WëñFÑ¬ĞÆ(ë@É(¶JŞlÀ­M ÊNQ ¶Å~íC¹îNÙ_àĞ—ÈŞø^D5Îx…‘„
+†ÇİA£·;:ìºáˆ£ùàÃ°{ñBÁ›âïç}èKÎaRqr5¤.–sÌÎAr'ëe{)Ë]€š•«%€’¢“F MÄRÌêàØs—‰Ry›gÓi¬[Ş=G¡i•kÜZ¥Ó
+É™€Ûuú~2¾9
+Â‰ZèZ»»ëxèUwQÑÑf…W¯nÒ÷ñ2ùÙŸ-•Wÿ|tT­<V¾V*÷Q0úîîVñáMwf~÷Õ<Z<x„Xâ?Ò¢ÇÄ9©ø›Ô·'iæH9™PhvN~í…¿ –Ñ'ÅCFHÛ)ê?OIVÊfâ`X2…‹áa¿;<>;ìõÏİšwÊO”§w4A‚ºS,n¦;„RwíÉä`9¢Ô4Zà20''õıÏ'*t#µ§‰Zˆ95ŸT¬÷hHÏâJñ°ÊŸ2C ‹WT¸À64q¥ùW•`
+^ÎºZİ'9jŸf¸	™.Õ*JIA@ŒóLP"ønÑN—GÑâ4ZÌıÚZÑ…´°PÉrBwÔ;ı¹}Ò;lŞKEûÊ¨#Û(ïl	”¶y¨>uÆ³`,$£ñóB6ƒ¤—0ÿ+îãğú58‘ßaš(Š2©È£³…diğS®ˆ X~{€×$
+¿M`|ã‡‰èOyOqÔéa¡øULZî’</-­TikVĞ¬âŞINŒ¦šB•ó\œ˜™¡D5òA>ïRí»£³Ÿ†gGınÿlğóÑY\»ó»äv.X¨n´•§3·‰×»P_ª0	üY/¼H0™ç°ó§$Ü wzöc>QÃ°¦˜Ò¦ ÌØÏv%4İµš€r\!àm^rrtÎ—çQÚÔd9VRÿco«Á|u\K`½³uyT­«î¢5P3åÇJô5Å££ğ|¨ŠºöÓÕg­JÎ¨íĞÙBşğ¤S¦†6î¢ Ä2–V¸×uMvYşY‹ŸåÊ]¢æwh¯¶÷»»Cÿz¦.5¹ËúÕüæWãŠŒ˜QF$Æ}ÉÒ¨oØà„ÂyøhOz†dóªJ]ıNµ
+†Š´Ó†ŠöÂ“ø(¦çÒ … ƒï˜'$hi¹Ä›¯¸µcƒG)Fö\òGì.6ÎYË)aÑÆ™%òö4–(š°.&l|*~¯¸ÜÈ,ü%õd=IJS#CZ[£X«ÌÍ\¬r‡ş¼ C<!şN=¨ıãòc#‰6&^Öûñ÷Êi´N	PjS‡‘¡Û°Íb	‘\.)"ïUrá6'Üej	`c‚=UœKá™
+O‚yP~òöx‡Å7{ïİÇQê*V>©–Ô%*zz|d—Øp)	Ø‚²!`bê¥@Xœs³¤ÛNë V¾B‡„R="Š½H®V“«ğ7Ü÷i7å*ìÊH/åp¼\N×Ü’!XP›%õƒB›™ë8$t­Í2˜TuÕæ¨”<µğÍŞyÌu{‰u:£*ßu]fÚöÏÄçÍ*œÌ4½ÙFÈÄD“q¤‘İH¸Kúåæª¿ª·e"ƒÛL‘åàFOT5KÛb4j‘±V˜Ï„˜˜Kˆ™¡QÄ.çLô8 Ò,ºlR«@S˜ü‘ı1–MDÉ!OÉN0	­ËÉ¼ü…[¦@="%ú+°Òœâa0ë¶–ºy•zÎç$Y5<ÙÊÒÕi§®­µº¶«+‘yJWfUĞµåÔUÆP£j±LØFÏ,S½Ü4ÔqD™ÌÁT·{jò¦ºKu#àÖ»€œcM¡£Å*®°3,œÆS8\@2'çJ_ÑŞ¤£œ}®?>¢KË)ÚÚµ0)È$Ä¬puyàÓM0SàéèÊªsZ1\k5Á %
+Ì‰½Ã/JÏ=¡RÀæGŸİ`Œm0ÊI¾Õ5-u±È®Su­oş¯S~#Wz€íÉ±YÁˆ–!ü¤§*²Êj{ÉbY˜am{áh¥7|ù‚ÇÏHlk‹"¼.‰lìL7t9fZ –yuø€k‚nE@1=Ö=ü5)‘îY¦DàÌVÖè!Åˆ¶×t"5‰Ø4¶ĞMw×—|81S‘¢ïF;ÂrJ%¬Õ˜ğğƒ{Œ”•f¤åš¨Yâ“²C¥/!RËÈÒÇ:¡hÕÇ<CÉ`Ê]/–ZœBbc× ÑHÏÕ¼ßFå#:‚ ¿R(ê$lúÜ–ÿ¤EÃ¨ùĞ…&“’+ŒÖ2éDÏ™W/=¦bÛşÛw¸/ƒÌâ¯h~Rc—BóäÓ…ÓŸÇe
+ñtG¢5ô¡á‡>Ü4¯	Ğ¹,Ué™%¡ü&IìÇTK¡Oô…4²×%!Ã¦L]cò’°>šnÎ¶Ée’âRF[aåHâÄ;”óæÊ½E“Û²À~‹c¨Õ´túe ¼cf?ßæ{›<1„µ‰á4ÄÁ’asW“ılå‰éQLÊûÊIìÚ³Ãå|şLş¤sˆBÒMÄŞ°pûw!«ñbõÒÙ`@¡º
+juÊúÇÇ´’Ï.ìÉÆ4L+÷¬öü|lÚh§Âì€ù.je#Y³øŒÀx"À5S¾ÿºÉ—÷ˆ¸=;º$ª
+Ê†«Ğü´G&~ù®á%=Mi¯’v4¥ÿïfd¿ç]¾RaN!ÿ[ÚÙíMß#=“égLä˜gLß´²„§åWÕé½¡¾ Öq/¯Í˜VúhĞÔà o¨­çzMšL¸œ÷ôÒóîÎïÌ.ŞÑ‘_ ZéåÑ#Â¦œîévY¼O"Br´*+8iÌcPVF˜Vk*p[M›“›+† §ä¦üİTÊt¥msßEõ£{…åD{ƒºÈZ-gz®5…±‰ÇVxTNY÷v)'Ş™‰{šN/ú%·ÊV°¶º--¹p£M ü¬œïV	Ä“Çğuõ™<óhÈæ.Úñt=ÃØ=´váO¢®œ)Ÿ—¨Ğæ™ùàÚß¦÷o3:¡_+SJEÚA¼ß!Â·ïı`FWzd
+ƒ5q€;˜Ú·å¦9—ûÈaÔY.x,1¸†¹ÙãS#oÚ\¨¤ãÏfdšœ»ÜñoA{6C6Æš˜Ì1óQº‚'%zÉœå%P^B¡t8ÀW!o­ÔËˆKÍÈ~oı Xzu ?ÊKl4b‹İú\
+Êåá7O^*#=Gš"u†.¶ÿú«
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/21/bb30c7c2349f09b592ea80e67a55251167e8bc squashfs-tools-patched/.git/objects/21/bb30c7c2349f09b592ea80e67a55251167e8bc
--- squashfs-tools/.git/objects/21/bb30c7c2349f09b592ea80e67a55251167e8bc	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/21/bb30c7c2349f09b592ea80e67a55251167e8bc	2022-01-01 15:09:15.609172588 +0800
@@ -0,0 +1,3 @@
+xµSKKÃ@öœ_1¶iMŸzğµjD…*‚!ÉnìBš-›ÅŠÿİİ$mšZ/zJ2³ûÍ÷˜ø÷¡×ö:M,‡QÄƒv ÍeÕYD)¡p’H1¿==[ÕjùÙiÍ²ÔÕ:¡!‹)¸“wx{{?r/.ÏŸÆ¤ºiRíH„úéx8³
+JÏ©ğ$ãq’1ì&&23õç›»£şŠÓÉ‚Å„/M”Æ„…k=¥qì°XÂ›«‡xª>N¡{\©>ÒÙÜtêÉzçŒ@sb,²¶¤®|4¬O€… ‹pªğª  ¨LEŒè 9å²=ªÎ…bÚŠÂÚk¬C€ƒ^—€ÿ!irAFk5GOuJ"8c]Õá¡j¸TfZ¶æ©n|YFÔdy¥Ì·@A“Äˆú‘5ªÍNÂ~&](“hµÄV8±¢k]€Vô¥®gş+$™Ó[±Ï#ÁÄş?Wâb¬gó{8È¬³JÛ\duM½¹Ş{LåƒàJkvÃ®ÙZøS¼d{·+lmÖß°¿„®Ü™|a—NÃt@oëVSVÛ‘ÛXú
+‡*«ôŞ(‹×
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/21/bf40bde0655a6ca133f3ca51b64864ae8202ff squashfs-tools-patched/.git/objects/21/bf40bde0655a6ca133f3ca51b64864ae8202ff
--- squashfs-tools/.git/objects/21/bf40bde0655a6ca133f3ca51b64864ae8202ff	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/21/bf40bde0655a6ca133f3ca51b64864ae8202ff	2022-01-01 15:09:15.637172590 +0800
@@ -0,0 +1,20 @@
+x½[ùSI–ŞŸù+r¦c¼%„l	Û=v<ÁÕ^EƒM€¼Çx;¦I¥J¦iÆÿû~ß{y–„ #v—0¶”ùòİW¾•¦óúÍöËy±¹aÌñïãÁa~Yóç—üú÷“=£ßg&+§U1.~Ï‡æªœ™óiOßòÙ¼(' ;øóÃ_Ì«çÛÛæ œŞÍŠ¯×•É.¦óöíÛÖv»ıÚô¾bùéàÛ¨üf2´Ú?¶:mâ¸®ªéO/^ÜŞŞ>ÿkë÷bú¼œ}}±c.æfT\æ“9ˆ/&Ã|fªÛÒÍh§aŞødóù³ïóI>ŒÌéâëÌ±®5™€¼?=&ÕíxËÉÔô*3Î“¹©®•¹+ær01ó|”_V¦œä¦¼ÂT>ÏfÌ`2¤V®ÊÑ¨¼5³Å(Ÿ+$X!S¸óÓ£ƒŞŞ±9úÏƒ£Ó~ïãŠiiËH:7ƒEuİ	5(â vÚ2ùoÓdİ™i>Õ\¬J’Wƒª¸Œ0‰uÃ»É`l¿ŠÉg‚Æ™‹ü^Ü å$	$Å¤ÊgWƒKÇ=(_£ÜÜàfQ™ùââPD1ùª‰Ö!wà[ñs½’!g„çforgÆå°¸{
+33ı.„KzË\—·9|š™åGìfårªÏ76áD?“ËÑ<ı9òòë?sâ
+teöïª|ã|*`Q~ƒÍ‹¯Èry=˜müOÀ à-ÈÍ‡Å¸_N÷©òíWacÿ>-r“eŸz“êåv£cvvLŞH‘ Ã	”5ê—Õ`$è:€.™5™Ç•ŒsU#¬g'å·\p½ÄÎ¾œí~Ùÿ¯ş‘É6÷WWù¬ÙŒØDïC¯Ïà…¦vM»kÎ“¯òñ·ŸíO×ü7rOÇ0E—Ù +¶0;æu×À‰y ë÷»Y&H¡Š7óOÎzfºæûw1íğ…il|9ØOX'.R½2™rnvw~:.ÆËÔ92TßÌñ7ø ƒˆÅ¨{½ÉábpyÓzw–†YØ2Ï>peKAÅ.ıÓ®$Bp{şé¸ÿåã/ ­³‰Å­êğŒ€”e¯éØ .¢%¿m¿X¤´8÷ú{_ÎÎ>YMX³æpfˆkmcÍ=å£yş‡Ôeex"»Ù2ú/İœé`7ê˜iF+àOg³Q˜úğñìdï¸÷÷#±€úbÇÅTâVvvg×¼yš‘zWˆv6mO³k.Jp)îwï$l—CÍlšM¬V?Q·Öµ!?M‡ƒŠ!¨dl	®,6MĞ¹Ip›–Ì4Œ%ì‚¸ëCÛcíó‚µM“o«„ğ•,|ÍøaRJxÔÿ²ÈÏ¦[f\l™½6~QKƒ¦4è=«Pä¶]Óéb|×Ğm$zH²*àğM,jào®ÁïwÖ˜œ(#b :o]³eº“şãŠílÛõögy®ß²é¬¼˜o™Éb|Œò1ÂGÄ¸Ë’Î`{?Ûå,À$e–È>§@a6§d@âÕ–Kò-X¿›ÛkÔÉ¬Õ*rH: â¤M$‘{Z˜Dôj`±8-çà~~2øÍDÕE'ÎQØs™
+!ÀG	ıæ8Ÿ`ÉqyK\æe à'ÎïÆåhîJ‹ç‚àÎÑI1\+ÙKˆş¡`zSg‰3+Q¹%‘x`öàºDSgÚÛ6™ÿL<`‰¦·—æÁ·Ì®‰8­ëh‚n	zò*ë‰gız§¡°Ä€›®³à“`k:‚‘‚¦æ4ê¦³íÕ!ÈŠÊNü5ò1Í*x4=ô@‰£M†é\'õÂŸ£Ña1¯v†ê†ÙÍÒ*d²T“°¼ç£²óÿ˜Ì@Ö~Éiñoø}2»7B;&«"Vd°?¸å¬HÎ‹¡AS?T—×'Å„ÌvÀŞC,a"ò¢Şü,ŸšÌMXZ¾l;FÉ"42¾,|ßæRb€ÕÀ‹®V ô:0ø±ƒ_Ö>.Ñ[Húó*ºVóL—<]4ìù.Ád]Z³ZĞ³r¤±ŠÉ*e3õ¥–Yr£ 9Ğb½Å~T1AêêĞş“RÄW	¯ }\`³€b/«s³`¤k÷÷Î¾œ£gÙ8¯Ê)¶’Ó{ ¯‡‹|ÿÓ{ßä°¼„ˆc»Vù<;àhøâ‚9øªÓ%vBUº±Ó‡ƒj°%®4¬÷¨,Év…åiÚîb˜­¬´Ÿ;ÚÇ}<=:ë÷Î…iî€Y•¤£} ˆ Óª7“úçö¯»Î½CQ{‹Æè5añ'¡%ßÜ"ÃNìÖ»é¡¨áEŒašÍ-Ár*”²´„oÄrã{cMLo-@jtiåu#G%uuÏòñ h8&˜I,ÑÉÚæ…Y‡ÚüÅ¼UæaÑC@ü{+/@ˆdâ/^Ã†Â8lØT}üÔ—MÆUñº…«!=,°›/'ƒÙdTªN ÄJÑNïÚ_î©quzmë]m=Û\»V‹÷t¡Š_Üc÷¸‰=¡¡·ùj¨dõ=6l€ù_»e_éŞénpÓévóŒÂój–Æÿ1˜ÿ\LŠùu>ì¡	h¡qØH£WcÖ¶˜’ÛÍæ·ù–p–(\w±TOøÃ–Ól†Ïvìàº2ê‹‰2·eh”>BŸÿºo›úõtV¢ãlÌ¡”âL<ÒlâÜ&EÇŸıî6$ÃDİï7³sêZYš”·¬Ö_äGSßŠr1—/vB}ÁLm•?Ìo3Òg­ÍÏ§Ø·´Ô vİHó4(­]9âÇ®¤ñ$ˆkØG—İu!Á,Mİî®—ÏÚÎÙ“Nñ#gVº€ZUaO^ 5WíË¶šë–At§ ğ]X_Y^ œÎSÖat0Bq$Åjİ…úš³³Š‡ÂŠ<Ë§m;…b9G%à–gÚ‰Ç::¶mëØËxì¥VZ-™U±äR”èˆæWUFê_ÔÇ{÷=‚ÚvZ*xäC8×¢Ê˜˜[M0ôIÎº¬—`tƒtq	·wş™æ§•Ëc•*OÃÔçWPˆúœJÆ§aÆÔãIrö‰N"¬úÀuÌ«¢á]l#V§ºK6S%X"Š 6UèsÙ=~±CušŠEÕÄ V’©q¸›ª ı«Õt¿>N4RÖêâ|ÀmDoRT½a`G™ò^;Á–ZvT8Ï³½úWWš¤ó9îõ¥'’ª„ŒÑŠìÍ¬¢¢x´…û^/^R%Q'?¯vğÃmR—'!ü±ñeC
+ÿ0ŠğÇjLÏöå\ÖÑ#ÄVljŒš‰hÂy¶:èŠ‰ÏÁb.dSrî!W¦9òoøcz6É	?•¹Ä–È½V½'k76-Q–t=S¡'óLÅ<{flÙÙ1¶f°éj*E)C[¢dåPZŒ¡@Â”µ ‹I'u­/¤Ÿ•f“*
+‘A¶6¼’ı4´šÍ°Œ,¢Ù	1;aTÀœA “V‹\QMi¬ZtªìÔ’¢ĞEÌzƒ¡ïL²’´è)šÅ¸3ùù“¦2×ƒ^Ê€Ñ¨Öˆ‘ÓÓñ•E?1ô“©îR;dırM¤Ë£¶”Zr«ªúÿA'÷ø­'Ë„Ëñ!C=)­ÉFà“„?+=
+ràvhup»ë3×•Ó+Vz„FøÃQíšPärZÖëRÏÀe„.1µı%”	†ªF&3„Ï,n?ÈçüÓÏ6Ï¬~,ÊRÄ¨•“ŸyºìN‘ÕdÉ¼‚EJÚb…Ów–(Ç¼
+èÎàE)©Ùà‘ã[†…CÑÍƒ_"4ÇDä]iİÛt%ZÊş¿4–vô²%áÅ Šs’oP"³7H-˜ÃÕ¬f:Õ$òwrØé¬â´¥úó = SWÍ¿—ìÿÄ*Bë?ZIÛ>TM8íùƒI£ÔŒU¶VÈE?§KêÉVºd­ßrñ°ô^¥ªº(ª $ãï>àSp x&ğ¬—A£Á«vâY€xfÚ¿uÚ¸‰€@ÉÁ'X^@ğ/WãU\<^\Xéâ-†}*Ê¥‹¹À–ş&ê¬:ÿpµ!ÉçeT;5^™†²“÷^°(S%ÒÕå	ÒğèƒšpÂ8á$  VúqÃ¡³të -I¼Òir]ŞÓ"nw"wŒÛ‘Z“ÙlúĞŒÜ7|<Õ6h?¤ùä.(ŞM '|'4¦úRCmE¤6ÓšW¿¯õÀÒ¡Ä@xŠd¡p®øÒéJÀ†Ôa5‹L)1ı[áÜÀgc\ƒÂ¸ŞïÅÓ]M8“›Aï.%}×:†GŠ[Ø©ìØqÓà0É İBø"!ƒÜ±Òë"ì*œÆ’„jş†û§ “´¦ØƒyGÕ¹,µ³ÿšRŒî&	€‡1ÎÒìí=%÷Ávï?­SÏ2	bEÖ—:ğ¨}{µƒ„ä{²ğ ±h§uÆyß¼€BãµC@ku=]‰ÿºËñ®’\½Êp„«l÷´
+<),„§—=r± `ü;‘@­±k#Q‚Ä(f˜ÃßÂ;‘7ÁãÚ†šáòI2J¶‚ÄÂÊIØ·„
+öh1'XœéâŸA!ªË„œE{±Ó‡3&×(· oê¢@
+øÁW”v©ÉQ/3Ë†¢Yò‰úÂ‡ë<ÅªË¾üp­RœÉ±+–ëßa§F±¬ŠÉ"JBq×m‘uIœŒ¢t´”íb$.aÖÅ¨l+ê¸Ù~8£.§¼÷¼|‘ ‹1¬Ìªõ„æÉ,
+îÓ²’DgNå‹£=q½¶VÈÂ«î%YLÏuy"r+%ªËU
+KU³§SÁ"Z+ğ©ş|ïÁ)şØ#À´¶s"eƒóX  Ëµ_ğ`ß±¼#x,/¿©åå¨Í9÷ñ³ÃÅ­;ÎAX|·ğÒùjG;¸¡–ÁŞÄcoûÈáMìÙ'µ	„ÔÕ0…2ö92·T"yØ˜ş‰U‚Aù‚$¹Zñ0œ¾ 
+´Zj.´´äJOá]_J%Å<1Di0¦QÓ ©S[­+ûôi…®Ü“§ 1½Øk+¨å\ß¦¥pKú³èb¨ ÁšëAéš†äÓ$ã¬˜Ú:Ş‘ÂÛ¹§ÉCô€˜D(|ZÿĞ¢ÈSG¥QâÜøÆ3ˆ4¾äb…†`=Õ8ßÁ–É:Å½wwº†'\C…ÎdÇæ£<€~ƒƒLÓc$ÑL®§l£—>û›\ü¤¨Ó)œ4ËQ‚Š,X">
+ÉõÛ
+ÑJ<0Q^#¶5	xâ„<P{Eç4–ºšMl‡ÅÿY‚l!ş36™Š‰ÏäĞBu"J>gÛx/ïoªÜ’g|Xì›VÁ=ÖŸâ¶RÆ,Ü ²1ê¤î†·[(#m0í8ûñ¢à¨Ä`B–ci@yÕU”Èp\E¯¹O/÷Kş9w}JK¿ƒÍ.‰EäX:ºâ­-7üX&Îk‘ upLÆÿ:!ü•ÁÂĞúç
+&buÕKº=–jµRUé³âDÎ(ÎDƒ±A"A×h8%±Æ1Ã©èë|(TS4‡ñ |iü›FUŸG¶‹T4±}x)³—ú’¯ÅÒ‹$`h÷~=Qb,™»r|T÷aQø~˜°	4èÿô²fSg‘´ÍodmûŠKcó>­úWü7,<››Ë“%÷ñx©Fhıa–‡ı¸îäqJËCÒ0àğÁÖ‹›“ğ|ÖA¯ÛtS.‘êï)å"Ï–•Ãx—ëƒµÚQÈ#'
+óïŞH—”Âö×^uº¦WoÊq×`­ÀÂéuš¡ÚaÖ)"±u
+9œ[’î4}Ü{zë”‹®¬Çÿ^Fw‚™ƒ@§øßo;‘	·ö@ƒ ÜsGí  ¬dDá#˜âíwŒÃiAò‡0¼@õ×±K-ñ\?{X>´¨9ì«—êT Ú<÷n.¹î_%”¡'¼WP=pqà+˜»^ù‚“¯›¤Æ@~_k8h_¤¹×hú
+*}í‘èô	äŸT¡¿òDûê"A£ÒAÖ^–$ï€Îôy2$£ò–£R#DÂnÓI0*»?úÒÊ˜£ºù²§ƒ-ŸàKÒ³qIØ¥GD °ôàˆ8B4&açŞp—¾Õ‚ğh/#søûºÀ9ãŠw[A¿áş/cË¿Û“åİpÕƒ®`ˆ¹Pßµşúowé
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/21/e278497ea7faf742388e240ef12ebda0ccdf7b squashfs-tools-patched/.git/objects/21/e278497ea7faf742388e240ef12ebda0ccdf7b
--- squashfs-tools/.git/objects/21/e278497ea7faf742388e240ef12ebda0ccdf7b	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/21/e278497ea7faf742388e240ef12ebda0ccdf7b	2022-01-01 15:09:15.637172590 +0800
@@ -0,0 +1,17 @@
+xÅZksÓXİÏùw35”œ8›¼•8†q‘×ØÉP³ërl9±¥Œ,˜Àşö=İ}_’l³³µ)è>úyºoß–.'É¥ªÕwëµ¿mm©£?¦ƒƒ0^oooWV~ˆâád>
+Õj/í?n^¯úƒnµŒãQ8Vı7“Çu·÷yMÃÍëæÊa<ŠÆ>ÍÍ-ùÓJ¦Ó$Şju[ÄÂ±ÅìÑ?÷ù×a8LFaº|A;¶VfÙ ‹†j˜Ä³L]tâìq]İìFQ%ñ`Ò‹şÕNc'rÿM«½ÔÔóçª¾]Ùƒ¼“Y¸ìz¢ÀBâPá6g³pTb#4kDsáÖãÁG2åYšÜjÁjÛ{++ÃÉ`6S­î %ÓWa¦ƒ,IWîW”Ñh¿¶ç=Ô÷Vnç—“hØÀ`q[PQ÷ªGYPÙS_°à.‰Fz 3û5˜ãñn}çñîöî³=µ_Çó“z­şôénıÙmĞV|fİxr"Q”JÃlÆôL?A i=Û}¦Ö==RÛÇø©¨u~n6Um·R!»â_õ/·“¸ÖnooóÎzag]™°¤‚_œ•¢l‘¡ŠfPİWÉ~Læ!=Gq¦NæS™ùFôl„E¢-ï˜ğ©«w™²¡ˆt,¤=›Ec˜­M;Ï…µ705Ÿd /ŒÁÀQKsCÕØ$¬i6_’"¤s£4£½'ld9)¡…-ZR™Õ8°rÂÎ4"É:c¨î«Mƒ™Ğ;??D¥%
+Ó³uµaòG§P'”İ"¥Œ <XÎ’6´æãq˜RØ÷ƒOY¨ÖdŒ[œLì‚JCÉ’`Qù…"çßKV"4Gá$Õ·ï4ÙÑ—B»f–ñÒÊè!°H–}.,˜¡ïÄs~`åŞ:ZïÄÜ0Kq½Nbn)­,EìÍIIĞÁpæÕ[kØæ²ÎQrE†( ¦È˜a\Áü=Ë­WMÂ²´©U ‘wLŒhnv'ì­ J²„]ÛZÄR‹`À¾X§Y'Ö*)KlËæ9gğŸSò…È,f{D³ôãTÒ&bwtRĞ³´;?Íé ü˜›å3ªè+Xúû$qôêZˆˆ¿'¹óÒ×ê¹YÑœÄZŸ¡'å‡ëh„ÍçÄJ±˜@IMÕçÏJvÕŒyM¼Åøúú; Œ¢<p²>­ha•âŠA¼b¸X'ìSÁ§ñ¯€‚6°À*Ğ‹ÀÁÍI ”™ÀúÂD®çsÁ@†#×“·q’*“"_ÁR £zôH@bŸ3›ŠÖ×«4¼¾îË$+È.lÎô„0ÁtŠ@Éïr2Ò›NÜËÒp0mP.”"Fuzáïó0Î¢ÁÄLWİlëøÓE|'âÎô–k"©õ$²i«M™¼'IÖ®T:şµqòúäôÍI¿s|f@Å	Õ§9Íª¡8ÓhºÇr¥ˆ¬H+ÄÆÄ´JÈ*ºf ØöÎÛç?İp0ªãµËní6M†\\e8’*KRë“&gËÑş^Ò~y™†ÓAD•ÕÙ  67¤™j"õĞ
+Á½ĞC´n	Èhİ!J¶¸¬BÚWŞF%²'i]EŒ!2@Î[Y‚ gõwÔ(GGB1o,Ï:öú§¯aAĞ1%6ŸÒd»ÓyöU Úù¯"Q£Î ğzÙ9j«µşØ¯/óğ\\<äÄ¢Ò¡?FÙP-UwQšÍSI¶}»ùÆrîôş?
+ÚÂ0šdR¨ÚŞ¤QV‰Ø¿2¬ÏæñçXøqÙèğr/‡Ï²ä+ÀvùVÎ¡@‹R ‰ÑïŠ–ˆâ:¢P"Qˆã=ş"ŒoS”\ã l¬ş·»İÓ®)`U4Sãùdò[¼ªOcíşËıÎ‘qÛÒÀk¥CgŞÅ¹ßÎ%ä\.o¡…€»o‹8—Àâ]çÔlğ«æÿ”rZş× "¹/n‘-Ã@v×ŸpºÉ¦eïè.¥§İ*ÎÑÂi%ó˜JRBE®o‚ç£ıî«v¿srŞ~Õîª;{­¢Ÿçaúé,LqLñP…iğˆ×UÛZÚüy>ÒŒ”Ò,ÄğFAÒ±†“dx#54šR¼é·8M^¦áï…DÕÉğÓ÷©QCocğ­£ÓÖë^ÿ¬İí÷ÚŞœé|˜©úCW¸ÕÎ:ñ8¡©“LçÉŸÿJ°HU¿îßâ½G½L›Z[	ÕÑà ÈûôèÅîñW¡ƒD‹‘£u?„Öš':bKAèÂ7Ôî ı8ÒÇ$nÍq-b²U¯×Ï”›Õ?¾ö†O[gÉ‡‘fxS&Ô"(Ü9CQl”Ö—0±„Ö¼ÑÈÇÎ3“&K£dBì¼Ê)F7İ›Şü’îs°éSÔ|^d¢óA…}rE&1ÅüŒÌÃ:põEèŒ1TPw¡Ì\÷ê/¿J{ÏSï±FšLfnäïMÁæ€Ï_ ¥YWjÜĞ‹¸É
+ á"`)è8'ch¥1Uv.*ïÉ,fúùÓT±ùêÇŸÑ;ŒîvwXqşOádp‹†,yFŒ¢10FğBU˜OÒ±ÕSáDûÑÛKÓr¡äè^"Šñã‘DÚnún¦©Ør5ÊP··w3 µê¬: ÌmZHô‡ü&ö)â+ƒ‚Q4ä>wú‰°QU—I2ÁQ}p¾CyÁÓÕšÇšÌHıêÎ£ó2{™¤§1g.ˆ3^NJ–yI¨ÁÔüJ•¸€L&(‚ ƒ-èïîÓ
+u€ƒ:şoaÃuÙWß½ï} Í“JS{Rf€_.MÙzĞH£´Â×§
+´(©í€no]5‡êÅ¨ W%ò6ÂÃE>ªÒ¯×bêÄjQ é73ĞD@ƒúò‘ŞOÏÈW½>/µAT`è<É­€u*²BSZ‘oC¼[õäx´Dó¦9DÄøS¢+æ­u¨“ŠIXåp,J*!è;„i(o2W)ùÏKF$‡“H¢TÔ–Â /+è[[ò}Få»6cî’­SNúÀĞu>•ù?>©ãÎYoµª‚y<‹®âpD/I*ì /“é0^Ä_[ÌVÉ²µf-»‘§¾íÅ¼kÈt> FøÇxWh6Ãp<êÙ³QûqvB­¹sD(zöæübî@l›İ‘z}°5Sªl¡HÆ©ïHWP³³QtSêÌ‹©`v¤ù†ÿ/øít"²¶ó¨Ät
+§Ã·á(ÄYe6P[#¥äìóë4ùĞNÓ$¬—ê¶{Gç8ÉéÕ•)â†×ƒT­¡©IÚ7(î”´¿¡äIÒ¯ˆĞån÷÷N»çb#×Å,LÕ%š†7‹·^œŸ¾<nŸv-onb'™LpkÀMJMÃi’~JÖ”»Y	råô¥Vû@êõqJ]fôóhõà¼¾ºWÜÑ“;˜\¡òÌ¾D§³!áA‚¬ÛÉèÅ/^[ÏÏåĞñÎw±.™0·S¹÷:[q¹ÎXÌÕ
+¶ò«=«P¥Ë‹šâyì¸eO¸®#—.qªÛÈ‰»‚—ôôUÓ9ŞÏ_¢•ˆÒé™
+ Ñÿú Rj'ğ¡B‡¼çô"ˆ)~ÌQÉ€ûí2)&‹á³¥Ñ8¡–şz@­A6úÎ wá+zñµ|5E:Ñ v–¥Ï;†j‹4•¦*M¸¯cÍJÇŸ$Å.µFÉá›üõê¯ó×”Àß£Éüåmc®G¨¨mz+İOO÷+L]›şÔtO›ÊÑw÷@„i{~d£É}d™›Â§uXÖ==ëò¶Îáì-õˆ1z/&Œ	{AúÎa£qs˜t]^‚CaÑñ ^¿ŒğÁJÊĞOWú²IAys2ŸAºvÑ‰Œ©ú3:fó#o·ßIÂ„Œ¿ìw;û'ç,h˜fQ8{kIq#›¨è‰íw›wü^ÿ¼ÑÙ1Vq“óÉ/hç¾à¢ãq=pqÄç»Ñ£VsÔzçİ9Ì^Î²TJLÿC´°r™í4ìQ@X;ètãÚØ&/J–ÂG5ÎŒf»Az8Ê
+|º¨\¨üAwgñ74,%+/6š¸ã[Ï‹ÙŒ“ª *ãÌ
+57©ûïn-ù|¢Ï¡2@š†è¹åæcÒ†½œÚ|”ˆÛÃ‹D’¨J`Ü…/úUzE–K¯LGR ¡o'†Ö¸÷´‰[Ã”ã
+ÿ˜Ş Ö‰Áqv›ÿ:ääšIú¶µä?bÀ3¯r®ó—pÜÛ€ j%ö!pqp£™o°QÆfÓuTFw~]Cº€Ÿcşd›Ó·¾Ä—f%o.›uøsÔ!°ß"ñ:ö¹ÖvTî±a‘ºÕÌ³.©vô‹OE}!~ê›ß¾—2ËÈ(!½¥:wZ—½M;¼3Ê¥kC´i	Â>máæ„µù]:qËÅµ…]Rìb/Ù;s»ÔÀ_"°%Ûä'“„È9òÂ1_bÓ&…'¾ßyªnoUmóœZ.!¡¡Sìò¡±áï$'n4¥mCö×ÉéD#¨ñ•}£©_°Ò%Á”À^Æ2-W¥¼¢›Js]f¯
+ôSÅiÌ¼Éç,ó*’iY` ‚£Ê¶§îoÅ²Ë¦IT¦ø˜Rñ+!|Dú´îå"¶LlkñS b$läñ–ÿE­!ËY(øáâ¯ÒØuùÊáŞîm*ŸPâ?Jº"ç±RH9ÇÚ.«×:EwÕ6Kâœ
+¾7ÉÚ¨¾<İWEÔ&uÙyÒİ.uÉ‡¤ä<.ä˜¬ó9é‡¤aHx% 2wh’9ŒJKP3‹H•Õ™­v“><Š 1È´İI²äx¯T0æĞî@Ï(å—Sp^1$ÍRs—4Ep)ø¦åğH³Æƒµ¯süVˆ~+‰a»$„}û-	cñW1Š—Û‹bÙ×A0F¯	©•]…3úĞ‰‹ü!¹û-¬†@èáŞ£;šõ _óÊ>\˜+%õˆñ¤õ HHpù¢í/îdëœN±ˆ7²ó5±ªªñ Ÿm;×ù:‘lºË€;÷Å¾ÉÅ9•¤;§ª*Kç`³0\}‚y6K¡xÁ-VlQœHçs+Ü©ã-„˜%NBoI+Ô€R^RZZ¼Po|ÿ‰è³  Œ˜«ç
+ÎóÍè¹î{x9Ké6¡ò(x¿Á"Ne©òäDPhÿ­™«ĞÁµV¾¬ü‹ñV
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/22/03dfc143a918fb961b59874cb23584c1afe774 squashfs-tools-patched/.git/objects/22/03dfc143a918fb961b59874cb23584c1afe774
--- squashfs-tools/.git/objects/22/03dfc143a918fb961b59874cb23584c1afe774	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/22/03dfc143a918fb961b59874cb23584c1afe774	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1 @@
+x…“QkÂ0Ç÷ê}Š<ø`‘vØÁ¬Nç¨8ÜÃ|1G´P:~úİå’tBu äwÿ_ì%—­)·b0xHïŞÖ«¹‰áyªL6ÔŸı>‹\Œ`½Ä°:Šx“Y1¿c+¯RHc Vù+%‡ç±1¥JJTù÷Ş¯©“ŠøåNÛÔóO]IU[ı¢åNWV.N¼ÔúhÅR(SœaTy%ŸiU_¼÷ì`xÇ÷ºÒ) ü®Lt{ÔXàeè[#èt{Øf$âÒ›p-¦¶½È»(µÈe¡G¶ÀæmŠ{ ™H’{üqØÆ\Ö™Ã¦.À4ù‡$¢öˆ’Â[ ×‘óWBİ9İÆı)".(´cM9Ñ„9İN…"B4àÚn¶2Ú¡±VRWÌ\B;Ù­j·»„ôGìmßkã 7´åğ:éëÀC0ù—±3~sñu0õ¨]æ, Œ–§:q··^Ò[²oĞ¿)€_=ä+”
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/22/705a00378c5dfe0bfc79cc737d3637a700c615 squashfs-tools-patched/.git/objects/22/705a00378c5dfe0bfc79cc737d3637a700c615
--- squashfs-tools/.git/objects/22/705a00378c5dfe0bfc79cc737d3637a700c615	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/22/705a00378c5dfe0bfc79cc737d3637a700c615	2022-01-01 15:09:15.661172591 +0800
@@ -0,0 +1,8 @@
+xWkSÛFíWùWÜ:“`ƒ ’¶)1S‡1‰gÌcl3)g2²´²¶ÈZuW‚ºMş{Ïİ•_„LË$Œöq_gÏ}0MÕ”_¾zıÃánvéL‹ ù³LŠe*ÌÂb~@4N¤!ü(‘³$]P¨æ¹Æˆˆ ‘ÊÒëÙÂÒjVùBC¨ FØ¤£Vûˆw¯™¦2§*g‰Ğô&w¿-í(=;(ïN+-Ö\«™æìH¬… £ââ!Ğâ„ª¤0ÈàK$M¡å´D0²  ‹•fƒsÉxÁ{eÁ`‘*„R±]¼»¼¡w":Héºœ¦2¤Ef‹†rŞ4	".¬Ä9û0ª| sÅA!UvBBB½¦{¡Ötä³
+¥©ìª&•óÅ&ü[P
+àWw¾ï:¬ˆdfÍ'*G	T"¨ÀISA¥q™Z{À€>ôÇï¯nÆÔ½¼¥İá°{9¾=Áå"Q8÷Â©’ó<•`ê +À„=¾èÏŞC¤û¶?èo9‚óşø²7ÑùÕºtİûg7ƒî®o†×W£¸2*Ÿ|SŠ¡l®´ HLÍ2ğ[¼¤wiDIp/ğ¢¡÷ğ- çröÌÿ}Íl7HU6³aâ2ØRç„dL™*|zĞ)”Õµõ,¾~JŸ^½¦± <‚®Ó ´O£’e[>½U¦P™O]jµÛíıöqëgŸnFİe8œŸ9)Bh>¬ÕÉ,LËHĞSDR$§Û[©œ>ŞÓ2›mï…Å"Û[BëÌj[««cOéƒ¤«‘ˆe&h<¼éQ{µ<ïF=j­Öİß?ú—¸òÓñ//k5W†œàƒOy`¼!„	¥¬æ6â3¯M~W†÷Øm|ór€Cc35 R3ÔÊš—i!^–7à/«¯Oê,IüÿmdwÕ)Ò™+Ï\dEµ#³H†H ›”ÏÅ€L™çJc‹UÖ$î®^¡&¦]&æÈ­Ny…µ¦Y]n6kÿÔ¼óş Áè¤æ9 êÓ. Æo‹D‡.oœ;‹Æ'#ÿÔ¡ÖI­æÅ¾b¤lÖX[¯ëz“â;M‚5¯7^õ3› ,*rõ¹AºÜ£*Ùç Iı¹™Ô‘öa€¼Çé$«ûö\<k;(‰–Ë’&Ûô´(J‘¥ Ö_áãj°h´E¡
+TÃ*‚íc%PäØ<Àİİ£ÆŠD{U§§Òó* ğiªÂ/+˜ö:$­“V³ªĞakwÑ»øì r×Ø{ÏCtòLÆª¦='hEløäS9)xmE6UOáÛ
+ÑA°ÃÇ–>']Ü¡M¬LgmïÅKÔîò>µ?ÑÚ™d;KHwíxªĞ
+ôL0i9ÆŠ`ämMKàÓÙ¦‰,ØäƒïÔp‹CG¬/ïp†ÂR„óc	O…ùL!«cTeÁt÷,7<Å ßÈÈ¡˜+TfÂ¶P™ª9j+ÒZü…l¨Áı5ŒËÓJ°j\ÌKš.ÅÜ³¶‰¨én[ğBŒè("[6Qd|Üßwïı	Ï¶3iíXç=V°¿ÿT }îıPe…ÌJÛ¿¹)dôG9Ï‰»d¡*÷ÑEBŒ<V }îR ïƒp}
+ˆ!”ıw-&"¼³Í®>Aª6¦Axg€‹#–ß<DkÌ%ê4G*Û‚JİÚ<CŠ¡ë^ªÒ9ñ-P@¥E_¾<Í¹ÉY@O;tTYçáá<ßb8ÚÜ‘2ŒŸz“+SUïVé/‘b2â­ŠÚá¯'â£¼²Í9W„~L~zô³bü°¢÷6­+B®½]õSz™3‰ß™ruÏóşƒŞİ‚zWç>¨¡ç(S<Ä®ĞBí èf+ùîl
+Y±~i“‹P¢n†ŠòAû–	š(úš}š¥È&é,˜x	²DŸ‹$z\bÌˆ˜Î"ãD—Éá°·ïc#~âylfØ{›ia&JÏèC¸B+ĞÑP%rulB?o Õ!£X&(c»Øl Å´·‡ºóP‡À×xBÏÔapÂ0i'K9W-nŸAˆx¸C²yÄkM6¬•éÆÙk	Wå¥Ø0°9 T¾ö„4ş\AëşÎaÙ‚»ö¬ãš¡µ»ÍF+Se5ËğŸ6axQuR­à¦«›¿şªõ~­ı€îú2
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/23/b3caea307b7ea8cd7424bc1d490fdb650b39ef squashfs-tools-patched/.git/objects/23/b3caea307b7ea8cd7424bc1d490fdb650b39ef
--- squashfs-tools/.git/objects/23/b3caea307b7ea8cd7424bc1d490fdb650b39ef	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/23/b3caea307b7ea8cd7424bc1d490fdb650b39ef	2022-01-01 15:09:15.629172589 +0800
@@ -0,0 +1 @@
+xUA‚0Å;ïS½+¬SÇ¥‹„¦’Öõa:q B¿Ój¶ã~¼ßû¿=Æçƒ²Ã~Ç´l&„„º7ê)PòšgÚ§6êp^36äRe©Ë8BWD6S;œ´¿–¶Ss.EUòDxº£4ÿî>¿Õ®B÷Mò"`8fuµÌ7í8wŠV†À²Ñf¿€Wù™f?êW*Óé7YÌ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/27/2a0eb18d89d061f621a09e4c9abab3eb00ef9e squashfs-tools-patched/.git/objects/27/2a0eb18d89d061f621a09e4c9abab3eb00ef9e
--- squashfs-tools/.git/objects/27/2a0eb18d89d061f621a09e4c9abab3eb00ef9e	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/27/2a0eb18d89d061f621a09e4c9abab3eb00ef9e	2022-01-01 15:09:15.637172590 +0800
@@ -0,0 +1,13 @@
+xuVmsÚ8¾ÏüŠ½é‡B4m“63˜Sš0¼Ì\Ûé0Æ ‹-û,9éô¿ß³’1/áøb¤]íË³Ïj5ã9]4®¿ŸQ‰hğycãÑ~ˆúŠ÷¾}i“[§$•éÂó•­=‰TËXUJ[Íq÷3]Ö[MêÄÉ&•Ë•¡²_¡æû÷ïk­Fãõ—qJCï)ŒŸ¨Ì;µÆU­ñ®+c’ëóóõz][{–I=N—ç–¥¦PúBiP¦‘’YÇÛ-}Í
+İİOi ´†ôN(‘z!³9ÎÑÀ¥²U¹Øk«‚X£(V/´:N¡o(ÒdV¡Mœ‘ï)Ò"¾¡X	Š	-‚!OŒé"ÃxMi
+í4a$O¢ÎÉ‡½N¿= Ş_ŞpÒ¸ç4öPª’Ç®y™Y;ë@p…ª$şMRän(i$¶š˜]k”Rú^!ÎåEù2”ê‘Sk…ÊÏ%âoJ¢B0À.a¤(y=</d(h-MfHgó¿„TKgM£:İĞ&Ê®Ğ¶uj«Eq Ï€NĞLÉéˆÂÆ“»®Ò*^0È¤bÀÖÙ eåãìÄz­—Î@¢Wr¾,h6cB'íI¯Ûë<t{³?K¯ ¨ã)Y	QÈùèl8zøtÑ"…Ü`2Hå§Ât"<¸¤ãHĞE«6—¡Lu•±¤9 ‹D§Ê´·dÃæ‚‚ÅI©Ë|6Æq¿p?ş:ô¾ÌÆıo½Ù$bÊ7Úˆèµ&-ŸÅÌÔékNÔB…òà„®.mT¬í,Iâ”ËÇŞ
+˜¦}e.Z¼´ ÙÄ§ıûÉEkÖÏ¦ƒ‡û»6§‹~Ôr©C«eé•µø_
+
+ß~
+Ïc„59t|2DÊ3°ëƒ6¢«¯n?öpÀQN´Íë…ï]š®¾…ÉÎ0Å%YœÛÏÊ‰Š¼5º³H«8o¡õÆÓÁdöğ™'İö¤=ëF#j¢9íÑOíqÏV›šï.¯eƒşÄ‰Ş^½;:†,†½Ñ¤ß;7¥’Ù$‚ÓÔ&ÍpsÍ:|İ#;\F
+]úéºBÿfû/ÙşKæü/¯tW¢ßcå¥õ¦ôëÈÒM©„ÛiâÇÎIùH•Î Gâ£ñÍFşÊKsq×3^•o"[Ú
+ì!…;aî³ˆË¤Ëa’®Pù¾?ò´¨¼w vú¥	ì$•
+fÛÖÛ##ÖWŸ²ÅB¤œ;z	]bõWÁÊShj‰îCÇEÒAo‡^ºäI!=Ä?™LEp`Å^PyÑ­{Ü"}%M? r­…NÖ.ŸÊvÛêƒ»Ã«çèzfâuA\‡ô®ªÀ÷XêRşş€[‚ì0±§s¦Œ=æt0ö–;—ÃXïíßá]â…‡{]‰q¦|1˜r{º#‘èï—E3[F"ò¤uc‹Tk]S`_6)) ¬YI¤
+	°¥Êg;püÄ¯Ö¼æŞ^DkŒdŒ©W"p7û	ıÆ5Å'MİdßÊëT±3Øà^†ƒÈ3ş
+ä×øQ=a´9®ÓDDÉUÆÅf.CšSÖ+¡h§e‰ü‘<L~‘åĞ>³º-1;ËOh³ŸÄŸÚm5}¤#ßä*;@§qC¿ìxãrFóêğSb‘ÆŠ’ğÃA¤ğÜØmÔ‘{‘WÁçs¿Ãp•Ÿ.<G^üBP1^ø:d1b÷ÃŒ· °9¶¾ã·vš?êv^fî
+ÛGˆÎ´«ÏÉ+lk¸JlwÂğ­âåg—gn¶ôùÑ8KGÍ‰Ô]t[#¼a­äFòõ‘Üñt‹½<İôûs Ô±
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/27/a3d385aa1d5a591562d21474d1609b8a3e7c92 squashfs-tools-patched/.git/objects/27/a3d385aa1d5a591562d21474d1609b8a3e7c92
--- squashfs-tools/.git/objects/27/a3d385aa1d5a591562d21474d1609b8a3e7c92	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/27/a3d385aa1d5a591562d21474d1609b8a3e7c92	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1,10 @@
+xYmoÛ6ŞgÿŠk8r^œ&À6 M^7H‚¢NÛYP(2S3‘%O¤—vY÷Ûw/$EÊÎË`›EïŞ=w<rWe}?ş°ÿÓw{{0ªçó¼šèJ½Í£ša±Xôzßëª(—S;}}ıe8ÛˆWWÑ|•Ï•Yä…‚³¸ïõş¬õ&‹RÛh:+êÊXx?±®>Cß4ÅNû5UÆîw¾½û OßÌök6xåâ«º.áemÕi[9†ë¼4ŠDueAÓëºLãÔËW áĞúğDUŸíu‚ŞŞ Y¸+fyóÉBÒ(v¡/Iêº†Çádó÷M’§¿Øì‹ğ!+¢ˆ—Á&ôûĞJ‰±Šú··eÀU£ò[ùøÆvX“³Èş€íc(H‚æiä@ĞOõ4Óè¦oÏCpúUXôR‘7Öˆë}°Ì¹š/È Yäáy£ç–J•72p7Ó¥‚Ì6KÕz5¨Â(›ÙÛ
+EX5Î³Ç ¹kö#s2rŒPh^ ÔØ8šøè¶×Óifö>’5«¢²Ë¦`a¿ô9³glnuÂbÏ‘ÛÉ¶ÅlüË>zgswóUà>*IÚÜCÉG5êji¼Îµ
+·n'¶^ˆ}ÊhJ*äæÆîîF«›3clÆVäFÈìÌc/0Æ€ñ”;nGÚÛúûoJ‚cƒ°µ‡éBş‘MÕº¥Zµœ‹!e‡¨úS4E¿…]Ÿ;OÑ>+u#YûN™ei/âµ˜±É¼M_ Je\\…-ıL†+µÇ¸RäìıZ7sØ,ôÛìW’jåS£"êÔˆu·oWéÜî(•Nô_JÒƒcbBìP4”+©RT³pÔU*t[ª»S® XVWL'¬µëSä¬®Äïú³Å%ÕtıqŞvÇ;¯
+kC˜BT $Ÿ "E¢êE]ùĞêxç%æ"3r¨ /l®+ã´©
+®—Uau]Ár1Í-²MLÑše9¯%m½´‡XD6;±AãµG+'ÚcÍCÄj	S".,§í„N&ó8†~@©øA\[Ôâ—äXZñ¢“İæ.]j‡õ\™3ÒphŠü|Ï†HÓcŠ€ÌúóIGXnÏj<DÎî¾šç9VD5R«©úÂx©ÿ6ÁÇ¼©°V‰Yÿ":D™èÁDà‚"¡Š”ÄGI}yåÆÂrûİ¡§Ğ,[§_…íø•É8gşE¤şr8şE„\.ˆ¿[-GÇ¸UÆu’|º™ø™ı+Q¤H3±¤c>ğÆ!t>Ö¬¸uÈîÜ(ı9rmH„Éx‹Ã"oÔY=ÊzÆf(…_úãìÉ>!í+]ÌO/ß“·£Éù»Ì±Ï\‚–¨bÑŞ×"ò´ß4I:./û9iƒäßDV/‰‡sĞoÈÎšú6ºÓx$’ä„~IÎ‹d†åš@á~œà}ÁJüAí‡yX	m û>ıhİğ<= æ01<<Ÿ©F±#ğÈ
+Ùœ,„ùÛé+tò—ÊípízÄÕÖbfª§®¸…²ëfIgÊ–˜Ò»-Ï&ôüëB¾yƒçXülvH³¢LĞe$"¸ïúù	‰²Û·µ±ÜéP³ ^š¾ÈO-®ˆ¶"šîõ£¶3ß5…‚'‚ã§-OéÉ¤šF=[9(ë…QÑ,>r:ßWQFËï¨ë§?õ€ß¨—{†ÛğªñLW”§ÁÙd&%|UmñÌ,KÇ(’iË•Q6<… L”•ø‹|tFpKN"òrI´ñ‡…Hş§ {kşD¸M•Ç’£rb¼vGniø+~¸`¯	®HµeSw*Û°A·BÉ.Â§”3¦x¿„i…^-‹hÚ3Š~?Ÿl'z®­šÒîä<<ôÇÚf¾¯O·È­ó1%fr4ŞYÂ#˜ÿo³".]ÇB´vœ%÷IÆ¤u§õ‹‘Ö™¯à‰A‡I®k+1…!
+û$=å|à±Ø'á:Í«Thò£7¾ãİ/BPôn Œ'®]»E×7Ë¯$îÅs‰–rÏÈ·aÚÃ.
+wLÂÄilN*{§ß,’¶Ÿ<Ó¡(a£‚§Û®¡	ú‹éıDŒ"5I”:&½Æ5DŸèù¢TmNàÒ:ú'	9Ş`“îAî¹}W‹z¡šŸ`..3ƒ'1>Aq’äVÁoaNaÛ¨°„\÷ú£k»J¶Œüb°hêBMùÔ#öñ­Ì	ù+½û$&âEÍí!„­BîÅN‚“EÄ<MûNB
+HxrÂÇ¦PUär3qåÌú½şâ»c¸y³4^~C/¤"ã%‰·= 
+­ï]Îëk/.àå¬ĞÓ‡ºİvG-·’ßæ¦áÒ1ÏÅUû,âÉ¿£ƒ,Â.*©3A(ª‡Ì+Öñ;©¤É:[YétfÃrñ•kúòŠpã‚î‰áâ2bâd±!€-§{Oé¼¨@—£qeı3’Zø„Ä”wñ#ÛĞ÷FM:šïÃh¡¥¯'Œr-kFn?1ä¾t8¼}9AƒÅ²iTeÇ®kğMa¡†ù’;%öÍÅØ#»a¨pãkéM÷¢šN¯äâÆİ>ä"‹oeE’VÂÌ"ĞŠØdÚç–'L¨xc±ÑÅ‘¥ÓP¯ğĞ™Ş¡w<Á¶ûx¶go|@ä¶o“ƒ²3Æù°»Ï¯ìÔÖqwøº,ë;’duGaôğ+cGF™A/˜çB¡qÙ]ÿï\†¥ş[ï_»QO
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/27/a77b104bb180762cfb5d04a45bbf20a969a081 squashfs-tools-patched/.git/objects/27/a77b104bb180762cfb5d04a45bbf20a969a081
--- squashfs-tools/.git/objects/27/a77b104bb180762cfb5d04a45bbf20a969a081	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/27/a77b104bb180762cfb5d04a45bbf20a969a081	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1 @@
+xKÊÉOR046aĞ×W.IqL«ĞËàâRÎLËKIMSˆqqt‹ˆ÷àRò3óR‘…€Êò’sJSR”ôôôÈ9?77?Oß·2<3/%¿¼X/C	—¿ÔrÄ¼”œÔ"".åÔ¼”Ì4. öú+
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/29/d4c4145e0ad9fbac1d6bbd4b730778ef998adb squashfs-tools-patched/.git/objects/29/d4c4145e0ad9fbac1d6bbd4b730778ef998adb
--- squashfs-tools/.git/objects/29/d4c4145e0ad9fbac1d6bbd4b730778ef998adb	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/29/d4c4145e0ad9fbac1d6bbd4b730778ef998adb	2022-01-01 15:09:15.665172591 +0800
@@ -0,0 +1,11 @@
+xİ[ysÛÆï¿Ğ§ØN¦Ò‘m‘ÔåÊ“¢H™• lÉi‘ ‰ŠX ´¥¸égïïísIIîd&®f‚»ûŞ¾sß±ğí"¸eµÆ›FıßySâN™õ·+Óz×¶ì¶µó<ßÍ½~±Ã^0ë_k'šO#ü¦×f°z½Ù<f•q•Õ÷öê»ôlğç>ğç!ñç1¾¡gm?ë»„¯°¶Oo—so±ğV¬¬gs7doWbà¯‘$áUÎ^­ï~”¤Œæ^ÄVa0%ÃÏièº,
+¦ñg'tOØC°fcÇg¡;ñ¢8ôn×±Ë¼˜9şäuÒ†Ë`âMhl„,»,vÃeÄ‚)9ï_±s×wCgÁ.×·oÌºŞØõ#—ÀìNƒÑÜ°ÛÑ&,Ik@ìÄ^àŸ0×ú}rÃïL YÅ‰‰Ô+ZX}lá€µöÕ~S¶&Ìóùöó`æ@	¦>CœìÖeëÈ®\àûĞ½\˜Ù¿aÌáĞìnN°8˜u?¹•·\-<0a†?@&Ät¯5l¾ˆyÚévF7´;£~Ë²X{0d&»4‡£NóªkÙåÕğr`µ^1fA*`Ÿl–)›Ù2]6qcÇ[DŠñh2u‹	›;Ÿ\htìzŸ@›ÃÆ0Ç'jkø3Î&(Iç„ySæñ.ûz08à‚Ìé‘ÈNU¹ËŞ°‘ñ¸ìráŒ]ö’Yk‚m4`Ü§Aş.ë™l¯^«Õ^Ö{ğ‚+ËTì(s¶§Ñ«9p¿Ş)»_Ól¾kÙí¡yŞkõG–ÑôÛs;õY9có•¶ÕùØ2ÊhzæOƒ¡aûš©NŸOíi¦ÌóNP{÷G£ÚQãğxÃÛú`^ÒºÃc±²¼ÎÁ×ÎÎë,ò~qI]K(á°Šç—|’M<è5Â‡*»]ã»ˆ$S:—z­‘yfLÁ±q\{Sß²¨;87ŒZƒïÎY/â„¾ÿ–ÚnKîRkÔöê5ñ5=óZ­ÛÛ?>8:,”¬ãÕ…0zÎ=ó×Ë[x:D²ö&—ÃŒ~èXïœYäáÁAã3Dğ×ŸÅs‚Ÿzøí,]V5³úÁAU‹¤oöZv·Õ7ŒúĞ”äÛé¿7»3Ã¨T¸ÃĞ£Êöî§™¿êF0n°»ö#oæÃE=?Î‚o½6G#ØêWÁv/
+¿¬i¶º²àSšµõ*h"Œ¢Ø]²éÂ™éµĞt¸9—$×@jF­,xräCíÚ˜h”aú)Jçšİæ¢6N Ã8(Ã]]v;MsÔ‚±”g[×—î‘Gå¹şàäh¼äHõ¼)C5½K{p	/¯Á°Kr9íŒ*$Î]vëÅUR½±äïì{M•¡®ú„vˆ¸•á¨:kY.ªÉ¨0G»ìï; ÉÔô(Z:G‰ôìQ¤É‘ıLÌmfi<(|)Ûùç¢Cš±ŸâDvÛğf€u¸ÛK´õ4r8Ra²æi·õ<8ÆœuqËNè}’à(:´ÊMdOc^éP*çz&J¦CÙ»hwÍsqÂÛEê3¡Ç”÷ô°§!ùª³øì<Dò…¼k²F>8F^jçîøÎó±È½_aìÜ.\yïÄq¸‹œl¹²‘ÍV)yìßÜ9ñsÂŞ¾…³c /SziÈ¾ìÓ íVÉìOˆf +Ó@s‡	PJIì÷ôr,_lN$¼IÀÁ4ZÛ«BfHUòÑ9~X¹"<SœeâU¤Ï:C{ts‰³W	x f5ÁÀºéu;ı	®	
+ˆ\g­÷r^šï†é¼&0´;í„ÖkĞ¼hä¼&8tSÖ4¢;lKXMˆèæyCœ(…‰n»šFzİ5»‘õ•÷Èñˆª“}MV»E£üx°‘: 9ÑĞ-¦GÃ+kÔB ¡[¬°ZÍ«!*&m – óºjÙƒA—çf%êÅ"ÄÄvçÚî™ÖïéTd.Q?Ï]^bòœ–
+b²ëĞ"¤a¨¬Ö~úÎc1-‰\”ŠS‘pã*ì:m
+™	ÌˆğÕwœİY“YK%Jå´Šø'Âş’“6³«ì/âØºŠıU¥j`hÒ‰t‘`Tş(‰Ø„â^@&òH8Œâ¾¾ÿq/@„8s8é6IA¬})'ã{„‰èDS§Ã«.U|¬"”è|ˆl™{SEAÕub@Â¨¢ê5Ç/Y ¦dQÔLà	4"8 ¯rKÍÓ:vQqH'…¢¡‚QÊk‡t"o ´ÛVkDğZğïeå¢ÅĞ»àTLí|ÿ¤0çEi†Za³*3M
+<?0ˆ_FŒ&¤E=¦F2[ö¾m¡ú¡êVÊyK¦0æ§t‘¤wa…È}+<VÇ#ÉHD·T\©Ür¹Õ‰ºš¤m„ND]%4„âÏ.z<D`¢öN¨â#ZjK5aK)WnOè»9³¥ëóÎZúÂÓtr¨­¨¯¤T¦lŸŞŒİ›ÄŸ‰ªU1BÍ‚`ZAïn=FÙ.›€<W ílü‡fÎ6ÌşYëšcN=™S»²×jÃdM®Éğø¶´Bâ ÁQŞçOjŸ4+|æFJJ[6IÌ Y“Û½*d`ÿ;ÇJx:†¹Ğ9©ì…ôCê2m)Óş±‚»õŠ=n1İÁàâê²d/ÊP”…÷ÕéM! £›Ì"C¾š’¶˜ÊèÚR8}Æ(¶ìò56‘İEºM¢l5§¸ø­ÌAíÃ9ÕCvhL,aƒ! ûÅl4q
+G†D›k;é€@5ÊÏ`ü*Å+´z¥g±Âö¢²³x+E«½3OŒMÍ=EÁ¢ìz–Eº›(Zåì…¨ÀñÛŞD$*âó›¤ºOxÌ:‹ÊàÎh?…ıÕE( ÿ­Œ Ëc¢‹$ŞGM¡”Ç)Üò<.%8;6'8~uàÙ$õŞØA×tı@ÙnŒÛ-\¢B¢Ò^öu)¼“A¾Š>ü±&%¥‹€äÖÀ¦Vÿ!JÌÇ¹eAÙF;/¥dĞLœƒ Äãu­¥÷ÌáEkÈ•îedyH×-H8'î½à^[Ö‘¥#ÛDÂÔ²2+ç pıI[f’°áæjØ¶†¦*æÛõ¯z§¨«5ı«;À­.®vdşG<ˆ”}Ù1’D)(ÒæUÆÉ‘ †ÁY.Ïá.1ŒC+Y 9±r&';¿ä·âÃÖÅ-CÛ"ÃÏ¢Â½Ç–(uõÜ( ÷î¼•f˜.Ä\P•î¥Õ(ÉÈHÅõsî¤Q:ù‡àPÖƒ<M÷èşYx‚À·Fó€á®Íwâ’ú^X‹P»TzF’—Kl[Â3ÈUYËÇnçÔV¥ygĞÏtOº{fn*m÷t?r3™û“ëù™´IÖı¸ŸŸ:Øyıš5z÷gfN&8$M‚g2áÒÀ½ÿÄUUpF	åœ¼ÃQ'“io¯Âuåå¨ó¾UXšvØÄª®™„L6£OğB´^áÎPTä‰¦èšÂ1g/q…ÛTti™ëO<5ˆ÷üñb’ïmO` ¯æ?&¥FÒéÛï[Cê`:·Å§¦÷•o&6 )´9…Âñà­$—5ökÔmÔqöÒ™yã“ü(·øƒZzŒ•t/ÜğçúŒUMÔ%ayh0ú+³mjêñO>l›U*+‡Ü§ZM}:!9Ojê_ÜbãŠ\œ0pscy7ìØÃå+âÿ¿¼•Ñdºü+œ»YæÀ\6ª¥)UXëÎ	e”ômIùTHÁL3Ç¯65ãhıãæY3ABàÒN… +{)$\2†Alóß@˜9-nb7²ÉTóãŞÄæåŸpÆù9•Úm^Á7Ú<|Y°y‰õæ¢:ÉÏgbDbOØŒS¨ı’ÑW5oùÂ9.)a³ÏĞ0èšÿgr
+İş·Nä
+ÉÛs×¡Ïš²tHÅIá4Ï’#'©¤F‰¦‰aédûÙEf†³1RG´·ÿ®i.¨Ì_xş^üø€í[d¥À w9=ƒ÷Ó7¨ª!¸àì¥¶ø?b°ÀuªÕ2ÛÑÃ’ŒúÛW­bDFTqbrtã©º³o‰õm1C…²Â9¬«Fø©MU¯>ÿY®ƒ6Êmñ»\˜97¨W(ÁHÂm&5ÉÊ!3­œ0*5Ä`
+ö\ÙK,`y‚ÜE–Aaõ÷äå…ÏJ’”iHV	„œ+—îÜ”¡*º’y§.ÑX|c‚+	ç—İ&è¼tR©œĞãsuÊ½Ÿ(me¼²ù8Z’‹şKrv¬}úğ=Y&²ÂÔ|‹hJ‰¬A# ¯¸°°ÜKËJİ >A²ª ¢Y^<h–•NJƒF4‹j`@³¬dÉ`G»°˜Ğá+­£TvC’D4òëW]q‘8§4¬Bş_2/ê ¢ÕåøÖš‡ÈI)AÄ}¥dÔ|t›Ÿ<^®¨c>•A6`äLm™¿öE=¬;¯¸¥Û$Ø¤h·Šn3¾Oèk}ÉHœ‹ä“ n3.o ”áT 	UÛÎ+ÙÍÈÅå¯¾âN­„ï%ÄSh[ğ™¬PUm€|zè%M³ˆU"üÓ”uäÌÜª*¿,;kmü#tÛâ‡/¼äôÑ”h=Ñd¹†ù‚3y.%œ¥,˜ê£P/‹ãQíĞúÍÙB6ÌY…Öñã¸V·OY5ñĞ>|'|Éáãˆ•ã“–¿£¶ãtç¿KQóz
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/2a/408050fe15aa96685315750bbd19c8e93af26e squashfs-tools-patched/.git/objects/2a/408050fe15aa96685315750bbd19c8e93af26e
--- squashfs-tools/.git/objects/2a/408050fe15aa96685315750bbd19c8e93af26e	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/2a/408050fe15aa96685315750bbd19c8e93af26e	2022-01-01 15:09:15.617172589 +0800
@@ -0,0 +1,3 @@
+xµVQkÛ0Şs~…è Än’®lŒ,4%›_º²Ğ§±Ç–©XbYéÖŒı÷İé$Y–{ªsw:İwß§»n¶Õ†]~xwñê<fï‰â»IÆâóÁàµ(³í>çìÄ˜ïOZ¶Åv[e0+‘³õaYå\&eQ%¥PÃ¥ûÉâ=Ñà÷€AØÕ“âWû¢ÀXˆ;ÕÎñüVV\*Áëh:øÓMº’œw“˜¾|à^íË,jCüuïÓ)º÷˜;<ÕºÊuT¼_ÓªÚj¤ˆ’¾Y\hİIßãùÍ~§SÕlÆŞ`jëè·Bø•(óÛTÈÎ‰£8t›f?ÖJòt×9öŒë®ÔNqàSäZ~]^óB”<ËwşĞÅ˜´~9™Ô,b’¾mã^äñ.)ÕÛK&¨’…¾œ	öÑµÕõ{ÊÄÙYG½96‰ş6ßÄ÷€~«…a;D	ü‘9Ÿ£¥ßíµ¿?À#A¬Ô-<* ìĞ@ßú?q`¿ì•á½_‡æäõ~«,WÿÚH“ålæÚM*†NZµ`£$W{YÂ¼Y¥.İ
+Tn;·ª`ŠÄˆÙZM@Ræü=1ë1r8¢{Ií	B¬K‚HJŸÍfL´/D9LÂÃ7¾ĞØÏ€sEWYÿ/<(Äá¯|	àr%¶|£ÂQl´BŠˆ »‚¯t‘å¾£\§r8 ÔÀ–ôvŠÌèÄ7?“lã”Á
+Ãc6} ­¦ûtÍˆ‰†Éï8%çxŞ@ªAH4,Eu/«ŸìbŠKÑ€šàUÇšz¼´yê)Ó'İjh‰eUY+½	‹JR@3Èš$õÛ=Œœp¤ç†òÕ4­+SÜéfS#´¤õì|˜Ãhƒ/³ÂÌ¯ñ<©1¦g¸ˆÏiM€Àƒ€1é\I}-$ÏT%Ÿìüñ‹RÑoºIwœ¢½Í)ÍŞ0É›Š_ÜÍØv…ávâ¢ÿ±•ÑÄ5­ZÈì^<òëT¥›´6]Œ,Î7Ô¶|£·¾G”…mö®5Bwë`×ú.?ŒZ¢nkcd	Y;¬14­ÀP—#"<ÚfóŸV0’[kl*w¢ÆõL¥ë[O=( ğp1Wí­os"¦vF°xùĞß“Í®rLãˆÑ’pr±.ã]!¥Ç%ióú4ZÔ„ãå/W±§
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/2a/d071679e8d807bf1ed10894e096bbd38583e0f squashfs-tools-patched/.git/objects/2a/d071679e8d807bf1ed10894e096bbd38583e0f
--- squashfs-tools/.git/objects/2a/d071679e8d807bf1ed10894e096bbd38583e0f	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/2a/d071679e8d807bf1ed10894e096bbd38583e0f	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1 @@
+xR]KÃ0õ9¿â2AZ™A&n"hñ£`-ø%Knm0KJ“)uÔßn²Ù®¢ˆOÍ='÷ÜsO:“zGãã­Ñ"=Ÿk5Š²K!1N÷B¶E®8æeQš$émæÈøæ"N³k²í¡ğWÎ5*&áÄX.ô~qÚ‡j3²u‰ÆÃ|ğ°Æ=(©Ÿ„âúÍ]¢èMIÂmË~é-GâÔÕ„IjD>§É’”•¶È,ò	ÊBVPÅ%N]9ÓZBZ¢:ŠVuÀ´2XA+Øõ³‡«†\ÒgNI¹˜IÁ¼L§„“V/Ø;aÙxÙKˆ¤6„ShÚ‘-ÒÖWhoP=Û"xŒ•Â\•!¬yMç™…{Ä—`}äÂXª>èD¿~9»S‚¶Ğ¼ët†ÚPbåc™ÀzÍ>¤nµ.’a¸ ŒïèŒÜ!åÁ«v9µt_¸ÿ¸‹½©éÂşwlT!µøcğpıNlÅÉ7Zû×ØxyªD×õ·¥¦iÜÿ‡Š‹œ|K$ık
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/2b/1670d9925b5292a29f7a7bd29542faa2967d7e squashfs-tools-patched/.git/objects/2b/1670d9925b5292a29f7a7bd29542faa2967d7e
--- squashfs-tools/.git/objects/2b/1670d9925b5292a29f7a7bd29542faa2967d7e	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/2b/1670d9925b5292a29f7a7bd29542faa2967d7e	2022-01-01 15:09:15.649172590 +0800
@@ -0,0 +1,9 @@
+xÍWYoÛFî3ÅÄFRf¢Ã=ÒÊ6`É´#D‡!«(
+W (i­E‘	¹ríîoïìÅ]J–›	Z¿h¹;;ûÍ7§'q:ïê?ığÍ>'32‡0ìvFÁğ´ÛœÃğ­³»4!ÛÎ>M¦ñzF`ï4£-ÊÚéŒd¯{ÖÁ°}Fæ9ßsªÕÖ°İƒU:£s:MÈY”1Ÿ‹—ß®Fáh0èZ
+r6£iYç*ŠãtŠ{àì“µ9…†öyZ—c:	éıMØ\hVJI÷Îƒw½ÓnwĞvï|¨yóŒqz>\l½¾†ı Zbš¬ïªK’%$~½81 ÔIG±¯@HX âw‰¤iú:Xêµq~©50õ¡p[¬·Œ¸UÖh#ò’Ëİ¦,ûëU/½%èé¾wvÿp¿å,[Ot);#SçÁh£œÚ€U¨VùõáøºGGğfÜtíKMÇq:ın§ÀmJgöQ'¡ÌµôC%.t7<|‹¿€êÃMS|ÍÓ\
+ÇPk…#8ÄŸƒ.ÍÿÄéÖ›pƒ§®åá—06/­w_XVÑñõÍØã?V´~¶’‚~š¡WÜÎù¸&	£QÜI®XF¢Th"™¸ôí{%k}h£ä=ÑÌV"ûÓpñK§?:l@tu¿š¤±°SX®÷Å-Ü.]ç&‰É –åyı”(ßoJ:„öY*~¤; †íğ"µ:#×v±X_+Àc_C—{zÿXĞ˜€«:‚Ú]½V´ÃK
+ÜÒ¤-sµmÂñHFØ:KôóŸâÒ_)[ô"6]´îùJõA„ST¼ó?sµLÉ4€Ş’)CW¸?œœÀ¼Ä´£Û°>ğÄTûE5>1Œêp •QöDHù2XeäFˆ‘Õ0àäª®KxQäæ
+
+èÃ`GPçFòK&/“‚¯&X4–š/¹ı_gÌîö ºC©š¯B~YÎ-PQ³
+±Û\fä9ßŞOó­íË4ïE9’`7ŞSªU°ª©ëıŒİH>çÖ<xx<.6Î8çÍ»–ójeG_2æ¢]§EvÊ0Üé"Ê âYµW[	T	3uÑ:ãyyt*Õ¢µl4È6º+ÏÓP|MiÄ•Ì•÷Ë²¢pºlÂ„‘˜BªsU^1|[¸6Œ3ïñ*l¾d ÜXå>^#D'¶Ä=x¥‹Aù×¨°ë¬€Á‚R Ãc¡Õjõ¬Ôó.°¸m Õ\9ı“¤s×Š¯xP±_Vz«U9Ù¹{ò.+Ö-éÀãog¿'{ş?+U:y*3¢ÂécF*5J"È½ Ëp&Ó3ßÉ{X‘Ušİ‹Y¨[TEz¼@022ÍL³xƒÙVˆ"¨b…J·oENá›²)¶sv–bbsÖ3/}ÆÈÆæ8gîšnr
+²¹}A˜ˆz+*lÓMvaTëÆ-"ç«2¨IÃu#”ÃNX&@e„Ç‡åò‰E‡­¯óˆFİ¼§ºo0]vËcIÅD—´òúÙÃiÙìçFÓÏ$Åİ(ÍÍÖˆlã–÷ÌÅÂK†lòÂ%c4Kô³üüÛIïÑ¤c©”¬`PádPÌ•Am‘OO“©şOÿ±İ·
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/2b/290f0a8000230bf6df090d652dd1df81126416 squashfs-tools-patched/.git/objects/2b/290f0a8000230bf6df090d652dd1df81126416
--- squashfs-tools/.git/objects/2b/290f0a8000230bf6df090d652dd1df81126416	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/2b/290f0a8000230bf6df090d652dd1df81126416	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1,4 @@
+xµ’ÁJÄ0†=ç)zÙ-e‹xXP\¥®Ré}/¡M&:˜MJ“"íÓ›6uíi23ş/Ã¤Ñ¶ıÍõUBÊHTÀyyzäåë9gI¨‘Á¿e–º—÷£¦f÷ùÀXÃÓÛñ
+ÛÁo-L=öÜÖÒä‡pQÍ˜¯
+–ô3s:-œª [h$©àšF×gl;T{”;FÆƒÏu°ç½™ :U±Ù¦H%:ŸA_Zó±d%š,¼Å8‹ÆÙ¾¸¨ fAµİŞ] ûq]MæËnHš³Ë ß_ò»
+×¢øB³¿XbcÛÄ(Ix²¦îîh›œÄV)‡~Z"KâúsWúZ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/2c/6f69a53d4844e4553912cd60c7b1659986a1b6 squashfs-tools-patched/.git/objects/2c/6f69a53d4844e4553912cd60c7b1659986a1b6
--- squashfs-tools/.git/objects/2c/6f69a53d4844e4553912cd60c7b1659986a1b6	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/2c/6f69a53d4844e4553912cd60c7b1659986a1b6	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,5 @@
+xVÛNÛ@í³¿b 	Ù¹”Ø¹àŠ©TEâªTª„RÇ›²ÂØ•í@*B¿½3;»k›¸¨È±bïœ3gÎÌnˆ’,‚ 'ï:p–/Òåİ÷pò~	#Ç9é2YÇö«•»}Ç9ê8E¹(ådZâ'‘©€kQ”áäòêìw)\ºAä9Ï@.Êu‚ÁlØn¿mÎÏ½çÅÁL±XípD¸.ŞÊ|'œã,³´ Ü%Ü_.Šûëìc’dO"¾Baëâ&œÃığ5P_ğN×Ë‰F+•~&Ë/ë‡HäÊˆ xí…Pªş1“1lÂÉí§,}yy{‘ÊÒıv‘–Ã :¿rñHšzPó5+Ø»
+'hzËø¬9<·?6Ş8š¤–ííDëÕJä6‹Hc$±iö¤14„´Jë)+EºÌb™şd¡:1§a}J¯~ŸÈY¢ r.g‡)Œ=•Qw]t+‚~Uğ©‰®Y`£Æä^*z£3ôA-<İÉD¸•¶éŒ);M Ï 9èÆÆÎ‰Øz’­V…À:èÁöeó9„ÃCœT~øÀE11hF´¤Ûe  Îc)ÓµàçEÇÔÔV]T·BÖlÀNSòš-ñ:ˆjZk†R_1—r@$…P´F³îš4‚WY®T Ø7íÈn—‹5>Zm*Á!™s|lXê¹§Øß,°|Çı¾ÓèÂH7‚jjœ¸éÑûÖ}íV»çô|$9sŠWÕìDL1Â4¨Í(ò%JÓ@„Úí‡
+¦SFlÛVÕÆ«
+kÎÂŸü7"`DØ ¼Udöçºõj3P3´ø\ã6ï·q¦ëi,6&ØlX³×‰“ÿˆi?2öğ†U4vÆh2µÿO
+Mm¯ºI§¼‘OtQ.÷µ`* ¥íœÖÍƒ(E@…Ğà¹ª,\vƒ*“Šª¡geGö^árxpïŸ¦ÅÅ³¿ÁO¾MÁ;ÁÙÑo•–úÇu­\¿Cšqâ±D-#2¬˜Zq{-ˆ ¾ğ+ ehRÓoCwÆç2Y_õÄG\¾˜g½«ì™\¤x[;NZÎˆª=mv–G9é£Šl.ú§ã/´aÛ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/2c/7e462d592750b35a63683d636da957cecde4c1 squashfs-tools-patched/.git/objects/2c/7e462d592750b35a63683d636da957cecde4c1
--- squashfs-tools/.git/objects/2c/7e462d592750b35a63683d636da957cecde4c1	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/2c/7e462d592750b35a63683d636da957cecde4c1	2022-01-01 15:09:15.601172588 +0800
@@ -0,0 +1,2 @@
+x}VmoÛ6ŞgÿŠCóÅQâ6NŠ"Xº¶Ò,¬ÂˆİÈ04uªˆH¤!R^ìaÿ}GR’å—0`óx¼{øÜ=G/sµ„ë›O·¿|`º}2‰Ìû(ªÜ“•ÈL b†gÒ>–ª¦ÏÀòŸª$—B÷®¯®nÃ«ÁÕGø&d†[çjM«YµÌ‡DLH>ôzg"¥0)Äñôùaòõ>ZÄ½3²‰ûFr•<¯„w‡D¿ÏŞuŒ±µµç_"óÈt6Î™‹-BŸ?ÃğæüĞåkU8/]»üGÄôôëĞ»sïe›£¼÷òÍî´öé­ı6g÷ŒÏh6+´jSVÜ@Ff¾‘¼÷O`¬T3Rá&wI"&sÃJÓZğUìÚ¨Õ*¦?ïzt&ô|ƒo {&UF=¡FóeÒ g²w¸GùİÏrW­è.î¶ÊT‰–ˆíêpOä9İ ñmoÁõ¦'’³œÊ½»°Ûø"–uĞ^³|Ü%käÛDš›kU1+G­1ñ]q×ûjb‰‘†òÚ=€~¥q$^c§Ôçıµ	«Ë&da%	9Sºµ‰Ğ†IÊsNAIsÔS!ãN©÷ï«¢Øî´%Âï¿¦Å*ÃÙ·˜[¯8·!5j9>>¼¾İ¡uÒ?Ğ<’’	&W’Œ7†-«4Å²E·"¤;J‚ŒtÔîÙ…mÉÖd6^»$]‚Kğ	¢xÉíUşv-kÙ±óËÈ¸ÎµèÙ^êãJ	[Ä…
+«’¨ìÔ,Xšq•vn½ïÓ˜¦¢ğİ^ãÊ·‡~$ÌÑš‰Üf¥,<t²¤â;cìxéØ3*­*7õˆs¿i€¨îŸ‡JrŒ>ˆ/<uÂÒ©Ü:9f–Æ5ÌŸG=ğ—ËDQš M-l÷«-û\ìŒ‡¬Ù†'—$œnŸhZÉ¾óÙë»VÛ!€ç·UŞÊ×ÔÛ7d'ßpz=4õé>ÊîãÜò&L«ŸN9à†Êš	^™ï,¯¨zn"ê,¸}Âíuí`µx,V3Öö&ïş¸÷Ş…£š7òƒæGSîĞ•ßë ‚ÎÂŸ®H¬ÓsÇ)2qhålŸ~7Tdh‘îN¸Ç·ü/a2ßrz9!`ö‹ÌiâûÇ¿Ñjì_–ãtí(è0ßÚ^W£$ñ…#ıƒ@;jÚ.è´Ìé3£”†À)„'®è~_°e§pN:B°v~§ÉzÂ™Æ¹¡×´8e'ÛÊD¤½ÿ ärşh
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/2c/954f81eae9a2ff3fc30a29cf0524a08626366d squashfs-tools-patched/.git/objects/2c/954f81eae9a2ff3fc30a29cf0524a08626366d
--- squashfs-tools/.git/objects/2c/954f81eae9a2ff3fc30a29cf0524a08626366d	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/2c/954f81eae9a2ff3fc30a29cf0524a08626366d	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1,2 @@
+x½RMOã0åì_1m%”@EIÊ²•BNM@‘–Ø"±bQ”§µ”ÚUâØ¨ÿ}ÇnÒ¦|9Œì™y~y3q.b°Î'öÑhS±Z	>º}½©XêÑìlIÈ€e<¥ÜÜ^èù×ÁÌ÷È #ŒÓÃ By’W)…şüuMË³eŸ‰7õ¼”E•H¨	À}ÀåØ/’‘å4¾u©}û?V~ÅK¶à4…dvñ8yrÈFïèÕa˜¬óªT¶+ğÎ¿V…C"x)5É€æ%ı
+r‚²©›F‘gúë75„İDĞ	+¹ŞÖÂx®´Š…ÈA¬iIQ¸®Ñ–¶°†-+,l“Ô€=g¢ ƒq	\8wğ¸Ò¾Y²TdÆÂ21xzj"€e`Æ¡N'æ1‚Ùô\Ì¾OÚ*¹}PPY²•Qš7>İù¨…Ş§-@İ¾ïa¡àºª/6{Uß‹ĞJ}û'ôæşİ,œ}‘ËêOûÍĞ¾‚íéõğ ú`iw‹²İâP%É ÒÛ}jg¿­2˜sİÿİA<ZÑ!äCxÆ9>ÛCˆñŒÕ9F»@ûv‰ömbÂ_=²n—åTl8ñºKXï(5§&Õ¬šVó"1l´Àj³¿«ĞVğÿõË9N
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/2d/2f10fa9d08185d6749f0debaa48ea529e57869 squashfs-tools-patched/.git/objects/2d/2f10fa9d08185d6749f0debaa48ea529e57869
--- squashfs-tools/.git/objects/2d/2f10fa9d08185d6749f0debaa48ea529e57869	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/2d/2f10fa9d08185d6749f0debaa48ea529e57869	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1 @@
+x+)JMU047e01 Ç¢äŒÌ²T†ÂèMiY^ß÷;g¦.4Ÿõf•`D…s~nn~CÔËcÆéOşóQ8Çñí¯[ÁG¸‚‚¢Ôâb†=®SW¬Ş»1\wæé¥¯fm²;lch``fb¢àéœŸ’Z¤—ÁĞšÇA*{‡îÙ†eVZe–åØÂÔ—¥&æí^$ea}İwß‰Ü{Û>X^İeA -xHÊ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/2e/ea57178f2e17dc9544adef065f0765793d5a4e squashfs-tools-patched/.git/objects/2e/ea57178f2e17dc9544adef065f0765793d5a4e
--- squashfs-tools/.git/objects/2e/ea57178f2e17dc9544adef065f0765793d5a4e	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/2e/ea57178f2e17dc9544adef065f0765793d5a4e	2022-01-01 15:09:15.617172589 +0800
@@ -0,0 +1,29 @@
+xÕ]yo[G’ß¿õ):@ hIc+™Œ75ul„ø‚eÏ`ÇJ|ŠhË¤@R>“ï¾õ«£»º_?’r2³»‚ñ½êêêº«/^NNÃ7;wîüçü¹şúéx¼}ú^[ûz4>»¼6áOüğâOÙ“ıéÙvñè 9›<]ûzØœÆMxvüøÉ£Ş‡ğ9ŒÎ{øåşıp{#L›ùõtNşyøêÉ‹çO>zòì¿ï…ßÖÖŞMFÃpòiozpzøáx<š÷ö÷¦g£wÍÁ`>8ÌšÃ¡?<İXû¼0{É-Ö‡§[»¾qàğàhr9l¦'óÁtştpöæd>moÇÃæC ¢*½ÈÉl4MÆ3ã0.›øğùD@âÑàJ”£<š6MÇ(7ó£×?'˜£ëñÙFô7düö¸·x€Ìƒ¶k˜mÈÚ`+PÆ‡rÈ
+yfbâ!gbÚF_l5€¤}o¸öçşÚ>x{2úÔ„ÿjæBš
+=ïÆópÎ¢f®o<˜%ao„3ç<°ş¨"2
+j<{éF›ğ2¢—éÏá–Gù3S—“FdV!É¤ıs÷­¤ªóòÜPoÌ)ôAavEÏaAG¸/ƒ	ëx>AÌ›Y6`œò–U?’’Â‚#)è1˜5G]_^Æ±[ßdf,Øß¨‰rlî·5¸šµ“¾zvxòâáóğèã	¹ ½ËËÉ™jzÿj3ÌH6¯HŠôŸZD?ôú@‰Q8 µ0OÅã0}µ¿šËYC„Yü8ââFLiP÷Õ¿*	'rŸüÄ2O„›Ë"®].6æ¥¤¿8Ï¿Ù!ƒ§šDÏ“ôËŞœğøÄwi£D©¿;Ö›÷2(x½ã±ÛŞÁYÿÔó0	l°¥:Õ(Lc“ı«9ÜíÇ×ovú,³ÉyO:ŞØ‘ÑÌÕóÉ´7b
+Â(üĞ…ç^İº•Ô{±³{9ú™DµíS¸u?ïC	¥6 ;k†värD	±%µ9QIÀh3%A:ÆD©–¼¡®—0Çá«0(½ÍéÊÙÊYÄJU²‰‘èŒZ¯Ì§0Ñ—´¹²²ª,ÕOseªôI Nuå„…ê	<ïY ÇóæmèÃO’*úldœ˜Qø`C%ŸKÁ©y{5ÿ(éA…V[»?fòH¤wæáÖ×©ifÄ Ì«iÎC¸8z•<-0³Üº#½pä˜Æ×ªpÖ–uF¡ !¼ûfûÎ7DÛÙd:mÎæ—ÃûÉôM3ïGóª†ç™µøvûö_¿'“+h|˜½]]Æ¿T)\H?ï/hh½;Ò «‘1@òNÖ]Fº÷lÿÇã¿¾:|öìÉ3ãK+…Œ]DG,BhYßæmÎS~Â~çÅ8Yë,|E	$!œR¢ú&âßºeERò/»ÇÅ‚w8C¡_ÆJ•œ:dJ`}£eö¹ÈÍG-=~Vé:ú¬ØJ¦ğ÷à¥åo¡g—,JtŠXÅÖÎH-.!O$õYF†¤áÚ5F­‰îñø|²ˆ˜9_²{  “Ä3ÙK_g­’«ùÏ”2-†%fõ²j³’<ÈuôW­ÒéôB×,+í‹Œ[şQÒSâ”ÓiG*ÍÁiÖ‘öÀyxo-¶v‹Àn¹DàÜ¤•¤PW•˜ÍÁO¥28	D]âÁgÍ`ø|ô¶éI¡±ÿäô5yÂ¿ÓßÉô‡ı“O>Î›×ççÍt7¬IGäÕ&«FÍn†‚	A".ÌD>ß}æ¯ÌşƒÉäRP„Óø+X&ä$ãÙ'{”s¤”8C<b'ä®Ï.´È‘	ãŒ«)yº}ÒÌ{ó‹QæÆ‚äqCÎex¾÷ÎÈÉc%Í``M9ˆ4µ­#bøË¯ñ(#7Ic2ñ0¤¶i`ûc™æîFuûrò~3\Œ~¹„ÆÀ“O`¡ÀôF2Wt)ÎŞ£yÀ @áöğıÃÉ{òBøı@h¬ó#5v@‰qì3JODş?óÀ)jÓ´HxCó4Ã}Š˜¯@§ßë[’‘±}<ó/„0?ùÍÈÑ°åÙ„®‰G¡J T¬]³ù?¦#‹°ìíR–á¸)i{ggÍlVeğ¦×¿ƒ¸„du]µ²s4ƒóŠy0B¢Õ;Fá,Æú#ım3ÀÙĞ|y™¬Œ×ñõèœ¤^=üç£½WÇ_í? •áÌJ‹ç]?« ¨Fcñ]¢/p‚T™_M'``3„[‘7bFÈÖ.H¥DA(Ü©¶4„B¹‘™Ùl7{Á…}øõ×¼ï°Ë^İò—˜¾:Ú;~˜h[÷ó†òj8a›ù¬–Ã|»u‹äE•a[:"©¼ÚÚÊIãõµÎ6t±j	£’èê¬i3†zG_Âƒ
+¾nÆÃÑ9QßYÆÔ¥\ürËr¡“\;“àe<w(@PyİÕ¡:ÛVwİ7¸¼Ö ˆ:ŠK*yHãİ2%ø¶9¬Ò§"{uæİ<ğDûú©©£vóëıĞ³"ê4üğCèİ¥9‘@Aø+³cúîÛ.&ËÛğ#¾û¿>bˆæy3›ŸŒ~hŞ¿Ùş‘4=ñ(sz‰ßf¢@j',ÍR~ã"v5)™ƒDL(oÉ<8=*¼kˆ
+ˆ
+`RGDV8DJp®Ïæá%k”œÏ¬bÈ“B_”J&bí7”^£9m`Ò×¡?šGÖP=ní›ªŒjsøªUøÖèèŸÂ;áï[Wì:Eµí©"©Ôâ„¶*¼+tÌ§E<~¨1ï±šmø”+£ó_jû‘9$ò¶‹¬½wºqS{gìTŒœ6Óœ÷ëfe;MÅ2 h~òv0{ßöá.+oôzUS­í…ç‹]ã"G-¥ºA±…õ :t1HK‰¨‰ëSš½&R}«“¿àüÑŠ´—]8j°^lSxQ€å
+'~ëÃîÛwßn´œtà±„]š´àI°eN›…kÍE§q3­ìàA~÷-í)VU`USBP½ˆvÃáÈ¹‘GQ§cßìä$V,çéƒ:(=¼ğDÚ(?­”ãñ“çÇrŞU4’°I¡9<6$^x¡•ñ5jB±ô.ùŒªM3=8|å0G½¶H|^´¹DåµFZZ%ÄŒqÜq—=w´q/©Ì§“7MsÜVe9F)á# ¼?e®ZƒíŒHcc@	³XÀV¥Ü´w6êV¤ÚsDˆtT/Òb·uT°ºÎ@eöÇœÕúşétrÕLç£&QBˆ›öıÌ*¡”!rƒ²ÜÂH¸l]\1«Ó¿ñÑ–KæÃ±ÎdÅ+E~"áà¶K]Ã?£ùŞ|>^SrÓ
+[¤V{û¯CF$µiãÉ¢Á›ÈhSFKß[3®([*.(M8å|}ãë·X"¡I#kış»U×u9À,(²ò“P=:JZZ]Ğ¤îŒ„´F	då*\kÎš)+Á9NŞ‹~&Î¡ FEn¡(un½ş»ä±dáLY¯×;¡—+Ìğ·p'|O%ºh>÷³@–ÄT‹?FN´Ø»7mtÎ¤.™<K|ÉšH8o³Ç•D™ıGóØDEªå×ÿ}ªh“‚É“‹hb]‰9­ú]Œ~¡‚hÖco–9~RJ†‚¡ßJSeø¦,6ÀCÒv‚øVË>¢eÛ(´7gO*°8Ñ¼Sğº¤¡Xğ—¨j”Ú²fš2†›§x¼^Á˜•ÄØšJ_<ªØp#U.‹Mn&ƒuËXêcÌìdrîÉùù¬™Ë€	Œô—#x¶}¦Ë˜ü>AºĞïóúıª¯TğtÿÙşÌ”€õÃPr¼l«é€6né È`6¡´“ˆÁ¶“\ÊEˆó˜¨3è<zœÃ3zÉ «º“xó¡~Ş[òó‘õ¥>1¼bÁÑ…÷£8
+§o”Ã³Gfô’\œÖPˆÔ™UY³Ågu-^)ñGòÒ
+ó$òn…÷Nl·„²üf(U+>ğîé0†RßK`,«¥b¬QEU£³–	‚Nğšß5¤	WsâvÒÉ¦„]ì¦T2pfE-Kuµ(•œfœcÈß g]š·²şÊÚ’‹7’¢²Wi>Ì›éxp	%5	æéŒAˆĞ8×³§"CJWÈK>ùé{Şø[ä˜EIKõ©õ‘l” T1O#‹EäU“Gõdäöi«ò”7y¥gh-ıé€f90Ìôø)9TZØ/ì^±?L`Çº´÷ë¥WO®çÚÜòVÏÄÇ<#¤r=Ò&œtkØB2aˆ Î}VuU7~níJÓ¤²CRÖ}†AÄ*–˜QNÃÆöÑ!b+vÄÀ›°r%3¶&œ­Ò·q‰¡³â½Ğºå6`;- ÇBÿ$f´»XAÒ¥®†W˜ÜŒok÷Q3¿˜ëİ>>à(“okAøíG44j£Ÿqœk#Ûìè  ŸM%„Œ—{¹C;å9Ï×¾lHy¯3õÑéaÔÇÔÅj“¶¦–p!øÑ¥,üš¨©ôI‚‰[Ê"o‰¨„ÛCö6v:Y ë¢ĞIën:W âŠ±6XÖ]›4H‰?_ù¼ÜİôÖuˆif"ÙR-&Ê4p+fşù‰‡á>Ó£Ôí¶VÍ¢óÎÓP„£ò¯®Qæºu7c¬É²¤BøeJ™Ğ\Œâ)û1`µ“Ô¦-Ünı6×iVV“et˜©‹ÁşÏ¨[7W‘+9Îhã<×'\Û¨˜£ğ‘8ûÃœ{«Ez&œ´R«%ø$ LÒĞœ0Yx?’ï'@ñâ`›$Ëhˆ{Ê÷rµˆeĞ­»ö‚ÖÒ4pqÅ^Ê]a¤É)™ÖsLÁÖîñø;óL9WiB|µ6H¡ûYş!HrßŠBô<Ò@‹óNåö7AáÄ Vi“‰&C–2
+U®Ì#2ağDmŞŒfcy3ïg"&f_¯…ßê®dpFòšsû^xM_d
+=‘ÓÀ„ÎN>qyDâ5yM¦Ö@Òl†×´!^ĞR(Áo¦Ş/¯èDææ”D€e[Ÿàdğ7FÌ"ç/à2)ë¸Sg*ôÜx~B¶/š¡P®£
+öÅ)f&M@4‰èè $çzp‚,Y6Á Ó´Ícgy‚éyNİÓ²M]q¦mÜè˜&ÅÜ´eŸi((œöà²©‘â à±šFd€ÅcÇ¬dZ¬T¼TµTf;…@r-O9³¦Ó€²IVæØ¦VÄTªV»Ìâ	€¬ƒÂ€ÁQnâ±®C(û\eéîö4S˜‚cZ´ª*¨6V}d|9'î±¸´‰ÚÅ©û‘ƒ±¥Æ/µ‰hq€Jã!Õ7Éçı¥eóuÒÏX¢Ùy±Rj\¯Ûä›èÂÖ®£ŠœÁk<QTÿÚ•³˜ßòÌ6t7[gkÍA¥)Ó)¢aáé6‡şÙôÌ&0ÙÇëKsIxíŸS{ú(3Óål–Ó.ÚÒáë'Uo8Ú½7”f°0ÆMÈ1s!shyhÈÎ¯¹Î¢*ƒ¾Im|M‘¥].^âaœn,4¡mD³V#â 30h~ìvŞÂ>‹±Î­½TJ"Œ8âW|’‘ÌeÄÚA-)&XÏ¯O5çX!V%ÿn³åªÔaÊSÓ"‚V£éša¿–s9djù{±ÆáıNZfá§C›Nıš&+]#HRŸÅ”GÍ²È#­´ğ¦‰Nuü$sÌFMx8‡‡ê–/®êüµÉ‚Ziººè<Ÿ“®QËùUFé­,ñËÍÜ‰Â{ª‰ —¾ÓxÚÜ'Z,f^j“,°=ª¶Ú€fy53©¹OìvÎ\*ÊnóI.ûlµ­oq0>Ô,‘ô
+XÚáèígúKû·œ…˜ÓÓÜ>Ú/ì	ŸÅÎñ¥ıO¡¿á\»é…Ş6‘•ğ«>	c~Ôódë‹6Íº;õ‹úÅ©v™ó¤è•¢ÅøTÔ½Ş%÷ÅÕär#±êiÎ›å|''9ß7áì¢9{æ»‹!ŒfrSÔFªƒ¸f×oM'¢ïË‹?XÏõéL<5Á.0J±C¨oÑ(nÍ(×¦Z“‹XzÈÑîÄB3ÑQÉÑÜ˜È8Í%˜©e™Ûúæ«š€%§ü/gZ`ÈĞ€MäIÒ#ñ -­h ”W;¡Ò|—§3°ÉP;urá3Í¡íìkúÕ2Ì‘c\^·L‚âSRƒøÖ¯hQ7DÌªzì‚ÀïÔš‡¿÷û•Ó;ajJÉÌ“ÖYŒV·;V¯az'…öVfŞD+uÆÆ_q(<c”˜f	tîmvÀÖe•+æñä%‹˜
+ÍxÇ¢œ:’è¢«ôd§–Zk?âÒÌº\':’²7j"E"ù½]"ª¼0?æÛÏBÍà935™´ìgMAzË±Ü	t"_ú²R¬­À šo¸¢G˜±	¸Å€F0¸˜H«'?6è–S’,ÑÀ§8!%¯rz”-nRPÑ¦É¶ÂÒö~ÎJYÓä[­7šbĞ…"½t(³êX[ÑÆ;[•|IÅp&.Ùoö¿K=¸4*(.¼n'ˆM%’t ‘´½¯KÚÚÕu”¢ÉÏ¼s;™³D=Yçâ«uze…Ò+<>-ç72í·>áŞ®ßS‚aš1²Ø¦y8V]ªR4%Y6×g¾püSÃü;'/[nßx·§…Ø&O.ƒ“
+Eøß¢MÔìˆ£ìæˆòB+Ë%K‡q#¦8‡CyR<YŒÉo”àoŠgsf2ûbP¼r˜ö…!(ĞómDÁSì”¦ğqr½%©M)@áiej¸\)dÊïG"}ùXœ¬ƒê4
+))ñ+&n£rQ/%wK‰"‡êŒm1“sXaµp7R“.e &¹¸P†f¡m3\»Yõã‰ßêên2¨as>¸¾œÛ²Åït
+®ğ›óó»GoGóÙË¿ Â}¦mû·7éßCş÷Hş½‹'Gûá7šõN¹Šè¦ZŞæÇâ…4n ;Øc¥zŒAËÌ½½$QICÑCÌOÄDÔç\6ã”¦é³«t»f©q"QØRæ"mèHLøê€ì¼ˆ$rCìŞp'Uµ;>®Bxmİ—4G¾$¤?‡_iŠ½òo¨»;?ó!»I¡™Œûaç*/åH‘´3Ws6€hÑ™C+‹3)L®¹ûp@ÇnÉ#4>¤ãGÖÜØëÈ³HcÓ~jÇ=`õ @´I <°ƒ÷«à8CÆmŒş=2¡”‚H€+4:Ô,ô‘ùæ¹´¥QaTš[Ê}Vlß •!ìü¬4e°¼‰GÕE3•Ğöá‡ğ—øÁç‹^)’6ê1kÜ!üÎN…1Ûs§c“Ú+™W¨­:VxÈà(J‘I;@ç“Î.ÓêJNfİb¨°‰Şî0Ğ¶iº£K˜ÇàøRPÏaovÉnàv„/Ùªá{<rÖ²·&›Q†Ş6hÓDË—vÕVgÖUc¾\a­_ã†ôòÿÍ ºeØó¡Ö,ŠöñàNSåînè}GJ¯oÉÎLæz?†/cHN£‹ütCG]=ñ¶±oR¦*bSF/î%ÑuïêÆ.™_ôèœÓ’(“†ié¢™îtÓ(J¹|Ø—hË¦Õ"®ò“y²AbõÊåf¥KZ«"we ^2µúˆ¬ß`ëET±¦hY¼É7r¸ÒGó’f–Š’¡ñzOzbâJo‘ Åç	ü0İ¤X¾±º,ª)‘?ÊXZ'R‘eˆ§ô¨Z`äsM…=\mÚ”²óZÏàª+êı: xyMÅ‚[JêœöMt,Î*ŸR©çjìDÏ¤“šø‚!ö™Ï‰$à¼€À°t™½RR jYH6‚z	”]Ÿ·wN'Ä¦Åg-c÷qæ%÷N?¨çÃI¬Ÿà°dŸ¾’?RG–ÇåÂ#£¥ÁM"|›®ZI„¡œ*wç1TÖØ™µKyL4%Kfœ\@›avxJÀØe¥oY"`9
+ÀôÇ Ë'F`Ñä.Ò:‡ç\Ûˆœ`êöhD œÅ…˜àZ2ë" 	´D€tó ÂâŒŞâ¶tni¨ÕĞÖaê’W’d–'ùïÇ±IEŒm]¦tÕ:¢ö—I ,K¦Pœ£]LbûH.«Ò¦¿ôÖ¢M¶'¦<káúŒÎ¤êü´»cĞqSÑö[A15@Âà»K•íjœÁoÊßŸ²hVaNUXÅ,L[ƒ+­MœAy¹rk™… ¯X~Ò×ĞşâÍr‡aFß/P>‡ºRÖH1\„´Åz¶G·ÓZÒ€7ˆßmñÆ„¾q¼_™ÚÇÕ–h£€”N<œÃowÁK”·é4~ºÜ†¾ò¢ÀÑ£°‘È%~“éG?£¥	=o-ó*“İâˆ ;"öĞô(7Ñğ‹…£.ğã™6ĞÉs´ãq‘E_Ô‘DÄÉJ,iwü4éz!¡[ÑïBD6ğã™çKSkK†CçÂJ]m¼Ì•÷g:–˜ËĞ#D]Ï2½3ºT qs’=¯p2ÂOÄœÒ,‘~Ñ	õuIWEW\rõ¢IpnZ³°ñ):¼ÿ²äİU5.ó3E•J#Ïşìº[m±ÇÒ„™,¬)»ÔCl,‰ÍÚ¦ú-[ Ö*alT?±îèMëÒªÍé%«ë-’&ê‚zbEÍÁJ¸ãÇ«ø‰¾q_ìâH¨¾Ï9·¤ú®Er7Tb&Ãh²Jl$íÊxo<”¯ôÁjK< «•2©‘Ÿğ·2sÜbá,=€ÈåÍĞŸ\ÏåW}ºØ¢Pèú¡Hp_‹K†Ó¢ÓÉ¬ÒfD¿LëLÜüÊ4Ò^
+	t*Ö)/Bµ½ñîOnôúÌ
+c²z—zÒ~(x‘İí®n"kdVÁÀÍ;ğ¨N]Bq…s9"|ù#c¼ï35IJ‰àÁéÒ’e•—@…§™¥¹’C[ŠÒS.¶°
+ü´ëÈ°âŠ“"pµ‡íÙ­º‘à<Q#&MÂH œyO²à\­~w@wÍF-eŸù4×Å5`Lü£w‹öY±¥QÉÊ­¤§û›æ»×Ó¯õW]ê<£îR]/›êV•t%fT­šŠ¤+ûÀ#UÕÒî»MU¤asüw‰zÄÖyñk2£X˜J©”TO	V;‡›<GD‘$Q£‹p¥X[|Û½£?EÄÕ±šD6Q¡Ä;b<¶êÉx°x
+yf÷ÿÊ'Ú›XËäTô*ò •İ9_•eå¼²C°îÌ×±‚P´ÛN¨˜ë`a
+¶•0·æ3lá­…+]ûœXxûÓ³¿7ÓÑùÇŞÔn²	w#a`Á õŞ¿L†FI4Ü®©İz “¬éß¿:âyù2°OáV’ƒöAÍRŸ/È´êND™ú&
+Ç©œ‚\û–=Í#PKT¨³|Çy:dhQòôõeÈ§] ”t%E¤iŠb‡az vY$Ea+nÇÂhó6&$J2ÇàÅ³?:Á«¦ìÔ†ÆEÉe)]Ñ©Ÿ\5ãUR¸BàºìÁî¦PêU*V¸™İÿüÒ_ËŒlƒX†yG—²Ğ·À4ƒ¢SHGÓÉ[¥Ç^Ğäà˜®‡‘:HRÆê+Ëe,‹m¨<¶tÀ”:Á§d~XW·T-K^Où{;XoOñ©°z¢ópÙuâŞŒ|ÍUv©µ& ìGŸ×/Î¼l_ŒZÜ«C”ğnşáéöşe3˜öXcè“r”—,oá«#hà¯S|ãæƒæhOõ{01V>Û[Dè†¸®Ò”èáè½šûÑàõdJQoÅ›bu~.è°C¢È\Á”÷¾ÄÇÑ[fXm¸ÀEW¶‹È/•:)#'d/®(Ãk´!ÒllÔE½:¬½i7ĞïÕ:aÈE]ĞÕ‘¥Tz èr ä2AŒF/Ä5CD¾Ú©ynñ†”Ğ€^úÕ!&Ò9Í&Ğ5ßCÿ;ï°L‰Uâ<¨rSOyFÅalieíéxÒ†n
+J¨U¨ªOlËŞ‘ØÅ2âOR’€6—ÇÅT›ÈÊÒ!ÿºX·Ñ„¶ËïH‡å=2y·¬ñ ™q¹³¯Ÿ¹sYnÊïR
+ëì&c/bu	ˆµQÄ%8ã×T¾ÑMÌ†7½B!äg6äEMÒßWö^¤kï÷TmŒæˆ¥şº!z©É:o­M0ÆJ’ÉÅ§À "›v-ÍEóe”€ÿ‰Râ«"u6ûÏæ øY$@‚Ÿ¢c›mu$Øúä!}ß°®@IıÖß%ıùå“<1ÅK¬Ì]Ï½bqD<Y²Võ$­†1•ÊxºHĞ~˜È†v°†K¦èˆŒÈ]Â(LÄ¿…àlE ÚxE³Tzí'cˆ¤ˆíyî+¤ÙAl¼)U>m}3WKGW(ÈşØl4ËÕˆ1ÿ—äØÜ½Ì$³@kó¼u….|oµÉ'ôñŒu.çËÿ ÙtìR
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/32/d450b3b9955cdf00651a4f411dea672428a774 squashfs-tools-patched/.git/objects/32/d450b3b9955cdf00651a4f411dea672428a774
--- squashfs-tools/.git/objects/32/d450b3b9955cdf00651a4f411dea672428a774	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/32/d450b3b9955cdf00651a4f411dea672428a774	2022-01-01 15:09:15.601172588 +0800
@@ -0,0 +1,4 @@
+xm’[OÂ@…}Ş_q/(”bQ1Ñxy€ O¾4…ÎÊšÚÅí.^~½³ÔQŸÚ9{Îô›Ù.s½Ä ?<è61^=Æ5ÂçºØ’±d µÁëp€•ÎñùMˆ8Š†a/
+£Cáú³t›ë-W3·ÌÕ
+™~JUfWˆº’EFIâÃÉ•¨s¥
+úØR¬rÇık‹·•uMˆnS0D¦¬ÒEy$ íìz'œŒpéò|êì¦RÚ|ø²&C¿t¨’(}LKß#(­¡ôÉ<WCªœíq-±t2‚æÑótSúÀØÉ6ì®{Ê_°/†2”ñJöùz»øéè30Xü¥¶v¾OÑúÅ0Âœ¬3Õ¼w÷Éô–;ğób>ŸÎ“ÉÙâ!&©MAÆh#üzUaw÷–LÈ_Qƒğd%Ëo–ĞôLmøÕ-*¿¯?–Ş¾¥÷¯%Ş·ÄÿZúû–~e©(¾VYqpå_‚cş=ˆ—(ÅÄÇÇŒ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/33/5c984a2323e15aa06e4fa007a94aa11c157999 squashfs-tools-patched/.git/objects/33/5c984a2323e15aa06e4fa007a94aa11c157999
--- squashfs-tools/.git/objects/33/5c984a2323e15aa06e4fa007a94aa11c157999	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/33/5c984a2323e15aa06e4fa007a94aa11c157999	2022-01-01 15:09:15.653172590 +0800
@@ -0,0 +1,2 @@
+xU=N1…©÷ï ìˆvKú½@ş†x•‰ÛY”Ûã!Rš8yŸ¿G¼¼½>]+)üX-ğõŒ=Xª%CyH*HœVèçZW=sÓïöˆQOmdÿNİ>²³’±Ì#•9­tFÜzFÈuRİö!(
+îm.¸ô‰8>ü*?&ŠÎ†LR’µéüÌ÷ÊgZ)xÅ\6ÎãEÃÃØ»ür´òhÑ‹º¤ü¡üï†]øæÛ–Óéêl7
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/34/e1a5a923b8815ca5c37ec4134356f9808bbb67 squashfs-tools-patched/.git/objects/34/e1a5a923b8815ca5c37ec4134356f9808bbb67
--- squashfs-tools/.git/objects/34/e1a5a923b8815ca5c37ec4134356f9808bbb67	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/34/e1a5a923b8815ca5c37ec4134356f9808bbb67	2022-01-01 15:09:15.649172590 +0800
@@ -0,0 +1,5 @@
+x}UMoÚ@íyÅA-Èv€ÀÑPRAÚC.ÑÚ^ğ¦Æ¦¶I Uÿ{gÆ^c()Ä¼·3o?N}°GƒÑ'/İî2•ç:M`«Š(á~’C«×unÛ¢ó¿SDü›A'pû‘ÌaŸè_{¾Ndv„W£ÑºŸ´»â1R«dSD®±&`,T:™ùºÈ(Äß dIZ€:J…`÷Kß®:/(C¨Ö:Á#d¶ şË‚xéî(,-U®²W
+Ëa|»Mrµn`õ&wUT6Úî±İc×LT\Hhå{ÿE)‘L6ª-&ê`3Ø‘
+><Íİ*ø¡2ê=BìBŞãL&AÔt:•YR#'ïë	²ÇPB† ßf±ğN.VŸ=|Ck¬70MB-“¶)D¥İxÉF1{ÏMØê!vïøîeSù"èÖ@¹œ»œ_ÉUƒÖ 3ÍÃ†OEÁHŞÉå£ıÖo¢ËyóÄ¢ûjá.¯4¢„)ßh±˜Oª|gs|:×yÀ®¤Z3K…Ÿ´J­.h‘Z÷¹
+Û]ø+ømYPây¡dØ¬³Š2ü4uä~»‹ÓPˆ®0QëX54:AõlÒï™8WJ÷ a9gX"`
+Õ	`Ù.eféšhÚ}7e ’#'‘¸Ù‹9¤p4¡eq¾ÜÔ’£$—ïˆ†ÿÄÑÔ†‡w~MÜtÖifõÅ“¾À'Fî^vÜá»ãpÿà²Ó•aq@Ü®:¶c4×«¡‘y:C9ı¨"”qêIy½±Õ®áÍêSêÄ74™B“>3<5÷a—%'§w®h-•ŒkëMãVÆ-ˆë4ÒÉd¼Iq±àfÄã<×9îZ\<xŒŸyd.qÙâè!(»F)MÏÑ]V&EĞõf=hÓKø­mêµÆõ»ºs;v]n_.?bSñ¡`s1Œœ¹Í<å;¼àÕ%Jg3õÊÍÌ¸ ÑcÉšŒd“É¾ôEvßv.O•Ï;úq7N×_È<K³(œ&sÖ…Ë&4[Hs«˜Âe®L_¨lü÷¸¥ùï-ö[•â/Ç’Ãh
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/34/f4f09ea5828be17e5810ba86e21f9188717472 squashfs-tools-patched/.git/objects/34/f4f09ea5828be17e5810ba86e21f9188717472
--- squashfs-tools/.git/objects/34/f4f09ea5828be17e5810ba86e21f9188717472	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/34/f4f09ea5828be17e5810ba86e21f9188717472	2022-01-01 15:09:15.601172588 +0800
@@ -0,0 +1,20 @@
+xí\{SG¿¿ù“¤Ê‘„‰K9á‘
+Øò9Uæ|ªEZ™5ÒJ'­ğƒ8Ÿı~İ=Ïİ;ñå.v•4ÓÓÓï×.¾/ÔÚwëßµÿö°¦ß$iÿ›j4ÔI”õ.Õ ßã©Œ§êø¹Š†/ÇÓ$»ÍVZÍæ£ÆZ³Ñ\Wß«#,«Óèz8¾Æ·ÓùÅ0é©şx%©ª=\Yù*I{Ãy?V›³lš¤/¿¹Üö¿Ô×^~é ±vÍ.¿ÁÚÊWıdÄêj4ÉŞÒò³h8UÓíœDo°v0>OGÑ0y«JåGiÖnU›oôŸª;`á:Y<9™•5µ¹©ÖšU9$™Íg™ºˆÕdüüªEœXRìù“hv¥*¿U®ìŠÁØPkUïFx˜Ì²ñôm' ¯M÷¶›UÏNM3ÀÇ©j¯¬Ì²(ƒ<¯ÇI:JNÆ¯»Ó8®ì±šHk ²6©«£Î»ápÜSµˆ~TWnV”JªòÅ¤±İO¦q/;J'ó¬ŠeÚRP*àÛŒ?×@/æƒA<İfquƒÁ‚5µ¥š´ü~åıÊ
+vÇbk7†¥ÄjÕ.ì2æ¾ŸÅ³xzm¥»©Öª²‰h&“4óyÜ›ÆQVÂ¥¨ÖŞ"X0¯a/Àå‹~‹ø+Pì­•Mü’ X*Gw‡ı,â›ÆÙ|šª5‘šÅäÄ¬¶ Sõë¯,|‹ç‹-e9•å­ zmË]·SB»V¹Pde÷m«ZUÛÁ™CEBe¥v³ª£ÁĞ¯ù!ixØ@nö£¤uvŠ³Ó1ôOŸ÷æÓiœâû,oÁUu£4n‹zvÆørè`õoh#–@®¯È-Ş”a<ç„xEÛG÷ãùhç:J†ÑÅ0¦+î q-FàG5H“ñŒq³Ïú˜Ïâş¼?fqV@YWš–Ùü‚Cœx¯à;NFK-e6I²U²êÑãŸ »~4	)‹ú»dwyaº‚Ûï~Úÿ%šÅQï2îk›Æ³ù0S°€Îóî“ŸÉX•Ö$QJ¤²±álX¤#Ì²CŠ!TIyäku{TôƒL õ­†¾ÓP„]$Ï•Sd¢LœO‹R³Àäm0ÙwÕe]= TfĞQÊxE	7šËs(Ú-	¡()ìÒŠ=Cf·
+iˆõT‰6¹2Eiªm:mb Ç»¢L8¸,ød|ßb'£x4D¨™º¡W+™}ÄÜ.9C@L¼q÷]
+ÆáQ-çª¬,kÔ-Qò*;Âñ‰oşã¸O¬•[?ÕúK jVsƒR™Ñ9*Ò¢g(!ÉFT	B}UmÉIÃôô@†y48‹ÿ=GRï—“}Í¬	´d+ÒèD2à¶ç	¾ÄT|é1bèã–(³w÷®vR5~°wåjoü¬~&(ªÈ¶ıMg“t}¸·4i8û1Dbø”¡J-Äg{óLJĞ-ÕnÑ…dÙÉ®öX,¤óÕªœ<°¼Np°#ìÌ®’	ï&Ù;Æl°ã¼¡Q'/	“¬@¸¶
+İ›öNÇÃ·ªùfÿÇİGÚ­æÊJÁPöÆ)ŒvŞËÊmD§œÄ°á—\ã-$ëÒÒJ¼D¤ğÂI –µ©ZÿvC%««¤ÑüU&NÃÁ2á¨¯ˆ8}ü•…ã6Ô+9L»t¦2UÛÛ¨»Õ¿TåÊHçú­‚´ÎE¹`_½iï<ysSZâx·(=Ryüô2™í£Ùì$¡ÏËsAı©ëª\}MÂc[NPnA÷¨ó}Ÿ(#8¨o)"ï¿;‹5ÅU!>Ít’Q°îüJĞã}”ë7¡ÇT÷ÆƒŠ g)˜ÔhN<ÌÁP]³âúº>dë4u¨àZPÆI3nwùèGŸ½›ÆMò”v
+—;ış®ø÷>¶†Qÿ,Mœ]à9Æ
+ºÒ¦MßA´KC6Jrò¨A¿
+KçJyc¨Ú·YJ÷qŠ.Á!‚;àQåwÛ»¥›XÑ#¹ˆ‰Ã¥@uK ÛBzDÊ`$/ª‡hÊQ/Jçş4Á´©iL!39Lö6æĞ;,pKİE	Qıu¬RTjŒ9EÔï'Y2N£¡º@çP‡dÓ^L s$6W©ˆ{c´
+««*Jû˜6póÜOz|zúğHCRSâ=Õ•:Yš&Ğ™€6¡4~½÷¶‡™Œ*É†b¥¯c°€À	şƒÜT{X…€Y464_Îˆe´/›@RqÃp9HŞÄ}Êaún6:Â¢ë0Wn©–A\RŠÔ:ş–¸`W*Îb}…¹Jƒûœ!â›¼û+q>“4±`£Å!‰.ÏX_´ñ(ÜØFåäİ
+áòRNyÉ_×‹şM2­Ú ›êÓ¯3Õ»ŒÒ—1FR_¨£ìëjM©ø8™¢`b@"&"h8B€?-³Öº®—h×‰i¡äÛNòtÂ“>0Qút24@Àã]ZÓ²°1Pºã±<S\]5¨ËŒb6AöZ¢Ç™U‹ìêöãí[·ï>æŞ¾î‡Ä@UVhCæ!)İh«Õî9™Æ×Ú/pŒ¤Cß:È”ÜïÀ7:(áwÎ§ı[é KRaØ5'sÈ}éc«WŒ%qÃÃ¥é"ïÄq]şş€0X65êïËv¬ÛàÔò"ĞöA’¢º ©<PNˆ(™³d]$XÛÍ§Æ|a—Ë”ÖjÁ«+„ô-&êÉä‰3TÜh¥3²Ù8.­Q³§wƒÊæhK¸xıKól„ŞUI®œ+—¨Õy°´ ×ÑÆ6äÙ|µF~Înç] Èo	ƒ³bx%1Lrã{PK(ş ’3wËAj¨Íiƒ™’@
+à¸ÁßàÎm7²øYì$h›iô¦pĞ]€4íí,ÈõF\qz¬¬Åa¡Ö´HNÕ^ú5F64 L  8€Şƒ0i¸Ä.Š|ƒm2Ïå3ˆ£4Y¢«Ìw}¸Ç7vÓ Z/“–,÷´‡ˆÄÁœáÀÆLZ>ÿÑÇˆ“œ½ğW	§¸Åy”©q”L~Ìõ¾#†ó†ĞI·…cm>LË;z
+œï3eaÑšL‘ü@.z^÷\ŠRn¹í£«¶éîÌŒ¹®L_•dñhfÄş#ZR4ù		*¯lYŞç_óƒ<ôú„z'bê²ƒq˜!Å˜¸9Rb£*%p¹y9pë› :† omü­pÊÕ y7Tí"-GSu»bÎó³7òû¡¬à´éß>V ®À<A¸{Ç¿ şëdÆîSşE+>)–©Š0L(èÙc™ûPŞÎÅQzf¡O½ç)Å›Êf‰îN ñ½›P	j•„+ˆËÀ%¶øÌİáÀ5uØ£ç\|$u&qÏx”	¶Ö…zó)ƒÙ¹®z4¬SòlÎÿP1£‡®Ï˜³h‚âÏî˜©e€§ÖGÙ¡?uFüäY\×qÌõÖåıG;Ú'úñ0‹ Æüââ†¼l`}ÊtOÁNK¶"²TKÄ¸á¸¡ñM.„NÜÍh0ZğØ-ãÎ€#óU*šˆ ª~×ˆD”¸ÍªaÂáäâ\„	‘±ÌìWX~ÜR5Ğcb›aÃURx@§8
+ŒJ½¾L†x·auöDµ¯1+ƒ`Øi/Î±õ‚@€Ÿ?û J]Lãé€àéR©úŠSìhRÊFÔñó+
+L…CU !æZGºx€ÊxX¤h¢•j÷“¾q ×VWS¡®ı{ IÀ“lÚ“%ËüÉ/¯Øawfí®3¤8-:(‚®hÖI%tk+ÎèŸÆ½­Õ4³ô“è(Íõ‹LDÌÃ ²¢ˆz@@9vA~:H| ×ãÁ^²İ¬Å…!'sE®ĞÏ[Cháoß³,Nß«u0Øã¨†_qåB|àYÇ„’ÓäNË„–%ƒËŸ>¼8içÆÌ&°‘ó¦à´%›ä¼¹–ÛÔEx.ÉA¦ò+”áf!>;Ú]&cmØp­ı‚h‚ÅÚñ@Üø´;¢]?Ìš!Ğv·¦-öÙ.½ÛÈÃ`*Ükç»èÖ%¨îµqÛâÖ¡á(=8ùÓORÙ¨ò9(£WyF]œ±q	ùöWÅË„T?®/[­İØ@ ÁÎµ¨òA?>Ò%S„0áÃ}2+>KŸã›y[ãäÉ³ıîé“ú'´·ºZl87xë2ÊÂó^ i28õQÈİ À'îÚ«Á°ûaİÍSlß17wÏöŸ*óÅ¼´4æwíÇa¿ç¥–¨0ã¼¨ipñ»†ÏŸöŸvOvîîwº‡û;?îŸµ*£$=Ó:İÙOªÌ—+€˜æS…ÒôC"JĞÎ!Y›”¬Ÿ1P’vÎĞG¢³»›J¨ ÷AËøƒÈ4}`ç=cÆ=‚T4â‰´È¤æ±ªŠ[ÿô0^@4Òêü|tªÅd1Hıp+"T˜Y’Î1¼°˜Nº§;g;'^´‘xoróG"ĞVav[“±-êÜ->wO<İ?«ˆÕu;(Ê•5ªlEÍÕJ¾+3zÁÌÃNB|ê¬[Y¡ÌÉßƒ’İÌ. :c‹dä¢X¾B(#ÌWw‘áav>¢Mw7ku}Kr,æÅÎ`\ŒNª¥WøaøáNç°ÕİÛ9Ş£lD&ÖIsnİ†KTè.·* ˆtŞª‡µ[tºV¥×e,¿íçÉäS°ÌO¡‰åîs¸Ç'çwÏÌó¿ç¤˜G8z3²–ñºV©ÈWŠ„Ñ
+¤‚K[Ë_ƒÕ®~`,Bîa“(±™«ƒäMû°<¾ZU¡¹oF•ÚòÖ#°ÁkpÀŠøıŸĞü(Jk.6óÑ‰	£aY…b±nÒñ& ò œİ ½y¿ÜÜãMÆ6ôš{Qî¶ó
+º¨~2à]MÁoçf²n›ì ¯µÁ-#¸PÒtbâÒùmiæìÌ²ÏÂÎ(?î”ºÜbJğüI—‰:*Óè¯oaå¡¼ÌÖÿ / »kç<‚…Ö^Ò3Ö­g¬/ã$ÿóHö¹ÚZ°çReö.„ßæbëË¸˜O}öhºÓå4	¸ò‹-cpMÏ3yŠ`M“Ãïâ™Î<?Úøİö¾Bfë7×ºBˆĞŸ–!x¨BŒªvŞ‹µT0i±îÜ†Uè¹‹Ùu,qP7ÏØá„ó/¡ü÷c—&¨¡Zù Fr6"ù„QÉ»¿)ãMC†hæCâÖaïsÜÊE¡[pBS|Z.$´
+!AGãü¡ZôLîsÔÒ.ı×ÇE-/=ùÅ\#L!Ğ”É’n«ŸîTšL¯.¾pW*Oëm–,íƒ+v[~Î¯ù¼şí°÷Ò¿Ù¡ÂG‹³N¯7Ğ˜Š½\€şl,ßõSe¾°ßÇëOÒè÷Çˆš’îı‘~Ñ=ìî—èï]¦:‘Kg2^˜´îğÑ1ĞdIêz\M1H£PÅ/ÎbHˆ>—_
+İÍ
+¶ñQŒéÌ]èá?1o¡âÚAïroşô$ÀUæ#|}zl›R¤	*¢"Bp^ÖJˆ«É°î6(Jtš_ŒáC-!”VX1}¼´êÜÓHÙQ”Z8bÆôpô}äÊ;›PrtÜÿs?IÚ*p*£’}9¿‡ìóÕê_Vö{_JæPÒ²ùİdJ\tW„<,fÏ{ëeA¨¦œ¥6O¶»(:”Fÿ?Fş´[~íÙSú2ŠùïÈUµk†’L(ŸÛôò8œ¥r2èÒÇîÁ<íU½S¼Jm`¼nÿÇ}Ğ_*"ğwsˆçÿ{‡°°UŠ¸ •» ä¿:qW”l–^RG×PáI¯ÔÊïÜPÜ¼Áß@P,Ç˜uòu&äš||qû„Ş!"ûÖTÓÇòÃ´CÇÈèU&Ô¡È8„Õêß Ö¿ÓwOBóµÖ½Í^–PÎá÷&4¬-îIhx8O({orÂä}OrÂÃœ÷+ÿL¹À²
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/35/031576353b87ee9a0b9fef47a13a9a9284975b squashfs-tools-patched/.git/objects/35/031576353b87ee9a0b9fef47a13a9a9284975b
--- squashfs-tools/.git/objects/35/031576353b87ee9a0b9fef47a13a9a9284975b	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/35/031576353b87ee9a0b9fef47a13a9a9284975b	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1 @@
+x+)JMU0²d01 ó*Ó˜¾YùlwMÃ[÷œ>ö°÷×|ç.1 àT
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/35/129f038d1c096bdc59aa6c0d0850083a2b4e05 squashfs-tools-patched/.git/objects/35/129f038d1c096bdc59aa6c0d0850083a2b4e05
--- squashfs-tools/.git/objects/35/129f038d1c096bdc59aa6c0d0850083a2b4e05	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/35/129f038d1c096bdc59aa6c0d0850083a2b4e05	2022-01-01 15:09:15.661172591 +0800
@@ -0,0 +1,4 @@
+xuSaoÚ0İg~Å“ú¥­R
+e[U1MK+h‘( $¨â2äB¬;³ÚüûSºv*E‘|¾{÷Ş»óF™n¾_9‘…Î©@2J³y2Z?tNø(5}ˆ\wp;KÂÜŸZ¸²p(¤"×8Oû.•Ò?RîJÕ`kö•%ç(Wæ0Z5çC[dS5–‹<N·g¸êõQøw‹R*%+LM½+ÉâGõøõÆ¢kì®[ÿşyÄjiTÖì¬Ø:…%‚3…–†hL­ĞÌ(—Î[¹©Y’ô:¿464Ü›\MˆÕlŒ…/	ìŞÁíá~¶Ä=i²BaQo”Üb*·¤…ráP… +Y÷¦i+ÆCzä€±a`á¥ÑCdx‹YÇg\EÂXœ
+¨Z˜*$1¿Šíÿ—ÛıDï»¬R·íKS±„’!YÔ3Û‰¡vTÔªíÇài’=Ì—âÙ
+Oq’Ä³l5äd_¾¥½BÉ}¥$c3­Ğ¾aOãÇQr÷À%ñíd:ÉVAÁx’ÍFiŠñ<AŒEœd“»å4N°X&‹y:âIÙ– >÷ƒí%ää…TîMøŠ'é˜ÊQŠñD·$ÌMğæUY+şsäĞW(£w­LNæm9.Î²€6>Â³•¼ Ş´XÿÍ1”¿2Â·dÄöJl	HëP;ô"Üçğ£wÕï÷/úƒŞu„e¿Éá—âYe·dÜËN‡^xÖ•/ÃÛY{œK-ıú˜µ~Ÿ;'¤y_;Ë®=a
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/35/5c8e9a6f06dd355785bccbc6e18dfa9f438a16 squashfs-tools-patched/.git/objects/35/5c8e9a6f06dd355785bccbc6e18dfa9f438a16
--- squashfs-tools/.git/objects/35/5c8e9a6f06dd355785bccbc6e18dfa9f438a16	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/35/5c8e9a6f06dd355785bccbc6e18dfa9f438a16	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1,4 @@
+x+)JMU032a040031Q0¯ÒK).`˜¦¶ÁNÈM}MÔ,ÇÊ Ş3_r£/!«(ghé>-À™ô]ÿî3»ëZî¦ÃU8æää'ë%3xÿú¢Õ’È2ÓôNß¶ÓâÇŸ§-ë.AS”Áğ<è½„–H­¡·„›ê=¥ëöo9Wä’šœŸ’
+4Š)(ŸO¡&¸×Ğ¦_|_ôä’úÔ›ÇĞUe0<œÿ¸ıâ¦_÷ÒÚ8?ğŠlWàlÿWåZQR”˜\4ìeƒö1å¾…Ò~{×ŸÓˆ?xıÿW	eññÒ9K5(FÍaİrßl*7\™GjbJjĞ°'ı«<Blæ
+*¥ÌpâJŠ<=WSv&ºª†™Û¾ÿÈU.ËİÁ›¡ııZÛ6¸*Ï< 9ßDì›k^Ìdş®÷ìûtŸ«|·¯"«È`8áÌU=ùÉ¤´[wV„oS~(4ıBEIj.Ğ”Û.ár»ÿÖM•5—ıï¯7ŞŠ¼<¨j2æ§İr>èå‰÷_~.vX]³¡t¾\ob&È5<
+//›¢k#Á'wæ`âÚ-Ÿ7MªÉMÌNMËÌIe8¾›u¯§å²@½íÊ³¢ŞœáU546@S£—œÌ Ä|ÿ óJ‰ßÓ¤#Û}6™¶\ÿ¼ ÷·óK
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/35/8a7b52650ebf46fb40a984e0e9a129864d77d0 squashfs-tools-patched/.git/objects/35/8a7b52650ebf46fb40a984e0e9a129864d77d0
--- squashfs-tools/.git/objects/35/8a7b52650ebf46fb40a984e0e9a129864d77d0	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/35/8a7b52650ebf46fb40a984e0e9a129864d77d0	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1,3 @@
+x½VÛnÓ@åÙ_1¤¢²§MSE•BkJ¤˜FM¸¨B²œì&]áØ‘/­B[¾™İu_ !Ušİ™sæÌÍ$ˆ&ĞyqüüÉÁô‚ šîO¡Õ—/¢x>­ø©ˆB˜eá”şIŒN»}Üj¿juıyÃĞ¿¢[c˜M1-|ÂŞaìˆã3ğ>õßuğ[82Æ¡{'Bİ%û7§Æ™˜mÅ’”bB¡ÍbC»i¢ÜÁœ"äà®½Ş`pyæ;o>\ÈŠÎ’j(€ñI6W|f1ç-y,™%t2‡ZÌ¹ĞE\""X"LaîÉÆœE~yí“Êª+X}à˜«€fnÜF¸uÏ]If"¾q/ú°Œ{@Ì@.Âk¬cá@ÌÓ,©*ÀOpĞY •|‰±LeÑA€Ù2F.3™ñ8¶¡ñ%”àÙa›Ád•òÄ†©¦Hk6€ÏXŒÉnØ¤]èE³iƒ™…‰˜‡œYK]Hã]RÙGÂÌƒ„ã§^/#Óy4TkÜÕ[”ËTL¨>OÕšŸr§éğtİ¶¾”ùä—[­m­·ÙåP¤
+jŠ±§uA9HurµûËr×“<Ä 'P`[+"h6¥tZ‰µREœf~  ·óp×;»tİşØ†aïÂñ®œŞù§«şØÁ$kû·2Ñ¢”H®¨î(ÒÚ“òõ"Y5_	\‹jò&ÆWÎÀé4E9$§£À w…= FŒŒL.{/¯ûÃb@Ìz:*FıkÇãåøñœı9¡%(çHWKNÕôG«7ìÃŞO×»]ŠE¶Z&R.XÍhkå4‹—©‚ò:äI
+ @])r¨º8n6ë6*#Âè0¦=u«i³±,àïüÜ;ŸÇfã+CuöY4,ª&iC*K‚VQ¬@)«¹”÷R³J–Ú€wõg-kËW6Y«jQ-ƒÀÛ  Ÿÿå ôâü™à‰²`[r'«™ê{™</ìîVF¸‹Sqİ.µ-ŠK)NóÅÃc‹Æãÿò×'©ì=êQlVÒ“:€R}¯ ’ºÙ21%ßØ<”/n‘Ñ¢Ih6oÊÚq™tVÏ›üI³•‘aå!¿uMâ»&Vøkâ¢k"Í¿gœÊ &ç(ì
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/35/9daa733f317968417bd904e510af7fc3734306 squashfs-tools-patched/.git/objects/35/9daa733f317968417bd904e510af7fc3734306
--- squashfs-tools/.git/objects/35/9daa733f317968417bd904e510af7fc3734306	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/35/9daa733f317968417bd904e510af7fc3734306	2022-01-01 15:09:15.653172590 +0800
@@ -0,0 +1,62 @@
+xå}ûw7²æşJımåD¢´%'3sÖ5£È´£=<’|¯íå¡Ä¦Ä5ÅÖğa[7öıÛ÷ûêF7›”d'9wgsfd6(
+õB¡€>íg§É_6şúıßşÇƒÕ…d5Ù¦íqš´“Ñ¿&íÑEw”t{ıtt=§—÷“ää¢7Jğ¿vrÑ;¿è_'gÙåÕ0ÒN‚–$ô¯	'j…Gœ]]ÑhœÔÏV’‡››ëüûPş~'¿g½½~¿w•ìe“ó‹t˜üp¥ÿpŒîgÃóû“w[WPºfçÃö%QëÓ4eİñ‡ö0}œ\g“ä¬= vŞh<ìN0¼Ş8i:²!;¼Ì:½î5Ë&ƒ:_¤É8^’¬+Ï^&ÏÓA:l÷““Ó~ï,Ùë¥ƒQÊæíQrÅÂÑhpz--‡cÃ!y–p{ÜË“´ğÃä}:á9y¸NÙ0©·ÇDu˜dW¬¸ü®“>¦"Ô½?c¼ù°:Io İ_dWÂ@bP@Îä4M&£´;éK AòËîÉO‡/O’íƒWÉ/ÛGGÛ'¯£òø"ÃÛô}ª z—WıbÛƒñ5hBŒ÷›G;?¡Éö»{»'¯8‚g»'ÍããäÙáQ²¼Ø>:Ùİy¹·}”¼xyôâğ¸	î9U0|˜MÓ¤`—Ù0M:é¸İë|à¯0“#`×ï$í÷)fô,í½nmpá1“ÁÏ†Ì~Ûılp.ÃDep‹1Îã¤×MÙx=ù0ìAÆ™À*Ì#›çS¹üå&')È“&/úí³4i$Ç¶ıî»õäÇl4ÎëÉşv²ñpss³±ùİÆßÖ“—ÇÛ>œö'úşÀ>XXø¦78ëO:iòC÷l0îß¿ØŠŠ:½a:ËFãN'íN•õ{§Se½¬\4ìÎKe×££q»Ü	JÇ×Wé¨Xy2€(uŠeİÁe{|vQ,¼úPªu>¼*Ö€fyğ¡İ+õ;LÏÓÅŠıŞeo\Â#2¶œV‹®%Z]T^Œ^\¾óWÅr›‡B] Î†¬¶ Zñ,ÃÌ€'®ÚÃ”£ÌÜH'DƒB8»h“Õ³É°u5®'«#ÈòYúxÁ^CóLÎ t¤e²Ú¶Ï/1¥­ÑUz–<I^îíÍª›~Æ¸UÕË«ñõm*^fïÓÛÔË¨¬*+öchZÅÜÃØcàkG|Æ[Áµú WıJ1ŠŞ•(L»Ó:t»Pœ«–#¨\j0ÎŞ¥ƒæbÕ-¿ÇíÓ~úú-ü¶Pû-Y¬/®''‡?·_4Z?mïüÜ<YO`½>¯Ëû{¿³-Uğ÷KKVaûà)Ìœúäp¢Ò{VxpÈ>¼îºwq¸¿¿•ÿÃ!³²¡“ ¬F|ùi÷¤Ù:~±½ÓŒš¼³Âì÷xÙÀØ6’ÏŸ/,”©•ÆN,ş4Z¡b£[Måú™uÓW˜+­×É<£É)~¯ púFp`vÕ_Ú—iİ
+š‘$«S5à6•Ù—§®RÌŸìdİ:¥\‡m…ç¢Xö{ƒtÅ*¯°gÕ{éÇŞ|„ö İ¿¥t.,|&Dõäøä¨u¼û¿šÉÃ¿ü5P‹0ÏS‘Œg Wé¥ÎWÀ}V}Jœ¥,Ô
+¯gû¡_ï?S•È…š
+5©›/Ôøšj„:×zò¯I6N;Gí|­4©o®÷k°‰u×iÉ“'Éò›å”×†éx‚9!5ŸdF»Ş“bÔ{{_—Ü{¾‚™][Œg—Wõ 5cùCC:„Lş+¿ò+DjCàÕN1‹ïˆ	!—êJl/-CCC#Y[˜Ï Æ<H#Qhô¤<lR—ø­ªP²~òY¿ W†#£UĞ‰‚ä²İïgguç$0G[¨MZí7÷[Í££Ã£ºÔ ˜o•÷¹;è{m8®p—…åà%‚ñÔ'&(%Ç 1~¡óŒòUM¹FŒsœq„Š¬³¸¬C(„*d®åPî9Ö„øÙï	WR*zƒQ&ÙP0ôÁŠë‰ˆT:Àr¤ëcã€„\ÚF¦Şç&âãZÚ‡[O†|AV 6† ~€ß™ásv©ĞéP§†S$î›ÓS5Biàt
+l²c·•ÿ|êÅI_^QÕÔjÆ™"ÿò{/Y¬º’,%ÿØşõ&u-Ø/ò€Ù_×^(œ)yoò#ÈDBºY[˜¼AFAç‚‘Æ·'³T][Cï|ÊÇù ]{„êª7›iv4$<G$„tî<¼€L¿SK_¥é»™ÆÁÔ:–B€4E°l¨ïId\Ğ%­
+	hU‰³(VRŠ…š´&ì1V÷\ªŠéS›f¾ÏzYn·Ô,±êuÃ¬FÅaRø»±E[Jİ¶}r¸ß:yõ¢©¬Aœ{2¹‘\õ’àD²U{œ]ŞÃáÀÏáù(7#\ìd©ƒ·ï_÷Ş*ŸT½Ä›Úç„BÎ_	©—ÛG¯+0	›Ç#ST&ƒöğº•]İ—±šÀúmf}VcõşÅˆ}Ï€êµ†Z‹ü°G³ˆ-0\I°x20NÕk*¼@oê±dW¸	{ kQ($4RŸ$A…¢ñ)ÓÁGb<£kÑÙ‚Ô·SéJœ¥ô’ºVÉe³$™|íL’¾¹@K-æ_#%xhL½Üüz“Qcd¢xoB»‘²>ÛE¶¨;Ÿ–¨h‰¹/PLG¬Ì¬5¹rî£wô…YK4ïîJvH£y¬ô•…ÁÑ„¦AÙïş5¶£,Ûê`•¿ó7œ–Dx†Yp+ÙFp©JN¥™Xº”ê¾K/¡… ÉéPÑ¢²e±¦ÀFEwò_!Òõ«9U‹Ù OQ*Z •¼YüvôfñÍ k'é£)ÎµH‡T}’,úâ eÈ¿Õê°MR7æìF,T›"¬e¼§óWÕBÛÄ6hiôBğ ‡f mã…ª.mjèyWƒvB›„RY<'@ƒÑÀ`±„0i<:Ò,*O‡í³wéxÄRqáüç#“É§ÑbdQ—À‹nE7i,TèÆ«}ñ Î3 1z×»j‘=06*i›/âb¨dÈÙ@¯"k½€`écfÁ•³Ö©îµøÍb]9,ÆÿˆêÉaşƒö$Ú£c#8wD¥•„c¢}Í‰¥Fµ@¬êQMÓJ½sòî:¢EÉ¢ÏºHÑüQÕŠÃ’qÅœFF‡ fÃw&WTŞ…‰îÁÏÛ,ŞpŸ?ô-KºÃ€Œ5®İrä:àÚb4§ëñœŞmğ=LBAO¸_u45÷¯àÈ™`6¶ò÷".ëÉR.©à€$,iA}Y«q’Šdÿö/DÈ±[Ò,¢ÕJL«»òßGÁçåÀ1b•¿+R}¦PÎ‡‚%ŸåQ|¨ës#æ¤ZÎFØŒ9»P±bµáµ’;¢„9nÏëy·ëªEˆphëµˆ2i5|\_e{ª&õF.W5¹Ú“ş˜Õî:£¢ú]&°q5”²uÕ{o`PW*é¼ùòQ˜HÅ¬É‰L?Åâ•±ÍN%…Ã¢d¤–rqÉñÏGÜªê™áâ{55ˆ[()7L4ÔQ¹\àüà¿"¡›¹…XZ"áŞ,~úôf‘ô3âÖß,BxÖÈq‚>¡iR‘f¢N¦ãI=Ç¸B÷{_ˆ|d÷GĞV^„¼ëƒãºÓD…Q©afâO––°*ğ‚Ã#›‡ò’GfZ¨^$z„·š){­èƒòD^™™ÓR¶r¶L†ÛeÛW¢İİOŒ}D2‚E^.õœT*g›UV‰—ôÛº%ü¯Ëyò¿ygn½®cÖÆ¾Ö*+Â“u»©¸kôÉeÈı|vîŞ¼—Ùv€n¹¬êP–hÂjÁK,¶@çÜ.k!bI×R¤–Ï²D±Œâ²ûTè§Í7êS&=vfî:Ûôş9µ"Ÿ79g6?Ø4“éŠ=³ÂÉ‹uo@~™½|‰4oÁS®«Sw«%6=Á¿
+6Éeu±ê)uÈùºíÄ˜šÜ>¡.NH0ã35ƒ±‰S¾ë<–,Î]½_Ü]'Hâ@–Re¸ÍÄd€Şa‘ƒ85öYÉé3$¸4L.O±‹‰v¨¬0¶€:ş"&šRÈ„†$¶ aG (ÍGšîĞNŞ·‡=îmzË²­ŸæMIDh›‘¢¨œœé%íÂTp,l%ƒvkİêÔ)ëTé¨¸*¹°ªVÑÍÃÉ|\G>u–	+•Ëc¡…6ÌÅÅƒ^+ µË‘y„œ·g‘Ü·
+•ºñêä®"Ö&j·Ìñtö’sšÄˆ×s{$®ò†8Aœá?Z\À¹ºŠWÿûuåp‹c`Ô‡´èBr<ÅooPÂ­º¿í¬«µHßéÛ°Z]mŸ¸SÓ«$N¢W6;[±0›®a¶üc.ÑB¢#›ï°DÃs‰ôônæŸys·7–‚şÂ¸Å?¾bİ†å§xOÌOáC}C¨Àê»\SXêì"Ë°€R:'ô"˜ˆ­D8TŒ7ùñ'°{¯%[…ùì0%Õ³£íçûÍƒ“ÖöÎÉîá—?â¢x~Š'Ÿ¨b[Á‰D,…,…'àâ¬¶æ¯;{/Ÿ6g/fØèFTºW¨¾ÿâäÕLĞQzNài4…óşáÌD8Jì© ²’b˜ÑÊR†æ¤*`å™Kâ^rç1Röy!T~_?eJ·)±''Oá
+1Ò@è/íjÔóZ+¯ó^!»aAOñèÎ¬n¬ëŠmnUuÅ©	o¨FÛGC5¯š	ÿ™WÍœwşCeî&~£+ìº2÷€¹J·Ç÷íş„)ÈìL·5Ó.ÚMQ§bÓ‹-Ân—Òª%(Ù"C$Ãµƒ¤+M•ğx/0ğK§hKP‹ıXpHÃ§İA=ŠŸGÜ4uI¦ómšæ½|L
+ŞÃ9²u3d$½@…Ä¿¶mV†ƒAQÚ6¨WÌ×ù¶BÈ+É§O*3«#óÖ÷V_aå›pÂV]§œ\Ñ"VàÄ«Ø#q¦u)Ë|­uXìS#}%mŸ]@»#åÊ6[Êõ¦3‹—FU=÷uM´~’¶XSëÆZ\¢IÍ@€s7×ñçáÊ?H-z‰ö|ÿ¡"ÁoZ#I;Ç®ÅÔ4.Ãl4J.%ë1g˜”M”`Û„ÿÿ±ß¼³·4OH°ã¤õ{ƒRÌ¸?€Lóo · ?¹ºÊ†("ˆdm®4lĞUym"&{RUrßò¬·E,"EqT ›K©§ÃÙÈ¼Z¦	0U6 ¢¯G µ#Å­eá/ìïÕMÕ†ä>ûD)kÆÅJ»B‘ßĞ1¤‡Ö2]k°[½0ml!±‰f-H‘nrÜÚ}¶B­A¹Ï…4ä>4å3@ÇU<×ÕügİÑ.UµÌDÔ´_7«2ĞCÅ¥Ğuu	j'½_ÄH"ÒB³Æ–¼áâ÷~â™Ä<ñì
+v.1ÕIr“ŠÍÂSİ¡T€>®olb@Ïğ¥ê=@¾
+n'ƒ ë,†}SœÑE,›ÉnŸlêÕjgÙ`ÜL@tô:­S¼kŠ$<d}Tmğ”V¢“¼¶ÿ;œ\ChÑºÏ4m”FÕ6=³„gˆtzÖë"í[äL¯A,afzvwäÎƒM#2“5oõK8ºÈwÿ¦¬ÜbîåÜ9=ù¡*'œi³ÄÊ¬9˜2*úßl­Î‹D¼llH#TÖ*—³Ñ,×uò™Û’0‰ïÇ•r˜´UêŞ›êr2VTo.Œäišm¯{Õ8ëÛjÉ„°&¾1_†¼Ÿd<?…ıÆ[¦èiÉˆŠ+D0«İQ:.»Ó8_Õ²ûµ5ï:³*!_’Œİ—Ğõkh;q>sKÕÔã³E–Â×I
+¤h¯ür¢Ø@i¢^–Íğv,§Lzî¸6•±±İÚdj^óµDYO©°
+#ªnª0v•ªávÆ
+Ğuöş”*½W³„¿¥ò`…hÈ§e›S fî-†Œ¾iùösÅ;¬%¤}ì©<»Qg³ƒÒv­dqÙë‹JUn$FºÕt³dU~ÇvY
+D„ÕdA¹Øæ	˜7ÆÉ*¸*0ÁŸ†äº„V»ÿ¡}=*(À?	5ë”›F”ûo‡%ä8WN;vz–3ù»Ò§ˆyÇmÿtFx
+ö5¿s=S]Tb†Éà¿fÊJxÙë<8GŠòM”•#¡òG×;“^Ç¶@±¼ÓX€$®ŸBÙåuQ¤ Ë³~ŸAx§8h•‡%WOi™åĞŒxÖ4mlõNW}ú”ğçÖ¶ÙÛK~ø!ùîáŠ†VKû ªIuÍÅÂ'qÏ¹ÏHÿ4Dœ®Á34½ù7<™@riü¡Ã3Vò¯â¯>À0m AMâ¦¯ick:8-@¶Ğ‡
+>$;Ï@²7€YÄ¸Ø;ô“Á»AöaÀ³ÇÃÙø¢³âÒÅÃx>§¶Îfó3Ã9¿ûÌ°•ÍŞafXıgæ|˜M®’UıGæå|85/òV¦EG&Ï­óaÏw™Aôî³"½D³B÷'HŠdCm¥'ö*çª_FC¤Gı#É!ğ=òšmüËÎ¿8>ù¤+ÓãÁLªÿ"ãâ7æ:`C†~ÿzƒ „¥åµìjƒyÉ ¥B+çİ–z^ï4v¶Ka^¯ÒØR¬ğhxJƒ¿eï†‰i+cöœ¬ øIVå(ûROÅAüdÅï2YåuYÓÚK½²æòí›Y½
+8^°Âßˆ¬şö6dåÿ8vE`çÃõI‡ˆûOã¾@^”—É‹"²ÒÏK\«Èu¡pûfàvy]ÙÎ;Ÿ9/^!Ÿ/™ÃğaLEŠa¥‰Bx=sÊd!ÍşUƒ§ëwwyİJ†¯†_¾ÓâËJ(•BÔAQ¯.T˜ò“1ø?wì°(ÑÀQ)9kaš¤¡Úô88Ì?uB£DÒsãPtJBS›“Ò¼Ùxó‰C¸1wÌ÷¾ÉoÌvv6ÆcÈª_&8z>@”UX¬FğôûE‘=¤§…àæ¯P£˜h)7†¦H4CÉjøIñA,õì"={Ç„ aº,ç'ÆC$üs[áÿÀı’ *;3Œ¯‡·ÌxÌÓÙ¹!JZ%í.ï£‘ÁZ:‘±÷ïr++A´)yC½Ør±¨ÅŒÚÉê"R‡¤°Ò3BxÕOoÈM|ƒã)ˆkêhÜ‰f½zæl€øÎÓ¸9e\è÷áàRq¸òr+ÙøşS—}&®ßf¼’¨äb÷d«B€å×™a?C… §CÉ=ê4¶B‚5I“Zû‡È08ÜÁ®G-ªÈŸ¨ÃŠ/pD…w}X¨+õĞrZ©kìü…\2º¾<Íx’€ÇR†ûk€½œgí·k¯×OŞ¾hís+L~ «×Ãß®qIÁšoeƒÉÜ¦i	Qûˆ®‚DF‹†(Ã;à	‡lÇŠíøb¨¥$7F=FäD¾Û£wÑ#ªLÿª¥¨ù`æÌ“É)üW‘ÏÉ²%3yÁy¹ +´í7¤'©°ôÂ=S¸LËTjÕ\}nBğXü¥ üÜ5H‰ØåĞÔ7ò¢´ Ó£ÿ&Ã–<Cİ¦‚"Y3Ë“en}k·Ÿ@Èïÿ¶Abæ;¿šı²|^ª÷pão•õ²R½ÍHH¦1xí¨º¥ü»vÓgQ+l&ö…k"J„ÂÈÊ£ÖA¯IçÜ[/ŞöÓ§ÄÁçkİFuİ£æştİ'Õu›è 7YQYmëVÙóQÒŒU'¤symy=Yn,Sğ–Ÿà·dJÜò·gË’'“Ë®
+YWÂ-N&á›¢ T¦ı¨ÛRÀŒˆ„G0zü˜	W'5²_P
+ÔÆ¾ªªÒ˜PV±‰ à;W
+Z†ÈËt65pà¨!b–
+Éã‰Á¶ÒhÃ‚@¹İ+Ÿ|"1%Ôƒ>é³Ë2¦±-ó\ Z*‹¶ND~¾ÿÃÎgÛk~(×|øğauÍåš¸³¬ºæ¨\ó¯&½Ù¼ûq¹*Sxªê¯V•:sªãˆyËÇ^
+s8àN¸ì·“ÁõÒY«Õã™bÚ2ÛÚå#¹„‹¼S:’%š†ï˜¡&ú¼hSEûGï¤e•5k£¤À¯è$**˜Ü=`r‹ùUá}óqÔ^WFqbKyÛµ±°Û|×•¶±¦ô“wÔ…À‘Û°úå#ˆ…İ÷g'„âp‰\İå1 x,êóúmT
+V758uÀ•¦7€…añ«±e¤—†8[°Ï*â|aƒ*¾'§¸‹Ä
+ÓŞÑTğG†ÆQ—½3ƒj·œ	ÜE(N<1µ:!Væ{È}U^í>e *{êbÃ±…%)·5e=Ñà
+qÚ¹Ö•hNüßE35|4Â%]_¥ÀĞ|›}ËóôK¬ÍÈ:—N`g"Z0:GÌ—VaÚTZ"É•¿È¡¶Íf‰fƒ|†¨‰hT™m­#Q’E{ûúõ1ÙA¶ƒA“Y?Óò$]Ëê°¼ĞW•ÕÄëqhğXñ°äàGù^¹€Œê7¶ø“qrXä²¹£æNP£ÔÔeK™ùjÈ°‚ıäÆ–'cmm%å@æÊMYsg6şn^có½q¡ãª.éôyåºƒ[6Àï“G6pøÄá¢cÊxèj8Ü#(ÑôWøùÒ¢^$ç£IòSÓîyf¹&îÓİ\Y‘]ÌÉ¯¸:Èıä2rÉ=n¿C¶UŠ›q}Ği¬NÛìË-ìhãU†{!Ò¹nE¦†ÜÆ:Êÿ&‹	u¸œñ É ÑÀ¤Åo0tYërï("c\E›Ç½
+eq€JëVYKf°ÌJ¸FJû|†D“»Ë­^U¾ó­€FxÒß:<şièpãíÄ° ˜n
+¿ä¿¼-Î(Œ•4™§ï«¿ét5šh\a‹KCU±—2_ò3 ºi=e«¬íïj¬L½)hQj«ùoĞ‡8c“±`³`*ƒ7M~Éhıg:ÄÒq¬(5ÃfŒ"—$@×ËÀ˜p—	f
+±‚Å<·xAÑ6õ`¯tÕS‚™j©7ÄÎh||øòh§9·½åÅtf@°£#\\†MÛÛ'˜r9~:é²Ï‹‘î8ÀÍÌÆßzÜ\Îì;~oµõçsÊ•B/ù»îÊ‹æÄQòJ-a˜à‰åïÉEfşm3NDÕ[ZÉåÂ¸²2ëG]KIV;ë>¯¶VóıÆœTp9y=Ã4Š_€j=#‚ßãu~N®s¸èùÙğ=3ì Õ{z&ÔîÈÆ–¥Á
+9NO8Âõß5ùY§WI-Dwà˜;¥Õ>Ë“CaÄxJQlfŠÀ¥6À‰Ü³6üä€´ä¿–³f–'O3ƒËC¼ZKéíz©ü¼iŸwÈÇ¯GTıhÖ0£:âQ¡½ósD%ÔæCñ°Ì¶ZvPû€@F†z=ÜSÇ@úÀ®Äı¼"˜á‰ò€¼×–Â`‰­Pù¦`%lwàÊvœA( èJè„û¡ƒ?MYC—‚íı0.G×†‡©ñÍArù7u!“FWfa«ÔÔNIé'9‡8°Ä½œ÷v.ÀùŠïu•6µÂ„@•†ûìOS’-Ï•ÔÑnqœD©RÎ`.M]xÑ}n|.$éRäß54ü=ÙSÕL¹ŒŠmÄÓÌóòåzŠäMq!\|*óó%šb:x*{3ÙÇMå.ÓşKy ·šceÎp>~É	Oß¨Xƒ1R®ÂVtuä…(ƒ‚§£[sòÒy}U.…¡³8ÙtrÍ­— )Í
+F–Ş`MO»¡6ï &”<Vïq&%»âÙ‰à‘â<%U®$8ø×›5¤ş#¸Œò ‡	ĞN| 4;›ï¨y°½_€(-¦ ²T=­:»ÄêL¯Õö	»ZN!ãKW¸gkÜ­/ù ¹=øv„…|¡y~O-
+æ ĞæDÄ—ÿRÙÓ~Ü~êóyÿ‰FÃ°ÂáO%¹z Áà{qÅŒ3³Ÿ	¶o&M¦Y§“­AáğŠwşÛÃ1©e]­‚èö¹5[yT3k1ÃÛ@C¹SÛÓğ:`5Lh’1í²ó£@<Æîˆú˜å@LÊà{ôZ4àËC^	¯¿ÅHÅ5ÊNO?ËŞM®bÊH…”hsYÀ+e‘Y¡lài€@Ÿz†ÊrµTò|í,ÎxU(ìäöpA!¯@F¡oXºåÑÆî°e˜·‘Ã:$—ìÈùñ\ñàÂ8Y9×3Ld‹¥fü–HTŞóàHxáëhO’øå4’ˆIKy¾äà
+y-2«Óc¬&íM¾Ä/íş»PÎAp¾º˜AøíNî>à€#›íõŞÁ€gqùÖéòaâÔÙè·¡ÊØ1Ö\^ò¦LxÒ~,rà„*L^[»Gš
+D9ú-Â°ÀÉëI[9ƒÆÛ½¹‡>Õ<vÚ¸&JÒ<G‹ø 2Õ¤t…™¼aO%ÖAkêóD¥ÇÍ*gDYÚ§£¬Ïï	y|>†í³Ë„,¡"Q1QÛ¸j¯ Ó¦û h˜ê-1•€Q.+†åQâ Á+AM¼òXæä±Ü×\gµÏÀœİ†Kj‘µ°|e](õûÑ¢³x8ô*æâıPYøÜÃC¥é2½FıÈP‰TÂêPZ¼	Ò®
+BÏ—0GxÕÜlÚ;×¹€ \NÚÎ{î{Ğe	roeôÀcŠÊÂĞ8¸[``z{Œ—Ar.ó>dòéS2r–<KPcR­1~°/¹[UğÇ»ÈÂ?¸ˆà†6XHfFĞ?—k}Ğ¯9Âq{|”I¿€¤BÛOÛİHô`3p é Ÿg‚Y¦Íõ•y RJï‘äİ†–cm/óN:K(³œ×T‹á‘P8÷x­Î¦†Ë¢šRnäõyõ.lÑ+"XÅí/íÆüw^(;ÊŒ½d”:l¥¢²“p\ú?øU-/ †\ùê‰ûAÃ“—8G£.'ß±ŞD9êBßÁoÊßĞÒ	öeÕÏ_şq0‹,çIlØc‘5+¨Oeğ>Õ…æ=\ğ¤Õ8@7Ÿ”8bR«é'"÷©FÕä="ïñ8®`ÿ-–€Yò-6MIb›©‹£	8*®=·Ef3¸‰ê\ÀŞqÆ ñô ÿ½C÷@Ä»Ç(‰_4ş»ö/Sš££^1ãN]XÖïû)}¡„-|mÍ)Fx…áC1VX¬Ë.Óá9o'&#€ê|Me‘¨«-zA´¾¡S•~èLkâê.‚ TYn\3®×Tš•dÀ‰ùB‚Ú9¬qÆÁŸDºjáNÿo¨Æz=­ÄaÒ„ïïGbĞ?ÂÂšÁ§–Îtj+§t§’£|>¡9»Èƒ§q.`±A×ç×|b¡WNLŞ÷Ú £RXßŞ»-Ø]c…ÊBgW
+ëÊP‘B‚š4"‡I#-å‚şxE§“¡œçŠMÜ_‡«8å‡À%ÑÀ™"á?Œ%É¢CêªÖÙÑG¯$[£úõÿ7Ì•š)?Ï¯şuÍ4ŸÉHàÀbÑÂ‘‡Ø"ùÒšİVÊ‚…%L¾,‘¥<-|ø>1W­´á¶Ê’ ²ı†–Áç´¬n°+ÉrD‹¯8ÕÑÙ-¾Äıq`àÌoÂ5·nº²|„JÇĞ(,0¶8èbS×ÍÅeØTCK^•SwîòP©‹êaê¬id\MéÉ’4¯@¡É×¤Ğ@GˆZş»„òmíÚDxSoŠâ?‘ZLÚçğì°
+¥½u¿¦Æöâ©ø´ª¬£&îÖ f'£÷ÂMÄÿÆN:³”š4Á‘FqÚàÊÃPã;Ÿ\É`¹Ï5eúW~bEˆ–Ò@ŞvbìèVa}Æ¯ÀfH~	œÜ«b*=‘>6d7€Ş¶nŒ!>>;A¯r×Ñ(Åº·§”Ç„ÊãÓ_dğsu£‹ñ¾Q‡et ÆX9“ÜÍ/áøù<èºY¦®`&ßßBÀŸÈ . ai†°şî_)Œ Ñ™wœ’ÖùVÖ7Üè°• x4Œê2Z.M9ŒÀô‹h³¦ %´ {µ-üLEHÅ7¥ÖÁ6¶*ãÓlŸŠ7U‹ì.VĞ{f¥d˜S{˜,•İKõ¹´R®0QZ:î\	:’µƒWüºÄE1u‰Fzèº¢BÆŠo>Ñ0ÉºD Ò´‘.ü}Ğ¶—-N‘¤,ø u¸‘òbpe•\é]Gïrë@:ç!o†úr¿Ä [Ëî±²b¹ğµ¨‰Qwl%tr&Út‘`aNÙbÉGY®Kƒ)oX‚‚:YâÆÉÔÛÈË“e€x"·ŠÆû¼À‚%œ¾q şN‘øØ‡Œ iÌnæÚœ¯Õ\É‚Y}ŠŒ_u2èkßäÂW­	çyğ‹¤”ÏDaò…¡N¢˜+¿V„Â‚Û]åŠÏŸ"ã`¹¯¡$L&½àhiÈ0+Fé{[×²~OÆÂ8±D6ÄG†Ó>×ça9×ğˆµD$Œè •=ôÓ¶…Öß…0‚aÖ? ­]õX",eÆo`võm6¾€,>¸`y‘hÍû˜¢HL•÷	L‘T$=¸3dcU$'&WØöÄ
+º¨¢áe‰ÍŒ“O3©IáGãP#8{”›øúšM¶H¢¯ÈZ·TæÒz˜àA¹ÛÛº¦a³î°Å†¸ã¹áèp£š«tî}¸ª2oléŞ‡—j¸Ö"q^hi™`ÎHÈ…é{ët « ˜FN>ô…|:dBe>üWyBâÉ²^MúUC,«"ùB/²×‡†\÷}Y le	_mL©Yd#¿‡z¸€"
+r{ÄqKÈ¿ò’>ğÿM­Bª‹ê¿Cæ®šÅ¸šÔs¸r+5/f-Â–¥d!q%~&»%6¹.(×ª}Krâk´¢¨0\e²)Æ¼fŒ”³–ÿkøO%ñN Ll"2Ä!ë¿X™À=‡5Æd
+ª õšaÔh°5:
+²9?BNß2;´@»Ãp…o“í|E@C’pÊEBu%gq<À›•Ló JşI¤Ç\¾àØXSé[[é0õ"æ/¦Â
+XÛ uÏ<ç/²uBÊG¬‹/	ü3rŠåi¼vF—WtË›ƒ°¾GÃEEò­eLª(é0&ã1pG†Å%{ía'ÄAK‹êºyq…¤Ò÷¡Ş¢¼™¡»p\AÙ¾ê&J0KÒÃKè)WãÓÙ&q xJ%ê•µ¢F¹m–pÌ\O…È:’&PI-´+Xb§êlzcgCR£c^8‡ÑXÙ3}¯×Å‡èn(_{î1¡î‚Ê‡¬µVn 6V¦wLOË‡hèÊ	ƒ„¼d^Â”îŒ
+®—À3˜ÈXˆw Ê4«4yGBàØ”jÑ˜Q ƒŠË§É@ê|“±	öü%	cß¥ÛûØ˜\)µàıº£"5åÑ ®¡^rÙ±	ÔÎB×.0æ…ˆûÑÉp&ş ­ìôb`Ím‘rjöÂ²ÓÙ4ÁgBek;T#5#o"_‚ç•»	l¶7ÂdªÜƒ…7CßA Ä§şMĞz¢
+qî3YµÉ™ßKQ¹#i\İ‘Íq<®‚—„¡Å»²¬şÕ+?ì]İİ—¹Íò/vÂÜÚŞÊ‡ÈÏØ	 ñ^(`‰ Pø­vœ³&ÒFâ8ã~µ|„Î²s·XÛUrÛ~ëCsØìƒP2$.øZn‡x«_yÍO©ò~ÜZÀ[ÚŞRSØÒá#”Ö–ĞcÅ1Ö@¶ñ½	@¬©¸¥×âŠçØCÔ}íPê.'un‹aq‚°éGˆ"}¡b¢Ø•Q*´•kËïƒŸ–bTÿ÷æGW[¾Ô·ûÅ·ù¶æ‡§Ÿ_~Ç—ür7Æâ`)p‹£B·d;ÉC[Ÿc¥.VIRdc0ø$4åÂ^®LÈôûâZ€ø#æ7o©pÉ Ü×ü<jíeĞ–çË¥+)X³{´±šû­çGÍí“æHkŠ{cÛ1%ˆ˜Ö"ÄFÄ½æñq%8tQèºùObñaï1À™'ûÊ÷›˜ßÈğ¯ŞÇÂp.u:ØÒ£¼ğŒ¸Ì´Y“Õ¬ÜRh´]¡¢›
+qÿ¿v„Tá£íƒçMfûÖ½ñ“doïğàykûWqªx÷@OÕ˜ÿ¡€¸Lyİ»ÛÃÈ§gÂì‹.¿ğËÓ8°Óò[
+<ñ«óz …Ò
+íànØ›D&_Ó“ƒlŒÛ`ß4t¯qFõİ	ÎçáÎºBôôr˜’Höİ±±Ğë@plKÑ0ß@CÛğ:C:&âÂ?áFW˜¯¸*¨aŞ÷‡±bD>RšC‹GeŞ0M‹e‘ì’ïªAy)3cÉ¸2¡j0AÚ&“ÓùåºlÔ‡Íñ:ĞO‹é1Ş´SÕ‰Åã‘éòŞ¤½}@Î]êÏçrhßúXÅ‘Ü‡ß_}yÉ—ús^½wy½Ÿ+ë 6"²Yº¸¨–éÄ¯*’[T2¨8<y<Ê(cZ
+1Ã¹REƒ<fág£›æw¥D¨"¤¨/0ƒÖ XÛtÚ#L!¶dD½ÅÚIyŒ†Ö‰‹|Í”¯¥‡mY~’Ûøm¤ºvG(pWdº13¹ì‘4( RÊi¥*\ço®òƒõ
+£Î¾äs[zşmIuó’éå%i-&™Sf‰Ú–KrÒ<>i ÑõdC²ÄÃT™_¤ÄòÚ;)Óòp:Ì«åû+¥Í­ĞØ|ÎÇîåÂ1+¡®Ä–ÑÚQ ­s‹	 …‹¿ds(föŠóÇlmL,gÑ¾$Ê3Åé$Óİ<—
+s‰ päŞçR¤ï÷›J2†|‹Vâàå~«ùOÕ_óØãˆ®T.ÉIı‡õdk=i¬'k+²Ã)j3|Q¼4ÍDÉM4ØÄyNµŒ_AÍ[0ó])@˜¿„Sb$¼¤HâÕmIˆä=–ÂdÈü†³b±LÊ˜%’
+Óòƒ¥+,»xâĞƒDœ&¿ä'sÄaüj˜gì„EÔyve=Ùß>Ùùi=ÙÁõe+É›Ø«äûo¾iá³L¶@Ìõd®:%f¡G3ß‡¨ßğ¬¨û6‰©”.-Ä!±Sv«XŸ³zÏ.Œ°òm’É?.#­á¡²Û xvoXÀQà_˜÷¹ä”¸‡õÛGz4Ÿ&®ş³/"pÕ]´LX™¦ Ú¶ÊTDÙJ5}œĞƒšÅ·Îm_¥Î07àŒ\}r˜5üÏ½
+×·Â¾¬áŸÃ‡^8Vø:ŞF”³TP+]hK{ºõ·klÿtû­¹í?üÏl–Iüy¥¾k6ƒ¿§&T(’¼ş¸\¿MêâYÂ³àáÀâÅ^S\ğÕÂ>"qÈ-¸Ï	®-d„3,üÍó9‘.ƒ<a 2&:2»RC,šÙ¢ÊÉµñKeWÈòâôa1Àğdoi¸H¶˜DÎxa§bd¬Çùş›J#s9ä–üğ)_¡#şİ†´;Å‹L™‚. ûí3’Æ”ÒzTV!¨ëêã¶æ»l|Ÿ¡¾C¼®à7ùé9$I~e@ÛìÇ×êKl¯'ß
+-Å¬œ™c½!¸öãÜ3pÅ1©mD§™^(V:q•‹~«+cEÖR[q–¶µwğ3¾>Ä¡;(R ÁÅ\ÿjtTwñì·^lŸüDşIšG»‡Oågó×U¡ÔWŸ×uO±ıB<Œ_¾•ØşÈfˆ““3P#‹lËÜ'uÈ\¦bWhõ*+ıÂ™>nóÍürŠ„JÊ (RÁÎ"ÅçşŠuàdñW
+`X0åâÙ5¼`ˆ|Dº.à‘"±ô¦ÑˆÌ < ó;A~ı†3#”ôŸ8\šk£:˜œ!t?&GzE^
+†€“@Êx¤V¾ĞÉà‰?§ò‘ÓŠ©í¢ka(È!.FÌn^‘:w+:!"X´"ğoÕe	ùQóyI~ıöVs±´ÖØ(4ÆF·o\hdº :æt-7M«„Êæ¨[B|€;”ßİ²µÔ-µ'ÙNûìL 2›pZ±¤+˜M¼J ¥Öó	X	÷bìç7GÍú¸]û–mQ³ÔVÎùİĞZêÄí‚Çó`|9ß_Á½ÆWğp€ñUœ |%?8_ÇÕÌWòv€óÅ |1Ÿwáv]ğÃÑ²TvˆİqG2ÜÒsëà5NLĞ‘øM²Kwàª-–“Ïpy´L¼·å~\$jk¹ı¸Ç†§q‘è¦åN\´ótıòY\´ûìEW^„Øß;ÿƒëş-¬FBï/ˆƒB&œFäà!“¢MdÎœ!.\Z,®J½§~XD4|’Or..|©°+êÀ)+tÅà9œ(—B"i²©ÑªÂ¹¯€Ê‚É]ğüÊW±Õ3âª/‘¶i·áS~%Jˆ¨¡—aR1üa mS%³Š?}şcÀ9ÅlY@ÍzÇé²G$(Y¼%ºü@ xœ›wZ2¹dEWÈ= Ş‡kSü¦?LáÉ`ür,=Z!o0bœ©JxB4‡vğ¹/Š!EîEùµçäY— Ş¢ï.ë}}ç2S>ìä™pÀãVÙ#»|ÉD¾¦çéÇ6m‘S‡[¾K¡{{«Ù´”%­53r¯ñk´b›T†YÜŒ€jaØ<xÚ|Ê…2¡¢™®œd]ğš›ToeC5lÄÚİ” 0Ü…]e6Äéeô'Cî–>ü^Vß²næyš'|ş14*nÊÃiéEÄrô:+Xk¡ì}”T¥ƒ\æd•¦µlG‚XDb1½¡$“øå,Ì¹<»èõáÇ	9èĞP9’$íñ„»¢¬{Wi·óú!?X«‹Eˆ$N¡ª%Ÿ	"VÈG¡èËÖ Ô¯T4y\äj”#
+rØ°Ö¶Ë~<¬!è¢c¬ªßÕÎÄê-½6È!‘{BCÛÂ‚Ë6ô‰îÈÎtµ¢l0@²(Óáç>°¯cáe|0Œ¸cÁ+w¦HKS9ëg£´~|òôğåIëÙî^óàĞ&Ÿ”a"z &åÆÙ9qj¼Z¢ŞüuÍ·w÷^5Q€y­U_d¯Ø_ÿ6NñTX…
+ZÕl¿"ó'=VÁ†$I|¡W¯I™wÄ-h#†døn§ÕuÜñØˆŸI¤#°bÙ},£xß-x
+¬G&\Kş²ù0ÂëæÊcêP•«v§%B;Ay‰§5_Ğëd˜¦ò,”ıvÑÎ=5Eó	¡q&>'ºD¤XfÈDÊÅ—o¢hYÊ†qriùĞî¯äkˆ"É’J$Ü);…zæ¢ @Ø$cÓ{¿ì>#35ŸÂ}¢¤óŠ¸äŸlŸ¼<Åî˜TÀ—	Wõ…L‰u
+ó._ëc8„¼.š"=3ïs^'}ZÈ„ê¡JñaŠ.ÖJ2lS–Fã¢õkBnay)1_ax#•Ùs­iº’Ê‘jãÖÊÉP]öuÊ	5{L¥@öTcr¹Ä˜j«ôıƒÁ0ĞV`~È4û—³¬±™•Wr´Æ¡ËÑ`ƒlP_í¡X[GO92ñ¬³’«ŞYz*(ÀİƒXÿ…â’^å8°×‡w÷½‡KÊ¿‹ˆQ—v;‚Z…|W¢§™ÓÚ¥4	‚!6ìv¾ï³Á%“5ß·‡=.µÌ.0ıHÏ!i2¡Äõ ÷£<İŞCì6(LËè_“öè¢;’œÚRodQòG’‰èê;d&ÒÌø¡ZÉYÖÆIù?eÜú-ï9±*ˆ¸û£ª/ÿ²­Ğÿ¦O°‰›mFTYŠ)¨>ú2dÀcqg3TÚé¸ğÊ}8©àÓİ©ŠCŒ~Ú<] ê¢şmœ±‡XFÖé90Cñ+è‚šH×‹_¡ï]ÌĞ÷¦3§5şß+>DyiÒ¦[¿éu±7ŸÿóåöñOÏ['GÛ;M_ÈkÆ÷Ç…m9ÏswàQk|»u¡[çïÆ—lTÛ'‡û­“W/°µÿÁWô8Üƒßİ:œé:È®Hüû\ĞéN’ÌjILUDX!ş®H·õŞãê_)£çcÊ¥"×è¸…Ñp\×4¼ğ¢)ŠrH‹Ã~y°}ô*·7“+4ÇÙ»t`Ám6´‡×­ìê~võö>(Ë`ÊM§DôRm>²^t³ˆwTW”«°{ë_èçó¼Ñì¼ú­óÊÃl#˜,ßs†2×•şÎQZ„¤^Ä;$§]7¨äQvHÂNUnø#‰mE^/2…À¼	Z{‹ønSe2š2±pñ@üòÀFoE‡BAjÅ Ü5^¯Ùf`ÎU2Å&dÛ±­ğíÀø¶XMva%¡o¤¼03æ…“q´Î†”9mTsL¡g¸ \İdÀaT¦<­v5¯ğ`<Ñv_±Üç@ÑG¾W¢snªß¶Ïi’­AxœİBÒq­ºş]Wp”zÇÂ<äÆfÇ:ÿ¦$ğóÂ7r¢°š|;èôºyhÔ”g” ?K¡İEÚgh1äñ¼Yï.ºåÓwş„÷vT>$>XıhŸS›D³[ÑÇ¡¿®MüIê«ĞD—¬ÛkÑö0¯~]ÖÄdÙ>Q¸òsTÙ&Ñºòs^]Jw òQêó¼VZÜ(<Îk7¸¹ìf(Bø1*ö,´~Ì«';ZS~Î«fZR|Ğèáºø»2GšA”Ï”>S7y@“‘´±sÂmó´aşá;Õ£2„k³¨`^;e¨]T0¯]Î3ñ Ë¥ó äõ^*œ×Şø'j—ÌkIvŠš…ÇymÈZQ›ğ8¯2YÔ**˜×n#&Oör>“Ç\Ó0¦z#Xt_ã	Æƒu××€/¾‡Ôk/œµyÌ{¡Ç­õÌ÷.@Á›ÆfÓOÀ]eSìfítÄÊÊİÍÀ<;Ú~¾ß<8iib†Œ?ÎÑĞP	ÿÚ Íf¢©} ´EÊ)\S­½g^çî]W@ıBmÍ&vØÓPdÎÁaëv Ä±®ÕYkf»ÿ¡}=jàDNööŞ/Û¯ş|4¶‚©€SEãÆŒN0€[ôS³.”*ÄÌ¾¸½5Ê;‡û/ÑÚ|:ŸÌr°_ùÅÈŒ3Ù1 —·exjóâÌ©Íx¹›ãq+3ÚaÊ:uûz"¿ÄÉ4ÄÔB=¿j…"¿
+P™ç1607ÕØÈÇàĞ>Ü5¥å#ØÚâY åÎk>úS²­óEqò(Xúñ§“İÃƒ$ÙWò¨C¨EÒIRPÁªQÑÜÊ)ÁD#ÈoÓâ£–*æÿŠßP
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/35/e1a18751707b926324a82ce1f942514c7fec45 squashfs-tools-patched/.git/objects/35/e1a18751707b926324a82ce1f942514c7fec45
--- squashfs-tools/.git/objects/35/e1a18751707b926324a82ce1f942514c7fec45	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/35/e1a18751707b926324a82ce1f942514c7fec45	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1,3 @@
+xSMo›@ìyÅ(•ª]çÃÆv2Rãö[”4§Èµ ãv]È¬QÒ(ÿ=ïíb„Û´‡^ Í{3oçÍ’äeo4=7b^><”Åp~3?K«Jˆ÷ºHóİ*ÃÑ­Y}Z?ı8êƒÜÇHmb£S¤eQÜ]f2ÆO*^—ù.0züòù2&ãQ(D[Sy6û'yv?>÷TiJ½‚Ã¯
+mlM*ñ,€u¹…l™šCh|éãøXQ·a?|K=:´ˆ¥êÂ`ãxâ!6Å½†Üâ<Ë`ŒŒ"F¿ufœ$åuÆm}B]Às}szAR[Æ_Ä‹i×µuiı±QrXí’\§3jbjW‘
+Ïn$d%|_ö;×wW­b“]>™Lò‰Ûâ²‰ó]FÇqk—¶¨¤ƒûLôh6¨İKÆIsoñ|4Nş·©²QÄ¦H#'üåÉxŸu«ÜeØË~Ú%0¢õd‡È hÅÇø›	jGùÓ½‰·FÑui/Ùÿ’î×°{P6ñ	jı+[ûj×çş›†òq‰ğòÏ†8¨øNöÅJÜeZ-DÁ} Ú_s–=Œâ¡°•¼…Åº[ÒğÚ^ñG!ø
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/36/8328c67e8360a1250733f9a65f8cf66c36a6b3 squashfs-tools-patched/.git/objects/36/8328c67e8360a1250733f9a65f8cf66c36a6b3
--- squashfs-tools/.git/objects/36/8328c67e8360a1250733f9a65f8cf66c36a6b3	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/36/8328c67e8360a1250733f9a65f8cf66c36a6b3	2022-01-01 15:09:15.649172590 +0800
@@ -0,0 +1,6 @@
+xUQoÚ0Şs~Å©}-]I
+¬íCKÛ	Ğ4èÃVU($¦X¤v•˜Š®êßw¤À†ä“’»óçóİ}çq¬ÇäûµÚ‡C©Âx	:è
+ÕÖ‘H>OçPNT$&4u÷.FßCüI%Ö
+ø,U³şüñ§xº’©	T(Rª—mh=ßqàadH¡V©¡Ë_Ãkšu¥I÷ÅÂdwŒ—}ŞÓ9½Ö\Z-Ï%ß¥—ê.QÒ„ğOã­µ¼˜pºšü‹K›ËÃyeÙKïÄ¶è§.m.—(ËvôÁT'fçˆı«K›«ŒÌ'İ1/O‚ËiSŞ¶É…¶Óïvú×ô¬eD™²£¤©dŸôñqÔA,ªRL¯«¤­Ö¢·-»oŸ"Tº=’=0¶>?ñş_ğ¶¤ûà¿¯ı^èÈ÷>Øå²ì…œ—søÜ·Ğ]¥3Êüú¡ÓA¬Í¥4)5×¬¼’aW?äÑäŸ-©ãXäÆFÓqÁ@‘(ºíô‡'>Í˜Ïè”ÄÜÙÏâ†û­dãW2¡eË.tóŠnZÑ™yfHñ:£6Ú.Ğ+chÆ$ÛñÀXñ3gö{,@°@V€ã± Ì
+à< ² ÒG8VxÊ°pT,€´8ŸV ç7Éa‚g!éPsQ²¹WÏ™²Lì7aJ•¥>€¶jóÃ_ttN~QÉ	U¬âŒx0–¶¦7aæ({ñåï¦7‘×rŞ
+ÑZô¤â1W·ÈôÁ‚õ•YÑë“bğò8Öq:Ô&ˆµZØ‹ /bù l?Ö×˜V¹ê"ã©¤3”ª€d»‰ìáYŠí,ÂÓ²ŠñZEe›W0"ˆÜˆ—§V …åfÇë×ªâÑÙn¹wL~[ŸØ¤jOµÅòÑÊbªmó°9Ëì^	R†‘G`J+Œa¤‘Zm"á=ı,8Ë7:Y‡Fu8e$Ä>ğ)\vùØ"ı×H<q¬ß{0¤†Í¶÷9¸kêHªBåÁ³­•ÁØa?¶Ÿr¶…ŠäÄùi3©
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/39/3bb8afea057d1b60279facc88a9a5f362a33c8 squashfs-tools-patched/.git/objects/39/3bb8afea057d1b60279facc88a9a5f362a33c8
--- squashfs-tools/.git/objects/39/3bb8afea057d1b60279facc88a9a5f362a33c8	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/39/3bb8afea057d1b60279facc88a9a5f362a33c8	2022-01-01 15:09:15.629172589 +0800
@@ -0,0 +1,2 @@
+x}T]oÚ0İs~ÅU÷£bíÃTºI¶k´†¢AWm/‘q.ÃÂ±YâĞfU÷Ûwš :^ˆï—Ï9>öBêNO?¾9>†k¯¿rœ·Bq™EGışñÍO_İé‡şê¨òføêŠ’˜Ø$8ŠÅ˜nGšNFÁål:ò.áÉqL¾Á—pç+sò<Ÿš‡×*5up°ÇïL^éd¢“˜Iñá¸e‹;èÀù9œĞß{‡K–¦à50\{gà l²…šèz‡Ã34“rÁøºQá½PnFƒüN­•~P~¼qh`E%ä9§ıÆÙr‰ÉT§ÃWR3¢3Yˆ3b½@X‰Ôè$·)xƒFgl¥%=nPÙ¥^ĞW,]µvÈI–!	BUAîéxj’ó&ùšâgˆÃú»(ßjÁNj·cç±«qNØ<+q€1AÜË¾©'øŞM¾Nnï'¡Lnsó†Äq6¿.ç×·®¯„é¸şg¨Œ`ÒW3“ ‹¡+ª¯Ñ®#t-¸|C‰,Å²¸SÛ¹Ş"Â~<tÇ¹Á|ASXÏ®h÷ÂŒÖÀû{•§[4£ƒhÕ÷êó/ÜS/¤ˆ‰•r‡(¬\ŒšdñhË„d‰Âœå•°Iè=S-”Ád®½,IHªì\„³„*O6|µÃ¹FÜŒ¢¨ôé—:!9¨ıUmÓn-	ÈèİhõSS¶ÓÈåLq"»'LyYçíN*$dtW^±RS_·i±–÷j³C—W·¼œ»‰É˜,½^*a]3–š¯+Ÿ7+
+Ò­§|bÎFûıiwÿ=˜´—ÎB®.n}d¼Zwà	ÂzAÏ_ı9„gç™dyvşG&Ïx
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/39/7e17c0791dbc6beb25a248c6585d1754149077 squashfs-tools-patched/.git/objects/39/7e17c0791dbc6beb25a248c6585d1754149077
--- squashfs-tools/.git/objects/39/7e17c0791dbc6beb25a248c6585d1754149077	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/39/7e17c0791dbc6beb25a248c6585d1754149077	2022-01-01 15:09:15.661172591 +0800
@@ -0,0 +1,10 @@
+xW[OãFî«ùGZ©J¢p	°tW©ªf!Y¢Âæ"„ªÊrìq<ÂödÇ6VıïıÎøš¤}qì3çúÍ¹eª%}ştñËéÇğéöÛìûb0»Íìëƒ ÈXl;Ô¡ÙÌI?Á;^ªõFËURËmÓéÉÉi—ŸgæynÍóÂ<3ÏOæù™Ÿ½óì±.|é‘î3í>a(×t£²U 4ı¾Î	&…GJ¯²§?
+æLh­ÕJ;áÕ×BP¢üôÅÑ¢O•‘ëÄ¤…'“TËe–
+’)9±w¬4Œ”'ıÓ2à¢)¥BG	)ß||½[ĞWí„tŸ-CéÒtEœw`‰I <ZnŒÄˆ}˜>ĞHA±“J÷IH¨×ô,t‚o:í²
+¥©å¤ìª&µfÆ6üÛPèÀ’÷èxë°<’±1¨5B A½ NZ
+Êág¡±èa<¿,æ4¸{¤‡Át:¸›?öÁœ
+§âYäªd´%˜Ú‰Ó0ao‡ÓËkˆ¾ŒoÆóG`4ßg3M¦4 ûÁt>¾\Ü¦t¿˜ŞOfÃ#¢PAø¬à}LÉ‡²HiAH&eà¸ÉŞ…Î³ÀºB>Ã7‡\ääOŞV¨â•	Ô‰Ó'éS¬Ò.½h‰I•rëÙíú*»ôñ3Íàt:® Cše,{v†ÿ¢’TÅ]ºĞÉi¯×;ì ³ANôT%t_íñÁ24sSò¤¶eì+ú÷ÀrG[–ÕY;i;‘è×¤$[2”,Nä*2N-ËEÂ¥o¨P*ÜTé]fËë=:Ä«fğjsÆ©ÄñbÃSÁ6;|Œ·}G(¦_§H(ãìÕ(ù¯¿1¤›ï‹êp…½CUœ¤¨eG{v¡Â;+O$­yßö!Î=ßK‡Aû`cñŠˆş×–8„Â<<2ËÌ¯Õ×|V'Wb•i ?á­e•nßi.gÑR0üÛ‡10}5¿Ğu"2OÙ²qwéfİH-œÆ™V*å›Óh(²­PáË°!+Û×Î*oR³:á‹³Il´—}§±ºªYc5ÊA;îp«ŠÊ|ClŸÈöÎqY L«*À”,?,ËĞù{Õ /7©`—$`¯ßÖ@g*÷É.²¸¦ÊX}%y–Ñ"GÊW© G3Ò\mpŸ’,ÚsTJÙana°÷ÎjN3 V*#a¢8”Gi‘4Á+.‰3±rÖ¤†Ä€{…Ÿy(ßOc”æ°ÆêëÉ¤G©³så0¾²‡wóéx8£ÓÕú ò5VŠ–ôÚ„ıJ­ç!õÚíšw6°ã+êmQ¾‚rZµ¨Ø	‚LZ³Çe0P?tVœeá{T”×.xèì&á"g½–È[L· ã{L«ó0§ÙFì&uø¤6ÛdoØ/A»ŸW{4¾Ú“ùõpjÕ±7Ïî§“KŒR8”¢ã™s´œ¶eµğ<ü£Q¤MTF»ĞÂoøq1{îÓbüü†±Í™Êƒrñâ™¼6‰t±:å æ¼)aåt²3ıÛŒÛ‚@?2‘™-AóÖÄ‹çqDµ³Îß†tş–>®¾Û·ÃÛ}‡_¦ãùğİãÑÖqÊz	Æw#r1ƒ$6G$Ò³äJ1+Ìm5ßD­³˜»Ş­iVûcº™<°ãç¦àóúdM­CÖUÑµÎ)a92dÓ,a¨^8{ÑÏ#ö€Í6¸¼›@~¹™\~³'£Ñl8çŠÃD:.:
+Vfôêğ¤ÚÆó…î"İ‹ÖRSàĞheF _öïB|i¶©¦ü¡¿cÔÜ;uReçvaïÈ
+^„ó\Şx¢"»ø:°˜}Ã7xáU³(Ãÿ¸ê®Õ­¢5mÍa—3?ìÚÇÈ‘qÅŠ}¶#ü½xµÓªYç„.yÙ:­$Š^RMÿ
+Z3ŠP›æ»+V^,vå¿WçèŒù€°ó~¾}­Õ¨£<
+ÿú{KÎDà'¶ÉĞ4u©š¨]^-»ô¬Ğ’;íJÌ|;ğF#l5¸÷¿6ÇurÛCª°cµ‘FSwácŠÕÀk5UÕ¬M*­Djc|ı,ëê}^FÕ Ó€&‡Âø»Ç¾YŒå ·Ñ [<¬ŠÀ!ôğ?åWi
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/3a/1d0fbec868ed1ea1034ccb53fc75b1d141003d squashfs-tools-patched/.git/objects/3a/1d0fbec868ed1ea1034ccb53fc75b1d141003d
--- squashfs-tools/.git/objects/3a/1d0fbec868ed1ea1034ccb53fc75b1d141003d	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/3a/1d0fbec868ed1ea1034ccb53fc75b1d141003d	2022-01-01 15:09:40.213173601 +0800
@@ -0,0 +1,6 @@
+x}Ô{<“{ğ_‘¹”3tYÅy)­“6µiH—©˜nH"³bf¶=3löl˜0åR”Âé8($Ç­œ”nTİ\ºÑM½âU«ÔtNJé<«­3—×yşyşyÿ>Ïïù½>¿¯HÈb™[—Ú "`K"™»¬w¤¸m¡€6Ÿé¹h÷dWraõ~ÓÌí«¨æzHä1w¡¹®²Ê¨ú]Õ{/ZFZÂ6~SZU	®‹ÍfØ[e9(OßÓÂ5ÄÑ¢ƒw¿D¨Œeµ“+eQH X²=kƒ…EíHè¦#¨²¦Ó$Ù*Ä`Š¸üĞEL`“{v J Õ;îk?GWHëaG‘>yV…v5ÿ=ûÄãmÔØú !Qe˜&Ä‚­ÂÄ,1ò
+æÂ"	ºí–Úã­›ØòÌq‹Ü•—şÖı? Ğğ@ŸÎÏÄØyõ¦~]5±!¯÷N½€"²`˜/D‚o’›Š©úw®¼MNo6šAöaurjfÍ	®:7PwÈ‡9zTk¯Ê±„B$
+±áĞËß=;+ò¿¬Ò¦XE9Ğhê=r¢¸z„!°”EQ…œXËæg;Vš:kîü°¥ª°ÎäüµŒ­µ1•{P1{’6¥uª$7”ÍG²$P“„7˜òuµxˆ=s8CS@àÒÛesl³Ó17Ó´”r§†ğOáU"8Š¤±­ªèaƒËÂœ„GÖ9nÆøÑœuİ‹Ç¸ÃL¡¥Õ^şÀs-ŒYóëâ³[rÎü€!È¶Ş+çòæÉ0kU.LÄ
++	$º¦ŒŒÒÀ^Å;­û,†Uò2â¦³{E&?0_î;ôÑ›9I1½„#yÕ×3ŒúìXóz8·-µ†t\ëóFæQ¹—ú3QCxp˜˜Cle½’qÕ´½êÒïö›2œ|“¨î£†ƒ€}ìŒZ‰Ù%{t]#Õw†çÔ4õ%ùL¤Tt¶Á	a…~k­gioxnÛñõÑİ±œÉMÍú¾ªÏåàó[)‚v(^8:ßq Õ¯ Äç|ús”`(û“E9åßA›Œ‡.ü9ğ¥:»eÓËmwä-î ºº\$şÔuÚGgMPC˜%ThŞ«óD^¾ÃC¾U/\kÿËŠ·İ¦#jïÿó~/zÁté„tzf»Iñ-©®ÊYŒ@ºr‚ Qs4`·ÏwØà³äckW§`Ê³Nz»[¡c(¿fÔY„k¦V8İU—ÿ{ŒÜ¥œ<* l¶IóòÊ€€ ı†ê’xÍ¤H†H$T¦­Aó·¶ÅˆâeòÓ!Z¥äšñ…Ê}ù-áÙxÀi‘<¥Eï+`àÛ–B°1Î×J5Õã=ğ9<E×]wÎm’
+!£B„Ä$?ÎsL<_uïf2c·éì_vÁoh
+du4|ÄÍ7´ò’<®§íùüµÁh­Z¨ÚFg"ã‡!Bş1şä/®;a#İ|Üë×šf6#í„€egÃT?ıûCåf<ÙFÙŸ¢,êÓá† ¡ïjnŞxïİÊ›n“Ÿ/“I°ŠXu¦R0¥¹µE(Û–»Ösª13\{…%ê¤JˆC¿ÇYw¥¯#ÅÚln »Ô¤]*fÏ5y'í¬÷n8iæ:yWb½ÒıäÃç¯Æ‘vKw»Â» o%Êş`‡×†.mÊJlïíHˆ{ÕU.áë%­¸°Mæ>¿·àZ§aã(÷íÊ:Ø)¨ÙfŸú’b®wñ> Ÿ°²¹ã¸E|!—L,òñÕ-Òş³JçëÅ®zèƒc1^İºèüzúúLÌ17û}æ«"ÎŞ$¦«&oóÓêJÖ#¾ÁÅ%'Òæ=›x0pLèwA¿/?G·è¬¤İ•5úîté·İ~q,şVkä|Ş{R*İYüìKÛ{Ÿ² ó`±—J«É–ûkÃ"¦±NÜñbú6ãgGdøc=7ÂU+EÛ/É]Bûe—gª‰æÜí‹½š™Q·¹ï1´Õ7±ì©ökCêXXÊË{îÑöúuÃÏZP›Ãûç¿ø§XaØ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/3a/2c9daedd039f572fc9ccacd309e6e818dbffcd squashfs-tools-patched/.git/objects/3a/2c9daedd039f572fc9ccacd309e6e818dbffcd
--- squashfs-tools/.git/objects/3a/2c9daedd039f572fc9ccacd309e6e818dbffcd	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/3a/2c9daedd039f572fc9ccacd309e6e818dbffcd	2022-01-01 15:09:15.605172588 +0800
@@ -0,0 +1,76 @@
+xí}ûwÇ±æş¬¿bŸhAŠ”IJVœè±G¤Ö	)ñt’®.‚,@ Ğ²Ìdÿöı¾zu÷Ì ¤%{÷ëØ¦ÕÕÕõêêš“áø¤º·õİ½oÿÇ7«Õî/çİ§£Şí^µ¾^íşuïq…§ñizckcã÷ë[ø¯úCõâíxZíwÂÓşÅÉpĞ«NÇçİÁ¨ZıæÆ¯£Şğâ´_=˜Í§ƒÑÛÛïİ¸ğ_ŸöÏ£~uøı«?=>bë¶ò-sViÓNtY©şş÷féÖJ1èé`Ì1¿îNg>¿ñ	¾ûMYúl0:½Â¯g±Úyµ·ğôğğxïÙñŞQşl¹7—¶]ú†7fóîŒæÕ|>¯V÷*F‚÷ÛÃqïıáà—ş^÷çªÓÙ¬<Š¿üaïx{÷ÕÎ_üõéñö‹£Ã•j½Ú\ÆÎUç÷ì¸¹ù{å£I·—àW
+{ó»¬É^wŞ{÷x:í~$ÖbCiqĞï§§@P[uÈÇ{v¾?Ş}ú¿şR­V[Õ­êÎ
+~4ks”_^œĞ“Á´ß›oæ³ªs§˜êÆ©Ùº›ğ@ÙŸºÃàØùáÅh~gkE(õ>5¯{àØáÑxŞ
+¸ÍÍ®¨µyVQÎ^)ˆùø§¾Àú6ÚŸO^ŒsCï}¢zô¨\1rĞ?½èA"X6MEa:èõßÎ”BY=ÚKe‰rÙ„øi<8u!~“Ù11ììÛKQµ:Y¹qy£ª&ë†ıŸúC0è·÷õùtĞ›ËZ?díyOyW›ò]&úïäDÿíßõ×™•œÈhÙèâüûîìİöÇy%Gï¦ıî)Ÿ×7màÓÁ¼ÿ’Õ¾G9æm³y9w‡`ÙS¢Èùœ|zapVu´üAµ±M|ÚŞEşõöèŸÈ”V8ûT A½êÙºØ *›wWV ­ìáÃê^´ÛúVj„•·î­¬¬dƒ{• IüIó;yİ$Õq@'cA¼Ÿ¬ÍVV'‹äµ¶bA¢¿D7s,°˜Ş^Ö5Zÿ­ïĞÜ»›··E÷>Á`¦Û¶
+ñîEáÃên62¥¬FphgóT¦"w+ü‡†FËü0‚³!…Ë³â‡RVUí&í+(¥4ÈÍ›Äˆs]Á<I!%(Û}İÎúOX^Å:ÑU³•‚û¼?bÒØéG³yU—bÊ7ìŞ%à–UÖ€;Vå‡ğA® “İ”²Óşüb:ª¤à¶³¹ˆaf EÅï¾z~¼}x`¶û‰šôÁ¼:ƒS İşÏYµ³ÿƒ˜p7¨yÇÌa†»ã·fwÆç“i6«îl¤&hëøàéQg2­U¨^©.«‹ÑlğvÔ?­†ãÑÛjp¿:†~<ìuGĞgÓY¿ss°†õÏ XìZtà‘Á
+…Â 1«+ÕM®T•Ö¤ßÏ‡ãù¦Š°„Ò¶T JlbÇR#¥´ùGŒu«˜Làâ†8õ*:Q¡qª­›!ïWä³6¬8;eÂ€L³â‹%‚Â@{®Ì \Çgşs<_©¾üÔ£}¹:=ó
+~W³HÇÏº3RVlMBµúÖË”ºÔßÔy[kÕäg{4Z½ŞxãZ/•m²L¤
+MÉ„ïKH÷ˆ•#
+%ênİ¢
+ (U•-1íºNPÔ‹²‹Æ?ê“Œş£ XıÈñîW?ŞºµVõ>;$¼{Ä»C:¬8Â„òš>_ş&s€ıÁº‹ækÒÿfõ€ÔÙ ¦şÑê:­oU°>2üE&§`À1£à„
+ôZB›l‡Fƒ7Â2\joV—#mbÈŞœ®ùr&Ôœ¶mÀ{p“zuQ‹©‘Ã$/
+šB¦z°)å^¶,æ='yÛ¤€‰Ñ/æş&¦™š~Q&šÏ.†Ã'ì#F=j¼öUxs•¸ëæ'ğÌİÅÁÓıÃêîó“>¦ÔéÎ!v.ıû©Û·‹Ş¼:Şy5™àyå*pBgma}¤[Åm
+à@Š¡ÉÚ|1Ûy×æE0Fh`úî£™(+:ÁÎÅÊí§Ö¬V4{]ÌñÌ¶rŠ:v¡"…QŠ-ˆ8`›PqEİnt4Ş‡à„f TŞ‘åPM¢6ï¥šL5b¼ÑZŞ­¼f6?êûfÿªÎû
+S´n”¨=ÂğÉØVRlVœd´Ît¸”íugï1\­cm“‰éO©®e;õbtÚÿ9'œõ²n3Ãc{%¨ü¾Ñv½zß„^[…BBc4@ÑB±§nÜ…ö^mg”ïhÛ5c³„¾ªeõ&µoaÓ	
+s[ö»i’Rº»#¥ßÅªjé¾µ-‹){ûÛøxŠĞvÏÙ¶()Ö|Bî?È‚ß	`ï£âğãùÉxèŒœÊÙ![sm¿78m„ŠV@Ö¡èûÁÛw)MÛ†fM+(ï’¯±beÍe»ViL=ĞwĞQ–—A–5ÈÂ/^VIìê•\…z:Ä~5	Áê˜ØÜª+Íä—çõŞE]š¯•‰úK<8HZ¬äz}¸ Pp9¼óÁéÕ]mQk]ßaá^7Q5(è0`Ã,Ø¥²šdªX,C¦‹‹Y¼ñarÂ
+6¦Ûç®3ˆ½ñ6Ó…0EÑM	ˆ´á
+vĞ½Eˆ¡—Û°)Ë8x£½nï<“{w±»øà8àIj©ª£ıêÉÅYñ°;8/·»3iıâ°ÿ·WóÃ9âçÕêØfĞ±ï‚©ŸõOYvx ³£/Ór¼ôÇœ ÷ÅHÁn_œÉÌ8–—Ug£BÕ]¤úİ§İyWFÂ|0ğ†©Ìºœi$SğÙûx€¨MGBL«“ÉZ¥¿	ŞºìªUş«®¼•ô.¦¤\U©ã˜µa°M¥Ü(]™OÉNgıP„ßhĞt»@Ã]”)TÕyÿ¼7ùØQ¤P¬?¼G×¶ÕúCf…lYİ*JcàfİÙĞ¶v‡=~õGì
+¡_2l7>ÁBrŞÜ„‹àf^}M­
+äÍÁ­‰é`vĞŸäİ„\T?ß¸ªÁæU¶®h°±‹}wŞf1öÅ¼'ê;Ù™‚ €Ğf¾Ö›×İ…ÿà~V€bf¢tàZÔ}„fq|2Ü%é ˜'•‚ ¡jA.dV<íOğX²Æ¦ÃP˜é*úÛÒj)UĞ¸îO}a€6á¶˜Jµ0ÏúÓêœÑ{ıÍõW9Ì
+_`;ŠŠE‘«íñxXK”Vø'ƒ½7Ï¡ïÉîÛİ!L<k™·S=·lDnö'İÓ×›[ß	%fU¡“QeL?ıâ‹'¾&1+kv.¦Óşhnµ©šA şl.¸a)ŞÎße}GğD»ƒ©DkŠÿÔeî¶;¨0º0÷¾ü è}¦õÂ°¢AÓ0ØÇ‚)ùü’”{±NàY˜îtDÁ½4õ òÓœadmûÆQ™cç/<ƒÙÌ{`Õ|êİÓÓÁ|0u‡¯ÎÎf}Y^£ÊµX6ÍÇDÙ§„	€ô…$c3SîorüN}s» €²èr#äË}L{³º¹Œ…Ø4IE
++öÖª!,Üä„<’Š'Ü7±˜ÿJ—¤ÓÕõ¥ûï¯ë_ô†pU¨¨XÏ wo²ş¿³šª‰Fùy—k+ø˜£ñØ½{w½-"ûÂèÆÁ>Ì`4˜½SQúÅp>Ğ3AÆHgàNíL!+’Ôœì|ì©0€wáG®ÌËd·º§6ëÿŞ¢ûœ*aØªY2q0xfÓĞ(?ª<æq®÷}wt:„Í°³JïèÎ¢Á©VÍKL–´Z=…1€×v^6¸†¥œ ğì“VÑN§º0êZ©…Øp­5sÀşeXvã~5°p³˜wDæyˆÙİTAÄ½ÁÁ¨–õGù#hDã‹R=,L®®Á8èOÔ-0EI)«P`ÿX€{©Òcµ±k’nã·”&•ŠG,ÀÓ("¿Rwqƒuy¾‘:ñw­Ûó…7³ø]ïˆ¨8×¿‰äsWÈMş®wD€ªÑp'V:Ï	@VÜ$÷dPYV Ë«Z Ná·
+ı‘ºò¹¥½ïo¤Ozèlü|gcƒ‰)”-hG†ÚXXL‚ÃªĞØ÷ÎÇSu‰¯V&èÑ0´—†VQ­qSåşWÀÍ¥4-¯”«]ç_u÷ÚÏÕ	_\'˜ù]®Ä{1+|ˆyæ4„¤‡w€£ÕëæF,tlAó`Á?!w6A‚TÄğ6RvÙ†Q­8ÑšIÔèñ@Ô ]Çúè! 2“´§ûlh¥å9‘çMHfä‚w`õf
+`==8xup¼ÿøàñ­4uŒŸHPö«o8Šô¤á9\[?>·XóÁ¤şL6RJ'É,úV±ËÄ¤1ÉÃŠZ£E±Ï-š×ÃõÿÂÑe
+ù¾€u\ª21DïPğe™d³ÙúØ45³MÊtˆvîÔBG§IMbÛÑ$£ã!·#JÛëc"S
+Fä	râùçü¤İtú—2Ë¼ÓM½™b-ªª¨a„ÕH‚Hb×¢ÙƒêîB :‰¼¹B$m…ºõéçMAµü‘=aù[»õ.,¡2g-mšï™b%óBÙz,
+z!?A)7êØK[¥ê«‡Õñyz&”Îıaë¸—‚mYêªhÏ© ur³Ÿt‚	vbPÃ³Ï˜'Ê>)Ê–DÔbÌÜ` ŸX5×ßï"[rÚ¾ìÿŒCRçÁXs	¿7şƒ	ƒSzg­º»VUßâÿ{øŸßşã¾Gø3Ø2á+ÂşİZÕüoÃ•ÿ·‡I]Z€·V5ÿÛÄÊÿ[¾OçG æ¿_«šÿ•€9€ÇY«¦0‘;ÈÄ@*Ğ
+6vÌlòãc¤û$dJØPÿµœ£"6Æ`3]´Åºä
+2X€™IVNæı‹Ñ¶üó0C µ‡4âHûaÑñÍ"“7:) ‘%şÆT’H¡ÀpšEÅ¥%YRÀdÂ‹SuàÓ#“ny§^„ii	 1ñˆ•Sòîø‡hv·x&Ùî6­Í{+Î˜d÷@àñIóÅ„Ö§øEŠ«Õ.k-Œéq1º&Œ†`çš…ƒt^¤#ÈÃZ•!f’o‡QA)&¢.ÿ˜Ô
+1EğÑç f6Ş­¦k
+ë‰6İd½\ÌgÓ>2ğMLÛ&!Ímip·S¼eY·¨iãÙˆJW¤‚êiãmi€Ä/Ws8+ÍXiÊsU>ÿüÌşp²À%Ö•û-eÚYC<&ÌE¯ã1qZbZMJçq­³y6¼˜½SÄ2'•ĞÉD2Îg4X—X—‰MĞ2ğcÚ\0š÷gtFEÈÙú£?3Å\e²k¶åX#TóÑĞ&¦¥^ÚŸ^=5&*à´ÒV)=©qÓŞÿ>~öøğèxçñîn)yÛ )&-t!%<sp…‘¹§~Ë
+WvCşğ}IåÜØˆ„ÈJD8.A1;4™÷ÏííYsNÑ¸±ü£Í¬!OÖc6Ú…·n¡Xs&;:‡‡+åà&®.‡èƒ¾‡óøÎcS—â*Q&gšI ´)pú
+O ïˆVvÖ×AƒÄãBmæå	}§d¢Ú–fÔ›»`nİ"k†ÙÛ
+X‚,ß-Ñäü'8Ún[_¨ÖA×Ã–ßf‘>WÇÁ(¤Eµ¢‘†´ÒK>Å¨k~÷_èY“4Ağ/YT….…09Õ!™¢
+€ë£öfe9®’œ·¾î %­ÛÖÍ…ZÔL²¿U¤Ë®CÊ :èƒITrgÆXÃ…âÿ¶ø6°2şU4Â¬kÄ‰À˜ì=O‚Z3ÉñR
+Ù¦Aß*ãUöU¾•èØÆ!×)Y,(d§‹Å‘£P9€á$I¤i(•âã
+l%
+ÇÇ2tj'™ë„(Ä~ É‘Ø…T²W .ñ3_KxÏäÀùeÇD!ÿÉNLó„œ|Pr­}†¹¶üOcé,a¨d}N¦ÆşğÆÁøÇÊüËWÑU[­|Yú§ÁÜÜ"“…ÀCÀ”;p ¸ø3º\ÖDùno=¤ÇßÙ›Bp+&g‹İÍøÖ«tğ¦|”ıAÿôÓæÓ–m¢hì<kŒÓh¬\ÌŞPZ@€sh‡+¨$#€Z©ïÍŠeâ™&š}·ò	4¬Buóaõ2¸ÿY)8Q=W’¹Ó©÷^Î¥g¦é«ÕıH(ÔÀ€¼ÊÛBC/›©ò‡H{RîË(Ç‘ÂPOB‡D%$Û!ê)!EkFQÇOA;^]$b‘¾AÇPP’“Á\3¹äÚ”nş¢w(Òpò6E©³	üt™dêqĞ€ñF¨h8'˜®[P™6önüu¢B'&8+‡ª¶˜%\Yÿ;­ÏëA®Š| ªoÊ€Zi	ğ€" “Ò,å}ŒoáXúTŒ“ uÒ¦óéÑñşÁ‹§ŒFÁVËù«BØ’¡ÅJõŸ½³®šµÆ›0 %Î·?Î"Û?wº-H,À`½ó/ÁàxÃf	-Ÿ¬SÏìE±"Mjã¥¡VN¢aµ«e½7”Z+Õ?‡g”ÏÆÒ6Mf™LÛËn9ËùÛ‡ÄYİ“º!¿HYMøºˆ¼)Üú]›B1Õ8löÚúÑÖáüêËØºØºË°¹ßÖN·ªÃ×¸‚,aw>P†Â°‹‰zmÓø	$ÿ§McËª”±‘Ş‚"->×¹[ÍE¡}Qÿ|—¯¼×¹·0«ÜÜ‹ÄN¥ÍAĞxrƒwŸæCM‡­ô¶YµõuıªÿÄ¾xoje‹çÂIPÑÁ;_£!€ä‚A&4®|Àq+£á‘(uìuØ¦cú/%’%¿Ôh•§¿$:a:F”/HÊa†Ï	dƒ‰®ÔrWpÎ§‰sÒ{êså4’¶­¤µ{áç®Åœøj“Çú²aÔ·šÅI‰jãkº.t\¤óJú÷ÉèSÅ°¬¯'b-e±:A°ëÔfrÎAÑ«å¯… …ºBhŸ[D«ê†ª80]ÏCß‚hÄï-<à½ÈìÂŠ}¸ş&qúSó-3º—óe¼K†¸­¥£ùNù _hi¬‚¯&]sˆæ[H%(yU©V}[®4wíT‡}p•[­R¯(WÄ#sÔx¶¦‹”Irjêx‰ï²Y¦mlÖ9“uYq0gºÜdÌğ•¯TlS}pÙ”k·V[LxJÑ.-×ÀÇ¯©X>EX"[¬p6m×NY LgÔœ:N!}îh]p›=Ø„!–Ù;[Åì­ÀgíRâqGOí«îÔŒ*Ÿ†®“fºdÅ@ˆï"bÎp-”‘Ú0Je–¹™ÒÀ€²°ä¿À}fŒf­òÈØÖ‰0*F€(BhŒİÓsÚ|®OwZ ¼nÙ«8ß
+{ÙİÍ¢Ù&6#mÍNmo- ‰‹À®®©	³Ö8\4ÖÛØàĞ—h­±NlÑåàÄ¹D*\ëb(¹Tc&8¶SnCˆùò¨£WqœBF@$)¡£œkI2Ês,2§èq ÊŒáuÃCXYâ˜~NX™Ö9†üñ•ÚWÍ3ñhLÆŒğL©~B¶i¡ú‘kE"!–hWC¬f2Š32,Å>Å††û‡	ŞìKXNdĞ+`ÄC¨‚ØØ
+«ğj:›ˆ3Íc¹fjä@pŞµ+äÉ8Ñ[À©1%ÏßV%”¤|SëzÅgOMõ‹×äsÃzí’WkGƒü-¼í@®J<=à–,À¦
+¿,eÑ+ÈQ[N£·Ú£­æÂ}’°¦¯w\'bå-´™v[eÚ85iÅEÒğf`éL¨¦ÒãÄ–ÕµUU}‘IÌÊöÅ:èÁ	®­¼šK¬J×VrŸ«È¥«ægßüÇ¨2€ÕoO£Û¬wş8_ô©ƒaë¯§18mÀÅQ• Š¾©rûğı`B³“•á½Ç4ZnKÍÄğıe‰ŞÄÕ*­3^ÅŞBŞDVza%‡}\4%ç2\¼_lĞUŞ-TÌp»ÓñÒ*)àòf^á ˜­@dğZ¦îE@Wè­Wbä–-MèoOEù~¤>ï°`85K“+ ¥ı¾ş4šXÕÜŠøhÕ°ˆ‘˜èüvë´úí½Sôü;GL˜Cû—0›od>4•uR:=Ê3bu2 ,ÂÖÅ˜LèME[¢M¼2©Â¥-_œŸœ|l]–ı1˜¿?=Û[ª'G@9Ü)‘}>ü2ƒŠt¾a\oÔz¡>ã3òF&`ÚbY:­ä²8 EiµÉen‚ûRRd½òi8
+áÕE×ëH¼(ïäãk­À¶S@lùó}¾hñ‚pXêÀóoşªÖõ„òe›Ü?'%¡YÔCG«g {İ÷ıÇr_‘¤¶Iòš]F ~dÔYçUq–÷7¡Á³.n^Ã5¯veŒBó„Ä6ˆ0„Wƒy1+@H‡“ÀJ¬€+r“G¨d@îöG›b¢ZU?ò/¬‡›cUqJ!ªÊv²²¼#‚Ë¤÷œ›.l¤/’h»×2œÌsÂvÿbŠ÷'‹±ö'òÊw ¼}Ÿı6.8%ÁÔ³$äSlwZ¦©<µ…Ã‹<<Ä“"£ÉÂé*¿Ûq”šà$Úê uÜ%È…iÁç_¾B›¾B
+¥±ïméáPëİ6XjË†âÅŒºHT°&·.¯WD•a÷IàVfuÈ±üŞø½Œ|\&ÓÙ·eî³Ä“T:@¹®ù^¼„ÎUöFÊkÎ p=B6ºsxƒoCX?t§È–ˆ7VÓ†a•¢UÓÁE#…£È{¸÷DÌ/(@ı›Û(äi\]ãv‚i¶s=Á†`ôÏ¯W P@c]–iBÓ¦6TºÄ­´ˆ™²¤sKÜ×7î––¥4§¢sÂMJÊŸ*£õQÃa¸”e®ÏÇÁ¢m‚	¿¤‚Ù–
+¬½’® ñŠDkW§f­¯Gçd«’Ùt¥”Føü³U„ó€l=½Ş(`¥	c„7·	ï`$¶‰†öÃÛàD(òUg˜ 'ïPoiğĞĞx‰tÇOâ˜¸TÕ 	c§l©‘.i^	¬ƒ’wI\ Â—´ÏFKboŸ÷ä6z÷s(^m2Ş§“—Ä$‘¡İÜß‹h¢Oì0âP.ÀK ör«$áäİ;ãlºóØM{Ì¤XEZŞ†M‰ú¶ŞP|¯T&[•FğªPN¨BC¸ç·†{#˜ıä¸‹¦Â•ëf<zÈC5ıP{¸g—\°–ƒt6´dÏ"êØ à®{yû¶l@¤$ë¥X¿ğFº£zyÖkUÓJô8€7øív*yzü—3*üIIUZlÕÎ/ÔK—øß]X¿·qMü¶ Qc¡)s¾±=ƒ‘TÓı: ~cb-K’:§[&/«®ÛJ¯RfÛqö¶6‚2şVXd>qËÈ!"‰ƒA7üg4¬{Óá'á¸Y™
+€ZöÎ0d7İ¹›_x:©+%¡õŠÙ}d;]¦³‚Îİ:b5Q÷g„MÅ\\¢¼ tá´K¥OLéV€Y¼QŠ‘6\¾{@r{˜ğp©Å( âŸ¶/„¹ÄbÎ²NõC>ñUü×êÜáEzÒÉÙ=É•Y*X9EÃòØƒvàT¸¯“)á5oÉ—–´©ÆZŞÆ“üÍs°;Ö(ÆŞ]ĞP¹£/fA^Kş$çƒÑ…H¶r´íÁæœ
+ĞÁeÍşPî%eH«’İ¤âã%Ñ-6”
+Ö,MÌy¨¢½/J¸7Yp°»ó“ƒÏš¼á‰è>*BJ”´jĞ*ŠH¦-20ZUû´¤M<	µÖ¼¸RëZô7EŒ¹ ÍL+s©]’—Í!CØz7B%ã
+Sdxú D­‚È“Âf€hX	P…Â˜0¿Ê¶`J²-¦®ù\ 2*Ä!Ø5AAyi¯T3ú1‹2˜’ÁÀ )´3$ä¶ì€;n;”£eÔH‘¾ádæ™õnıÕçĞ§t— èR]ÏsBÏÂ©1"ˆb7˜FâBsg›oHm+¹GkûÚ|“öL¾ó'¯ò÷#½1Şm$ÙjÍ§.ä&Oà"}|Âô&q>jÖ]ÂYT¿úÃb`(@!ë*, CUµlX$ªˆ*YxA­ ƒí‰“)Âéºg°òCÏ´¿NÍyÒü^ãÈä®˜v˜Ù»­h92«Å} ú¾Éñz¨ ”ğÄ—%:G”JòJL´è®ŠÅ‰+ßZøVå—2ïP:¹ni“9¾%ëšá­R™ÈhP9i¥ëUºÀ.5tÏî“,q °mŒ™:Ì¿DĞ)&¯ø’vöœŒòõuîmU0Ë÷~ÙÜvQ„•Ìp
+?ÃMP‚§<Ñ£ÄË	ZBÕiÍ³[à²gVÛF;åTáÌz…{Ó|æ4b\
+&Äâñèt×Nd³v‹p1[5Ã;†sŠúWq|İñ×¦F•‘Ú Ôs—‘U>|KA¢A@ø†ª.ZÙSi˜E üëîœ‰ùê‡:(Rî4o¬¯ÛÌAXVõÆY ±R<±®±Èv”\`F¿O¤fE°ºøPƒ†É<ì…wuL–ÚÍó›uÒ9ƒ+‚8a“p¿4e9®µ°
+qõüğØ¨Øè9QÃıĞÂé`ÃÈ‘“H	kmË%E1…1ÑVN$Z5”Ğ.İ¢‰Q ×wó"¹3Àû²1$¼¬]˜é\*nS.?ˆdCp¼+â‰`Ûƒ¡iì7¯½:d"BÉ9ßyøGGÜøÈı½[ ¿ÑÆL	[£¨âÔÍîõtàé§
+xí&=:àİÌëÛ1ç@µŠ‡HèéF	s$c™«¬Ç<oéö2vw¦C¹´8‘.üªµ03:"Øu¹¹LùÆOfÓ¢‘*ˆéĞ,qŞ¬Âíå¸õ4‘´Íò¸ĞgR]OØ’RÂ¿:ÃR§2–£@›zBúşoïş…‡ÅV
+Û,xàE"ÀÅˆíq	M´ôk cÎ«¤(8Hˆ(g‚/E‰…¢Ó30Sl£)7¥ËZTõ4ßğ/°EL®ÿa·ŒÍaDF[!‘Ã³l	¤`J™WJ'í#¬.3$YO÷,&f5P¿Éğjo¹t„[bÒ—Xì{L³æwk¶0\n4ÑïÕÄ$=©V!Å²ĞhãïÉ™h‘!uIœ¡ÌíÚöóø«´~r‚ş ¶€RÂa™®Rş·.`0¨‰ú;i.­ôèÚÉO%‚øpÍ˜ĞPàŞêêIñ”eœÅœ2JH€t„ÓHÆ¨ÓFcÔq¦ 7Ğ	JÙK!& üå/ „C½ZNX„1*H3ç×ß²í«O¾é®Ë¶ÉÅNßœ”ğ°Ìù5@RÚ8˜Ùƒ¢—pwv}PÙÏõ|f¥R_›’Q¥6“ [ÕÚµJù:@Şû-n:¢n»;¨;Èõ¥b›ì _É/¥¦9¼÷ÕBd¸eİ>iV”éÌ×ÛŞwñKPHÃœğàÕ¸Ò¢,ËØn!»g¶	m2qfóÁ³Ù.c­ñùŠÄ´‘F°¥üÎßFwàêšÃ¹Úq½Ó4e[äw”€†¸ôÜ`Éòân¨e92Ï$4,î¦Ù[òIz§DåöÈ6¿5XLÖÕÛêµ¡¹ïÌ.TÇ'@Ü–.ñ²ùÒ5qİ°ğ0²ıµÎø³-¦®Èêß®m]©xˆPÍz]ì¼dïÎÓ,ëå»ˆ²Nì²~+ú{N\Y'êï ¾[vq62AgJ‡Oê-!Š+Ì€<J &Å)ıÜÃ‘Öà¯Åï®ş	?¤·\’#*‡ºy€Õ7&êbéLuÒyH¯ˆ’Êå!R¥Ç¥ÙbÓœÌ ap’ª“¯v^7X[CèÖC[¿
+ÿµb¯¶;@äADÌÙ•x-ßg›ù×ºÀúXT¥toÊ:]¤è«ÔAÃ}Òf^›…„Zˆ;ŸÕcF—£i:—ÊgbĞd"v¼€9 ˜É[Ç0ÔœÏ²Ğ±2$Mú)ûGô˜F÷«N¢‘œäûI¬‹7¤ôMü†XçZS–E¤x–x·ÑF`OıÅvj‹(÷‰|-¶V@ğÅÌÛEx,–êk™6l,¹hYt÷ßUKçÛ:*ÍKt$ÇÛˆg·…10H®t„Èğâ
+J£t¦É£“XY¢/K1 ÛêH²í¶OŞfa|Ö!JT,‚Î#Î&ËóÖÒâõ [0àW$¥¼•ø‡j˜)YĞàş÷I_lÓ}üÒej‹^˜¶dh4Ÿ~ä½phğÚ†7Š@\"AakÉSâğë›ØÆq¶:wØjšëÔÈÒ¯¹^ÚìQA¢´`$' QË¼c
+8¶òÚ´“£lÂòú¹º<jÓ8Á–#™±±½
+ŸŒ hÑĞ¬ÙçÍ ›È)iÓrŸ¬*‡]à$Ò„¾Äš“‘ğ,‡ŒTå– å_ÇQß.z’Kj:ìJÛ.½Wz	±©L·’©%‘‹¼°/ÆÕLÕ-}“@‚İÌótşrEÂÀŞ'OÜ—Ø”½ctÖˆHÔªÊc†¼Âz2ĞÖ'	‚ÄÃÿEŞ:…Âyb†¨¤tKÜF\À®ª×·n Z-;:bsş)ñÍÕqÍ.3ã…c’L \gQ+~ö"ã‡L—Ö£­Šv8éDlZC£-èÊ¦—ÆÀü±Ğå-©anHèœº,YAM¹‘aä/Ğµˆ±€RÉğfÑˆ¢”¹½Z¯vƒ¿ı—ş«ËÌ kñCwd¹\CUA=Æ§ÒL·x@áƒxjl¬¼¦~ZâšPõ‡Óª,=
+r ¶Û[_©}}pMÎğndQ€PÎ‘>„ßË²ŠHV7O¹CF“%¥¨?$K'HÆ²ªLßzI¨LëÖ¥Qe×z$¡üD´ş$+ğµ'§ŠPÅ Yæ.ŠpÖOU¬˜r¦­æeK[“DØ@ñ¶®:_5da~|ÉIqaˆp/]~ë“)ƒk«‚ËL˜Ô]¥´Y®œ²ÄTj3ñw6Ú0‚aŸ3Ç„jB^
+vĞ¯¯;yâ–cza,u.O6ARÄqQß<f)‡Th5k-B ÇçİŸyÙÜU†Ì@QƒµBIw÷&:‹ÀÙ	ç1§qWÃºämˆær—J¨f¾YéV±FÿÔ-ùƒªôªß¦¤ƒs}Î[™¬¬wâÅ£È"Ø·y[ì«Æ'#†xVâu,‚g]r+‹Ê½.Ckï•Á	ßy×ŠQ¯è±í§K}Ím#äº5ƒ$W¹nì¿ a¬™Ù–|¦µB›KŒme­1;/´¾v“Wé×è›§YşXÎ¦b^æ.ç:c]½ltH–,]Cn°ø-ë¨¯*qDÿ“–àÓ½gÂhô«¶xĞlZPùS]j(…$Ä$æ)¼Z®DÍÄÔ+MĞj.v&À‰qbËHLø§nâÛn¶ûDÏ.üSÎ
+ËÙ\âÒñæ(¥Ùmq¾Ùˆš«†Î"œÍëËô	8»7ípZJA}›¶9K–"@şQ …inºçECŠï²&ê(°HsNlåFºŞÔ]A3<>¥ı•ÿíâcì+Û³	ÂjÁhù6•kêçßŸPÇÔ×/NÔİ’:êbAQèGâØ?(	ê ™Ä«a2ı§¾Şï@…Å]SE?í¦$ÈqG‚©í‰JäİŸ¨½ˆ„Ad`5k ¿™–÷ÂÚ{±å[±¡f(š…Œc.İÏf™LåBø$ë:¬Vb}Æ.ÀCL0‘`sÅ	9qÙ2Rá ì˜§ò ŸmÌÆ©Rfµ)Gæ	ZÖ<&Ûáç»‡Ø˜n­~s¿ÊĞæpÖÀ(Øˆğ€[Íãøô¬9ft9Ì>	†Wt}9b-‰êxß"˜}[îÁÅÚÓBÅ¥yu~­Ì:£x6ƒâä~PºSŞ¬Ò²ãò,:ç†"‰.Ñ.V¬4è•t†èµ­Fb…ĞÓ_v¯æóZ˜4ã.İºÅü9³oV}ÃÄÁê7ÁüòéJ³õ}„øõßœ ñRŞSÇ¦.‹‘¤‰ù;;*³¥2¢õqôjöÓÚ–ÉZm%(Cèß_·j[E`œäÍÙ5JÚªÉš¾D°ùÑo\DÍ2± #ûÕ^ÿ¿®6³ÍZİw\æõÿºñ’uâ‚AL¸_NÏ¿n¹jÌœKG";“È´K2Sc?}»Vw§äHQ¶øç×-—ox®2¤J¯ÿ¦[®dËd±0ä:û´Ïâsş”ÿnøÎlLO@*pëÛ•’‹Txvq¤J?bã©Wl{nñ+^òÂ[_ËIOsÓyño¹ûÎ¯¹€	ÁÇø¸«ëÌ¸9|2˜áz·“Á[şUÆoÜ]á‹hˆ4ÔæS¯ô’º­WWøËÀWİTÁ·§r~»¶Ö»Ì™ĞW­ûK©ÌôOºJ­¹€Ğÿ?^là´£ÙÒ©­è{ÅœÈ¤W¨E’GşöbÑâ³/3øBézX]@LÄƒ$ø)»[ÙWê¾rém)ÇFª™-/l—¼ÉtƒÓÅ‘K¡$ç”F^;*Ÿ~¬X*úFcé5ÌNóµÈËÃ=Wˆ#"‚iĞó¬¹áeŒ#ã a}Î:{Q ÒKòñ¶yHµ@f«P‘-H«U@’,#‹;`ö@ÜH\âoç¶ÏJ×0›‘õ@’„ê¹WúëŞãcO»Õ…Ëæìƒ¤yß[;¦ªQ„Óx’Î•{¾³£ñ±¾Ù¥!®‰Ğ¯CÅÈWVP”r‰€ckÑÒù®ró*9”p_ez¹¥ÛF8VÙ» …á	Dp<~Y`Ó†L:¡pØËgœ˜)Àb(î£?~ãçïâ:Úh§!]YÒİØ­¥{GèAÖöH,EÃúó[ö-MdßæCÔ°Ğ/jü7.µv½“A¯O@»n~‹ëš((ºL×º¼(dŒi³jğ¥–³9)ˆÿrÖƒòfRC(Dtíeœ¤ÍÑ²Öú
+Ò‚7¡T§HğV4GlÁ5HÓ4‹è%Mqw$·A8Cf@ER• ½v¶<9ĞÁ2åµã(²$ZÑ‡âz•òCB»¶ğípD°×A¤dKgœ]ÕãwøœÉq6ß\zUù†ª¶‹A„/Ät%½ú¹©ñŸgQ‘ĞÅ‘.jİÃú·VÏ&ğE‰4Æ6‹Û8Ğ¿®¹•‹!sbA!h³G™Ğ'dõıöº-‚ÎcxhĞ«ä®uùî3òòöºÓ÷ıi«Ãìñ‰Âa6;ÜòæÓğ2qş;˜í-º¨Ÿ²Mp%„î‘îÃìè7:¼ â½‘E¿¼N`Àmšñy²äoÃÛ·P¶:DÍQ¤ÈsìŞŞO¹…kÕWèw†İ3YP^ÜñÂaÊo‰8yĞÎ¢â=§¯ÛV0cîÃö5º®ßiH_ÄÌŠåöæ6Šfß;ö±qe yïò‘É;ÚÙ¿ø˜o¹ëPw60}"e:DÛ¼ºÎL:ØÔtò›/Ì\âÈC^µó®ß{ÿt:O‹+ß•ûÌnLû³‹áœ‰xO s´š´÷ö½Û(«µ†`€©}ËÜzŠ­QÅÇï–LsäVHO?ÉQXĞñl0ÌŞ!÷<ıšÈÔ‰äãß­²: O(­à`ô‡}`½÷Ì>/Û¡W¿Qëİ2®Mù?o*AõRMI İVÇ©İÿ”}dG0|‚HÕ´W2fşñrå©·yç0)øC4Ö³Áp(ì#±¼1Ÿa@â×M2|)ãpğK?{‡Ôîf·;Èås&¹ø(ßtÖgÀƒy‡t. º‚Ã"×7ôkÉ:ÅÙ'f“ ÄİÛ±Ë/òµ.Ô0óï•¯áÑNMóÇ‚6ï~òJùğ«&íê÷^ ø|Å"°	z]‚¶™1xôN1¡ÍÎ@Ö4Çxq‚ZíäÊRéƒ rŒ’‹jø€k¥œQs |…~î6MÀlŒW¯œ-?_(ãànL›ğXË€#¼ÔØ¦M¯ËîÁ]âhÉ	0Y‘ÒÂŞ¤2¼‘Z´ÁN4m£+×ÊCÙj}5 ’ò#Éi3«İ•¢ Œ²«6Wåš¢·1R–"É4J’½ír9×)ü’L¨¬N§Dä‹1å²6 Émcˆ–MªÅèˆ¶…01wŒà@{í—ìì•ÿº8=·Ûvk¬Û°‘òa4Ø]ˆŸ»Êjê:‡p¬’€Üİ˜¼ë²Ô
+[W5@ˆº#­*¯UºÓÚ ¤V®Ÿ82‚Oøå[z A¦†Æ	õ@<®·TF’¬œ«AcÙsŠ9œJı©ßÂ+¬€ãñh6Ÿ^ôŠø¯ªÍğ6S›Ì ‰'©Æ>Â57@´İ#³ójoÿàéááñŞ³ã½#¬neo¾Îfz”À÷æ·³î`ƒ–ÁI”tÅ‹r’_à‹3™!Q+íìbw)×<Ş”ZÓ›V­}B'¾J“5‡yğáu¢w_=?Ş>< 
+Ş•v›|<“y{lJ£şètpF÷æõ¯È£;Q>“>(úıÖ“EÑ¬ûSœ<ïß.+¢OşûîètØ‘vp#Ğ¼ßyqøËãápŒÏáxaÜS>~Y•—ùZƒÔ¬?’vyÀk
+ğÆgayyM§ù“ô#-¤ä³JìªÕz/±±Æ`Àµ`ÔgøH0ò0
+f­jEØ0dG0£“ŒÓŞ¤I·Ï#røä)Õ¬x£`{ğV©=É‰Aj2°‡"™+á‘ÀñÙLt…Rµôàk}}c)  \ ‡ºhÜz}}9áñÇà ãG@¬-i£ (ãèÄÜÙÉ†®M¡mİ=°ƒMáF_¶Uy{ÍW£ş6Dá}°å:¦‹8a—ôÙ¼£±|=ºËqÛ;Ê~M¬´pHucp/ßapq*ïHğ×öƒ‘îDB„.±~I³g-0X¿k_—ğ^\ìzãÛ®x2ÍE[ï1—óĞ%ö…¾	ÒmNsß…Í‹—¯şØ)·$€>SÀõİ4$RKïİåğ‰hãÍ¥¯QÃÇK4JóÔFÅ­Oò=ríŠù˜C6ïë~Æ+Æ#9mÖº§8¢FÁ]GÎ[ñ—¶W=Pø=¶ñ[ÚˆP,(9•Ë»¾ÔıûÑ5 -*js—­	Ä-ZV'Ÿ^c$ÅõcW› ÔpB?pG{·6q°uhå×Y9õ2­œß2œ®½VnlÄ¯»ß¼ËšlîRHÊ|Lc2Myˆî=ˆÇ+?(Çºß ›[–ïYoMÁç}D,Û¯Õ›´Ü’·®S¸øÄ–_oÏ“ñIø‚Úõ2!Ã(ù;ÒşĞØÅ1ÉÊ&œ¼Œ¯Š3.ƒ$IÅ‡²i¸òÖ9€ì[ªLú&v%Š—×cÑFî,úq]! R2“L¾Äwkîª@À qA9u \ÂÚ•/NÙµtiyÜÏ­ªG/Uü)n"£ÙYàâ@uQªİ©VôÜcürÓ’Óö
+¦ Ãõ<^Ç;¹Œ&ß|¢rÑÅ`çp>caı¤ßô5x½öº³Ë¥v>ª…ÄÓiQÅ©§‡¸Ò×ƒş|£r×Ş×ë¯s®H"€Ñ;!–¼>{÷ğf‹•Ò…j<‘ˆ^ßµª%µ‡<Y¯W®YN5'eAÌø¼™’áZ71XLÁåÓ»…ŸÀK´¯	a+Gú1}Í×ZLÕóÃêó©×¹ÀÉE\şğµY*Ï–©Ì:S™+›Ëå`Ş×ï+›@Î‘[c‘‹û¢ÌÙ AË-@;ÀŠ®B÷¶;½:c¤b±ò¥Úm µTŸ/u†¤s/µ˜wÑ©—6wZø¿Ù<Ò,ÌÙ¤)BL.ò:3ËéÀNC’Xør<[ÈÓ]û¯ ¡0º–)=Ä=Å£˜–­.ÈÖ¢¥G_j	’YúüÓ<£|6D0³‰ŸFÉ®8}bì´¢¡!S”±8ä®kö™÷¢3¦rĞ?½èÉi–Z‚çá ±q>'„ë‘Ú4!6.`Zi®…øDğÕÁü„^Fìš¡)meC“¶¦&¨-ç§Ù´£rúç3]zà”a‘¿JULTÔG:ä’ª_ø«X¸¦Èõ¨«á…zŞÈşëøT>ô‡\«§26H—º
+Â²gJ!ß„°"«B}cg×"¨Fsw–o"B·h¡°bKÇä;¹P¹’œ¢ŸõOµ¿2s~üïÜëıŒİm3š&Ál/=Åÿ]æ2WÏ6Ÿ”Ñx|U×Ghµ5$´ÚÁ¦#Âe­˜&€¾ÜFˆÏÙ&Zq¨"®ºR‹ô_Ï¢">/q'Ç¼FÂ€uK°w¥ÄãË…š8—…£ò;â†L™%SÜü<"O1Ü*2ß$Ç/â]KcjN8ZTÕh_¬,öL“§¹€O•÷î’—’%B3eôÉ©–ØŸ¿®xI´
+ÏÊ€ä÷İÙ»'ƒDa=TV$adënJ¼/‚‹a/£Š&:ïûıÉŸ£Óñ$^;"êv©øGŸ}ÁM¾d$™ç«XcEÀ7‹¨ÕU°‰G¢ÇŞÓ=v_Š–`è‰äô°™şÂĞµÈ#Ê·­R5lŒµ8—Ş#ƒ£wˆgJ® ê=(Ãgí.RÂ—€SUñÕaoÈs
+ôöÀ³üW/B%x˜JB{LàD“fè?¯À™ÿ*‰tÌtTÓ'^?Ñè‚k¤dÅ¢Ñºò€=Ÿ|c”‡¢2>:š®°c¹_o;êù¢ƒ˜ÂKsÀny9Ñš¢ìõÅT
+®3Iè*D–T—´!ûh„Q™)ee6•Lc­ÓAo.Bñ¨ªË,
+À8Ó“$;Â:Ñ	şW!–:É¬9D­h !Tï/, #±
++wi<]6ìç©ÔÕkxÌƒùû`x)(¦!ˆ@ó¤‘á^8êõ¿ÇÉNIÌ‚–ÔDPDlª+Ğ†àŸ$ÃA,G¶(D³D†ãúÚ†+Î§”¢±²Ì_«¾„¯–0ä5hC„Ô1äÛi£SXD¤‘_ı±y6*Ç:~²‹lqÊ4 @Ù7òr°“pùÃ²ëÚÑQÂE’)„®€D†%Æ’³Æª6e=`#®‹t]W³T?*¤9É@?æ1¿ıíãÃ£ÇGO‘0€Ï³V?z&†‘iyÚìàÍëæxOIÌşÔúuÏÖA ¶-k«º“`6Ñü6˜Ş11¡ÍÒ6›×h³µ¨h·‚lg‹£¦¡ …VTS§éƒÍ¥@ŸXêMö1³tÛ¡ˆ"EkP_ú¡ pÆ¨Ø³äéW)[¦ä	›AÆí©¼WÈ´4_Ì	\]ş¯äl›U‘ÃŞØu×©ˆùø¾z)!-rB£a›ÛºÃ¨WBæ´Hê[$+C¶ºÌDÂj,Ò9ß·ãÈh:Ö×@_SAÄ¢f'ÿ^;ÅTkÛH©Ò:½< S"t"É‹ÖW¿¾×ÃµâqD»zÓœ—Ü]V%'ÀİILÖsÙş°}›çn„­Ì¼{24/Z§”¥¬2qÊ,„q“©[Ú/9{¬¬LlsüÃ/ôÅZÎÄ\êàÈø§dÕÄ‚S«)Äb.x.‡‚éÒ&Ô“ÄÅU?u£	¥›ÓÈÏhDÂ†	¸¤ºèùéı“Aowü–~>Õ¼3>Ç}³d=Â‡wW‡Ÿ+7\ƒØJÆddô[¨lÛ¢k$[èÂzj¸1.EË_·Äy®œzdîÍªßCŞ:EÌ•—8{]2Ë¸ºšÔgEÆàZÁcëkâÖğ ÚÖnKßöCL<«8¾8ìÿí…g”¬z¢‡–¿ºÀm(’B²:öŸzéâµ·™÷A™N+qÔ1#õşÓtÁ´w;ÆEmüfµÍ» ¹s'¦µÑ–çÎ.¶ÚF–gã)Álv‰<¨ZH"ãÛÚ*[—"an1ï'‚po0Sé
+ú\A€Všp•ùóyrS‘—vØŸ¿M.æÛg: i~f?ã¡Eæ¨ÂOhÕºXÍYÿoèéuûìbÔùºÍ$Lqï#Ø×Û»r€Ø^?íÓ¿Ñÿb5÷úçKø|)öÊÔíëyıÄ³«ÖÒy5§0è*´4*Ú¼]0[úÑ52M¯!×bƒbı±¥ÄË4±ô!ºÂ‹¶ªWÍ½±•­çøÚk6ªošDQ•_Ûfp"q‘ÛB²ç'}¦Ø"éiËÕñ[(0°äKH&µ]V!%9,2:”·Áp¤±²Æxål8ş Æ«ê°a0LíÎ Çsp¹¼ïÓÊ®NBzô™|®É±hÊJÛ:TìØD'ä8c"¡Œ¦”ŠÆ=XE_ğMAı9›jüŠL:½çıóŞä#wŠXBO¨®@x@¨Æ¡"ªˆ¾z‘i#}ÄjÜ0arGàø¥İ§@÷I"‹xLEõ*²]I¸nF˜h\%dxÂ©Íu_M şIäöÇøâiz46×yŒ|ñb
+L¼ÔQİnª<KD…æ+sQgËHöé]¨–3>Göq°àê) ÄÃ•Ãó`Ú?mä¬®^Ô2V¯Z$rÂôî´yDgÃ…âïÇg&Õñ”™‘+0°I¡¤fÂ•HiÀtÊ
+µ>Ï²Î@ÍËL¬Iş_ª“ªk:†€CUêk`Ğùì:ŞSƒ"òB-‚[Íiº™¨“©;ÀÀ °ãS¤4C]Q?àòì:ä@Dğ_Vxî¯“©cp³ÿ…âË@•’°3EE‚¥B_%‰|„‚_ıp´ÿÃÑñÓWÏÄc·já­º«gçŞÎ¯™€”&!stú}/|ûÍ×[Œ6“äFùõ…½c—“fˆ_d‚E°eoÑ}rq~şñµ‚$:Ñ<Û1Ô·X›÷² AŞ_âW‚]p±ÓÉJ¹ßq¯‹fÎ=—µ´²MO\ p‚GŒ»œ#E6Å±ß.rÙJ¯$ÛéC§gıÒ‡=Ÿí}åR›K Ä?ŠÅÄÈ›5²´/ÒÈ¹dÙŞ»»–d±ílÔ0mâªíæ:¼½ğê9_‰"áõO6?úğ°•K±ùnİ-.“Q£àßI:ôÓÛ3™`¨¡À¬'88„é?ªVißÍY±1İI‰GÛ¸Ëysbc.ÊÌŸØ€/€=Â‹©ï¾øëÓv±ß|ğXµ—%"¥^*h3‘*I8Xî3™ ¹úÖÿp©võû,<Šn!›şİÓ;ˆ=[øì]G¿ˆ2àÃÈ*2h[¾¿g‡KÀÃ=şÉÖ“ë¸ò« [ƒ¡³™q> ôİ˜–‹_¨ÊD¾¨ãıâÎw æÆ’¶3‡ú.l±®U–¢yâƒ¸¹7&["e9İ©^%OåVÛê%ªøú7W³œ[ˆv¾fƒº;ÖJ´š‹âÒMÀD¯ÿ
+¾MNT]âÜ7°õ¤zoó&ôìn¶`ß¯+'<¦²%rüK|‚àÕ6— ïp‰fĞ¡?‹Ë½ µ©ºT˜™öTúÆ¢›Èİ4—5)°Kı"\½˜“GíĞXl¾ˆv.²»ÌŞrJb¯·|HòĞ-­6Ø^èÀw\dW½`É?†zıR¦Zö®[%Ò™amL
+–`±?rŸÚ'ÔN}qV%€\"d&™—¶Sqš>>›âF .t-Bnu†ü¿Üw
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/3b/a6d254eb781c926049ee4275c5f46198f2ec42 squashfs-tools-patched/.git/objects/3b/a6d254eb781c926049ee4275c5f46198f2ec42
--- squashfs-tools/.git/objects/3b/a6d254eb781c926049ee4275c5f46198f2ec42	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/3b/a6d254eb781c926049ee4275c5f46198f2ec42	2022-01-01 15:09:15.605172588 +0800
@@ -0,0 +1,2 @@
+xåX[oÛ6Ş³Å©¶‡¶h%ÇîŠÔ˜Ø–ìµlÃRÖ¦`Ğms‘DA—&é¯ß!u³ãKR¡{($ux.ß9<üHfåñüŞl_şò+˜Ì‰xÌ×	èô+õxH#°’Ôeæÿ‡:	™Gá-L‰O»Êä›O&l¥ `Nœ[²¡0»hÔıãİŸ³îFÕHB]è§Ìs¥Û70ä‘Oø›F1ã¼W›Mtóú5è3˜Îl0ô±ŸÚ½ÅÈ¾ |bA»/ï/ß¿ı! >sŞNXpˆ,"ÑƒÍûæE³Õh†£ngv:]¥›ÆÓ°¬ŞÈ {ËbÀŸ€'@à+ñ˜>¹¥kL[›ÃJÂM„Z˜—$Y°©Ùûh¼©<¥1…dKÁ¸y”€™;‡û>	\¿QTÕHºmEU„ ¨•B5ºæ)8$€8¤[? f‡k¶I±¸¢„w[ˆ0A	±²]=€‹‰É)Ô'¸ú€E4‚ªÇLè=ñCv*'Õè8já¯l”ıª+•m5šó8f+ì1gË™CcXcØıœHt@Q­2Ê‚z”ÄT—+üãŠ´î–W–‡²Yj»mÛ§›	¿ç‹ÙzÇïæ4È¥ÓiH—ÃìEÿKËq–bŠŠ²+p‡xs’l…|0ŸwO¥÷´aÚ“®ÏÜìcaº‘#åã!€òÛK\šW
+t»eŸTN@–áû=Ë€«˜.Íá UJea–Ù†Ûƒ-5fi¦ÉRg(Åšì9	|ê2d„3j6‰64÷SVà ”œÄsÊÓ(Æ›€Gt™mi‘nUŠÇØzº2y\ĞîñÍ´AûÔmô´Y4r<m·9œêFÿj”—(×gŸ¬üËìŠá•µĞ'“L>ùbö&ãşÒø<Ÿ-l¡q‡:hX`Ø?Š*yøİ˜;Pê†Ç„3s¾@:ÅVYš6B*àXW}{ÑØ¦ëÏ9BY%ìÕªJè¤„åß&¡ÇV­&–íNP}nöı2îĞ<<Ş]| Í-#å^ON÷­A»Õ]Å8ä6Êê+ÊÉ‘–0(e“ñô#Ú#“Ş>6Î¦à–FõÚ-“<<¢|¸qY>ÂìãsOj 7»Ş&Ÿ!îWjñ–z…îÑ\G$Mò4e®ôÂİ•S(àĞ	ó²a]Ï†-qûò}İÏ4&eĞ¹¹J˜w#vŠ™aoò0éLgØø.1³²Cóô´Ğ]uĞFã…1±Œ'y3; ê²æB¨Øv—ªr¿»Ó‡luDé1+IïÏbÌËiO!øléætég”ùeŒ´‰²}Ú\ş@Ú}9A¦½ƒeÇnğÿ?\e‡J^?Ï¡%´gsèÓÇ94·Ë¹á€C‹éÿ3‡ºâ±O¥ èO7Ú‰i˜ü4Äz4“Süº—!’èTG­.Â?‰ïì^ûøu¶s[<®Pr^v±E<A±ğ5¤”,¬Ó5I½d‰OW¼ff—çLİâiäPùøl4¬ÙÕb`tÕ›„Š#fà;mW¯¸ÃïÊl³b¬Š[Ø¡!‘HqöõF<œNa¸=ı¬áØJ"J|µ†éäÛn´¹eí˜fR?*ÚÖŠû‰·õ,}¢ÓZ‹*úR˜ÖÂë#¨U˜ÖŒŠ¤z‹#ÿ³ôıQo"Ë]­FÇ7ßÙö··Øıî©}û,Óu²ñˆO¤*¸"gÉŒJòÄ5ş+ÆÜ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/3b/e4bc27eaac5bf6ef2f28cd96f39137336a3415 squashfs-tools-patched/.git/objects/3b/e4bc27eaac5bf6ef2f28cd96f39137336a3415
--- squashfs-tools/.git/objects/3b/e4bc27eaac5bf6ef2f28cd96f39137336a3415	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/3b/e4bc27eaac5bf6ef2f28cd96f39137336a3415	2022-01-01 15:09:15.617172589 +0800
@@ -0,0 +1 @@
+xKÊÉOR044cĞ×RP0¯òHMLI-ÒKVĞÒçâRÎÌKÎ)MIUP‚Kd(qq9U–¤*d›Wg¦ç%–”¥F#s‚3«RclªÕÍÕuÔ«€„A…“3ˆtt‘Fæ ÒĞ¹Öš 0â$Ç
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/3c/4b71e802fdc42755e22e9e2665f5183bb77a43 squashfs-tools-patched/.git/objects/3c/4b71e802fdc42755e22e9e2665f5183bb77a43
--- squashfs-tools/.git/objects/3c/4b71e802fdc42755e22e9e2665f5183bb77a43	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/3c/4b71e802fdc42755e22e9e2665f5183bb77a43	2022-01-01 15:09:15.609172588 +0800
@@ -0,0 +1 @@
+xu‘ÑJ1E}ÎWŒõ%	µUDDJ»Pè³ »é,Ö¬¤Y¥+ıw3›MM¬}	'“;wnª¦­àşñîb.á¡_uuv¦@Î»ÒF5İar¼x›dô¹iZ5ó}¶z/ıjï0hlŒv¼H	ÈjPì›„óõSQ~”J»=,áf‘ğÃ÷]€Æ´q™za±tø¿şvºÇW¿¢úƒ¸,Éóº3Jğ±6qÖU¢Bşt<A°ô¾…ç4ÓïT‰{Â]gÜ’ÀÁ¯8|,ã”Hqô–¶ôjTàùËKj¾`> “ü×Ïæ3sYû’DgÌ â¼×à"ïşçÇbÖñÓ~ nä¿;
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/3c/86df35c22cb0e342ccd4b0a64e052cebba69f8 squashfs-tools-patched/.git/objects/3c/86df35c22cb0e342ccd4b0a64e052cebba69f8
--- squashfs-tools/.git/objects/3c/86df35c22cb0e342ccd4b0a64e052cebba69f8	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/3c/86df35c22cb0e342ccd4b0a64e052cebba69f8	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1 @@
+x+)JMU024g040031Q0¯rÖ+©(aˆe»¾Å}{`ÉËI×<Väq˜ş×®Ä-¿(7±¬îáùâ†K¯El®Z”ûH7¢7OĞÄ œşbß~H7øZøá=aœŠÜ;aÖø¦–dä§ƒˆÙi¸ôéTÇoıìN%½¨Ïµ	ƒZ•‘Y\’_T	VÆèØVX»æûü™Ö‡UÿZÌ9ŸÛU–S•›VS>éÚÁ²Go²Ì¬¸\ºÆÓöŒ '#[­
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/3d/34eb8dfec54cd43d5b14368dc39085b0d63068 squashfs-tools-patched/.git/objects/3d/34eb8dfec54cd43d5b14368dc39085b0d63068
--- squashfs-tools/.git/objects/3d/34eb8dfec54cd43d5b14368dc39085b0d63068	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/3d/34eb8dfec54cd43d5b14368dc39085b0d63068	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,5 @@
+xíU[oÚHî³ÅQy1Q i.°­TÙ¸NÅEÛª»·ö˜õ%M¥¿½çØ36S¥Û¼uI0öœÛwnŸg^0ƒöÁÑÑ³FnY«~¥iw)|	ŒõF¯móŒ½'	;Ó*xê
+¾-@1÷’‡çõz#û7ßDcx‹7õ«ç›*#G\r3Xğ°QÜöÜxK}Y©I4Dy×j7ŒÓÃ“Úa6k­£ã^ÍhíšÑÄ?úàõ>‡Šá='ŠZÌÑmÇçûà.ö!Jfşp1®¸´U€¿µşàÔ²ìÏ©Õ×Íó±Õg&B_…<ŠÌ@\ó0†J2/¨nÜ($û`Üú%<ôk´Õu- é1^‹àÙIµ‹…—õ• ·1§8¤D Ø€RááFz­YE eú}^ªoTASú½g¾i1‹aš^³WÕ´y ¢\Ãg;ñ‡Á5ÇÎEğ^Prxï'£×æ„]ØçĞ„š ¦r¨ğv4€U2óÜ9`—U­1‘Ö~!1‡·SñY_„å¯´;ônc{l–,—<ìj™òµ@¯v@êé˜Üİ}µ¾•¨Ñù,<0CîÄ\§v ¿‹$î¥Q€ù+Æ1J}Ò]—ÌÏ+—|JüU!±UŠ]L}§cÊîi-äEÙi—j¬÷à°(vâ$KñÇÖ‹Ã~ÍÕÉS z3Ÿçn0±³Ñ`<=ŸÀ©—DWTl€ëÀ]Àˆ{Ü‰xV³H¯âù~a½üõ¥ÌŠ.ìP(š±Ca½úe*÷4r’SN’@ÂåÖ`á”¦‹F	cŠã³a¯—Ø¥f4½é=â §ÕøöÀ'›*@P{µQ¬aÈ'_-
+î8Àğ›Úoí‹¿lfßÑ‰ê‰‰nFÜñtkÌÿM¸ˆ]Ç³äèÃŞÚ‚ˆV”>L-dr÷+Ï¥tŞnH|å#­ùÇ=ËzuŸ+>ˆ@
+å!r7¹iN+ïÂà’¨ÜË öVò)¼ñ¤?LÎ.ö1õêo’÷}ç ÂÅÂ]nó³|?ü~5f8¦%ÖéSM mÃš¨ØÜ‚bcI°“%XIŸòé‡HŸRm}Jñ£èóÇ®NÒgî†Š‡ƒ®
+›¯KúÆz‹ª.”QÜÓñ¨„»#HºLò¬b#ù†@‚yœ„Xa«Ş)Á=’˜%®Ÿ&æÜ.câG3ÿ	bŞâåÿiù7¦åï, P„
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/3d/bdb2fd1dc518c032237c00659dd786e0110d59 squashfs-tools-patched/.git/objects/3d/bdb2fd1dc518c032237c00659dd786e0110d59
--- squashfs-tools/.git/objects/3d/bdb2fd1dc518c032237c00659dd786e0110d59	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/3d/bdb2fd1dc518c032237c00659dd786e0110d59	2022-01-01 15:09:15.637172590 +0800
@@ -0,0 +1,23 @@
+xÍ\ıSÉÑ~æ¯˜ä*Î
+!ŒÀÛv
+v¨6%pòVü¦(³AH*ieãü¿çyºçsµœso*ªkgzú»{z¦—;ŒÎMûÅÖÖÖÿ<]]1¦óóMo?¿õó“âç|ı‚C?Ú5:61Ùh\7˜ê›ËÑÄÈ|É'Ób4l ÖŸìÿh­o>7{£ñİ¤ø|Ušì¢aÚ/_¾lmnl|o?cõqïË`ôÅdim¼hm<'«²ÿğôéíííúóÖÏÅx}4ùüt%Æ\LÍ ¸È‡Sp1öó‰)oGnhú@ÛóîıGÓÉ§SÌ¾Ë‡ù¤70Ç³s¬3]k2ywÜ!ÕÍx½¹ç öà°47yo85åU¯4w£™¹èÍ4ä¥s3ºÄT>ÍfLoØ§V.GƒÁèÖLfƒ|ª@b…X§p'Ç{‡»sğ¿{Ç§‡ŞSŒHKk¦GÒ¹éÍÊ+èN¨A4ÕšÉO ëàÎŒóÉMQN…ÁrDÒÓ²W½&±®7ìİØÇA1¼&àD°À¶s^€ßó; ¼a€€$¤–ùä²wá¸åËb›ÛÜÌJ3ÿŠ(†Ÿ!QÃ:ä.Â7VüÜ@¯dÈaİìïÌÍ¨_\‚½È‰éõû…>€áÇ’^3W£Û¾ÍLrÇ€#ÖY¹œD„êúÊ*œè»bx1˜§ßG_¿ú='.áH—æÍ]™¯|‡o,Ê8Ø´ø<¤,W½ÉÊwùŞ‚\¿ŸİœÆo¨òÍgacíf¹É²‡Ãrk³Ñ6;;&o¤H€áÊœÊŞ@ĞµÛ]2k2+çªFXÎF_rÁõıÊJy7Î)á´œÌà±g{İŞğsnãzåÚ½€ÊKzõÍìò2Ÿl×vŠN¨\FĞDÏ{‚Ğ(É1}œ¾?Û{ƒÁCªıp¸o<ï]\›Õğkàe¦›OgƒR0¨®uøà§rÒ£A¦Û+_MÂüöÊŠX*¨›÷úÌH³:é7DÖâÒd“~ëµÊi^½2á	ò1#ÜãgW$¾S3ÅorjdµrnU¬õšÌµ0¸f‚x ¦F@¥l‹Í²ÙŒ(R®"ïä¼:…9æ•¯ :`k+Ìäål24?½}«C_ƒ?v"ƒ®œ~šMğöueåéªqïl*pa6SkØAğeTôÕ‰¬/‹rŞl`ÌÅhêRÆ¬%ÿÎ{7kÖBçâÇ´ıX/€¿”¾ÖYƒü‰Ô*²,L‰8T8†uÎ˜¦	\)É)
+ŸKˆƒ
+LøgÑ'2šO?â=Ø“³B MavÌ÷Û¦€íÀŠ"·hÄå;RÒ‹†ùA§á"VöæÛCÜıu·ë‚}Âœaµ!<l»™åĞ1»M’ügØ;{ÛùxòAG0'ƒàÜeYşˆk;^øşC÷h·sø÷#q+L ™º$Û0÷F9ÛÙye^lë¶íSs2ÂËWâäeıNÿÙ/&ØÇ˜4ç}pMÔß&iu£nPTmQc?FsFcfOcÕ$&ŠÑÀLæw4¯)Z­{nY¹Í¸¢>UÎ×¯%’uD	QtÜT’ˆ(W¸pæy8SËNÑ¯bùÅ#a*0FŠBl¼ô5]g1š×¯Í–¥Wš'~Y‚Ü<1YiZ(Ç”Œ×If¿5‘m¨&ú vµ–)-¤•šõ¶?ä	CŞğh³•¢÷•M$ÚÛ`K5m¶w<Aµ»:Æïµt	ƒUøù…%…
+¹}]ºQ7Ìªâ¤Œn_Ù£wŒ 	È^é”ªE82MP»N°C2Õ ²IÛíçºÌÑêÎÅI· aÇJ£¬Í>—h–°ø$”“º‚Û0Hœ#6÷İH%R+‚é°JŒ±ì¿O@qê¯Üî¢DøîàôìÍáéf¦ÎsS¬™İüà ñPÀœ×ˆIöYìÃÕù‹ŒÂ€ ¼(¨œRÕ!~•¯˜l’ÌWÁLÃmGÂ[È'µ£%¹ÄX¤ Sâw_ø¤J+	à…z}6Ø5ZŞÆö¾İPçô¿WVj‚üt’Ûr6ô©OÚx\T"C‹bŸ¯“Ê óaïìÃñ)fİŞˆ'_X¸ıÉ]É-Èì°œW|Š‚JélSQªFSPQĞ›„ßw6Í¼)$šíRaÀ¼†×&]/Ã{‹`!N¿~‰ÍĞ`ËO¼€ÁTµX—g·)'ÿ?†#½éİÍùh EjµŸHmJnÊÈä^<jI¥‰ošoÉ8¥ĞÙ-ÏØˆõ˜W H¦ãS²ó‚[ò¯°­¸¶PV …±p; *"9âD±TüvŞ ÈÅürBãé¯Sà<ŞÌoÉBÓŞ>8Fm¡±@íÂ²?‚
+¿É^NZ`.út²j«Q(Ô~Ã©M”,…vmaâ¢QáEäío\ÖİÚb¬ÅÚX«Jm‰uzåÅU%™ÎeÏ5½1¸!,Œ’ø76™õwM|PZ™§Ëéy§-JÃDT/P”sEQ+šFÔXj'889Ë*k±‡¸¨vÕxEÅ _Úê4ZX…ÈÖÉåQı/‘÷(qnÍö¢Ë/!ú}úÖÊÕ+‡ğ¢LjÜSï~’›‚şî Eêu¨0±í6§ Ê‚Æø4'¦3Ë7œb·çq>¨‰Œ9Ç­ÂµÚ™Cü©Wa¸Ù{§SCTy²è?Mßà8zÔûÉDŒ:q‚»İ\¦Â`€¯;ùK:£[â2[¾»ö'’¤¦îvÑsAt­¨ãGE¿&jÙsˆş‚æ€`zQe‰3µ¨Ü’H<0µw5Â½¾ÙğhüØ¦Éüw„,bÏö†F¢éÍ¹yğ-ó„C°	zGHŠªôäUÖÏòõNCa=‰E–„0¾	¶¦#)¨a´À’6V6×ššW«âñh*’¸;ÑlAêç^ƒ’_¢KG[øUVF5İXW‹m¶0&s¤åVÈƒs6Öœ€Ö[}F+.Ãàæƒ™œW5«Ô<×b¶¥\;³y®í€çÚ*¨¼ÃŠÀ’%ö >i}O“t>K´’AÔ[M{Ó;¾xVQÚ‰çá¨{¡I‰"w‡è‰$Yç`ØOçÚiJz;ö‹iÙ²S¤9)»[…­ºÍ»_‡.ª#¹y3Jfà§#µÜ>K×íĞ‘±"ƒ§½ó´1]Jƒyè˜úk—£bBf3`?DbÅD”R§İ|l27aãÙòÅL 
+`”Ü ]CB' ,|·Á¥Ä€¤®«µ- —!©)Òö2°Î9ÉäVG—ª…æ-˜.y¼h'ãüLæĞØ¥«íV%QŠULæP)›©/µÌœÍ/™p³ª˜€ õ€ 
+õhÿM)âQrm€¶‡“ÅËªÀl‰ÊI:^ovOÎNpe½rRÆh-ôD?ïÏò7ßù6"«ÙĞ‰q´oË"Çİ3GÃ³ÜÁŒá;ˆpmÓ%mI;½ß+{šØ¥$®n
+ræ“tv”İãî‡ãƒîéáÁ‰0­¥–Í\"O÷àäcçôl÷t÷ì ÛıĞe#èôb<%õOÿà8±ën ³—¸ ı?ö$û Ú{ÉrSN,»õz|.çxKÓãmlËˆƒi6×,ï«„rÃg+øã
+¾—1¦Á8ÁôÒâì.¬Ü¢NQª{’ßôĞP‡c‚™dªaõóÔ,Cmş`^RŸªi'#ÄOÑä©@ˆdâBîÔ±5TêÓOÏº»ûWÅÓ)‹*ÒıİıÑ°7¹c3MT'd}?ÃŞ“<ó÷#)Û•õ¼ìÖKSÕ„zsYñkôHVÑ›R6œ?©*¨Bÿ3VSH…,Ûı™§Æ?ü(Ça—¶¯…'%ŠëMßÃbz•÷Q¶PEÊ•Vˆ^Y{Ó&¹İ¬~™®‰–’k†/m‡Ûuş^¯6ê‹¡2çºx†qÜÓª>OFØŒñ®ŒCéO7‰GšU¼Ç‘¢ã@ŒÏ>{„Z6º+KøÄÄ)fÏÑ£w-òáè–»ƒ½‚“[ ¼ªò¥Í¦ò`'ìúØîòG½é5ÖØÂ¢µ¹q}|Şh°©D"vİ@/•@iéÊÁ8¬¤—KW°.ˆ7½æ˜ôñÁâ°Á±My³ZûGNòñ†ÂV2ED©–ÛñX[Ç6ã±MÛŠÇ¶4Ç’,ªõ®dl`ÍÏx·«7PíSÈwî9‚éÛbj¹O!œ+àdLK­ö}
+°DCŒ%+‰¢¢ß°ˆ¾U»0°€1X)ó›q˜úô
+&ıu©šJxÕFü·ı/²Â¯­I€†w4€'<XDöEUº>$3Úè'Ä³³qüƒŞšõnŠéPBZqè«GÂº¼¬”¾Qw°¯×Şî­	pèÜÇ¯ƒ`zWz…“W}Æ[X0cÒÿ¢ïıC·Ğç²{ü&A5µ…‹tµ»ÇKa8XOı¦> …‡ìnUqŞçÈÙx©äïş8v”)Ÿ?†¨Ûå”êMS	Tï_İ’¨ƒ7!XÏÉæ„ÄÑtÙÎ¥%&Å£µ»(_ÿ³]ÿĞMĞ<éš	Ô ¶¯OÅ«tyZÚæ*?6‘ØÜ˜.ğ3„½ùÔWş¢=Ú˜8Ø‚…GÆÂAÍÅ~4áBX#±fâS°§˜é˜œ{Èøø*/ôàu'+¥@ğÕx0gøaëv"õÿx©sg…5Æ+½6¢	E‡`rĞW\…n+Ú?ªoĞVÖ™Ó—¶èE¾º1‡dqÕì.5{‹Êüu¢Ä!ñ™'OŒİ;wŒİxƒû†íJ¦ ¹Zâ"Ê9cÕr ¢½·œD)–NêZ_|R6šM8@F ²•9à•MJußl†e€ååQˆÙ	£æÜ	ŠjµÈÕ”f‹Îª¿RYt³Ş]‰Ğ—WYIZôsIxµÎæšŠíÏ$	§w°È{$jdš}y¼ó	§©İ•æ|ù‡¢GE†¸u›Ú¾¤ĞoÌúÍ')z¤hÀzÒ¬ÃoİI€ğ?Õôg¹ümsì£2ê’|
+>éMøo‘%ÃŞ=†‡Ä’KÒ\½j©…éÍ;¡Ö1÷¨|V—Ë<‹!òÂÃjEñ©ŸL‰#ÓUkÜóÒÉg/záØVúĞm†çF†uúqı@b ~¶67?æåTŒ.Ût]ìÎ‘à‡³GiyÑq°L×~yœ-bmS "ˆ—gö‚Ÿ7‰Ñe¤@ÂM›»‡”[Ş;nD×÷°Ig	ÚÈ¥}¨„Ò
+hÕ#¸ÇÏşS†KxrG0ÀŸ” LKr7Š¥ìÒ4æğ‘r:Tõ`/ä%(Ê<9£¡µ¥Nâa*ılÆ»~?™óÃGnÉDEƒÂ ‹·e`ÁÖÌéĞŞ7ÓOXe7^¥}ÒxIuw·eC²ÖßU¢dìnÕ79äª\Úµ¸¢D±·8ô.?~×åÃCˆ#œQ•{­MbLÎjËlF3¤5ğÎ‚º¤R+7›Ş¯jKŒc­‡êø!ÍG—Cñ¡8–¾¾ò‹ú“}ó¬áï!<0õ-Nç€Ú
+·¤[NW¦ ş“«ÍdŠÖr±ä½µçC	ª+-Áò}Â•Dü<Ò©`ŠjoÇÑ#±ù^‡UÌ\gYæTUÄ+µÄ\ŠàŠ&T¿ŠÅí©V¡ö[æÂ
+1ïÈñ¨Å’Ç¸ÊİÎ%N&şÅ~®¿U£¯ì¿;æ¹ù³yi~0mHUØ‡¥c"Œs#!>ä8š”‡°;@K2+ÁâĞMˆW,am
+àÕş¯Hº(¢¢t ÓiºçXEjŞœÏú\TcûêÂº„ûo;íâìK®jr°ëï¦qe^Ã™Üö9P·¹38Ç“ÈˆãÙÆªÛ#â€]ú*BhÌ.ÎT$ìÃ’8Â%!	7ÒhÌgiAˆ|ûÍŞåÔ«ô7cù*Z!·)ÕÕ~!(?hK« &°`ö+‘?¢n“ßÑìJ^©;%îÃZ½a‘ZÅ¿ÃÊ
+êØ–±-VNx}ïKŒúö"É`Pä@AIîƒnw`­V)œWA­ĞuIõ9YŠ³Hæ‡¦øÀÜ{Å•×b{®ù'O¤¬;(hÅolüY?hİNñoƒx£š ²¯Qøğš*vK–‡­"‚Zmê®XßÃ”•—X\•Ÿº1m„k‰ğ7_=“W“¨yK)ÒıõNüšn—e›ü›%×ÄtºÃë§h1A mäUšù8ÔuPy¥&pšòj)cãŠÏ‚µoÑ'Ê$Ïôùğr\kb9 àZÊnU½q²œKÁã½v*<êa5(9“ãÁ“‰ÆÀm.oqÈË"Ôi2¬¿ˆn­n¨
+ÁªNå	,“ÙÅùœì¢I–5 GôÇfSgá*º4²ûÕÆ;¿òø‹zt	¦ÒmvÿO÷W\al»oQ‹&OŞVåB'€´G&XéZNmúæ“[¾¬ £\"ÕkŸv¥y€×‰•¥ƒşA,¿GÀZf:Ï®lÕ«*b+”Fö‚×íÚİÀ­€µ²”c$ìa
+`Ö)"¥
+—£$ç–XÉ¬2ä¯¨‰{ïëË¤ˆÏ²¯ÅM˜jÁk3Şòb~¹¬Ğ­‡Aƒ•"7š_Ÿq¿¡¸MğBøh?‹]ê
+ÚŠ³Á¾ÚJ ]Œ4V$à’&G¬gZBz·	4ò»µ]]Âˆ7ü^dtv1%—C`v\¿Úu©uØõ«9ºï;¬PÕGH–@¾Í€Ğ÷Ã=™ F½_i&aã€ºúÊÂŞ‘ŒJÛ£R½‰D„İd?£RúùÑ-;*µ"G¥ä¤Ô5-_šêH—Â†#açú½X7×&„‰âİÅ.qù<Ôšøaé€ü»I<*bMn5í‘ŒYà´Á.£Åİò=LÙü½Ö5áƒEjr¡¾’ô/XĞ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/3e/52828c905c6d069e86c85a079da53fb86d0239 squashfs-tools-patched/.git/objects/3e/52828c905c6d069e86c85a079da53fb86d0239
--- squashfs-tools/.git/objects/3e/52828c905c6d069e86c85a079da53fb86d0239	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/3e/52828c905c6d069e86c85a079da53fb86d0239	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1,3 @@
+x+)JMU067d040031Qğ©ÊMtIMÎOIÕKfPÜï°÷AjTÎBãÏ§·y¤¬kbú©.ƒAÑ i½ĞagÉµXŠ7Iäşæ¬úd¡.8³
+d¦íŞMeJ0R®aH{½í o$’Úà’Ä’T¸bÎr¿8q†§ÔmşoNf·ß²,Ä¡8ƒA]‹ocoç…ÄoŠæùÌÚµù5ÃûyèŠCR‹K€ˆıòÄ"=àËc«àWÓã¼Yó§oWFR
+Uõ3ªÔZ‚óÚ²îõÍ^êÇÎº6­à‡ªÊMÌNMËÌIe¨Íš¼/eÑÅYsŒ²^şåìÓF˜×ajôÒ““fÏ‘2^´®TİËìUsãëìğ×G+7  r”S
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/3f/37f258af991dfae7867dcdda6bf710e0659969 squashfs-tools-patched/.git/objects/3f/37f258af991dfae7867dcdda6bf710e0659969
--- squashfs-tools/.git/objects/3f/37f258af991dfae7867dcdda6bf710e0659969	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/3f/37f258af991dfae7867dcdda6bf710e0659969	2022-01-01 15:09:15.669172591 +0800
@@ -0,0 +1,94 @@
+xí½m{Ç‘6z¾R¿bÌ\’!™¤^ìl²’­,-Q67©‡¤b9´/\ 	’X  -q<¿ıÜ÷]Uİ=ƒEÚNrÎs7Kafº«»«««ë­«†ãƒêÿşèßı_÷ïİªîUoFÓÿ¾èMO«^e?§Õñ`ØŸ^Ngı³µªÚ;L+ü¯WNN‡—Õáøì|ÒŸNûGÕ¤ß;ªÆ£á%!µğÈ7ÏÆç—TšUÃ»Õ£­ğïçúû…şş^ÿMÿ ¿Ôßçß‡ô÷á
+áQÕªúÃ/øîõé`8œW/Ç'§ıIõå¹½øÊÚxr²vñî©wHc9ŸŒO&½3éxÒïWÓññì}oÒR]/ªÃŞÃ:Lg“ÁÁÅ¬_fUott<aƒgã£Áñ%ß]ŒĞàì´_Íú“³i5>ÖÃ7[oªoú£ş¤7¬^_‡ÕËÁa4í³zoZóåôÈ;¸TìÃ®÷¡z1àŞl0=©ú€ŸT?õ'S<W„†ñ¤êôfìê¤Ÿ³à]ôï²öĞ(»¶`¼yXGÕ`¤æOÇçÂ)@bPïÎê _]LûÇCµTßmî}»ıf¯Zßú¾ún}gg}kïû'(<;ãkÿ§¾œ9éf—À	ıjcçÙ·¨²şõæËÍ½ï+ŒàÅæŞÖÆînõb{§Z¯^¯ïìm>{ór}§zıfçõöîÈnXÁğ	`1N«c ;OúÕQÖ§1ğï1“SônxTö~êcFûƒŸĞ·È÷œ=ÓàCÖlÇ£…A-N8OªÁq5ÏVª÷“d6¬Ú<²zÊ•ê÷ÿ^íõ~õzØ;ìW«Õîë~ş9Hüëñt6­T¯Ö«>|¸úğóXov×c8¾H§k‡ }ÿÖ­ßF‡Ã‹£~µ\|;].ŞÇèNß÷Î×Ú?q)÷fõ±¼Ç“úû½Ù¬ñ*7İŒÇõòÓÙQ‹çN}	®rÿo¥Ÿ6>Ì.ÏûÓµÓæk”?ëNÆ-Ÿfƒ³ş|0'¬ÃÆ—áàl0kÀ8d“pËıâp†Õˆ}ïxÒ;9ëf]=¯T÷°${öğ$Šş÷EÿEgã.¹`‚Rø‘q%Úƒèƒ'ã³®==¹u>;eîô¬ÚxÒµ7¹ĞXĞ‡îl)õH/ÜºuÿWiğ€)HKøp<šMÆÃê¼ş3ìƒÑˆ•bîßŒf$áC°îñdZ}U­>|‚×Õ³ÿüö±¨s<éM`ğÓşL}Ô?î]‹J€  ø‡üƒ] KŸe9ÖÊÁÅ	!ê?”±ŞĞä9úy<ø@KÑ'jûGk·æz„z§¨Õ=ßUÓ¯‡ï€wíSÇÓ.ái\ÓŠÓ<ŠÍÑ`6èÿ£U¹õæåË —©ººÇß>?çªëGØÉÀj',*£†¨¯»³ŞVp<ÄÏÕƒêïFÑ<q´úP£<¸œõ‰r¬v}!òW´cv§út4˜”ÓË³âñÖÒQÿ§âµÇùùÉ­ÃÓŞ„”4>ê{OmŒ / îÎÆ“ËÚ‡DÊ§ØÿíK33¹¬Aéòëş¿ış÷ŸÿÛó Ê¯O4Ôã£'·À'#°[Îğ½‹ˆ¨Cõ“ôĞ(¥•vÔ%O»ÿëÍúî·/v»›[Y¹ù¼ûbgı›bZ\•é%d–nùÂ~×z"jêNAÆíÃp|bCN)Ó /Ö_în¬`Çãü„=<}Ä63™u‡œİ½7Klá¤ÿ!ÊE7ïb­€øÁ(0OVx2Ïº¾2íÍáxxq6a“ñ5 èÁ<[˜\Ôu¦àëé„Ò™wgÅv-¼ÀÔrrj¸™¡•¡­7'T{#©¯€œYDW‘/|½úGöÆ¨qtqv ğU…õÍ·£qW»	¾]ßÛÛé>ßxaŸÈÓòGá<•†ãñ»‹ó.9öş¨øó­¥+·–@"/oîø¯oü×Ë­?û¯¯_Æ¯gßF¹ÍÛşuwûY|şµ`nÏÀrc$Â£³?Wìê«½ı«f‰ÔO§ŸVG_êŸÙ{}¶}åˆôõ í+‡¡¯Gm_‰}=lûJ¼èëyñuçÍ.ê ÷öŒëÓIñù»øl?áóûâóÎ7;¯­¶~@ì¯×Ïßéôzíí½o­¶~@,ª×Ïßét‡Zí·èZõ7v}÷ÍæsÁi¾‚6Q›‚æ÷T—w‹qµä«•Š?”10ïÄ7Ñ‰Æ+è?õN4¾³ªË‚µNÌ|‹W+Ö:üx'ş²÷Ö0Ñx•ëÓYÙïÆwvBuYpïê‚o5,˜:Z÷ÿı]å§ñà(3§ƒŞ¤#q[ÀJ&Ø‰V°è!UèÏYï1eñÆ»Xk¿ƒ„2õ!8¿í¾ÜÜÚ¨şÛçüâÖ-İ?ïö?f»·~¾õ÷[şÓ{ÈÎ§Ø¸FGÃşD_—\üÃîùõ/šXwãÃÙ°²ßÛÜ~öÍw›[»]©îx™»ÕWÜÌï’©0D®Ùegwï94¦î‹Í—[ÛwïâÛÒÆÎÎöNg9©¸:†âÒ?Z
+#q‹r‡?>¨–YkiÙüÃhc^ZòGpÀ?bCXú{ÕB¹,ß{ÏÖŞO!ŸÔÆŞNÎêCOÛKÇ}Va4·«/¬"QŞ;:êRê9ßwôÂ¦â€˜]šôg“QÕÙÜÚëb& ÛôîV_V¹şôtp<k… /­P>…‡j…MóWi8ƒD:8^¶‚óƒş¤æıª(àËv^ÿ`—áp¨¤s)KaÎ g;,5>î”eî’BIVTB“”°ñvs¯ûfËdœÎò6thè£g}(²0-ŒªÜ›sA©Í›[á4ıío¢‘y¤ˆŒ1“7­kZ÷îŠØE	Ü6„É	m=PŸVŸR¨šµƒ†Ê+<T$ ’jŒ=ªıxûÖW›A#ş…z”®Åg.‘P¸L—ÒÌŞñrzµb3S”„E	$¡¼Ï.¯Sv“a*—‡š+V¢»ç³ÉT÷ô~¥2ŒÙ"=Òá¨ÿavNŠª†úQê¤F#²{;X¿ÓQ%`Áhpõ©£ÅW¸ã€8óg¡’t-	ï{6l›Ü¬C`Ç÷ı·5IÍò˜°4C>°zkTzÃ40aŸ$]²©¼µ?ñzCg÷¤ßŠf¡6czz+ì[K†ÚWÜj£½yNJóØóÅÕ‚DMÉèa½Ù4¯FıóÓZŒI“Ø@+§ñÚXM´ló˜|tqvŞU¿ÚhYH®ÏÚ¼O@æÇåW½¶¾ocOÔz¿}t{
+N¸HÖËUò¶
+TZCÉ—™¨ş•œŞVãÙPö˜ìÓ!8Ø¼Ï¢¸U‡œ¥­~sæÑŞrÕÙxõzïû»Ë• wn¾øª?±[ ô‚;àTËÜûo@ş°=£ÆXXieÍ1Ó–NuÚ‡aF!Q?d>4Ølˆytc˜ÛÀ|oÓS˜	d-H,Š°ÎŸ­¿¤1wo£û-tøÊ¬>•Š­AøµÇÅ*ºú4waŸ?Iğ¾ À D	)|2Ë÷Ÿò#ÛâÊl¾óv½®ƒ%yß‰ìŞ?õ-ëfšæ;ï°ã®9¢Ä%B3kX½jjÀ¢Iu-à~9Ô’|KØ%ºë²Ù»é8Ó£Ó…İ3q|l~ÄøIaæm!âãÓ[cr½w\oë$›
+í1>½óñ5á­>M_YãŠÏ^²œåÔ(…iÒIšM¥Ú:Ü2T½BÛĞÛ~ÙªHHúEœ%-Š„9n¸¤ˆ¿Æj¸Êb&0ü4hYµ"Yë-¹Ê‚!q¥À|¢Ö‚†]İ¹ÓÚ„>q ™å#²Jî[k´Ú2Î©Šé49´`ÏnßZçèkl@TkÅàêŠi.^‘|ÊÆK4æ’Ê
+x¬ìÌwÜÙ/¹Ó7Z&hOZÿ–[pëÜ›¤V®V_ÂY1;¸8>†­»¶i£°tíåT[RKmt­UaÓ “Â¦§ 1±¡/Í)lª …Âæ+º¤¦S/REŠ§\$yò+˜IiÈ¥vãp„TQxÚÿ QÂ•³—7Wbˆ·¬±ÚŒxïİ…&'{?eCOñÆy¬"7|7>÷Gò å¯u¡Ï”)&!$)II¨/´®Z«p‹±åUğş¤:IzdÓÄJ‰Í@ŸKA/Òş‘íQ’gŒğˆJQ"*–è¯†ÿ¬W©@E¹;›	íMó=Û÷Átô©8W·JÜªÎxÆ\aa¨21ôˆ†!¤ğIÓ•>¹ËOæˆCXƒ…åhOWğı¿Sù£~8Ã<  o¹:™ŒßOÙ@ÇH—¢úÔ;4%4l¢ÊÇ#8@ÄîÆ‡0ÕM+˜Ù¦36„F{vZÃCXDæ[G$Šh@#ë%X2U\R(È«!¤)±mºD±ó’±©BçêÓ¬/ÆéÑŠÌ«ÂENãH¾#Ìù\! äÃ&Û‘õ’ìğ h‚·Còm%v	•srÌÍ¢UvÎ¾€:*7…Âu1ÂÄÄMR	]Ë‚¦ÅiØ|˜8Qƒp—¶†ÉšõƒÛ`ôpõ©ñ0ël¬z½şì3 Ÿ{¦$ÜÄgŒ¯¬¢8?ÒşRT¬óPÙsãfL	,ŒKÒ }ïÎ+ƒoÑ‘8˜Ğ¿{V„Lpt‘úïm"TÈGè-ı2æ½àÌ>ä˜ğÅ„ñ™¶2îÊ}âº;aÍÙuoÜû\ìBp1aV>‹:¿¢i5+BS-T‚>–¯\XpÙ%	 †a£–B Y"WÔ¤ùtaôFµ‰bí;çË­+>şDk	É"Ôb¹)™ïêÛ‰™­•í„Í--İñoÁ%ğŠtlóXq\pu]s-ÄrÉü¥m½ !a½é¡G/ë›Rƒœï‹CÊ«¸†ªªË\+¶©Chû“Øvu:~.Ğ0Š\†´Š6éäÃ½Ã"£À_Àˆ ¤êp½ñgâ<|ÅÃ>Vùùˆ&4Ìš%çÒÎÒû	®ÅH0.Ë¶+hLh„e:#¸ÌêOú«„v×ÆÁ©w
+sjmÙş^Ö³üo5jù•SA„p ñ,‡€,¡©Ì>„•’¥9q¨R6ú&;Ù7YßzÓ#'Š3°% ¶óÓ G&mcÏ°W›Ş…ó'6e1s›²Ì©¯ÇDÍ6%³r–$’@¤gŞI
+Z2#jîÅ3]ÖTµTÍ„¡¹”zÎz“w¾Ù¨ƒú
+8²aŸAQ!=FÑ!,o:íM.ïb¨ ªŒ<‚ÚáB‡èÂsÍ­ˆÆH†
+H?!ØçHQ€˜"îl\Ç(X¸|í‚0Š&F'ˆiÈàDŸâ€³€Öãúad$ÌhvmÍšÙÖ'Æäõ©ÓNb,ş:Ó¡G7áê_’)ãØK1¯¨Œ ³ò=Å1,Xƒğ¬‡~[%LàHC§-€Fÿ³àİ-›±±>œò{¹Êâ&ãŞÑaV˜;-µÁº> Ë¨-duCH¨×DR3”á²¤Yvk1É–tÊ’¢	°‚áÂÖ²M¼Í;â;OA{A;N³Be¦Û’æI–…oD$á^¨ÓÊ5æ!xZ ²ğÙÔ±¨ù+f€ü|©1KiqŒ€ø‹§¦ğrÙŒ©CÕ=ıSÎ|ùí6kĞj1=Ií`xr~J“70=PJ¦Õÿô'cÈÃ¶~¹İ€úMÅÛ ,ôKÅwÒ${@ZGX"Â¬úg=ì wHÆ4`¸Ÿ³nÓN,¥½æ!ÑHûéIö{ØFûÌÕ;ƒaõq…’£Ö«_ÀA’EÛÑê*Xz^¾¶&	~ÎZRA¹Ã•ï] äb£+ùĞvMæc›éM*(Á‚ûØÊ( ©†‹2¥X˜iúZ²Ä„¯É{8ˆPX¸'ş"
+—ÛK}®±·ˆ¬ëpè¤¥Û+5z¾YLxÀN“¿Tæze….YÍŒşZé‰ÄÁ…î³\ı§ªZ~A«7-_ÓÖØìŒñ¸Z„¤è£”QŒ¬ÙÂPqPp“=á—ÛèğZ¸¡¾? \|:<—´±R-¯¦ÿÌß…UÓ`ª<ñXºÁkg=Ø1>Ñ»ÁgŸ•`tØbu§^Nnm‹ÂCMhüî§×çã)Ht<¢:½$´ºÈ„:6Àˆ:ÚÛŞƒ§ëÛõİªzô{§h2»™õÎú>xDØŸò1yé1¶B†Ä>=|ˆ[PÖÙåşÃGñó?©îÃÌì18Õ´¦ÂÅĞ‹é…:ßƒçâ\=•Eå»0¢‚HÖ“óŞtú¾?VÉoUÍkç·³3D¨s€Şˆr5|Ñº_6F¨Eåá@ŒÍàâbC@,Xäù{Äş"¦˜£±4 [×d¥ß‘6ÂŠZÓ‘·$œ âÁ…Ë·à
+®ƒ!ÖøÎoÃ``<ÔŠŠKc¦î†>B{
+Åâ‘à÷µ`Y;ZBË"à'àúXšÙjÿğ!Îö  ”=Á€!ó¨™ 
+Fˆ]ÇïOxğ)Lv£×bÀÅ}ãásQq˜I`aùŞ2P^½âƒ°B<G˜êğ×êÓó÷]RkÃUn³¬¹8™œä¹ÀOŸ/qÉÀLÌÍ†ú?q6baÍOGñEóñ¨œâ£~®>=™ø”€¥zÄÃí)Xú}ü]ßÔrv"ç»»+šR½ ˜4¬kK‡§±¬œ	"T‘Æ¶V!†ã|^ 6š	éqÂµg†$×^ ¸öŒ d>/W.
+¸Jç*Ÿ4~Ş­VY˜Œ‡okŒû½!B0ğô)ÎTü)?>FÔ¨à82høŸ	Ck1"Ä6×:Œ8éß ÃhüÃ“
+¨.{=½ıùÑ
+şÿc]G8È²õŸÑ„wƒoÉ|‡G,Ï¿¿£ñ>øp|\(Ù)£% Iôh[èwî8Rø jHh=Z½ıà‘ı©øë1ÿ€Ì€éÙêÓÙY÷²Ó"ˆú÷ˆÊµWgP`ğ†İõG=Ä¼Ùo¦Ããï8­V2}î¿±b
+„iœ?A:d¤Ñ½jõ©õÅ+á¤Ëp0zÇáF‘`ÈÉd†9Wı)É5„¯lg[E~³4;n¦³Şd†1’éŠM'yDÖµ9ÿƒÊ³g dËpç[²7\–s¥x›å"p²ù>Y@ÅÆî6çLÈ	odØêS
+¤¤1¶ùqbIÿ¶–p3p®š‚vš¯ĞP~8¢¬È9ğs¿f6ÿ!3HÙ³ÙëÚ@ÂaÔ,dá¿æÛZUÃÁêS¢ğ.9P³Bš$Ÿ%	".\Í—õiJ«…gûÃ´`tqnNeÈnªc¨yEğ½‰ç*á§ÿ…YxqX‘>Dø¹P$ˆHn&Áïí¬?Ûè,«-yŒæ}”‹*¤ìêÁ‡ÛÃ!bùU
+ˆÔÈwôRœAlFÿ]‡}EÛ8²°±ñçîî¶50•ˆ¸÷ ú—,âŒ8=È?®'q[’I­ƒ¿£±¹oa#gå|›IAº…ıD;%¹'nløì+ÚöUJˆ|ì©‹Ä¸§ë]6¸U{$óÈ2‘ˆK8İâ„À`ÒqšÔ7Gf'––7¶_ŸŒ ;³&t'0©‘SiÚ@şõ|Ä$|¼¹¤p’°ÛĞ¹°q-ÃcèZ!®ıf´ª‘©Ìÿ-4j\» Ú{\;nŠşpÓ¦á²‡KKÕ+X¢à$¼K©µœŒA[<ğúÎ×IG~ƒ(q1ƒƒ}oòIúù8ŸU|µ±·ş|}o½»»ù×ÔÅ2â„ƒ †p<ZòJ$eû¸Ğöë•¨[t©2††`'Dˆ?+ƒ®tüe¨:ñâÖmõå—ø€*NA¿ªıÆ*§Eã±{«ş#–õmJ¶j´²m€h>é|¶ıêõNÿo<¢¼ãp[JÄGEÄâ$LÌŒì£âE0äÛgîr>:<?¼6]£İjªiÎ?'ëÊP€Ø\?u3:l&ü·«†pİ~¿Gqe¶Ó˜¥\0Do$Ë2-ıå¸¬N‡æ}ÄEÏ«Z"GXØ¨‡m?¨„q( a’”¯=,GÑg¼«<El–Ÿ}«Í0\1üä˜ Œà}-Ô.høÅî …F cµJ>¶·€ÈÕE‚Á[Ç}v€ÄgÀMí ê’ËI½U¬Ö¶; nã ü3§-:TÑ70Ù" Î§Kè÷´À!0¡oéş}g õÜ¹`Ó²_«”mrVOÔ†_¡è# 6:¥š”EäÆø&z®‡n„°<‘ü¬ÊD“¥%ñYÌ†ÖqšZît^!Ñ9ìÄA†Pè:aTO’îd$Áé>«#cÔ‚D¾ Z’
+¢ûLÇé5Ã1ƒc?Cßá:Ä?ë/ùÄ<OUÌœÇGğ2¤>Y:ÉÑ«‰ß?©öÁ» óöÑâ\€C¹7&dæ¥Ã†0EhíïQ‹Ê˜5ôNïˆx¾èõqĞX:ßÖYgæ–lËAº€RÛ"‰5óÔ'&}I4
+kCiò^È/¢;mwhŠ/œO´²?ñµî×/aĞù.­©RÜËºşnœ¡Mñ<Eğş‘¨@Æ“â•zzı oÁÑ#æªMø&ü‰°jÜIÓà1«ÿ¯çPÂ„²(¿dXWÉ:h#I
+óWí‚oU@«X­ë«$A+B1ÔL•ä±×:’lbğ?²îd«°Dó/kS„Mú¨ƒ€o
+Ù,~›¨)LèÇÎi¡$A<°Š¿2sĞ;½D3¾ü%K&W³«®a}™Ešš€j¥±ú±C¥´ `K:ÏZ¼õCXŸ}Åı+KquX¸kõ’ÅB;XÒ6æ¬âE=;å<·!Ruî°”Ìek:y“Äé¬F–¢Š(AÊšsË;ş/&¥è ö¶¨¯1a¾8–ĞÒJ¶^Ôjgî˜7RÕÜh8ÓM¥¤0–"‹À"W)vEîWÜ©†ˆ¥À	áY„îû†‡_©æ¸ø´õÂEí‚&„ÌÄk“F7)ÅCÉ¶Æ´¼g,0T cócÉ¼uv| WT
+¢°fCë„£1!¼! MÎcÿKã°©0c«Ú;fî2¶ ÇH=ucSæBÀŞÏ¹ÀSû€œ¢NP?Ø÷ı¬½Í	†aùdv
+ºP6
+è—!º¼hhmÛ|³T‹H‡iöİtßÌÍè“-	z13‚¶Úe..¥§›Î9¹Ó ‡óîğïJÏ~2ùD3‹ñÀ0˜šÄ ¬,¨X¦ïasò@ğ¬¿Û@/P2½`«ılĞô—	‘ÆÂÔh–È¥–â•JğÅ¼0·Ò/>Şá3Œ+XkëN}ÄåJ£æÎj4—Ü†¸D˜-¹ñ6ÃE]ÌáÖU$äILõñ”£¢»†Wü­õ8¤¾Å]†<6Bô
+**03Çˆj¹uÉĞn”×6Š )—ÍÌ>As	}Uıïxğ ´¾NÌ*P…ë\îŞå:;<Eµb°*Ò…ÿB”p£)òñª¿ÑÕ–PÈÆFqZ¦É~ä²/´ÏÂ¾™vg0gLiFŠıeö?µz`AİÜ0!‰Æ‹,sß)¿ ¨J-£—h"(=LîŠo% …Á—¸ùø¾Øb”Ã«@©°]ó13EÔRo¥|[ø`‘à²æû,Pÿ´Y@—»4tå©`ª¼¬dÁétÌaú‚üuS‹%!ÙY€3´ñgZ™S'ÙÖ;‚¥	 ‚lJ9\hfZÎ¡·/?{³c\§-”XüH+q Yº”Éù ‰\Ú Áj‚tÂpi©ŞÏæ"FĞñ^‡øË…XVÑ2,\úä‰Nñ*­¤6m¬Ò.°Š˜óB“ÏœË¨˜¥’›
+Š3£¥eEÔey#‰2~¬,µ¯ãdEÓ¤1Pd§{
+
+bË î%š[Ê`¤!FÛÁıâ…¨˜•p.;Vò@¯‹¡³Ğ
+ì÷ZAD<ÖÏêWe5—–
+Hèƒ
+>-Z„ZôGNe¸xDD/æÃQJoA‡d ¢/pT4`S²´d¬@ó“e…$¢å+wcGj…nV5“ÏcBÕ$vT›ÀB}ïãš¯¬Áåƒ(]Ë-œ¼Şûvgcıy÷Õ›½·ÈË·¹·‰Ì|İØÉYéçÕ”å¢¨öl{ëy½'P- Ü—¹9aÀ·ggÉgµızcK‰”]hç›Í-„ÈD°ªëh!©y¬Øq=¢n©ŞV|°½,ó<•b˜a«`%²Ei€-i3¤X)·óI¾V£âŠwT.…ØÚ‰—ª£·Şe*¤¨]óªXdi@*@(84Õ¯‡îÖkq¥:%ğC±çcK$}XÔõpŒä†ï—ïÛ¬0~È·Ø]¸ûåè(aG‰jHˆ&*•²Â\s i:º¡0½öIåëÒ®iX÷ôëïSBRcûú»ÀÍ_+>~«ÙtÃ¯Ÿ{ù¹ÕÀph¬^;qä[K„ƒJ<ÌŸà<à ş’Ïn…Pÿ-Sú.©ì+lPpRÓ'¦ è_ğ>PrMğ>HO_ø”>…Š@ŞÑÅy¢3î¶Ö×´x›şü#dÔ=æı4f_!H(WŒM&:kÏ	®”Üc=â£¡—Áé8+#ş
+¹„=)‰İ
+!}ê¡8à“Ò«şÓé_Ÿ,$ø–}ÆQ½u¾õzbBŸM·Ş—¯}²Îç:æDÕ¯;#äñ¶r(ù#âğhÚ3ƒÜ4+5m–5µ50ÀÚ—{¶Áû?¶¥²4<$š–4ÔD² kÆŠTX”WİV»ÎĞˆ“¸şÔ„{³hf¾ùƒm} Óè‡øv§âJµİ}†yNàíîw;Û[/¿¯˜®IÇ´ÿ„·°5l=C¡p²&MÎ›=Àiü‡?ü+
+’Œ£¨EÉ+Gå`Ëh«¡üV:x
+ŒÙ…ÛZ`æ"WCƒrƒ±–Õ²×r0sìU”0$˜¬2M¯e+˜%™É-Qs—²WçñßL5“î¦)LíÓóK˜´‰×0C}m³ ¿DØD65BºßÁ‰™ŸÆ>NVÎ)À'›+„©Cp°M :R'ÓwI§Añ¦§}&·‹“><¶}ô‡áç¢$Fcˆ²â)êÿn:ÁbL’m'®î¹­©ø	-FÆ9šŸ¢y‰/“Ğ]££('>ÉO–¾FÔ€û£2ş÷?’~ÃB%"VLYe;’3ğ\Ô X‚ZS [ó•´Cˆ¡,	ÒêÓo }Û_Æ¶Ì†¼GX®±š;•õÅÕ f|”îaÃ& 9z,’Öj(«¾3ÚxL/õÆMw Râ·ß´¥f	Í¶Rb°O‘ßLç,o¢qMfA–lÛÉs#…Æ(¥±çª=V£(Š±8ònŸÉ"FÜà¹ÿÏ›÷‚[Ä’+ÇÅÄQ0â_L¤ğ¶õ¥~1Á²f"4G¢=?:ˆ®)Q±ÈÇgGFjAÒt³åV[œm	Èˆş·HrÒGìÛÚ£}‹,ë=N†Ïä‹-ÍŠP¬´§Rß¬>È®gG‚ÀrZÃ+~?zK•;wLi^TIGï;S‹¤M½ıx»Ett¹†q¸>Ì¹”]cC8ë¢õµ¶¾«l|umŞ-0µÉÑúŠãˆG"uÃˆŒûLYÜİûşõ9MıÓK!HŸB¬©¦.Øˆ­‰äÌã±İ$äÓI°Sx–@Û*Å×2£í
+¤j¤6¸–ï9J<÷J³ß»ß¿Bzè?§®7FÕüÜ>2Q‡¹Å‚Õ'‡sV…Eµ\2AAÖl¡(–qpTNM$J¯QÏ5ÉÇ¡$;Ş¼Ñ=­,s),éLÈá 5G«Kİ–üN^@$`Dóî½6=(¨
+Bóı²°`Œ;ñêÄU¬s¢¸ñ{i™J
+hË›Òp£¤B¾|¹>øöÑs/‚0‘nà¨òÓÔi'Moü%¬j|Å¹”üu®îË«+ãˆa®m¦l»N‘f‰É.E.eRJ–r2öv‚Fu8,	Äb7Á5u^0™e/ mRÂ|À¥éĞ:ı'	Á¸ “ğtï3ĞZZ:ƒ]	]ÂqÏm®Õ…â›Çºåx ÁGi7’dÉú'\Òµ@{şR¿—éÆ@Æ”şD¨Ú
+İ%s]yĞS†2ä`òŠ’4úª»r3 ŒŠ™æƒkÄ°ƒ· p½¤Æ­Z|HM«G¸ñSçŠH¨o­Ë
+VGœÁb¨-7à!°³Ü‚\=ö)´–w.ë²9üDDÔ.Ã²ã,ñ ëuBíŞõµõçĞbe5>½¬}k's^“c{<;pM¦Ü$\R©İÑ ¶V„|Êh}uÂ;zšxÃT“òI(2â¹6íCl¿“Nq£Pß5§„G7öMJãkû´Lá—)Ò`µâÑÊ‘	Ì>Èj_Ÿ ıÈ¡½1ed*U%.‰H(±å¶b±O"Ü„!ŠFZL©Š»‚Õ½JêSÆ6Œœ$e`+¯gºnt™«(¦ÌÅúöè²øv„Y£y`ƒ–¿²ñåF‘fºÜşäîüH´YâúmˆU ğ¡õio~åà³F~m ZÜ‚Ğ5K‡.i¶›4´ä´‘IÎ1BúÕ‘h©#ÿ4ü¢¦[…0ÒFn›}FœËµÀ4››¶ˆ4/­Úv“øWó+‚Òææ^’}MIl¤¥)5.I¦Xg‰ Å}$›%ŠZaÇOùGÂ2Ï>”VÛêì Ò¾Ò¸;Î´{Ò]ÍñÚAHƒ»ÇÌÚ> 7øcRĞ]¬ÚzŸoáP_€EÉé~Êk6¡ìÚ•å‹! G÷’fqÉ4£Ñ\	œÃÔz+nÑi:òQ:9iÓtÈ/‹ŠÍùÕEæœÔCNn¼ÁoÎ¬í wPyv£ò(Üâ°ïáušU>ekµ„öĞâ”ïYòéOïÊIñ6•ì%zR¯…˜OÔbˆOÀáfĞhÒwŸ^ìÂ#nÃÀGõÇùõŒ!6[YĞ7§è#$Y]J#ÜLª{üeY¨©«Ø4¦ÈeCë·JØ9 šñûXF§©}1wÍAaÊí•s Íæ¯ñUóÂ}ŸüÄù~iòÛJ°r+hÕçWHíÜI2' 7²¨æä÷O>-@Y”á: -Ø‹‚¼ø‚ ÑºPŒ¸xFkÓnï‹¦32&?,Ã°Œ¨f&È4÷ø¦ÃfUû	:¬Ó¼½†Å6Zñ>ë²‡î¶¢d–ól"ìò â¹ájÈº„d&j®jÁ6tTĞ“š•‡¡x‡Wnâ×}Œ½Â´™¾ D¢ÛV‘HŠÃ¶8×L0°ŞóuÑ¾Ÿ–¬™iÌÕ+’ÛF³–ö¦¬)W ƒıE²cQ94 /Á9rœÇ¸muœÆÒÔ±bós'‚ „ú%Ô(úÀe¨áãO®‹F	=æ!¾ 5ÛM¡¾›5°.Q¡NLxÇKm@ÒZ){>o84â"%ÑY[™Lµ¤qxãíŞÆÖóçãÃÖöî›¯±R }D¤å­•í?|ğè‹É­X;÷IR…ÇĞh)O}à!YcÍ‰Œ,M¨Ğ&mG<?œãÚÖ«tòXêH;ìÇÍ0hÎRŒ^ÄYÏÍ5šKS± ÆFöÈC»—û /8#wà±Æ(ZJ›.Qaî»æø¹Ï¤Vr(-7Â„b‰íÈòk,ğ÷‚!"Î7sOQ…DbI5ˆ¾C.{hb¢8©ë<e„×iKrßú:×N(CPûèjš]²ÔM/V!¾˜îŒlL~|ÖïxÖ¤8sœr€ÀF8›òjêşjêhl §8àé°9#»¥·†ºİªÊz…İÏ½n ¾é¸VÒ0E6w1qÈğİœXôv0y”€CùÉ¦È”08Æ`6{Ôgn^fëeL ,{^É1À“/†N¿}É\C ™[‚Í¶É4Òë“l¢Í6ºYD« 5èTË],iæöá®¼)ã‰páp@ÙYbÇ|naMÖÜ,%ùUÙÌ‘?¶Õ­ÛF¿ Pstÿºmò>¼_4¢ÇGĞì–K¨båÀí½Æ‹N;Z­ÕÛÕëõ½ow»ë/qXg‚M ª$QÛÍ3/ü »w«ÏHGõ>›kaá.öˆÛ,¹¹DGo¼—n¿”|¼üg¿ûgŸ17$ß ½yâÉÊÀÕØZçDdJ¯b’_8M¦RqÔsSlâŒş{›3*+Õˆüt-š(-öŒiá½@A€±gª/<‚Tœ£¬¾ˆ4ğæ³ÏlgoÀÈÉqIR˜)¡D‹:4¯I´·óúJièwªëz<‰ú‡¢¡B]Â¶S:®ÎSKBÎ¶0„ÆPr…ïéx$ØªKê\2(/¶^uIú[ë¯6ş¦‡Ííçú	yçÕúŞ³o	RU$~÷Ök(¬sÑ=<é8©Œ•ªbŒÛ“Õû²g‚@Ú®˜úü’Û]ìvÛ™Xéı`8¬È°>8Ìk^@Àü˜ªHfd¡f‚ü‡šOB˜"	öL¸ü›Øº P©.>isNCº»¸Ï£ñhULÙï#:f/£éúYÆÕºÂS‹Ëá^dDB›¶vÎL­ËN¶Ëã“ØÓp…ÕaÁ»‰·R§ÑJÑ´ [8%”R†a³¼^7¸¤Ó°™1iiêéè" èX~½Ú4Q¨iò0ï¾kjÁcâ<y»Xe`Ÿº…ş(İ &YÔa¬:è½¦ÄËŞ…(NuQ0Ï¾Q¼%$ª€ŸÅ»d9°Ô\ÿS‚Yyí&’´Õ†›:jj½^ÌA®KI±F¼=\y6–CY~ÜÒX?æê†ÆtÄ•ËÖ¦»0æÔÌ–n•Ë¬ÙààÍÀq~1Où´ì£à‘3–,wõ¥ğQër˜CïÄ”A¾ vìÄğÃ%k´.ì²(;†q6@tÜIÀe^­1ô¢ãs8ğCêåæYÂø3òØ”|Æ A¨³’º»è'ôğg€s¾[”Â`kæšc£ÇOœªMŒ®‡ëYl
+çfj÷š8Êë?Ä\O0y'ÀŒÂÌ¾ª¤İE!_¨n:ØŞd„" $‹“‘Õ1SÉJü«ò ª«/¥èC+
+8<b=Rs˜ÒĞÖZ
+ëŠ;Ã—æ:”Â»BK‡-Ç©’Ôãá|-}Rw4#×qÖÔ9x–g¿zkŸ]L
+ºğå,ª?ş›g½¡Ñï”Ñ¦)jDÒ%kX°¢Ü£Ä±HÄ“x ãøÄ P‹PX$»ñJ¬	Ñ| ;®±ñ˜‘$Ûí°dZÉê Æó
+bùÿ8óéºã>P2çËÄ×öÅQŞÎÏ±/c™É4S¬‘d0C	¶X¸€h		'mqgŞ˜ëNÌ 'l/ @¡Œ[b3V¯.¼B ×yx?Œ‡ 0U?ÒY¼ÿP3ß7î‘Ã$Àzˆd_$ˆa¦äSÈ7¹‘/§³şd	©å0àğB†Üœö~òk„w¿Ù÷Hv¥m>şú¸ŠèD˜cc@!m7‚GËÏ×Oœ—cåŸ½Ãğêüa0;ovwş†¿óßâ_!øÍlÒøI¶hnU Ç%\;b#qÛrdë$½CJ\ê#¢Ì	£ÎêØïîzêÖ±xŸ‹r~^Å‚“]AWŒ8+úFºZ¥“Y3Û×aƒdŒÔ¢xûß¸É	W+5IÂgb9¥’öì6;ÈÌQRŒUÉL•In:6$¤p0J‰[ìT	åj\…‚ælN}ï‹¤yŒ¾[8¡@lUL©F|[úx¤Øû=jÈ¬->Rs˜u™ı·lLl!`ƒNkÿGI18–Íÿ!bŒ­ù@™d23[$Èj.ÅdŸalšaNfæE›‹s„§ö!,SâÓÀäõ¥\ë~Ğ²#Äå¶Ø„ù† º-cÉR—b÷PqÆÜQÀ-…¿2æ<Idm_–%ïªE‰(ëŞâ¾ÙÚBP¥T«ï”LHzy$vúÓWgùx!ü.djœp³RlÜÈ¨9½/Gì}¸ïŸ˜ª–à€*"˜`ŠÜò<xñ3°ˆkåÉúw`Ÿü9íØ»»•§qMß°hmë8
+ã2CæÅOeØ÷ß‘u»_¿·ÑİF(õ'Ï›pWm=ß\ßÊIç_ènÖ_+w{²:t“ÇˆT˜«¤GË7´æ‚‡wlÚ=ëıXÀÁÄ…fú_şfHÀÊ<!Ø1<‘áÁ€n{ıÈ²Ô:”òÒ'”6ÇÒ“[¿³´“‘)ÿ×é²:xÖFÙI½|ë4zª‹n?£ÜÏl«À˜Ò›õÎ©ñZ:'©ciZÿdôÀfxçrö‰ÃM¯
+¦h1+gPßº®N¶è)KŸ“›~‘, ªn¯=:®şle;zx¥‡»U‡ç;ª}È¿ıÑóÂù¬GZaíÂ{Tİ—rMçl}:k_;tR®á†—(‡¹)qé\…„ÍCKë¶N+¢8uvám‚8FÑNNöXÎ/3…	
+—Ğw—§+»Û¯÷v²çJ6®Uf'÷S•ZÙXP)'Y·‹tÔ¸˜ñd„\¯h‹ÌBª¸§¾“»àÈÔ7KËç±Z@Ûk#Ï¯ƒÂùLfYá #'_DÙ½Àı£˜ˆ?TX5b"6>'­¥&ˆ*¡‡:ÆnØ“şv½RäVcOå((.Î¿æ±&§(ÏØhK:+¡¬Å*„\{{j.iåyàs[/vĞÊ7Ş¾ŞŞÙ[ÿúåF}š‚Ù,+&¿lc“'ğ,“ñíiŒĞâ¨1æÇÃS¶k$iÙ~¾Ñ ¶p1Ò™!0ÆğœéÕûkŸÏÇİ ­m©AŞOÛÍ¡F²[Ûİ;ëß¼ÚØš£ZNgôğ’Fğ¸¥!‚kÖBÉ5‡ùÜk{´-BÜ‚î(w9¸V‰¿Ü¿õáûŞå”—á®ÆOœÕµbİe›&­h}ıåwëßï.BƒS‘±”)#Bµ®b"%g šß®ïíí4B’H`ì-—şU.'¤(|Ü¶õ¡±.×4èËê‹Z‡Ÿ)15:É*A#ôáSÙ”H
+¸¯ÀçÏ¤•oÅö"b>wÏ/è¹L«ÔîYÿ ÚÒ}şæõËÍgë{mKS3-~µáƒş¯ÑÁ­‹³X˜İ,-%?¹éXNï0–ë¹ñ¬^É^.è%(NX,dK¬»H¡Èµœ–ò|5œ¡ª×C-¾cµ–VtŒ°lÅ™EåIbÑ‚c@ƒ±é®´òHİ¢2l»²tyd:ëĞZK.À&Ùg1ÌÆ¬-è6*D[1¿eÉ…MéÂ¼Æ°üŠ]®Ø6¦hh¾Ü‚fDÚ-1Í)wĞ¹VBº®à4ç@ê@R xi+IˆE8T­{  ıJ_æ;D²[P+R«²(SĞRÚ}El»q±GCºÇß)f å\®
+Eö¯”øÄV>aĞR/ÎjÇ´ÿ?ynA*„l}’´9îkà’		[g‚’Â‘pñ"¥ÛyÑ–Z ÿM ìjî¢;[.º’.qÈwŒ¹Å-öCZ¼?$ÂŒÁig2õ²‰“÷ï»_¸³Æ«ğ|Æ=˜î,İ)åR
+ç.c‚¹Ï`$Ãİ¦ĞV}?2W2¯ì„H+Ç-w§Ü
+º} v^˜ÿ”oIjù6ßrÎ¤/IİŒ¨AÙ/ZÆæ— }‚Q˜µĞV¶”w]â,“S#´€',­¬¨Æ¾LgŒJÀ5uC–®5â‹ÓS\²Ş
+Áo/?ƒõ·i“…NĞŠX«ÉRa¶.%–+uW¤ÜPó@sŠGPóµõL')h‹†‹¬~Øú­+Î´³&JQÖGRhâxÄÜ`2_¸—©0¹d‹ÌŒÎ†”îçb˜]Ü>í¶bVè#úXo¦yk›;œôÉÉë]ÌÆ«2ˆ!â–šñH«ÅJå´G'ıQ28DìZêâñõˆú¡;L1].ñ×ı	83k‹š©·@a—†ìH-­ªùÂªŠõkl’Ìµ»·¾³5¼ÃŸÑÒOÄWÄúç¿w¼øs¼ˆŸ éM­&8wh7rÆ•uBãˆ{‹d ¡„®#.§
+wÈŞçu@QÁ2àêòøq"ğõlÄc w<'2ğ³Šx\¸"ÑÔ‡,È`}X;Ğ<Î‘¢5VœñŞu³X±C(y>`Ã½Óo¼ø\}<³U	ÑHÿÕO®ÂA)Å½û«8<9éÔ\$ÕŸ¨ÁÒ*v‚¸U§cë…÷Uöğç$ÛP€RòGLºUfW™»fÁ30x”'ÖÂŞG7S4A”.úŒN€_`˜lQ·ÅcèÖF\]à(³3SË‚K‰5Å é„‰ß D§‰µ0–4lnuÿ²±³»¹½E£pTÂ¿ÍJOsÁ«õ·*¥¦\g¾„/,üÍV[È+OÎÑÆ‚Æp9ÎnÆ‰«¤¼ıH=9ÁeßØ9«TÍHe¹¡ã¿e…^Ã¨üb¸‹FP“vòÆ8‘¹Ş>±…†aaŒ6¦be¸­ò
+›.ŸøßßÓ/©Eöò_2h’öA%ÿ‚‡ØşjğÁ˜¿ëM´§I²%u4îOy_¥oõ„*ˆê5h•Ë¯v÷Âú7›Ïx$/f$Ğ\¡îîwë¯›l×	mAƒP™°Ñ#SêÙ+.öÇ0Ì~ad‘"?‚£jõ ŒÏ?t2ÎlŒœep|I˜¨‹Ì*]ä’‚÷ˆ"š\Ï¹¼ƒIk®©Ì ÚMúç¢'w˜´8§ğhkÓfNÑÌ/Ş„ŠM’Á}Kw()tu&°QßrÁ ÙØ%oéèÇÜi" oõp<úB2`ìùé‡x6ËÍ-Nsw÷ÍëOÏ—;c`ıß«ıç·«çº&AZdñØ¯ÏÛï^ãÌ%¸¯DgA¥
+ù’À×èööFfQ&yfîè~åü…l%“Å0!êo¢'i‚aK“	ºle°Jdí~‘8:ÕS.ŒÖ6
+¾Ş	HµšRúÙÛ/HúŸ¾¹Ä$ñ=`Ğiu°` Ğ¯øà3©³Pîy­ªfñÌD°ˆ±E°›5X|%»{„#dºiDLxĞc"%Ì0ÀO-åf˜ PÖVŠ›¢4í}®¸šĞMªfæ×¨ßtyŸ{ÙŒWúy?ô0×	ZŠÌ^åò+Œú‡ç—­&ÔšÍ‚¦-ağ6j©PÁ¨ş˜Í’›H¨
+Ô¹èXÖ÷,bÄ²÷
+8&Õ‡¶v¬jJJ€õĞ‡„‡¥Ü4 9–Æ'ög¼e[„[f¢eøHGáƒˆ—èN±3xÎ•ât¥_W(1Dˆã\3h£‚JB…À¸¦ È1'">¦Ê>” ÷¨`Ï¼ğ¦6ˆ±`­İÏæú¹&ÆzÃ²]ùÇ³è•]µæ£8ßÍ2õpgÉ4Ï`®D2Ÿ/æÌÉaÒ(8Ç&ms–m&G.Õ†^M†ï¸
+Âx³s³ÒU€Z#¡ùû20¦n”›G÷s,4ËƒXGÊ•ÓıœU&T´ö¹³ª@]‚â6:¶oüÏtñÖƒ6ëù™Ì[=;²”¶{ü.2kà²$İ(ãú=9­Ëÿœµ$pd©;¼Ôw©é¬Îÿn„&«Rá,dæ27ÁëÓÊMÒÁ½¹!×OãE7æÃKˆÒŠáì9Oá¹Hz•KÓU¬n‚”ßår±¦W¹”³ğ1áz·Ò«\J~î\Bùkìø	‚¿¨•À`y’qÃ¹„è	!¹P~—ËÉ¶da	X~—Ë	TÍ8ŠÏ}ÊµZı¹C­Ÿsí@o{³m_sİy£~nvş[ÔsÿL.ê/ŠïrÈÔ
+èM”Èvó„Ÿô*Êdz†“ßE©éZ›¥5Ò¢ÜÜúîBy©÷ÏËÔÄ¶†˜E±,ïÆ¾Ô2I¶‹k¤Å6|”0øŠòFgYãÕúnïTwªWˆ
+ØÉvçh!j,¹O…”úıUõºÍáàşu	¾Éë”i?ÏM~çbTšÕ\.½*ŠåyÍåò»¢àtmnåsŸj[—Q®ÜúÙ $±ıc(½ßù²k5ü8sÍÜx~×µkÀ|ÚV¯×Ê¨ÅR!8mW.«³lìº!¾{óòû•bù\-ç×írù\iMz#Áæi®c±d®Ò…ó.°Ù!“lCl+aóêšCC7BZŒ)µ"•¤ÔIÒé7såMë™«u%zçJ· w®Ì5Ğ›Ü£”†²|átü¹‰­×Wé hÃÄ¼’"›•>±BgmAXŞGñUP£©…ãT5íZ…§"`I“JSè ³]ÉèF×,…‰µÄ€„ƒÇò;d—ağ|ZŞGÕ&ºs™/SRu›äKÙÑõ‡kVªGk¤˜}3ä©î˜=ù)TH÷èQVx#E–AZ…*û3ÜÙ´ØÎ2›ç@X*kMcõ\x&Ğ#ğÔ?ú©\ò–Ûaâ»OÆ¸1cÚõ\:Y4w¬ßNÅGr+"D¡ïæ)½ê.p*]ğ4ñ#ƒù³-È–ã¡Ğ„ÄMÜnƒ"?Ö}.ˆ¿<Ñœ=üœ64æ(JÖT!š¹È¡\SèÈ
+c ¼¹£qõáºÓû‚å·×•cÃµ!€ıXÇY¥œ1 BÀÅUÇ„¡MŒC_¾ªİ~Ÿïy a}úÃHiâ(Ø ;\NcŠf.8?ÓşËT†®¥÷ôƒqK¡IØ5ÙÈÃ1;FV¢ïB„R•Ä"ëpFPôÖFÁ…B“ÈNÿÒ˜z[Áõo]ß4ÜÀ¸ ã?Xè4ÿ(Xš±zEÌZ:$‡Gà øB…ah¬Ía
+ô0UÇ¡eÚÊBåb:8…0D¯÷p ‹–l?xŒco|…Óõ˜;«‰·tœ3I16SÓÂá)1ÀÌzŠF´ı;›½Úa^T?TıÊÌU1è«ƒ®zvpm3B z‡XõH¢~fˆŠ	ğóÑ}ë9ÀÄ‹ßé®R%ù.‘–;ôÃÖ£ùñˆ¼ÀFyóµy·«­92TÌásÔp1·ó#ö¼†`[Åùe2¬‚^$Ğãsy±’ñruÛÑ)¬%N{ƒ¼ÃxÓBÄq‚ù¦«û¸¸ı/¸$»Çã KK8«“ôhæ·tH˜òëœoÂÑËRøƒÓ(ô(êPŠ§ ‚½³ŞÃ¼ë2š»ÕqıXkxß—Ü³6:ÊÈrK\Nv`ÌEdgÙ´[ã=ûç+kMÀq%œÒ—ÏDòe=V@uıâ
+í²I),Bªw‘Ö]"^V™—üƒQ[ch¨¯‘}çÏ
+çXÛ­Øˆ0†]úûĞñı:B©D®²Ÿâ>ÏŠÀ©ÍA™ú¸š/&(2¡gŸ @µ° ²×vıƒÔ‹Ä£På±§¹?Öî)¼æ}‘\™çûGü Òm]ŒB"Ğ¥ 	Ç•‚)±fÑS:ùĞMM8X\8¢UPáXÉdŒ8<Œwxi~^^É3±˜$¡ œrÒ²Î4Û¤²Æotcr ñziS±R}‚9#ş®0<£xĞmR|&um*sÁÛ­,Úi¥xk£Añ$Øvé']DíßÓßíPM(A±ˆİ*¹”o^Ò¹-¨ã~(']U5±[[Såî^ĞàÒ=ŒÚÿM: ‚òÄ¬B|ÉáĞ#»òR=fÆÅ¦`ØL'Q˜¥<zjÕ²¸¦)mœ…®—±‹Ìâ6û©]+]2_É`_xø,jÈfT^Ì ƒyuèÂ°€ä{¬s)5lR®¾;ĞÀ‹<I¨Ì7vw }£lÉ×õD e=¿,™)•ò!˜Z¡`‚©5Ÿ/W³ãƒğòušÖnH‚&©4ák-.(#@g0ºU™¹¼¥ÁĞ¤·†§ihëµh{P!\Q‹K|k-/èĞêSQ©øèR"cóZ‘Io
+ğ³y~øÑ˜ÌW~1¥š‹šÇA1n¿ĞÄRSø—H¹â¬]STd7¸å{sõ«ÍÃ/âc ³·õ ƒj¢H²‚q9CÆ (GØıÖ8èpªc–¸Õ†f€Dàz¯gîÄ(°›E3õ¾Küå.„È„øaƒG$W­ªAH1æÎ¿tÄÂ9Á$n`¨"uICK§jw½nqÙ;Ë#&Ğ8ˆo[ì¶B´„=Ay%ÔŠ€	„É¼g] –ı`ik›ûwPüÿÁdüŠƒÚXUúıwØ›×Ç¯””dÉ½ÆÑ÷îÉàä”s¾ãlİØ½Ï"YM}„¸€à‡°<tXcˆÓÆùû)nüJ>F\v?ë¿´œ‰-LpÌ½î©±åLÑ°äèˆÆñL^=Î°Øw‰Kõ©
+Óo¥ÂU¸Mš÷n©7Ş7»z&÷j¾Sì“ÈV­]r-f§‹­N±ÄQücwGié€KÌÉ‹wl½™E;·¥İa)®k2ìÆ^è+3…¤æ¾½Ö¾¥÷(Y—rŠXóºlŸ?`ïoHô&šZ­BŠ7¹;T]—Edvv¾/#š@*Áv!çãò½¯x’TtY‚6È¹¨ì,“úyPôÄ%_¿À¤Ğ&²/’ş=‘˜>ëŞ±mÍÓÅÿ Ñ(Rê™‡3âC…ì°˜ŸJ@ì))–
+%oCTç-Öp}¥Ü†Á-ÉÕ±^Bd›Ê!ãZìĞ{#£™öÜê‰ùÙ}Ë…ö­›19ØúŸ\ß|ô~Á"1ØQè#°Ğ\Il£ 5ÂUŠš6QP“ŒeİjXõí¡ºRo ùÒëÊƒkN-j÷}+¿B÷K±¤¦5ä‰Âú6ÕÁhZbÀaItå¬¾\‰¥¸Éã¡¡> ‹–I 8ã×ƒUdÄW^zÍY‚1˜“üWşø~€¼ÿaşåÀlÆ‡³a›ÅŞæö³o¾C|ß_oáe´QÄÆÉÂSHİ—İ½çÛoöº´cnm›ÙÇÉ/©Ø)y{C©]ØVÿø Lg‡ãáÅY>²íHşH‰ÄtâÖŠá½÷lí=2ïŒ‡‚Ş{ÃÎî&;ÿì[h…ƒ:<Åe=££a_6ğ\hıåÎ+•A€ÔYQÈ”­!)°âìÖf?!7æ¡‹Gíßq°‰ışşCwj¥Àr4W *‹4aaË1pÍ½ÍW¸ÄàHÏ}'µa§çÅ¬İšâÔQopşÛ¨ìµ:Şà°d–¢[˜ZGãé°ß?ïÜ©ÃAG	ª$§Dë4m€åx¦Í­½	Ö;U¬
+†ÎX¾ğl+ z|B® ôÓfKç¶~ºgÈ‘õ¡Ëe‰¨"¤léì•x új;è!áb¾ô´™îÒC3•Ç‘í¤ÊÌD'—rT©¬½â6‹Äq^@ü¶?'Zo½ÖG$Ãjï%„“‚C¸Ñs€ë¬úCUÀHÛoµI"¾Pêoesæ0Î`‰ä?¤S”Faœ01ÿ…oŠ\N”tt˜ä¬7EdÖxx„sS‡)lÀ¸3–Ûÿz³¹'~ûæ5ĞsÊ3f<·a+/Lz´DÑ$%-LhC†S4„‰œ:±„Ÿ°|–o!Ã[CW|FÛüJòp;Hò3È1‚ÌšñãR&¦°AYØB7t Ì”ıÃ ğ?¬<ä¼ÈÓ!¡s9H”6ätƒ÷¬7À,gØ2Ì àT8æbö9Ï‰3ŞÁªÏ®TÁ@Q¦õEEä‡Óñ?Z¬¨é2ÏÊwæ1æhä&¸ÅÂ¼µ{;¯n‚Û;A+±qüÆ6@‹%Ïp&¥¹FØ`èa¸ø€&IÛgƒƒıGJBÍMôìş%< Y9xCÁğPƒ¥ycCõlïe÷Ûï~gpLˆß~×]ÿËúæËg¯ßx)¸›¾*_§L=‚_·P_<‰Ç¤¸Ó¢%øJA¹x@çŒ2W˜î$ÌÈ7ÖL—Ì†ã·_óMœcS.%áüz‹„Ïk»îÃ¤å¶1‹ˆˆ„Cd“	Á<ÛKÈq§»û¬»õzgûÙÆîîöÎnw{ëå0ç”:…!ÒmÁ`£ãáø}â•
+DÄ£Gg”Î‡—mÅÀ?êÉÙâùRÆı'Ü7«ôuîcòóÅ"t>“röw>à<¨»TäçÚ0şU:Më·Åà<ÅÊ¬-L17b;œÎáÒ‹$4¡å8ÿºïX+ûŸK­q–qiRÙ˜âœVyòMˆÃâÉ5s_pŠ÷À$Ï1¡6¹¸¯,t:´gqHòĞ „9ä8LÇc€ ñ&ÕeçW{§ôÊà€ß”±Öl!ü#Ş¨3349oŠ3Ëü|?íıvY|Ç½è9AÙË®!‹n‹Îxç#¿OMúús`Ç‡ù¹Ö»©<j~ö±ÂöÏ#¤tÃ?8&ôÎ¬fmoå¾­±Å&lŞ*7ÿh,	¦ªIB(V¬z_X‹ äTË`éÇÈ¥t:ÃÂÅ\â´$¯<»C¡´ê$·
+éC¦ù©Ï§ŒK9€ı0÷½}pvqf>}yù%Ğ.ôÇ¼qÌ®‡óy‡Dº£Íğ¢.P®Àwôˆ/lJ¸¥Ht—Î]&DĞ»“C‚"¢ÔV5É||Ÿ¨WSe:­‘Ü8W`d"ÁĞ° ñ¼¨DŒæp3¼ƒß‡´£Sœ´c>-3>ÆVtÅò¥Âc&º@Õ¸JzV-ò*Ğ4‰igı”kPƒÀ"ÒĞmxìo~>·ìÈ¨OFÚ›\¢­oå(K&y|ğÓ`|aÎP'H¸«œş3:Œ¾l©£rO©„Ò2¤óQEœ[à¦HŠóº4ORìƒ™ºØƒ‚èºûğQ%p&xˆƒ!è-Ş&Z`®ócäš³<;	@“©å=}¹Ñ8në –yLåÌ†o“Õ#5#c¯2bàHéŒ¼ç;œ€?0}ÄÁµ)ïêQ³NØê¶£½XÕA¹œ–Ö^ wsä…3'†-$¶/›Şx¢s—Ì&Ğ¦9g}’¯É…µ¦›XãK„c¦ñdsà2ÉdêõäCI?æÍx\ó TF¹‡u0Û‰ÁfŠæ»m fï”(V{ø. P€o!ÙdĞ’Um8hXØ5d1¶mÈèo'¶G VY/úÖ]3xß:áNvÎÚINÈ¾Õ³i¡8Á¸&ÕÕ‘`.kL‰í†ğCèÆæÆ‚%ıæS2á>ø[ƒX¡T™¶éĞô¼ÎÎËÍW›{¸Ÿfêêà&Ë—	åqÓMåX˜”1Å;4wb ŸTÕi’€×ø§]ÙåI‹QACµo°
+²WH>÷bsksï{ó>„Ùn~ŒvûõÆ–,KİWë;ßlnâp²M€û/€ÓÉÀÏlß&›Î  rv„ıûƒmÕTÏ•¥ µ MšS	¡Iş}ùÕ\ó2ZÀB;ÆBMØ ™(v0m­‰×XàDÒ¦C¬H‰òC'«sMBMv¯²S}H§fšå™¬p²ÌÎ."I§PRa!»;4~}¤F‹[lÜ ]È%RnÅ#Hê
+1”«¿Á=(”î¢kØA™DA«¡AEÖîÏÚĞRVğf1,"ò;l\ˆ±eU¿yíœ#å5loÎ÷IUãQµMœ~s»š‹Ù‡ğÉ(8‘H6ƒPWe}°“µ(m\ĞÕá–É<—`UH¸-ì‘xŞ€XXIkjRi‘)L.¡é¾ñ¤7]QDóÔ£úĞs&¹³}G[Ğ7§áwqª,tŠrö}Ó.;K~Áz!ß¸¢ï.êa8-B¢©Ìƒ½[S»¤³7ÎØšÊÀğÜÀÿbü‘¤†!Hé?L€UËŒP«[Ûì!p°Êş´·u,MpØ(øc‘Ìµ~a,*ÜFÍ²"qr@°º"X¨N²Å¨~%…£„9`DÔ’Zİ.šÊ•vQ4!ÊøHİ9êA½0M˜ı®úüƒÃ‚ì2â›Tx˜*bÜ4¹¸…G©Ì¥ã(×äà¹ZÇ¼Ï-õÔìâBÌ„½L5íz°P¶˜(TÈ¶jÚßL#ïÆè5à¬¸›5©“ñÅÛ “$çZòë„,Û·0¸4Ñè+RCdÙ{İ›€húCläö—qÇß†ù",C~
+9=OÍ•id{èù<«å)cæo-²!ïnà¸İ?Cˆ
+ûfŒÉ,u×ÂáÜØŒŒ±Zœ«ù8ºè²Í5İ²çÇ\åîHµÜS‚å¯æc3"uh¥[ İõ„4C¨¹mÒÛ+ü1}Û}1$¥º;L™Ş‚®rÅ!%ÚÊ¡Œ¬¸•­ëa*†„uåo÷”6ÇgH×ÖÖ4}?õºÊBÑ;'ÉÕhõ
+]6qûP ò¢5şè¼Î­%4¡¥|õhœÌà§fiu
+©qø­õâ¥µ
+ê]ºÉ˜ÅyÁqï4äúä-©úÕ”?>æTTŸ#c<Â´æWÍ?ö6& M\hÁiß§ÿàçêÓ¿}ºR}zŸVùÇ˜ğÎ\Ç'ƒgÔp`°ÃyfïD¼LJ(Æ{©‰²ò€hÊÖ:AÖ¦;Ûí,©Œ¢ªDY˜çÁë‡ã“‡X'rqâ@Ù>eM@{ÈÖ|îøÈ±S#FFŞ{œÂa] ºÏÚìŸ:ŠÒõ(hpœÙ&XOYòp&n!} Q'ƒÔ˜#ôÅĞš€ ô'(aû—£-Orpš.0˜‚Pt¦››
+¿áÂi:ã ‰BnñşM““•j7|0êªÓ‹?…ÜJigêÊ¤mvÒhoãf ¸y 5< ›<Šgb¬-FË O¡d—¢Tÿu#%Tt#)Yq¦8u‚¨ÊµPkS; ƒ`j¼æ]Àz8Â ’¹ÒúšìÛ–¨àòªãÓ¿ºJ@%Yw>ıêScş\’¹ışQß-@İi¢¢rĞòqgùÇêö=ÜÆp_Å˜‰ê›õ´ş’Cß£ßÕíÏQıömT´ò†F™,y|<¼˜"[.ÍxÁmëH‘‘]3|:Û†ÂoGNcæç¸Šä `DCn&Õ±µÙxØQ…;pğ=| còLç¤Ùf6A )ê¿.Fp!ÃñvVZ@¨÷ì(Û=ò“ˆ*I-30øôÑ d p~ºÛd3w•´èQ’5MÉ]‘“ÆjÑ²
+uwp$ï.}¹½õMçÿ¥ ÛÃú[S¼-Õ£”eĞ	ÂÏ ùË×d3,Ë4·@é…s†Ü!ÚFÚ,Zd@¦è »LOQzéô›ìd€»«¨â'y¶OUªŒô1TñaaQ£µ{²å'==·”¿®Ÿwbr¾ÊµÁ_šo×ß’¢ë¸†5ö¿`M‡ÿlF)«ã;×¹0×h„\jŒML"ãfØm¿0,4 >­àš‡l®{¤E,[ëÑ»MJş¼Öğ\U`²s·ú!/,1§¿_¬}^u=xøÅı¿¿ÿğÑ]IE•Ãñù¥#wİ­X°z}Š´¿8Ä÷r|qÂ³>Ë(¾´üå¹½şÊ×Æ““µ‹wO`öæ»O~P¼cZ§{¤m­½3’‚¬|Óññì=4í'ÕåøÂíÿ$ É $Ÿ ½bG÷Çk±ÙUT>À™­
+±F:÷’·æ›­7Õ7Ì4	}}q€ŒüÕËÈqÚoˆÙ>g1ì½Étş‚ÖÈ]ïg¥[y@"ãÑ“8ùä«Î±òh¥ÙK0‚,`ÜWr—”ëG²cÍ&¤-DXÆÍRì)¬høèÀ”ìÇt-jv°zqLl®3´Ù·¹÷-¢ùªõ­ï«ïÖwvÖ·ö¾‚ê³SğÇJé é*ĞåÓÀæg‚àxÛ±†8µgßÈú×›/aã%cz±¹·…Àê²‹¬ãş÷½Ígo^®ïT¯ßì¼ŞŞİáP®v‹'NNImÎpº‚½Ny[X/:e.®|HãN‘ñ¸àOû?¼¦d&„[²]eÚe¬+‚@€E†.ŒÇ(#`%-áEq;¤2&›ÕeàŒÄÆÅÀŒ®fUšæ¤›Óıs–KšID {;I/¬ì›ß’ÒıúÍ‹ˆ|¾ñbıÍË=¯Ô4c Âóõ½õ¹ÂZ£q"Ó£2
+²<€×³–.4¨¤½æ9oW—šêŒ™ÊP¼dpXRz$p úH.‡>Î\aQze¿Lˆ© şË"d¯Äêpk]Â>îöŠ‡°O@Jä$×-6×;¾j§y`TP–3@ÇlsÏşiŸV‹åU_}ËÖ‡8[ÒRÎKøé‰ÄkÑ¯¥%‚!yJ¼âüÃ<(jLmoí>kÀã°Ü<è!ŒBæâKÀvKÜµ@Æ«¡}´¬Ç¤$M­8Éä+çG€ftÀîãI&KH#eõ®5˜k6ñ¡GÙÂ5BáéºC¹ˆvì´«Î¦6ÄÔ|tr—äs«£zÛX$Ÿ}6àìqu9µÏ[nOW«â£º.0ä€`ÆvˆrI«ìÕÌÏ2Ì:´ââ·9öµÈ÷WÅYâ5>:"äı0ê3lbDõ!A"T–>©ÉÿÁìÛR¬çù«R`Ÿ;Ï SsÛQÑË©”oÄ1ûB!NÕ¦`sé[:ïÜ%¦Øµ‘ŞÿCvA0&×†«pÎ-dUn£Î—¨U4éQï£h¿Ö›ÛV+îsÇ®Â}v]ëÍ¶á¾h¾Ä½îäÄäç™øÈ”_5	ÜüÛ'a~‘æ#¤9h“7Zç!÷í7‡¶öÍEÑ…Â\ğÄ^c-´ÌBLq‘!ŒY0X¼wSêü(ìà~Úó
+95äÅà‡×‘’p`¬sN<X'³.Ú‹Íü*ê…ñãÂÎ0I;Î²ëòÎ[í‘1¾ÃİdÛCŒxpüozT€;çŞtRüè»ÃÀv‡«P;éŸôC@Y,î%@b„`x TK'õBX×íª« [©Vp z•§ªWu‘	ÿe†1™èÒÍtœq1ÕmÅ¿ó+‡ÍÆâ%DAş;?AåWşnú:–µMdš.>À”¢ËSmÚ&›øœ÷èæ×$È”òm|«F[’k‡â?*_5ÃBúoŒ»‘&è7—$2h÷bVıHVÚC¬ÁMqAÂû­q!bşWáBÿ"\cU‘y!ñß_ºH†‡i‰ÈÀëü³8=×¬µ…Hà˜Êât¬ÇVÊoüïª4ü­¹É0ó’&¢Îo†¨óµ›"êüà7^Zçÿ
+Š:?¸¢Pü¦ˆ:†ö[->‚üW ‹íÒy3¹TĞÔ0×¬{S4ÿç¬·j9r~cÂ+ ÿ+jcº.½ÊMQx$X\Ä5í_¿·ÑİŞy¾±CÏ8	»±õ|s}«¶GäÛ&~G±­íüJ~ÊÏXl•ÒsÍ‹lÃu½—ÿ„À×š”³œ#€ SvS£@¬$·.ÍÂomĞ®öÀNDí…ªäuda÷	³·ŸMyAövÖŸm$¯ís‹ŸJXY†qW-ão\à0úK×0<aƒdnÛ=x^R{ªæ9ëtLI± 0œOÃ„+Oıü\¨6]Ìà¶çkøšÈ4Ÿc¹añ>qÙlÎ1„T¹É¶û=Ü=oq“×´Ú÷Ï?Züƒİï‡;ƒ§H’MD‡†tàÏ³Tş8ošq+×³ÕŸöÍıã³fòö‡#!8ôâA³f¯Ù[–³ß’Ó†Ckdo€ov¶öhvÑ«/#ÎÓfá%¥¯#¿‡€#Fê#;S‹”°5—Ñ|•±‚Nö³¡\·ìRğİ1Uô«¥©pğ˜ä–nÆûn?.ÀDrO·uÃHÔïc4p[Ûo·_ïuw÷vÚº÷a_wºä5€¨ˆ3«õb?Û¸Pçˆ*­ØUî§µè.üvœXşß†ƒa!|àªĞñZ/o ZĞs¾aŸSÌ¥¹Æ9“XçñÓ|ÓdÇ¤¿Æi>ò—¢Â<të•Çàt]†O_Ï×Zìƒğ„‰ WW1˜wœgCD‘+(®ñ®ie††‘ı5ÀÈ}+j˜ï˜§ÈØá:$1ƒvï\Â¢ ŠÎnìO}0
+^T'´ºÿáiÓb >®ùÆW‡áä>Zš}œgc©u½­;óW÷i‹ÓˆÈ‰¹nâÊ<OÃŒIEO¨w(H»Òt¶:GM,ìŒ/ñë¬ØÕ©¿uC@ d¡¤w=>Z¬¥m?mÇœÅ-}?ê¡ófPF£<:‚Æv¡XÑªíJÀ}:­@%Ó6ûøy0¥“²™øafÑ”ù}Z¼ÌM|<Ù£v½aù½n?2¹}äLıXàoöe²Oƒ˜&ùÍHó`î|„ \aóm æ³ØõQ*,Iqì¿XÀ†™	Ìy`Š$["ëÖƒødğ¡£C\“™Gè=å¨:'ÃñÎ£œø‰ŒÿŞÈhã$$í˜”’ÃŠW¡+ç!+”àcÇÔÚöafm´ÆÂ“¬em™bTØ¦‡/¥Jƒ
+‰&Iñ½£ìŒÅBxêà[døÜşƒÕ/(564BÎ‚k_âùM B™ıhQ¦ÖÇ?^ÙGé|…™µ,œ»rĞY¡Ê}åªÇæË¿¾Z·ÅnšÇU`ÍZø¥‹‚˜¢W½Ñb\*3aïêŠÜÀlEç/^öÊÙºpæÌ¸|½Öd=ûU­ôp÷´ê9–‚…cÙN˜™tĞsrı~Êp0›a£)Õd¨Ã}Ø¤ÁsJ‡ñ„GûÙÆn9—(KPNm\FÏûaã†´“e•Ç6ÉhÙ·+äº2S8Šu–á“^61™ùdà¶Yˆ¹á-EŒW£w3úì3©FæÑàH
+ÔÂ‰1B„ìè#‹	†V¡*tH5ì¿+Õvwç9’Ë|#×8Téú™|Û¸·[• nä¨Q?îSúí¡ŸÚüïŠ××‡ƒ>ğ‘İÉ}PÃRì8¢TAšQ8ÙÌQò?ÏZÌRu/¨–â”\‹üD¡ 	ÑĞE”_R‘íEùØì7¹äw€l/o|Ç«"Nx·‡Ø­K=V1±{{Dyi˜ÒŸù¹Øşå§Jú§b]mé#t Ö‚”sªâ~r2g´j—y0ÃUt·­èËíoˆâÆÑ©¯•aÅ2* ŸÒ*r\è±¦5°\U/²¶CÅ™·Z_œÏ ı|“ömƒ+zM-1ƒõ«†#ú¶(‡püÎÃêË/saM×âîÖûAbÁ¿a—-x›yŞÆg.ıØ±Ş‘Ë5\ò9¢Ú¿¦Q}ç‘Ï³ùËÎ>%^Å•·}îLOÇ³œÄ)Dµò¨+²\=Ày„é6ä½ğlµÁÌ]VJ\J[+˜$_¬5ägK]lÆs\§{Ï³¼àXut­	}Q·<¤2'ë´ªåÔ2•ŠJ:O	®2É’Å§5Ê-Ìf•ó=`g&«œr§Ë&b!q+Ô0dÿAQK.Sq´™ËÜ¨½¨fKö#³Ï7_Ãóíáx¬İíìCq6«·ˆØ£D2Ö®”6êŞ¤µªR$Ã…·©ßnl·¥-îíCùÒ½|»˜…Î¦«Á§òd£Æı“qğPgtc,n5K¤2;¡w^úİ `êÛäÂÆ¸¿¦“ğsMj÷ÕXp\W¼²ƒŒ¦M:rš½Áö;™İ¤?ßŞ™ìèPãuÙ©æ§â&UŸëOŠ1å&éC—×rû<häX•Éğ\¿£”Ì@(6ÃYWê!ô½ƒä…ÃÌSˆÓé•«'‘Ò§àÌu”RIDüÅp CG^KNÑ—â%C¯W+
+–'¡ -º;Åá¤ÃA‘úÓogF¾˜íç¼ZçÏ1ùj]]¯Ó(¸ıâNl·•UkvgÆ/_ˆÀñ“b,<$ùˆLú¬ûúlóCî:l×n>Âzc•œG–”]>cË\|Yr9çÂÙ`ûŸ†>I]Ş‘²ÀäĞ~ûÇ¶¢tß‹úâk9Jî;ö'ækqRòÆ èu±‚ÎNyÖ_*šª
+©ÌF:éÜV6–<ªA\]Y	‚a4{g¥S¶`Rj+x#…YÙ@G:áE…y¦İŠæÓí,Ë%¢ııÖÿfÃK~
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/3f/5434cb733dad70e0e40961bd7fd3f6c7091f8c squashfs-tools-patched/.git/objects/3f/5434cb733dad70e0e40961bd7fd3f6c7091f8c
--- squashfs-tools/.git/objects/3f/5434cb733dad70e0e40961bd7fd3f6c7091f8c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/3f/5434cb733dad70e0e40961bd7fd3f6c7091f8c	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1 @@
+xmÎ1‚0`çşŠv0ØÁµg` 1ĞÅ©±öšš˜ğÿASÔõ»Ë{ÏwC‹ã~—ç|PDf²Ô»`ÑQ­¡–ª‚®H:‘ø¥$_¿ ´äèÎü$>¯1R	ŠÁ¾ÆT¼«4o[~ÑÅ?<lêrnÃh‘&ëŞ¬O~±¹ú0ŞÓ¶MËÜÈ¦¢È–Ö;òîPU
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/3f/f6d8a29f11eef685e081722c69beca969208ce squashfs-tools-patched/.git/objects/3f/f6d8a29f11eef685e081722c69beca969208ce
--- squashfs-tools/.git/objects/3f/f6d8a29f11eef685e081722c69beca969208ce	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/3f/f6d8a29f11eef685e081722c69beca969208ce	2022-01-01 15:09:15.633172589 +0800
@@ -0,0 +1 @@
+xKÊÉOR03`Ğ×W.IqL«ĞËàâRÎLËKIMSˆqqt‹ˆ÷àRò3óR‘…¸”SóR2Ó¸ «éÄ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/40/552b85758c78d709393d5e17cc34770deacd2d squashfs-tools-patched/.git/objects/40/552b85758c78d709393d5e17cc34770deacd2d
--- squashfs-tools/.git/objects/40/552b85758c78d709393d5e17cc34770deacd2d	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/40/552b85758c78d709393d5e17cc34770deacd2d	2022-01-01 15:09:15.649172590 +0800
@@ -0,0 +1,6 @@
+x•UQoÚ0Şs~Å©HSlmÓnšìa)R#›
+{šª(ÖgKL»ªâ¿ïìÄİÚòPûîû¾»û.,Ó|	ş™ù®C×,!kˆ¢Éx|¿ßD×NO(#ö¡Ó¡l•î'ß(_„yBŠÛÇÑ¿g»ìG^ÎyÌI‰aå4ş—í×âêüó±ä1[å	e›# fˆ;=Uê…–i~G„ødkœ&/,i“ü~ş-ó´÷†Cu¨gLiÒ€§ÏêĞ' ×t³•_là:‘ó8W
+hTõ¤"ƒ¥gUˆ2ñ‡?DŒµäÅnÅk¸"ØKR8@€Äõ3TŸ,
+¶9]‘ÁÑ[_]‹é7 Y„“føeÍÇv{(kxc†(O¦ Eşg‹¿V/¿²ÈôŞÀÙU'œMÂÙîršAAĞ©nÓè¦„Iš¾âˆM\¹…  øá«M#°R¤Şı!!£¼•_2I¢ºÖX-–è)@3C	ñŞ”SÓ«×y®NFugh‡ë0¢z=¡+—%·açüÚšç¶oîR%ìeí’'8j¥*œ½êÇQMÚ?R‰^–
+âåfú²›Íë¡hç¸áœüİÆiœ†lÎÑXt)‹pñß¾a:ÓcÁMÌ6z—º±ùØ8PM¾ñ]»Z³k°´Ø ª#´@5O€‚ğ]Á„™šæÄk«]u“¤%±ü¢\½ÜĞ‚ö{MÙáEùG«ˆkªŞè•µµY­­6 ]]³Ÿ¨Ñê¹ªÍ
+y]»Ç¶©|¯gX—\Š;4+ş¶–Ğµóã3#
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/42/106f56d17d74800b64bdf3ebb36d03a8233ebe squashfs-tools-patched/.git/objects/42/106f56d17d74800b64bdf3ebb36d03a8233ebe
--- squashfs-tools/.git/objects/42/106f56d17d74800b64bdf3ebb36d03a8233ebe	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/42/106f56d17d74800b64bdf3ebb36d03a8233ebe	2022-01-01 15:09:15.661172591 +0800
@@ -0,0 +1,20 @@
+x¥ZûWÇî¯Ò_1%ÇD`!ƒiÒSc“
+,1PI4q•4BkV»êîÊ@sü¿÷ûî<vW§irvgîÜÇwŸÃ0J†ê`ÿpÿ/z¶[W»ª«ƒ±
+TöïEM'™š„‘Î³\ÏZJõ§a¦ğ/PÓğv=ªQ2›§:ËôX¥Ü˜ÄÑ#©”vá+Ÿœ&óÇ›rÕí¨çûûMş|.?¹âzFQ8WÉâvªSõrnüİñÒJÒÛÖâîØRfæir›325IµVY2ÉïƒT©Çd¡FA¾Æa–§áp‘kæ*ˆÇÏ’”Î’q8yä³E<ÆùT«\§³L%ùòæòF½Ñ±NƒH]/†Q8RáHÇ™æö Ss>Ì¦~ø(;ÎÈCÏò Îò0‰”A>UŸušá»zŞ$‰$U '«©Jæ\¸şU€·¶µAŞB¬±
+c9~šÌ!Â$!Ô=Ô©†Z-2=YDrt ~:ïÿxuÓWíË÷ê§v·Û¾ì¿?Ââ|šà­ş¬©p6Be¦Aœ?B'äø]§{ú#¶´OÎ/Îûï)ÁÙyÿ²Óë©³«®j«ëv·~zsÑîªë›îõU¯Üô ˆO›uª& 6KR­Æ:Â(s‚¿‡%3pÕ4ø¬aÑ‘?ƒ· ø›“3~3eDI|+bb1Ğbs¤Â‰Š“¼©îÓ É¡U±#·¦lªïş¦úêÑê:
+FZí©Ş‚{é“$Ë“¸©ŞµÕşóƒƒƒ½ƒÃı¿6ÕM¯íÄ¡£‚<O³Ö´ŸÕëÆõN“ÙĞWÆFÉÏ@˜Îï5Œ3»sş@(ºî«!õÍXOÂX«~÷¦£êîëYû¢×QûõoÂx-@õe–Ã¤5=®<JÃø–ÏğpŸ˜¨(ŒÊ`pò¾ß\u_wºªøX~şfĞ¹|}Ş¾T'şcé=@Ó¿è¸%•oõotÏ*8Ôñ8ba‘'äÊr¿å„L²Ötkİ‹ì>˜W_‰b«tš&)¨˜(Šôü0†wåb6>æ:kàIS	¢ø£ÉMõ9	Çjwç¨¾¼m%£»•=~»Ú]&PÏr„‘BÜZŒr >›tœ§ê×zÍï«Õ°,Íê5€ ¼ğQ«%“I¦ùxe{m7oGõ/jWhæÁ0Ò¾ÿî»Ãï?Õ—Nõ*½(›û”¹µFfy©WêòæâÂ¿óŒHä´åÙbş:\ Êän1W²¢	±QÍ‚ùœ¿óäÙ$MfğYYÌh§D¿}üV^ûĞü2§~øæ »_ÕÂaÚÚjªŞ?nÚ½ÏzƒŸÛı~wpÓ¤¿4e	´„7^³
+^Õëw^»…™-6×¬ìuNoºŒ–&NÜ;P_ê_ gãî”R{E@àDÒCZ)µ
+~ã‘÷˜ş ¯bá"^·t¦J™‹ŸUL•!€šà30¨,Œ$†$âx"h§­`ÈBÇÀñøÀL#ÿ£“IÃÀJŞíÀjô"Úòj[í?Lğ´PëwÛ§ÆÖ2K/ìÒ'Q4nZVÔ“ñ/1Thy´ü‘H8i”Üã•àN½V{×y7èt»Wİ©×ŠE{Ç†Ë¸,¿3¤Á¯÷¢ò[ºŞÉ#ã<üß14JÜ*Ñ<®îÌP£TšË6\gÁ?dl*şVç_3µ˜÷+úMÓ¯j¡^Co•VùsE%{ÇÔ%U± 7µÔ†H™w%Ä,	öÛ€‘ÂŠê‡{ÇÖà/à”TçÄüÿe}Ù¬£$¶®Â2ÒJÔ†¨¨$n‹ÅùV•—t4fbD2:´uq0Ó•È£"	
+¸Hñ]Ù¡i»¢˜0	¢a™(1`¢6"›}µ×»òËå0äá"ÓiT4ù#ŠËWF½cù¶­Lğ¼îvÎÎ¼k÷ŞÒLAˆ¥ûG6@Û ~lÉ¶?¿‚²Qy=}jí_	Õn|™«« X6-†ıâkÆé·nbÔ‰Ém²9‘c@—Õ… Â0U³FßÇgxjò‚}èVÎ3çs›(yï˜Æˆá|8$§NUŒøFxì«»6-ñÑüqeGsE­†'1OÙ°Lˆ%Ék³Ìİ:a>¬ÈÀúí/ûß’[¡W$’sŠe¢ ~+Ş‰eŒ¥	kˆƒ²ku¥%E¶Ã ¦ß”"]U¨K$ìŠ×xßS3ôè½Vİ¾o#6k ‚IÒr˜fe›8Z;âjUËôã:/)çÔ	jÙ«²Å\§&¹ªİì$ºó„F¹‰3P?Âùéÿcı ŸùÁ–x:FqUÔxjW–ùÌ‡B¯—ÏM'ó¡/Ô—0ĞD’Ë½cCÄm7uš‚úBéüòŸí‹ó×ƒ“‹·tJkªu¯y6ŠœT/Æ«Zª‰Ú&F‡³Š3¹õYãÌæ¬)4âÅlˆ~Ø-ÂÂô¨œ2(3œàºg„«P‘××êb¤B³¦tq‚ï RÖ¶ı7h>+tĞJr#VÔk%á{?µ¯m-‰îø¢Ó(Óğêh³ZBw/ò‘OA²ØØõUey ‹&¤fË¬°€
+„uœ¶œıˆóYüÂryaé%e,0š^,ŞO.®NßJë×kàP‰c¼ÖV—a‘­K§Ø`h$ß\¶ı~ƒ"È­³héhëz–cZ±ìm‚d;ÁèA€V­{quùfÀò{©Uë˜ƒ,•Í9#àlƒÁ©R¬W-İ$&ÄÊ‚¶7¥€æÖê@Öè¹W»‡B¡zÙfE.½Ş˜zJ9<T/]°2I[Ò,#£~˜ë:%ƒ„Ï§ÛE7pÄ
+½ëôÛ¯Ûıö wş¯zcYÇPˆ ááV]¶gR¦4HF·9ÛñmÓºĞ±å¬áÇ¦´Hj–#:q­ÑğñCôæ¶0#ˆÕSY"F­?_×¤téªU{)Ó–=Rİí? c&,«[$¿eûî…S³€¶`hq’1ºˆb]s&@dT<l<\ªm­ãaÍéäŠõ´)ÔJ N–¾˜¨¾— ¸šd	MAîeÂËÜ0Eí»Ä³îFsœ%ÏfÏ"b–L0l*$~uv¢îµÌv™´ö?RQ÷Iz§0ÆôT.™6ÖsŒ|á:AãÕÈ½ÌöÙâ•\Âì{‰j¼äFµT¤Ğ´éHzdó é]e#ğ,2ÂG—›Z$Y$ĞÿsŒPcz.7¡•ØdMä+%f×Úr«n(xáf'bd´x[õ^»}ÛşŞÿª×ş—-<Õz[á%WøİÎèÈÊh"\q§CãNŸÎDmŸŠ„}Æ™³ÀRp^E8 ½±¤ $c™»y8Æûëƒi0¶ÌÁôKŒ¸Åk¾Å}üÆEJ®,U\@ÙMÂ
+QkğØ¡Ü
+ã$…»8¹çèÜ‰ã]Öèdçad¶Š[Ë	(÷;„”mœ	ƒ¶½í'¬—©æİÇà’Bğ6†™‚ë6•‘PTï³•&•ô#XÜ)­i¥Y¤bÖ,	¸™È² sÚ"â ?ao‚!úP)ˆH^E¹ïa/õùe©˜<İØ–H€	l†ü˜
+î™L"_m)xi
+˜C$YYe¢–™çÏ+ÏIÓ¿:p¯$¤–	£Öå K†½$jÆJg>˜›sTú€‚ï€Bá½˜P²Âë `Yˆ@Ş–o¯…£¥xVŒÖNı†Ë*E	~|û s”Ÿƒh¡Õ<@òÅÙ<›LÑÛF+›şQcT‹k•ß'ô»©Ô-6Õ»âb+ ?8¸ÍİàdŒ)Lµ@¶Š[R\œ*»áp)Õ¿Øá$GB‘h‚‹zŒ	xÅ
+KØ ºë¦›Ë±$YLqpn!·¼³Äù÷¼7äfäQÜ¢T¥“Çq;t`ÇZõ—ƒ·å"ip0ÜŒNĞzG*Áié=&0Â:_É¥¤‰%VØŠ(†nÎ*zÀÅa¡R “d_¨Nib8l½¢“ûi8šŠÑD©®qWÂœIZ¨şTÃ5’ô}V:’Rá‚3z®Æ5óˆ©æ‚[44Y`T¨İ=-„“gÁ#¦‡°U 5;¬šAF^\@_·örYTa'	¤H¡:TÖy‚ËÃ
+öêâÕEDLX@Y±V…¢ ‰½ß¤şbƒNªQ0Éí°‹å¸iäõ3î‘cÈÏ‹N©Ïpù²È,À¼¾1ı=c:Ì!ÏYf ‰ÜDBàØ¦”
+—ZĞeÂÀÅ/5Æ¥ú¥­ä€+x©!WcòLB…Ú-¼‘‘%·¯şù}W‰J†9	KK÷HÙk(—N1Å–UˆûË{6ÏS,á±ŸPõàZØô±ÒUÚkÏ­Ä±Üœf¢}Ë„Ç¢RõIÂµæoÍxĞf3@sc©TKZ¹±Dåêì¬×é¯#) Œã*aÏ¸½A’4ÎüÍ_ùÂË„äËñ’‚|2%Àº›Pò¯3š-Í	’àk‘n|B1kLq°~0fFÜòò8/ÍÁ‘ş—zÕN|P‰¸¬‚  ²(èm²+Òÿ²Òãv±&ÓU²ü)“,•øÕ_ú±ZD½ÉJµAç²ß}ß šj[äƒnĞyĞbO1À6“-÷oJãs¼¼sÓö‡Oè¥­¦"!¡v­C£N3¯Ô?Î™İšgb×O¢à–ñ÷‰Rÿ +wÛÛ#³5ñWœ	K=Eİğhÿ€ó¶r‡*Öqâ	ï-
+)t°tÙµ,îj2h&ú¸AÈôúI&eà'›¡È•v<.Ô¡Öš¦ ùT)Hj1ò[lÄ<Ã[Ê¸(†¦7ø›‰«[¿GÈ
+ï&l$I4 p"å²M1ÅJ3)n…í„jÓÎN–©ÈË#
+~€æ½Ä/Æ»››¢ˆûƒÕ­å8b˜u"ı® Ş<O%´C‘Grz…T­ƒÇ(ìpk•	·´~à6|QüC3kÙtÕ¥ÛbªÖAZîƒÄeúË:'p_­Ï­¼eú*\e%`jÑYì†^±µ,³zúô£¡±Ë§ğ€Ó%;¿.|HÊ–ÉA<4­‚ml±_,hªOÂ„İişæãKı¿Ç0ôx
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/45/c8cbc16530a95b9d475414126376043c2907b0 squashfs-tools-patched/.git/objects/45/c8cbc16530a95b9d475414126376043c2907b0
--- squashfs-tools/.git/objects/45/c8cbc16530a95b9d475414126376043c2907b0	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/45/c8cbc16530a95b9d475414126376043c2907b0	2022-01-01 15:09:15.665172591 +0800
@@ -0,0 +1,5 @@
+xµVmoâ8¾¯äWŒ„t"m–†×nTº´‹D)‚ 
+µ+‡XlÎNè¢½ûï7NxIXî>l>g<ó<3ã	‹/ Z¿küvs¥Á<ğõVĞeAÉÕ¡jšw¾+¦Ò†t/" ½N7şÅ|YæbYÿ¼GceoTÂZğ¥pV€K_’ûÑ‡#H¶<×a ˆGe$è"Ğæİp¡¬¸Gı­Ú‹™‡£€@DÄJ÷ái8…'ÂˆpBÅ‹º0 .a’¨ãFW›2 ,¶É‰G…a²Ã ;å¬„¢{"$ÊP5”. äD
+ª ¾V†:âÛBè ½m-•ñ)ß#-(KÂ|t‰¤>0° KâÇas ¯}ûëËÔk8ƒWk<¶†ö¬…ÆQÀQK6$uEWë"1L¦pX´Åœ(Ï½ñÃW<buûƒ¾=Sûö°7™ÀãË,Yc»ÿ0XcMÇ£—I¯0Á¬ }åàrNÁGg+.x$rh(÷ÄgXI‰èBgC°¢.¡Äæ€‹ıô«r¶Lh"’cã´€úÀxdÀ‡ Ø O™«£‚},¥;°	¦‡À(t\Ÿ`«³µši@—Ëˆ3-0«•JåS¥fŞ0X{:òÃY—]tz£iEêcëùR×Š¸¤ŒÀ|ŞÙ½ùËøKoÇeVßš÷†_úÖº‡eFµ±½½INÒŠ$Ä.Ræ†±G M˜GVîQƒK?A•ÇĞé(ùhÃ©ŠÇ<$•f)¯¤pH—‘‘®ıĞ
+1“tÉ°Tnà¸’Ğ4kı¤ğP¡µ4­à½™ß”İ[åzø“H&Jÿhš–]«şªØµ\ìj*Us¸j—q5ë¿
+×mW3‡«‘J;\õTª§(w|©´ãÓÌñ¹Íó9”¯ÀÂõ>Q±x•[(J(Ãı=|Öáo­P(%òï`~÷}ÚmÜOyğBYÆ=–4§¸à¼ZÿÙ»‰~!²Ò$±ÏcBw)¨dJ$¯a,æq—åÛ:£@Ò`ªOòĞh‡ªàªg0H@×ái¾RƒŒÑ%Ú“3iOİ\J€Ò&ºóÎÕ9p‰É¥‰ÛÏ®É«5šãèNŸKİ¾=Ñá=we‹Eµ[,Î±°ûKr¶Yø|×~¼k…¤1Z¸À/C‰bzM×ĞÆ,½¾6@ÂuçŸ=øl€—u<VØµl³$ÑDGw8E²(+M='×ªy¹Y×q$îFs˜=ªb`ÏF½ÍCÛäˆ*ÿ‹_Êàªkyâµ$q{G%¨Ò4ğßÌnè&7W×òµjÆ3|ªoÖ8´µ¾ÿ&üqSŞc
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/45/e231e8496976cfefb522ab8f3c37b941eadcce squashfs-tools-patched/.git/objects/45/e231e8496976cfefb522ab8f3c37b941eadcce
--- squashfs-tools/.git/objects/45/e231e8496976cfefb522ab8f3c37b941eadcce	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/45/e231e8496976cfefb522ab8f3c37b941eadcce	2022-01-01 15:09:15.601172588 +0800
@@ -0,0 +1,3 @@
+x¥T[oÚ0Şs~ÅQû0 @­ªª“hUi‘:QöŒœÄ«ÆF¾0XÕÿ¾sìpÙÖJ•ˆ¢ÄöùÎwîÎ¥Î¡w}‘~:oÁaİ9t:´PÅ
+­VÜ8n,TÚ _óÂ;–Kn“~š^wzi'½„Èf(±•Ô+Ü|.E¥^0¡ u$§¢R%¯`:½§ß’SÜÅw{¨Bú’ÃÉd³ä¶;?I’óV2™sË¡òªpB+»õ—Ì‰V–†[Ë-8,·Zzwpš ıûáã#eñ5BÑœá¹İœ#ëbI,hòên€o¦nğP2Çè¸Ì}UqDVüæµ(,u A&–ABj…7†++aœg™wîÀH(L04²QVLz‰Ã@‚M–+fe>b}}µÍEíW….…š¡±T¬’Ç“fzñd‹i¢|xã‹>fõÆÜy£lÔÅ
+ò‹#ÀØ—FTòÃ2BVÁF{(˜””ê¿ŠùK¸9,¼tb‰aÄ¶Cì¤±ğÖ:f(¾v‘!hTÂ ˆøU”¹\êâù-ë1Lj(ŒíA•‚)€¡3µ bÀ£ÖÏÃ9geRRñ‘Â9ô'<½ø£ï%‚†ãï\"ú{D?"èàq¹G¤ˆîÃA.f[Á?ˆ§ÑpL˜÷ÙğŠt¬ô‚ë‘0MĞLèÆÄœÃ×ÁAØgû¸Û *î³¥HFy¥dRÿcåäËÛºØV»Ûç1´¤]²ı°f,é­~fÊ]ô§a ém8¢ölP¼„/Àíq×,O8“ƒ.À}¼Á4Ãí`ƒ^âH4£+õtŸöZ[Aˆ¾ó† Cùÿš„‹®¾Ø°—¦µéi¦„k„kÂõ4v.¥^“èï¸qG}İŠŞF)¹ÑŞgq·l&Œ[y7Ù·5%vêÖşG(ßã˜M‚í~4Gˆ£Yhh IN9Ş Uò}:-K
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/46/3e9f476156c0927db2f388077ddfe1864f90d4 squashfs-tools-patched/.git/objects/46/3e9f476156c0927db2f388077ddfe1864f90d4
--- squashfs-tools/.git/objects/46/3e9f476156c0927db2f388077ddfe1864f90d4	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/46/3e9f476156c0927db2f388077ddfe1864f90d4	2022-01-01 15:09:15.657172590 +0800
@@ -0,0 +1,9 @@
+xUmoâFî×øWŒ”/	"$$wmO\Nu“X"àÚ¦(×VÖbñêÌ®»kÃ‘èş{g6¤Êú‰·gy3ó\Î¡ÿëå»Ÿy*Láş³ëE3ßö<Ç¬cÒqÿUŸw,è@ğOÅt–jzñVÅY	'ñ)\^ôß­—ñ<çŒdµÈPÁÇb«øMï¢{R-zÕ—O;”0ã
+%Š-©B-ÓrÍ`#+ˆ™ …	×¥âóªDà%0‘œKe.eÂÓÑUT‘‚2C(Q-5È´îÇS¸GŠåàUóœÇ0â1
+&œQv£Ô&0ßÔCÃ!Øq€¡$`Vr)€œà¬Pi’á²k ¤‚Vª
+daO‰ßrF<ßŞwêİ—• uúLTBFTÔšÚ	s„JcZåu>êÌÜğa2Á?ÁÌö}{>È¹Ì$Yq…[(¾,rN…Q3å†zb?:şí…Ø7îÈŸLC7;A Ã‰6x¶º·Ó‘íƒ7õ½Iàô ê
+•o ¾ßSH	l)B‚%ã¹n
+¢Ijb—'±ÒDcä+âÆ ¦MúŸÓÊ¥XÔe“ıâ€§ dÙ…µâ´ ¥¬ùj†ö~”]xÿB¤ö x9‹Î ¨LìÕÕEn¤.¥èÂ£—ı~ÿ¬uñK¦İ”³xæE´V¬(Põ²ípÏ-«¹«œ‹êk{NQtó:ÑÄ¿s|Ø?íî}äŒï\{7íóÀNc
+GNãòJ²1§]>æ"Î«á#Š„3ÑË>‘…iÍ
+^q¸¾6ò>~¥UtAš/Í„Z>¡×¬ˆrìÿ|Òh‚ª<X?¸ºÜ¹·•¿OíàaDî8˜Ù^t;yô¢‰'ú^à/ëˆgŸb¹,jsdD`…9\ïùüÛN§ƒ`ÍE"×‘æÏxJ¥Ô¡æƒ úÀĞÉ.6oE4¶Úı[ÓóİçòGUµC8ïÀ¦¬ÊKZø¶<èœ·Í©?ÆwÎĞÂº3>]¤;G#çgŞvœ¹ã»É,
+ÜÏôß[1­âê5‰"ú&ix±ÌP2o;°ê™ÒQµkuMÑëÍpÜ(dœ1Á–H1¿16"æ—˜¼¨™5±FŞæ(eFÂJò:ó*MQ½‰‚ô¿ñb=G„`ŞÛŸ&ÿv¢5)ÈÒ6¦I×şóâï~w2ÿÄºUâ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/47/0210224389a2ba859a1287e94e120c2c216a07 squashfs-tools-patched/.git/objects/47/0210224389a2ba859a1287e94e120c2c216a07
--- squashfs-tools/.git/objects/47/0210224389a2ba859a1287e94e120c2c216a07	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/47/0210224389a2ba859a1287e94e120c2c216a07	2022-01-01 15:09:15.649172590 +0800
@@ -0,0 +1,35 @@
+xí\ûsÛF’¾_ÅœS—¥’’¨‡í:U%'¼H–J”/¯ÚU$(bM< ´,ïeÿöû¾î`À‡egsW÷Ãª*3=İ=ıîÓt`:{_ïıËÅÏ—'¦ö½9hïw‚–ÿµ/é¦óÇ,¾Ÿ¦Ñİ2{_ıu«³»{hz÷if®ÃwÓô·g¥ïâQ”›b™Q:\Ì¢¤‹8Mš&gói”7Í$
+GQfÆ±¼›Æƒ,Ìb~„ÉÈi:ÍÍcº0Iñ­Eï¢i:7á|>‡„…Yä‘|‡élEyƒÚ8ÇÆq¸˜†`ï£$ÊÂ©ñVšYTLÒ‘IÇæù3N³YXqb·~çµ… ë>g¦ñğğĞ~ŞúÏÛiv¿ÕÖÃK¢'à“	ü2b+ç¿‹²G3óXy+<lÃÄÄ "}ª±š´µq8K9Nzş¼†S8ÅÄÅdÖ6A¯0a^má#wÏÂ÷ñl13q2Ì¢0“{~ê!`Åfğ6ŠæüVh¨¡hò9/‚Lœ¦`Ú,)Yô_‹8‹x¿9ygoSrºp½îùëş¹“0ONp9á»0†ƒid	Å!La
+Î8â$bƒû’<Êƒ`oË|ûú¹À-cõ·ö:¯¬1ºÎ4dÉ·×[Ag²;›‰ËkºüzËôÁîi<Aœ=GY$³t¤ÓQd`ÜÈô¯Ï»½“sşc÷üú¶wõzË[æ:KçŞ"K€÷1‹ÂÄJ)eyˆÛÍ£i4,LšD¼
+é§‹Ì¤sjX+í&[@9täÜB&S÷š ÌQ);@[ Yd 	Eñhòx“±#3H‹‰XXºt8¡4ÂÈO`ZæÙ«,ŠL‹Âr«Ÿ 1)ŠùñÎ•à>YPvtÏU¿×‚vŠì.¯Lç¸AP9ŒdH ë—¹	U¥i€!\@AÁr"Ãëhšè½¨úôÑÌ£lCüÈà †"§©†S|…]£Ç$œÙ·Ó8yËe™À0|=ˆÉ—GƒEîÛEôh”Ì8KgªÛ´’Ğ²tQ˜|1ø+.r) ²…‡”ØıP²÷ŞNr·E=«t9;†ïÃÑ(V ±Šu`1ÓØÀŒwbñpG:ğ<Š'
+
+•p&}Pvá¤Òx’FXŒšy%Íf8Ms¨l&àğš¶¢b_)…tõè/:Ç¾ËøÜxÅçR¬áàµÁ·à
+„÷÷aš8–âeÆ	È ‰\zaMEprI§ıš&á;j£Ú!Ø»˜V×³Ã¥_´î!=Ô®eùÇõôHDz²l3 îz!Ó°ˆà#Ü¹D¿<J±˜°@ğ\Æ1ßÀøıßñrÑ@(z¯Ü4.>ÌÂ[àÛ6_÷¡€‘ÿÁÉÖ®=œÏ!º\`ßÃ×Wïş
+O°EŸ«-¥3\˜H4&Ø`e=gNóTì cÙ«À®pÛ@”‡ôÔt¹ÉpºEê`n$ĞÁUˆ>ª±X£şuõ¬àcºOwt'	4x>O³Bî‘\‚ÛT<*ï>_ ·uX[átæB‚™$G€£!Q3È#È~îMá~ò<¼‡¤Ğ’I¬4ÇÛãÀ3áe³cÑiOŠÙÿ	º–ÃâMGF´"‹†QÌ¨$Cæ¥—»³ÎNÅBÜş½˜O  û­¡ŞãM<6IZ4Í˜ÒtŠãé[Ç¼JaMÓK†í¦9üdi®§á ¿àîııİ¦9Mó‚1&âZ³ÛÙÛÛkííï>7æMÿä“éY-h ²•ŠÙ…aä* öYAc(càg»_}/K·¨Ræ½ÍÀ9š²ZT%;O^ÃÛv±k6@ùphÂ±Õİ/Ö¯|úÈÿ€ZıÖ½`ë‘şm}ÃAïØ²~	·IËpÓtZùc^D³ °Ô/“ˆ0OÌÃ`ªÏ£è#D¾¨JÅo±µİvpB³käŒXÉ…‚d:²Yü@€‚ Îñæèq ö@˜ÇÆŞ-ˆË¼ädÉ"(&o^÷~Ü¹ˆ“ÅûÊ¬Wâ^ÑÙC\€\,1®iîap!üˆÅƒîÎs¤$;ä4“ "q'¦Ö¦TóÈ<›…o£gäœ;"T:§gPöp|¬{WSøÔUä5~˜-`©Ü!ZÈ×Ì*:rº¶OÖÚM3œ„	,U^dŒ¬`ù‰(iFşpj^šÖt¦Á|?â>5-=<~…åkÔÌºÆşAéÌB¤k_”ƒn¿úº¦ H=¿l™e¦pfíâ}ï„zÆPÈ{‡Y,±¼iˆÁ#[Áó¯$·´ë‘kê{uå{ Ä+åg¸æF› k›»N ˜9ÚÜ¶w¦ÙYûù‡ày‘Åa£íváQ€HRüMÕº4J9½tÁzÁ_Ô[RşJ¡8
+¯EÈ¾³‰QÉS\mß3’‘Å°XdÑª¥•«æ]W·Lîç0™|eB(_ˆjSÓ`mÖs¥36kVº¯²ˆ!šÅØAÅSQ îk¨”–®:–Vˆ¬ÃDV»U¢ÆXµÈw¸aßf¦‰ì4àÏY·ß4.à>£)ªï¶DwmÅFÀ–,cNãä–y ÀÂ¦·òÁeX :y£Ì
+®pW·æ“î„QPá£ï>m÷uS0ŒC9¼|ó){ohIº¢2<YŞâú‰kUÀdÙ¬êFVn•¼d4aÿ¬šoÜ„¬fÛÛj°»Œµoã-Â~;³ÕrÆ€g[‡/&§ò™iV^Ãjµí	™dc„Kö²@÷hj²Ú™u»‡J¸¥{ui$Ñƒ´¼|Å±‚XâÑ§ã´@JiÒ¿¶*¿kİ_ fÕ•Hªä¥­è
+®Hâ…Ij4ø¨‘)©JÉ©3ª!‹K®ãäÃ~ŒÈ§`”ÄµÈÂ¹út­Gà4(£»¨Wñw­æşı‹#„Í'­£ƒ¦9¹¹”Z·“ÅlĞ4×(&d×]‰.û×'7%‘‚ÌI6œ Ò+–'”¯ 6–‹Ï?X	]ã¯:UØá/vĞLÊÆ®Z`ŠƒÄêºEşÿdE‚,İÕn´ –/e^Ë}ÊÇÏQıßÉ‚ÙØÅ.r™À¯"RòsuÎ•T¨æÕ¿Á=Iª:eĞ‘ù—ó[Xı{ñª»S%¥{„¤2†„"D®—¡İÆ’™(³†0f)qCb;+åS”vé‰pkön ğGi”'Ğæ†dî>d……ãäyÇ”§ªIÖÏ!7¡{–0d´Í	6©V—ÕMhğ(e&®­ïÛ õbÆ6Å@$OúÉ¥`Ä¨~²Ê¯8û(9‚J²¶dš¢Óc31Yø‡Üh<‡1¿Ö$À[–P08â>j'Q±ãB³œ’ËÇ¥İ´Üe(dÆQÈ¨pC )Ni™ÿD§Iz£…ÜTâzÓXÌ™uÌå)-|ËœçHm¬gÂeJ3äØ„V„wwÍ÷§;`NböÌ·ß}@vñfi3İÑÊv¬Q¥{ÑÚëàDD.{j®QPˆÑ¸ÙgÆvryfNŠ	Ê)åFİÚÛõÏÇëK` æş²wİ¯,= è}Jš™›^¿+XögÈö6vtê˜7^´ö; Ö|eÎJæÑ¹+·”¤0”rRpl:­ÜßEh	H"’($iÉú­g¡(¯%‚¡â `MNC²ÕÜãô¤}e{'Vò&óRÙ…ì!eg	»(KÌ~§5@ú[’ ¯í¨üDóSf½Uıx"Ş—Pª’Úw¦è`8³«á±4ØŠ­G|šƒH4°ö;Û{Gè< €`)˜¡|Ï§øÂË8Ïa”)œ@}QøwĞÜ ¿Â)Z:3”¹@¾2Ğ¶)æ1bz¸Í4Jî‹	oKh>‰ÇÚÿ„à£Wk Mz{Ğm±wÎõu§‘sBg;¸ÔF R=JR†m¨+Ğ6©•ŒµWÂ}\“‹Ä¡°‡ZbâPFÃÙ©yˆ¤ú
+\l‹Q!?Äø.Ÿò;¹yécF¸–à;t#oSó&÷ÓAÔ[¤Ë)ô,çŸHW‡‹‚`}©–Âû—ĞX7ef…ĞùOÑ¾ÁİÍÅ+$—6À½üåO9ä‡×õM»İş3‹|Ø¦ˆİå'£c¾c;?›S,šÌÂìmÛÜÂè¢†ÿŠÔxæÇbm%SÃ•¬TéMğ'¢+(jŞæ;¨,å¢~F= ¨mƒi 78e@÷Ç‰¦Öøîš•Cç’:Ü7ºï]8]D,{¡|=\hˆPi/ï<‡F_öŠµJ–°ò1…•)•%3?^[k	üA!‡—bQ®Âü¾eE]JV:'a6’¾d”e)bİÆÍÉ¥%Á~)·ÀÖøW°Ä|À­¡ëš£A
+n +Ük´Â½¦i:üw<Øïà³ñ 8À~çãm•JÌOkdeWJAĞôØ%	¢lÚ¦1
+…Î<µÍ¹6MÄîïz_ÿ*70û»
+ëÌ-¬Ä+ØÛ…ôÿ©ïÄ›¤¤şíõ¯TĞV‰.˜–Ïì¢Æáƒ&ÜÔK(*/¥i:x=U8a'&`«!!áû-Z…‹è­ÖÊôKÆ7ùÊïnB²eÚ{÷Mã…zQŠ Øå(‚Š’ø‡Ò(0Ğ¦xuşÒyt íá·||] a_ªtMçµcoJPBøQ÷N¢%ßh|UåmMŒvÙNâîÎìQ”™[Ñ áLÏ¦0X£F‰¥SA„1gyaÕUËˆˆĞMŞ‚·Ï÷}æîu^xg¿É0bw-Œ{$phî£[Ğ:›ÄYÆ!
+q›>GhYr´‡—Ö!¢¤¬O‡kÆ9v°.Q˜[±¨IÅ¾‡6=*‚+à9¾<0Šò=ëE:‰Eí©óœ
+ËàŸxà³Êª“\øtnÔ>Sè|QÀÒê>¬]ŒzÛrâ–&QBˆ¹ÖÃ/XÔùËë6¸®ÚT•ÖÀ¢q ØÅ‰¾±Àª(#´lÀOç/;ms5B°	í]1œ€\L‡Ğ.g²[Kæ%QÊ¨ù:yúƒ:äùàSämZâUÅ ‘ïÙøo—¯îzg°J¤Å/àµ5rÇf}•Š[|Õus)©”	ƒb[œ *ax1S›. ¾¡ ”WÖ´‘Òd¸mî³‘¾K± İWCC—í«Ç>¢-M3@ÈÃØå}=¤}“NÛˆŞB€“%ÁªÇ[%ëÄ&ÃëìÂÁ\ÊšE‘ä)Šv¾
+Q];Û±
+á§«ó»X\‘ım„EÖ4Sõ–mK "“¥J#™-Õ™#Éü45¦SrI¹Öş2¶èÉìêÏÆ…µ1Xµ%çYQ1KÛÈ¶1ÍALŸ1`‘€Šë~-gDÆäx{r…Š{uVufV¶C¤:\7Úşº}ˆäÆì]J¼¬y‹íïXK v"™¯ƒíş?(ö}0G‡ëÁ´öìn=îÀg6kY“ÃğzfÀrîlÕ€í}5ˆA'#¼Î‘)víŠöÒ&P–1³bZ€öU!ŞÊÆšã˜û?á	~û/>Şz((†¶Êóç¤òI¬:­ı§nèíà#`ù•y!»ğ~ÜO| €÷övÍW{»"xk |.àÉĞŠâ¡'ÑßUm{;OR>Z´pD×ÀYAÜq+J‘¼ 5‘s„W¨ ¦œ!ÌŞF0§ÌeuFWb`g—u'(€e7a“v„ÀUŞ&Lqè6j¥…‰Ã?›øæ¤ÍŞ­Æ{:‰¬Ş3‰­¹á°§’Şä
+¦ JòĞÍÄ ¦Íy*@~š
+y1B¢ˆ„Õæ všU(ÖL°—!)n­ª-ø~»’$˜xäŒ²0åµ"—ytÀÊŠgY¿ì½<:ø~Ùc»]„+Z[g%<Z€»6X­Ùğ€nÁ«È¨5çš>BihMçO¥q‚$f‚ŠÕìË©¶š±ª5ˆ‘F“ke’Ş²`Ä(•,a7±/WqÔ±—Aw%™]7ìcëŒÁ+~,Äı3Ÿ^.5È°d˜óØ,5UeLÊI” ]~Å¼±!ìhœIù’2›…ÜúÃ"k„‡²AŸäË«ÃÕË|Ü ìŸ¦˜AÙ	ñ“±³4C™sYR‡bB`	(Tw8»<çô•V"XÆaŒì¯@€”Ù5P/¢e´"‡Ìâ÷ğ,lpœ—çc„¯—¦Aı„wg9¯´­UçbYz‚Å…Ê4sãhW#çC'tƒéŞ]°zõÊ—­W©'xN`ã"h=Dmößm­ñ%¯3Ä¸nÖÁzıXÆàzt˜qcƒÌøÉo5¬mXkA4'ÚmxVÒá³
+ TXÖH¡dcH[q@ÛÁc#'ÙÂ?%2†JŒÕC¡5h¹Ñ­ãàµØ*p™µL¶„&ÜÃ0Š	Å’µf»/iÅ‚àë1BÓ×Å°Ò©ïÂl†²ÍÀ£%çß*\8Ë@Qü—’¡7XÙçá0ß¯šË*Yß±äôà0$=pš.aş÷¸²&Pjü½Ä,eğN*…MDTşò}pVë`ƒ|-O—[ îÏ`õß³ÙøD+t¸ÙºÀÈ¬ó£<şARŒcå•İ¡RÖë˜ÁC0-‹‰UÔƒ¡B¬å6aƒ¬¡É*­ÔBv8ûvç0F†«>İ_ª¶PäM¥‚ÄÂÖğù„0¢5ÁDµG£²rqa|€ë¥z1Bar4xÎ@|»´:ÙîNÇc8ñá O§Œ•BXteä
+n¯ÄHÜ‚A|QbŒâdÛ¶¶DòYñQÕŒ”TÊ|Q[1ACëDºçDs-4#·äPW'p´­‚7»•v>BŠëx®d†Ğ`‰½£}1ußHÓ1‚4Éh¸Š*lÙ=’s-¾pbÒáš'‚ %bÏĞ«›d¯j—Á•ğÏØ óÓ/ÌçRîQ‡D?ÚäÈ¸+ø÷‚­Fbë8k}T;ŒaDzVÕá$ÌkØZ—v@e-Ò	óf%(\Zhõk¾	Ix) ˜=	¢P·Š+)`‹ß“=ƒHÀm_ı_ORÈµ5{´šÇZPõ`7"2Š0ù¶	Äó˜@q¼@ÏÃ|LEõvhßº9’†¤û¨„[Q‘'¢¼õõí¼'Lé(ÄÄÇsZátşÅô?s0å³ğŒ‚·¦ñ[´P‹“%Ôš]K©v:s!¦„]Ã‰]%„K½C—Y0ÒeØã"\$¨ĞRİd¬3ßõE4¢2[„¾P\¡ høÇ1{h»±3i˜N¤V¬¾GNÍ;Û{+@³àé,v1¥ ƒ‡*5dÛØ"0%HÚ@·%Ô
+¡iX)s·ş –çrèEÉo•§>Š±lL¨©;\F`¿ñK­lIŒs»Léa †0ä¾dSsLİ¦M3ÓĞ8ÍøtÇÇ—ë)¼8´:„Ã‘³:)¦±^Üd )Z`
+4Ì>-‡ûuŸcvŠ?÷ö°,RYK„ÜM³F^ã 8ÍW¢J¨<Ì®Th<Ë×8T!˜ö(×è%ÄÔ¥ü…²vw}su}~sÛ;ïßõ{?ŸÿùïLÀ®fÂÛLiÚ¾€ t¸/•ï yF¡[‹L¹šóñ?³³­n¤sĞÚ;°bK9ĞÙ\ø¤!x¬
+\µ‰Û6æ6?–'†ô¸ë’œÆ—¸]}ÒôpÁ£Bk¨İ2ÿf#¡›óş›‹Û»«ïi÷ÙIÄ$ùÄ°xqÎ&a#ƒÖƒÈ8/ïäµâæ³-pbx²¤õT9á‹DgøÊJ#Sx´ÚÈ¢=È—5º|e¶·ØâN‡Bê·Qñz1“«Tn™mq5éX·nåRğK³û1ÒŞvÃ¤p¸_"d="E¶e=RçDÃG>3},XQ­,:g%‘åE²¢QUhšÈ]HnÕÉåZËY¡~¬ Ãa„;wi§Nq¦ŸåXĞr7Nl›[µò–æÃ6<µTó¸D*£-L ’^©ÊÈ´ÓU¦2ØşeøBãÀ¾RM35û[¿Ñï
+;88Ë«>lïm6†ì²uEÁì'8éØ ù×ú†=k^K9$IÄUtöÇ¾WŸ@ü=_®T6c-†.ìkç=o¼'³™º´ğü¦¬Á­æ	À-t°âJÊ%+öCÀˆ‡ëÑ_×uÁ4şzêOÔWÏs•NñÈò’è€±PR*LE˜Õ²Õ'Ğ4xÖ\EJÓ|'B¶$£QĞøwà–ó¥®Ã«r!ÕwØÙ|‡shULñy¯ê7ÿ
+W«W&½Âc×“5‚Ğ.ïWÂ¾Ï“U¹Şë»îéfQ8¯k­¥ÚFc  ŠÃRâ Kóó*#,Ö@¬O1 Hƒcş&wŞ£èô’®9 àî%-¨1¯zçf›,×÷ÎäpD#Ã\#_Şö}E‰÷4æWcóIAå97pÔİRïÒxd¶Syœò‰¼²4i
+{{ ' zÈ·f›|%y{†Ù¤â5	ø…©[X0H[ßèûÜÒKsùHÄHcƒKø&²\Ü45úÄµ”ŞQŒsé8…t:‡Ùıc0¢zÛæ)À)No½ïªKh3«àuîñ¨O1 _®…û¹
+¿ï‡–5‹».ı<ínÕÕ[»p§~Î?®ĞWonïnÎOÎ6èô“Ö½eå]tVñ3”Ş>²!æûóL>Ì…x¿#á½F ¡ãqÒ•Q;äÅ}Pßq@p4*ò’Ä\uÍ.c¯2€²%…vµ‹:iã£Ò±f½$.¬M¥¥º®z)|Å¿ØšÄ»É	;_ïîï®…*p“®Ê-]rP
+Q¾4-jXé½Tíİiæ«•/BÕ3Èô‘T§dŠHâT<ÉE2lúM7-Føİ’xÊÄŞñà	ey2ûLıY³¼®RÔ&µkõhÉüã:%N²iƒÔ'ÌhÍ>K}¼ÿÔ¼G«yL*¥úMª÷å mWîÆ¹…OÖ´Ta@a}…é3¬gÊkäş3?ª«ÉXÔ„ÿ~‚ššÌ…FQÛ¦şGÃRµ\~±Ñëx¢í×$ÿéøXü:wôÉj±){úıı’Ó,¤ôq>¹AiĞÆ’Öëı¯y+Ì.‹x´eä'Cp4PÊº˜ÛeÕ&Ç×¯S4·©YòÃ3*ó´@¨rK¹oİã¦RÇ-£‚ö°-¿÷Àê¥Ï|×—X€¬` á×s¥5´a £W¤5´jŞ“¥WâéÏ²ÓKŸÿØ»•öR­¬¸Tê&2¶
+¶¶£@ågQãÕq-¯•É€Ù]ûÅÙÉíÉİùÍÍÕÙCB¯c¨Äx¥êå–Ò0cñœÅ!‹’t¨ÖJPß@yÏ– 9ã‰n›.E?¿ñ'¶
+´k'êLÊK5òQNõR_ÆQ->âa&%<:nmŞèjçöíêŒ)‹«åú±²¿çâª{wu}ËÎÄ ØM]OU5D§>py9GK}bUûS<¤<XÀ£rV¸9¤vÍ£Ñ«#p6 qPË‡>¡T†hñqøh´ª5"²¼@î­;
+Ës¡Yá“*Ó§WòVñj{OöÜ…¿é½¾İïÜõúwo.®^K$T>Xf¬ŠĞö/ôŸ!‡îéE´<ë/I±ütîE+P>½±şOıÛóK)¸ß‰Ô¤œ? kë}öGkĞpåŞknLşÉNwP¡´Ç„¾ø¼Ë‘ÌşÉv Ñ.›3øcXTçÜşÈ†š8<_ºÚ†ÔOª-J$M÷êr©‡gphšTÁ}Zb<<"?ÃFû’‹:óx(óÁ€³suq6ùc=(‚üŠĞ°×ş,8òSè&eßUû@¢ZÇ(IøMM”OeÚé¯üÕ™Ê¨ÍÚx6O6ÊØw‘Ñ4Ñ>$¡–WCÌÕè±éìp¿†ùëßaøôvã2F‡Û‘’3™'*‹ñu·ù£|
+X&èu‚µ¿´µöÃúÏoıDÅ‡`
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/48/d4c59edb9c48f0ae5f8777ced1c6bdfd1b4dd5 squashfs-tools-patched/.git/objects/48/d4c59edb9c48f0ae5f8777ced1c6bdfd1b4dd5
--- squashfs-tools/.git/objects/48/d4c59edb9c48f0ae5f8777ced1c6bdfd1b4dd5	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/48/d4c59edb9c48f0ae5f8777ced1c6bdfd1b4dd5	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1 @@
+x+)JMU044f040031QˆòÉLÒK.(`øºÒşıä-¬az–nºQ­Q¯Òüü¡jrªrSJ2ËRõ2´5ù¹”¹¿İçäMÕ½x¿Q(Eª071;5-3'•afâf¾Éó{¯|µ)„Á®Iãß ‘	*Õ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/4b/53b6cbaa5523a69589a5cdae53d28e80240662 squashfs-tools-patched/.git/objects/4b/53b6cbaa5523a69589a5cdae53d28e80240662
--- squashfs-tools/.git/objects/4b/53b6cbaa5523a69589a5cdae53d28e80240662	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/4b/53b6cbaa5523a69589a5cdae53d28e80240662	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,4 @@
+xÕS]š@í3¿âf}QÔmm%}PÀJZp³jš&M&|Œ•è®5ş÷gWmMŸÚ„ ¹wî=ç¹ÇÚ½·woZ-¦	–Fâ´¹”¤F´ !^ BÃ‡kŒ‘11­4–4|š %$ˆ7!†#Y­Òrvô§¹¼9ÍÌvkœÍâ8	XF(j6[ô±97š
+b/ËÀ¨(“-Nsœö%€õÆ£ èÙÕ:ÅY6ŠbšQÃÙÍÉO’<{µ–öÒ:Mrä8dÕs›äİ ³Xàô>ÉtÜFi¾ñbØ&QÓo“(—Ø„/¤ÙPîr·¡—{jÕ5‹~a>‚¦K%K†è|Cs÷³;ùê"Û¹gpÓ™éX³ñÄ”"+/‚H.¡T(”‹HºtĞ©ˆü¶èU0Í,°È®·¢d¸Ğh ô+ù^+ß)±=Ïö«ş<­NH˜ø Á•J¨00MdÏ,gÊ]{v½<j¥[İåï+ZPôß÷_qîø\á(T!£î¡Ì¶0"?ìPª”il×BŸæ¶)_¦¶‰ŒÊ¾FRx»ZP•×:İvO½û ‚öt§möíôŞÙWëVo†µ"LßGğ2¢œÙĞÒ*Ô-
+ÜC|"Æ	ñ-NMÛ
+åyÎrb‘pFlÉİñº¥&a ¢%('^«v¥äÂªùŠ\®¯ÄÇ» Të"â\?³€SÕ®¼K…À$ŒÒ3[!U
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/4b/d5e1830c9456a1af9721ed1302717573c68b3d squashfs-tools-patched/.git/objects/4b/d5e1830c9456a1af9721ed1302717573c68b3d
--- squashfs-tools/.git/objects/4b/d5e1830c9456a1af9721ed1302717573c68b3d	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/4b/d5e1830c9456a1af9721ed1302717573c68b3d	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1,4 @@
+xµO‚0@;ïSü°‹…¨åmÔ
+:‘t·ıDA6™[ô‡¾{j„Î]ïñX£Da4ˆÏGŸ·-!óZòÆ
+'3".o~åLØ õ`B]H^yÏ/i¢5¤Iš÷(ßI®jJ3ËöucP»Éİ ,Ea
+¾vW?pA@£±Z¥Cœ*yEmÜ;HäÌ–%ê“ê<X-6äõ³Üâ—á¸|QÄa2
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/4b/faf42a8461049935dc8eb6cb17c7e766a68b74 squashfs-tools-patched/.git/objects/4b/faf42a8461049935dc8eb6cb17c7e766a68b74
--- squashfs-tools/.git/objects/4b/faf42a8461049935dc8eb6cb17c7e766a68b74	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/4b/faf42a8461049935dc8eb6cb17c7e766a68b74	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1,2 @@
+x½SmkÛ0ŞgıŠ[ÂÀIãÆéÊ6–vĞu[[([ ƒ10¶%§G2’œ²”ş÷êä·8îÚOÛ'KwèîysœÉfÇ³7/¦cx»=Ë2™&àûà‘áR@ZˆšÁ;øÁ1¼‡«•T°ˆ6™ÜØÛ¢ˆ3 •ëˆO	r‘dep¢Íx|xó¡­êe7Bìî!e)Âå¯ğìúúÛyøéóÇ8Èvİï	”ÅÅ
+"=Mc s¦f]!HíØı™ˆ¬¬ÿ¼úúú¨ÅtrË•·Úe‚òt—ØâÂÀ*t[Ïea/§Ì{Õïl—2¬fm$§0^–*{å-Ÿ€æ[÷‘;€ïò¹=ğ<ìÂ©]1² ÅL¡.¨it%³4WdêYİ™RüÎNx5(ÄÓsH*ìX”(&^#Ü±KôàÀm-Ù4PÖN	‡Ó¾¸'Ä[n¿XCZ’%ÛˆRÅ´Ş£ùWÈ¿z/+	îœ»°|a=Ê1ô˜î¾uïíóÊ#;a×8[>µmhkËêÿYÌÓ®ÏˆX{&b±2²ó4~^²(wiñ.˜Y(™XÃ°æ&”9qCÅšC•Í§Ñ•ï†='é“éht	Ù“5qT¦6Aµ°§Ñ¬·ù~²î
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/4c/3890127d43efcd6383bcc5ecd7a75c2f90e5e4 squashfs-tools-patched/.git/objects/4c/3890127d43efcd6383bcc5ecd7a75c2f90e5e4
--- squashfs-tools/.git/objects/4c/3890127d43efcd6383bcc5ecd7a75c2f90e5e4	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/4c/3890127d43efcd6383bcc5ecd7a75c2f90e5e4	2022-01-01 15:09:15.649172590 +0800
@@ -0,0 +1,51 @@
+xoSI–îïëŠû!ry3=mÏlïöôÄDÈ líb`A´Ç±q#n!PcIÅ¨$Óì§ßßsNfVÈŞíèn©*óäùûœ“'“›EsŞşøÇ?şñÿûçıÙu8_]/ÃûñÙørt.®ßNÿÏ®Æ…?gÿÿ¥Z·u³
+o_¿9'ÕÍz[®ŸÂ›Ÿ~ú©(ÂQóğ´®ïî7aÿè@òŒ¾
+'ëª
+WÍíæ±\Wá¤Ù®æå†aÃd5{íãÿóOaZ-U¸X”³ê0\mëMşğ‡Ã»¦İèé£~xûæÍ›WoşğÃ¿„p}5*Âøkµ~jVU¨ÛğP­—õfSÍÃ¦	3È	åjæu»Y×7[†ãÙ¦^êËºj‹ĞÜ†Í=o.êYµj«0ofÛeµÚ³ûruW¯îB½Ñğ«fÊÅ¢y¬æ¯‹â?§z‘7÷U¸­×í&¬«EU¶LÏ<Æ'¾
+§UÛVëğşâôuÒŠ¾íj	¥Ğng3kÖNSL0õÍZ¾ØŞ@a8u*óøoÃ}µšU…‘f]m—7L‡^ÿ?ä’ÿ¹XWåòfQé³)DÇE·á–Y—09´IHÔ¼jë»•3sS~©BùX>…§f».n‘è¼YŠÍí½Ÿ[ÈaÃ"ß=±¾Õf]¶°RÒjŞW«j].âjŠ¸š6h€zµ©VsŸì­*ù¹²ÉÂw&3B2Õ¯^AÏR”¶[†Ô´yAÈIãØR‘!T¶a‹PZ$)nğ}d‡Ó›D6 ¹@ùğ°@ŒÍ²*Ú‡jV3îSäZ)%Ì“?”³/å]ÕBàÓC=³ç&ZÆxõÊµ¤ø–™sV³åvsß¬Ûğxß0Ñ¬³ÊFëp®n¶Å¬\Åøªq=~Gî `#FeEïW_ÂæßnExyÓ ò÷•f*Vzˆ™Íz^¯¤CA&®$[¸©0ÁuÑÁ…»§LáŠ…<…‡r½©gÛE¹fîC¿1‹Á©hŠê×‡E¹2ïĞ†›
+[3ù|BËƒVñP•_d &ËÄßC}%%b)Õz-ƒ…+Imx²Ş‡5„zo±Æ¢umì«~_¡ÊM!Ş—_]½ÒL×ó2î\^ö£•¬ïªB&g<F¿BT¨oM6u{ğ3_•.«u5«jfk1;š5ˆœW%å»jSÈ1Å±´ ÷ª‰6)Ö&n™:Ieğ€xÈ´QVaU=:_ÖÍİº\¶?Û£™7S_ÊLšeŞ /CJ§î¢I5p»ÙT3[Ç:XdhMT+œ‡$dœ]£•HEñ@e3ÃM=/2C¥ğbp…öˆû>•'^ğ]Ù~ñ¯ğGÛõZÄT¶­
+™OÂát¸™v–jŒYµŞ”õ
+%j ¥¾©õF6=&õÈèL—¤¡(’¶[ô“HŠ.›y}û$Û”“9á‹ê×RAî0=ñƒ_n‰lê¶`è	e¸­EìXn1ë;éˆ¤Œ¾ÔEdQ¨ò“#o1”;”Wë%ŸÓëC×[O¸A¹¤ÌuÎÆtu,¤Œ3q\È¡¸£2=}¬7÷ötäL^Tã+Ş‹ÄĞÜüMªr[/Ü«×rˆö2Ê!ÒŒb­¦ãçeñ|¢PŞâ¤_òn¦C5‰IÆÈê  A¯î0V2âÃÌÔö¾y´	ô?i7ğ¢uJ âËÊ¿­“n»§Â®^ª}0
+Ë°yl^µ›ê!,ñ²ÍüOaÿÍœ—°ŠC'f*2»Dâş[{¢¹ÅµEõïÇªÇûzvoâoíÛEuW.
+B­Ai6£öãşFõì1Åƒag¹UÉàYG›µ™ï£<ÃšÒà€ÀÂä#“ÃC2ºğR ñ)”?™Òj"sÜqâ7HÈŒ¡G¯FZ›¸y‚áËJ ¯Z ±ä¡NÍƒ ¡^ë©<Û.æ&È@]³Î˜Ï6¢L‰°Òh‰¨i bùÛÂ#îïZfyØn,0!L,KáäzËLÁB<è
+±©—…oªh³næÛ™?dö‹ü¿ò"`l²o~ÀÉv­É­Ú±ûìf\×Š«_´Â}rŞ
+ªÆU¦—Û†«Ÿ*hl±½!b ¹|Ğ+X3K(*£ïH¾Ñ¸jàH®W#àG×:›9J™VY¤wä"€ây a‰˜´–pß,ğÆP5•^à¼ğ[¨|‹Åq™Æ8.°§Ó>,so— ­C¥lÃæû`±ød,AâÉéÕéª„fõ­ô
+Gß‡8¦øT“8ĞÌÕl±õÜ™Æyñù|ÓÂJÈr©"\s‚G±]úæ+iĞ·¡ØıÖaèÁÍ¦¢ÀâyŸ*Ì£`ü¿[òDğÁiH&ÍÕÑ¸ı¸î ú!ş“Ò¼n»
+{°áhq–yAÉÊ\.Î1úòÌªY½ê«’ãƒv(‹+¯ØªAXUt™Ù¦@ˆA  CCÖ¶•ï.=I¬Pğb±¨ú&h‘b4Ø¦—DãOº"ûÃš·Yãàuı•—Qì¨uÙetşkÚãé7¤'R\ï#—![ÜjâU³‚ ÈªÆwö	¿U¦¢ÿfkâu]Š±µv£Êé¥‹´&‹yÒ%–å¯İ@k¦BT21ğRŒ—ç;Ë>S\ÏFcLŞóLiïœ•B›õ¦˜7h7‰QRÉ×àbãªL©ÏŸkë³¥±ü”L£>Â`1[‡©Y²b$‰{kPQŸ½€LPÎ¿âYË;¦ÁŒÅó‡j#]x©§	<	ó[m!<,*ñÌ-†OÓ:wÑı,7Ÿ¶ÄéuÂR>PW€Wİ˜~&o˜—×M/ó‹6™²Ï0«×”/1 ö&¶Dœ1'DRM`½32/ám›‹–äõŠeî‰‰¡£T)Öâ‘–õ(“D5 -W¼Lt$…éB)è ù¿ábxu[Îp"p^®çR_°ûì¾fáÌPCĞæ;¾ÅÇ£}ª¼HwŸ“‚‚# 3,¹ÿ}+‡§ÔR†n‘Ø#X‚Ud+‚˜¬§-—Uøõ0J0ZvÈÈó_'Mó€A~­¤•×™ÎœÕf+ êNÉÑqQSƒ’i
+SÄH¦ÒÏEVL™¾1«§;Qò»#ÉJ"È†X6{âboÎ²ÓìP—˜[DoÛ†jU"Irò v‹GÈõ¡jT‹ü.ñ$®á¦™ƒ n‡•ø3Ğ´—$‰
+t”cM«^‘’?‹™Y‡‹tH…†¡øYVÈ¦ñĞŠÎO ¢%nIV¸)ş”ÏüZâ0UÍ‹Óÿş´^mù½Âß3¶D­íg,ß•‚ä®ÒïBD÷×íï’'%l\İ(.zIÊSé™úºÀgš
+òíG?QØuë„Ò !açš(—Ù"ªõvåÈ7TÈ7#êgP*o,˜2ßƒà´ü˜%;šp5G£ñæ¸”MÀò^B¡ø*àáSÌ<àŞ6²Wãç2[¥.D€ãií	  d)=VyÊbOxXŠ*¼g‹.ƒ?aƒnËéù)¡miNÒôÀfûÎh(¾dI¶¼¸E=@v hYà;\€e|k€`»Cz[Ğı£’út|ùñ*ŒÎÃÑùÙñd:9?»
+'ç—üxñyröş0O®¦—“w×úÊüx~<9™ô
+
+?¼öÂåi,^°áJÕë>^”!e‡“H'*˜I ›R©’­±«ÄU ²Ğã-¹‘¼º4ÕA=ºpWäiRı_<+×Ã”¥”DúƒKÎ"y„ 8¬]Ëp'Æ¿ouû^6'0Ä¿à+ß;x]Œ•ªÆxi¹œÏINäÏìIı›yØKºBNıGñ]%‹“fâ÷2·n·«X—B»•0³mQÂ²Š%2,%	©L£Ğ	ç¾V+Õ]"}6äM"yİbßÙ-W­äÖñ¥,d0£Mw 	¤Í„ñjF*wuïÔéeTKU¯òU&xÍ¼ôec…S!Çr#ÓÛ)¡ä	°«Q4¼~Á–"¾aÄ½ÈË
+#‰¢ß #˜­êâN››¸¥ÂÇ¢|ü*TØ$”„ÆÒĞxÒËTû#‘ÎWãè#8¹ü‰ßÚ‰¾oBä.O*Ô^ÿ›[µZ	;¬¦f1$_AE‰hA¥Ù•¸S±kÿ—´B%&KB$à½=_D9ä‘UO74à‘ œT>ìõéÙ{} sŞ»êj¼{1ï5V¹šê]tOnÆ7•@Yõ©=ÄE,xõÇ6^ZiëD‚€“×!<•·~eÙfÒ²qûß0¼{‹Ê°“· ,¶â){l`±BRªªGµïié–j	ÉÊ{ñyQŞ’Ô<§±vrİ,Œ¸GW©o([3.ü·–av2ÂN¿zµÖå…"¿©b0Œf)H¬RÈ Wˆwç¢Š:å>ÎÛMN4hÑ2ºÔaÊ2@µ‚D¯ŠälÖƒ¯Všt–q™+—Zª9JÎQÊK™
+Ë;`À‰²”*Z:«p7úæÔmoFs1-f{ï×8İUÆ‰Qqä€â_3}„`ÌH¡É9İ°TRuFô*ŸYéz+éjP/2 XlË‹Ò6ùåo*ï4¹×~0ÿ¾yíÕiÄhLê”Švnß|Ù+ÁÇ~×v…å¾ãéTÜM5mùŒRŠË–F½?BŸòHA«¸×#ö²g·m¶-NA²Â¥¯v’Ps>yĞÖ,µ6ÖoÕÒHmÑ{ÊVàåİV5«™-ÊZ0¤BéÏáKE}ëA©²%úkØ²8l>@.²2û5¸icqPk+º¡ã´i7\Öštú™7Dn+¿ îäá-æØ†DÂ¦/¹€íB˜§’¦=Ü?µ*ÌDsp×(w%ò¹M¬ÀÎ(¬…¿²ü‡èÁy83B¢Ğî‘9VxûkÜÊ2GT°ûáxëm§'æö|ƒ:.LYıõH!)†Õ¤
+›{¼Ã/^óªıX—ÔÚ-6Ê¹·O…;S¸z_ÅáÙ—'\ÅÕ½)ØzıJR9P>ÓTC<Ëª²¾ƒhªØ,:ùŸ8B(ÌùÔŠ>šÒŠ£¸Šjq+ˆBvŸv÷L¤!ÜtA^«‘4}'&ˆj±UL¡"aœHTJ#ÀŠrˆÙTòuiyŠâCIù40 Ê¼ÌÎŸŠtÌvÒáÙ^ôR¶.Ha9êa¢ÄˆˆZÉ÷Áêµ£Q9ˆüï›O$a~ ½,Ôºœi÷O ÀhÎlHª³2h3µ2B¥I\Œ²Tèm·Ö2`XZÕ'ı4Ä…Î<e4>ˆ„é8Œ?ìåUÅZâÑuª¤İÊ£NkzÇÁ¬ëÕ×†zªô›'Ìö´ch»7¤ıM˜(•Û° –¹½lõĞ‡ñ¡)Ó(¹RoåÅ4[!È_F€,<é8b$ä5QÒ>ŠçâªcHAHèeêp@Mğò–NÀJ'ƒp÷°]ÛæÈºZZª"È‚ÁRí2Ü?ÁærÍYFo®>á­RHQ³ı;ı&”ñš†áAÃ6ñ7Nd*Y:µY<¾
+¯Ô`i/£ª¿Ş‰×1
+c;W[œ³{µ·Ú¤RO–â¢—³6kî^~•Õ&/ƒÕ¹~h¢àdzœ¿¶¼U£ sîXËÅŸb}y uÏåæ.0±ÃK:ş™?q¡íb@ì4î±Ûª”‰¢ª,Æz@dûÙÌ¥È^ÍGÚ„MØQ"—âî:Fî¯8VólöçT>¦íT³|/Ì2š0D¤ Ï$&•k•ÎÉ'i™‹jßK¼æW)¥MßS¸
+YîJD;rÇujï#“ov)«ë¡M 3NŞy™i× Ašï¬Z™‡åm%Úr2‘‡1‡GS¿İ3)1qÒğîgMÆÒ7øgé¹b•K”¬vE>/ÅLÉB§«_¨ë?mmØ4ÎC‹·ò6ÊÜ%	Ù»7!º;ea*²±B^
+‚Ú¤—–m‘këE¾Òlù8Ù˜Ì\ +¶ŸÈE£
+ÊØjH;÷ò¦^Â»ŒÓÙ:æÅs?S7g’X›S1Ë¦)ÈÊ×^/ƒˆ¸…/×âyŒ({Îì^"ŒsL¥
+à®»kàtçôA«˜AyG¹çÎSKiœ8·uˆ+»ê:%R Û@‘÷ï+M|è@?—ák³ âÈ%6mğö`}£½æiDx7lèQç©¿xcI”$Ü·0óãèp^LŠ„·’Všà»="ªËÃªyê0D9¨—dYÃ‰lTëğ\Ñ¿Ï¹š7mGêmÒÎDœårw«Dã¿ÍUá÷š,KÖ.»`.¾C}Ê?ûİdÕİJ†	 Ôîv¡‹ñ1%oÿbH?¼+ü-[ÕŠ„â9mğ ßêÛèO¾¨4x"­L±J¯B8v÷èpÈçzÁ¼;[|Iä¢cúsu6˜F¤ÇZàŠòn©¡Z\^ÉÔTDŒ
+ÅÂ¬Ó%€w¢~Ÿ=8J’†IÃ‰Ôq7É³ù¨õº½a1¥4«)ğT-¥1³áok 
+,b°ÔŸaiDòäÒïğSA4+¢œ4	z«ÁÖ0cÊÀrEÇ&ıcg5)?éìÓÃHßğ2UÏÖEoeØ‰Ğ€cæ«WÄÿØ§åT
+g¥¢¤eNÅ˜ßoÃsòoÕhŠ·Û‘ìÌ+‚pí)ı„±N5k³Zó¬c©mÃUõŠ?w¼ĞÏ (g)˜eEôÿíÊçÑŸÍ@ÌÍ’Í$ „Á.´¬K§Ö½T3ÌSÆÛg’3¥Q'4,İ´æo©äÆæšuĞôz<¬áH~Kèñk¹Pà+È·°ÍØµŒfœd(ÂPĞPH3Œ|—ÀRmñ|tcQc•æÍ²~–Õ•ÒØL·:}\‘M	Öúe:üÏ¯©4T]ÑÔ°>eC-U™UØ[(´~Xí<DòPâ1^Ñ®o]Èá†‚.‚¨ı‡Ä‰õ`ÎêDÚ|ça÷şSœv7|¥¨,4™Õ—ê¶ñÊ%?%£í-Ãˆ²È”Şğ‘<€g¤L‹Î$VEû·gn#Hß§·3´¸‚bfÁø~]²u'Ÿ³«/&»”^¯G–YOÄñy‰lU¦BÌ´“È´c/¦NYtÙ±'•GS.·¯‹äº~TË /"ïsµ¬µ›`Ğ›´k¿1É[î@öŒ ÿßó‘’C„+:uÑ&FĞÛwòñmGã}ß Ò$_SŠÔ–ÑwÍ;´å™=¢±F{]tµ[H÷T»åO<*û½è‰;§=È¾ğD—ŞÎ‚gS}‹ĞÆ†¨ÌË€êşšÂëN]x2Â|¸6cÕP”Xy$Ñ£˜· !)eÙH–ı!s8W“JÓëv1X}œd¡:¤ò:mABdiÚº£Ó|;Ûh#~Q‚Q”ÒİuÒeîiI»Tõˆø²nü{ÿ ^aPl,ç=Á}%
+úÕfƒH©
+ñg|·¹G»áçP(H–Np!µï·+˜aÍïBXÏS¯µ{–c]½ğ£o}æ`„úÆÙJm3 õf€êë–íÒ<3ÇTİÅ°hOîåmÅş}‡ê\6r¡VùLÜ}ÂÒj³vr.ŸÇ”>m½ÿvŒ?¾.Føü¡âµ-:È›“2±Âé®…²ëéœEhR6–_¥Şv8§3Ó.nF qQ¥¢şHŠ.rVyù=–Md¸‹ºqñävæK‰‚£fN»İ^2«½—$0‘Q½Ä1ÀôWÿL´i×êìï„c5%¡5ëô A*éñ}C>ó¼­•aHæ,ëß{=bô2Î'I:d²¾¾æÑ$ÉØ©«@÷uåàÇüquÃ	%	Ñ¬ÛE^u_ü™œÂ u€ƒ*´³ªÛ€éSdëeY×ezÚpÄ\1/Q•I<³Uã‘ñJ9ºƒãıbzg(bùs÷¦
+vŠãÅ¤b¾5Ôçj,ˆˆx eO2à´!S¢^â7—5LoãÜŸ‹ş4ûäP.µ‹Ã£Ã®¨ÒóO;4èªî†ãM˜rÆ"Ò’ãá`­#ëÖ7V	™Ê}ùÚ>ág8ıÓmIŒ ·1M;²Qí†õVuü´±Ì®A;UŒmGãjCxIØZ™Qû/¾™ØÙyg³P˜—şo –Ü•Ø(yÁÙæO2^,¸6ôÜIÚI·¹yß}B’úSz?f¾X:«N£`İ„M³-•{Êb6@ÀJ§jz~&mm”Îóö]ÆÊµİ¸R…¦‰å©æÏI š¹‘uQ|¢¶—¤¥aäÎ­pŒZuTíd&›Ö“Ür>±Òq¶Ö“4J˜–¢Ï¸sÇõ¶âŞ¾‹Óu“æô¦õ¸g{d×rx§Ú«ïvî57œS’Ó"êvi*]%YÛT_Fİ0İ{XšN¹wt,È¤üè*t²Èã«¬ß™fn ¶(ÖŞf¨*hFj«ÖòÙç@=¼IÒ†éƒo)j¾-˜+ş4Ñ!tb÷pÂ©$Æ˜·pšˆ)t~»å0Î##²A$vÓ…ØæaŒ0·ht} _¹àä;5–}«Ñä•JN«*Pb|.}e¥s7Ä˜–ƒë9ƒ•0ö |ËaQ…aK½©È•‹Ú!,]’ŠÎ}ËÔhÀO”ÌÀ’p.ŸÊ³¬Û–h+‰Ù‚Ó?8“ÒÛú±„¾1¬ I\ñMw’`õ:GÎaÏr¦£+XLÜ?sŸFå°O‰ëô=Îş	°kxéU'´àoV(ü Úw+¾,[@·ø”Baé*~hQ]­"’^„_€©Ìâ4¦Z©2Ú@lî Ö÷M…QİMGm3;–lÈÈb¼í£Øü'’BßÏ{ú'¦vĞH¤wÜí˜Ïü UNÁ3s•0l›X8dË–¨¶cùƒjÍ¾ €“Vı\¶ƒlØ8fM^9ûGÁqVÛ—#H=TQ¡ÇtO™u™¬ó_¸¸GŸÅug-n+ög-_ì¿FwQj½‹Aféğ:¿äc*»,Ë¿±Ù*îN;„ûÑ?³½ò¥Z¯ª…»àr³bëÁa“û­İ½ßÅşE­¨sOr—ßve	™‰8O•“ÒˆK(}?º·MÎ-eŞ÷*~Ëº,†bı
+™¢ÔºœsnÙSìFèÃ©[Ò½Ú-Ç¸®«¸áÎÏ«nŒwS’Qy1”Bëz¾jbªW—ĞíD€à£wJ—	ğHO}ètê{¡«ë×ÄÙqm!µFg›èåjğüKWYöêaŞ¢$´¼c/)i?UÎÜ<½òF:U~t‚—ÌÄ™Æ8ãwEìmĞdÒÑ•C8Š¨Üõ§SÏX0àqË¾æ©®´+ÉÉ[²ùõXÁ•8ÌA¦}5SÄQoÒTãlZMb´Õ(öºì5Æş?4¤ë;³ıƒ„ª9²ö}dÖ•Yhœø?÷¥¢ßü`Zƒ¦H¨RF“GòĞÂ!ÿÍóg£S±ı›8Ú†÷´Ñ™c“g`mÑ-ºvšŞëŒØ‘Ø‰ÌL[bmä7öl–šªl^7Ù¡ˆİr%3»oÂÎ²iÔP_¼"«Ş­”íQ®§Ç 9µ$q‹Sâ­­å_;KqÕ6”cn@¹]ä¢«f‘ç×Åhº{zIU³P¢ëŞ‡Tàš³²¤BI§úˆ„úH¡#K¶M³¾iM‚y¿’é÷ÕC«¯MõÕpMÿlŠ¤Ã˜’³N[ú­-ñŞ…XGê['$æ(%iÉ˜•XÎÑbùâP÷Ø®:>İ¢œ|ÜËeÃFjVbwºšƒSùÑ'ããeÖ³Ÿ0¥ÕŞM$hÇ†Ñ5Ú³tŒÎDú“‹4în¤@`[
+èõhÏıàÑ¨Ğdh!‡¯Òi¾PÊì'ÛÙÚS4Ô[]g…äó5‚föIJ:GªU<ÛSĞ¡µ©y'  5¢;÷\mO¬STU%OsÆ@´c=>Nj`ºyòÚe}½ÕBúT©³@qlà4õD
+I51–¦F¸xÙÏ/Î»uul+ R÷`¹Ö›»pô	úº"-‹YMÿœB”ór†Æ¢”³œªÃ™«6dÂÃ1;\bI˜(fC¼»Rêºd=–û%ºĞ§gBQûİ¢òf0Œ!Äû
+üÈÍ&İQÓs*İJûRÑ®¶]´ÁËP¢ğbU½!ÿøgÖ)$›ªjJ~æívÍk£½[[bº™WÅ8 •·ÅD'í6¬KLÈîçìèÅëB³tVï]ñM|zpğ±3iUg:_‰Éôú:å?‘c§&WŞĞ?>¹ESÄKÃwò]©ôËÛÎïì´”•ÍÊ®—Æo. ÙâVe:?RÅCĞcLğ˜èİea_²S¬®Æ[ê¶İVíÁ!@7k¥Vê¼4ı’*Q‰r$ÆÂœ*;Ráù,vŸİ8§G;ğg²íMaìî˜a
+ù…õ`Ğ«DQÖıRÎ±¾ı.J@ÉRDFLÙ©F(Î²ZßCÖŞÑr»àXoåmò¼E[7ñÎSmuh?LrÂúıª5©œTÊ¹‰Ëã¤/º×â.Ê!2<g]\9{TõM.!SÖp‚Ğr7(¾œÍjt:íÊIÑÜ.—æ‰Ÿ'¿« gë= ˜`ÎP›%vİ±hÁHÈúÎófDÈÏñµ¶¨ØISÖáK4Od»WñŠ5)›d‰½ås­º“/.K‘Ã±e‡^³MŞ5¯™3^’{CÂ’Á`áÛØóÁ_ï+& ‡Ø*,c‹d˜•Õ×\®QX$÷zõ¡Ûúğ© J.Ä¾^ÕtÃc©ZE½ƒS¢LO™ø­oPäÅ|uèùñw¯>J².õó&IÃ£ÅˆF[*ÒuûÉÍ^œaY±‰>ËóÅ"9º7ûYw!À>ºcVCnoÌRÏ\Ä †?©ÓD=«rakÕ‘æ…„i;üà1ÕSİQ‚²õ¼+ÏıüÇüØ÷éHšúgäç`2^ÆÎ«Ìr|yXèº€>š*ø©oÃQ*wºV³v¯£{LÀ(¢sóìäã%µØ—q,i»¹®H2S©Ù•Bİ\ùş–^Ö 6égíÖÀ»íƒ¤¤ÉıÔéïçé³>‹Wâaå|ÉG-ğ‚À¡…{èw¦5Ñ§Õ»Œ#‘æ¡§H@<µÑĞ±m–aGÓ¾PŸi©µ¾á"Ìæ±~¿*ÉDñ$ç6uı@Ç_D+­SÑö9rlÂñLXÏä•ÉÎ¡\ûòö¦îVdÆ»™“ş»t¯‡Š‚Àx<B)]é”ßâSÜš²Á*ºªĞ	¤ËèD¨Ë-#´·Š+zòœ]@HY»Áz\9"¤\÷Œ¸ï*µ¼=ĞÎÅ~ş`‰½ƒ•ÄµxI;â¼”Cz  Oe–$wq¸«—Iø™:\±İ¶ÌòÛq{xÛ*p2·~Ú5nÍ D-±R@ô7œMP/y*
+q„7èbæ»Sí—ÈâU
+ƒQ\¬t¿NyàDåä«tjç	Q)Ô
+üÒÁ3vT)((–šÌiÿ,b…Ü*Pšè”¼×5ìÍt;ĞƒÌŠ?iœQ“îÌ#Y‚…~è9˜i•#Åá’’-¦½‡øÆa¡TE§ò——S«z!Í¶)puTìÙYFøôq¥_ƒÜq0IÌÛ>é3@’ó–öRaÃô„_[á˜Å–ì{~5Š5¹ÑÀ{b»+.òsişG$,Øæp±'Ç@Œ#°§X‘rÍÔæ‰©ù­"LDdlİGÑ¼Ì.ÑÌD«ç£S%1#`À†ı–R¼X;°u(üy•6‡zÒ¬ÎŠ¸ÇŒ°ØıOP?=¢ÖÚÿv±ÙQñKbRjtíY‡sÈWŸ{&í5¹ÿUtKWXq ?6°àj5P­ÂÎj°õƒ}šÁ¹ZÃ8¦~\)0ßåÙ0O@1Ç„=³?3˜T¿% ÚN±‡<+vïÏº)HÇşejÚlá¾Ú\ ÷“RK(:ç¦]…4käNˆæ.áMÃ(Ş5ô–ˆ›f‚Ü&µO\´Æ7<˜T Ú•ì¡t*ù…<©YÒ×ÒV'·³›ë*•Ì*ÃîmÏªêŸ³óğity9:›~ÖÅ7tu¾®¯ÆaúaÌİÒï.G—ŸÃä*]3}N.Çãp~>Œ.ßõÜåXOœi,»!£7 OÛ€ã¿NÇgÓpÁ­“ét|Ş}£‹î°½;e¾Ñ'®ˆøëÑøb>}Ÿ…sşi9WÓ‘Ÿœ…O—\ÃqöŞÆÓ-—“÷¦áÃùéñøÒ®êøıùea/†‹Ñåt2¾
+—ç¿L‡kÚ]Aõ^ø4™~8¿f¾È­mtö¹ø÷ÉÙñaó-wnÿzq©«BWL>Bğ˜/'gG§×Çv÷À€)lba<6=7ÎñÙ4ºˆaüãKØw6½›œN¦°€ûEN&Ó3¦0Öœò£ëÓÑeqq}yq~5FÓÄQØ7ß—“«¬ òõ?®Gy ˜Ë%GgG&'^*zrÔrÃçók†»bİ§Ú´5Çã“ñÑtòÒåI¦¹ºş8.ôÜÑùÕÔtzÎÆGĞ+õàVò_&GÆ‡ËñÅhr)._^j”ó3–ôb!<nü‹TàúL×™‡Ëñ\³Š 1FïQ61“W‹$÷O&GBÌ0ş¡½Âğ?£FçÜHş9Ø­,Ÿ8z0m¾¶e¨°´SÎÑ;¸ÁÅæ2ÓO!…î9}½_õ”ÀhŠ—³s1úÅøh2:µïQ=d}
+y·È\±dI‘â a„8¥ÒÒCÔCœ–	2Íä,ésG³ÌâÜÏ
+^ê_8=‡¿Œv<š4”ıùnÌ<Ååøc³tt}‰ié	½‚^]cl“3Š€¯¦&—ÇÙø`TœŒ&§×¨b$8étÃBiº&I¹@®ÎO¦XÙ˜Š¢t LNŠ«ë£Ñt5K_pÅ»1Á`yÎlájí†4BùhŠæ;ñ7vÜßc±/>fUn›‘€œZ±mjÅ6>ü,×{Àr<ì–—Œ!3ŞWG. ·;|SË"j©]^ ²Eıú.µngc&E	ÏùˆOVzl–dƒs9x† áåBAßnÕWÃP¯¢*`ºéCgÖRduYË.Ujß(rP„ìø»š#b¥ÃTì°÷£»ĞòS;ùêH/ÒÕš;¯­äú¸7WúaÓ®°ÉnRğ†ÿœŠ”óJ<âOd1š(Ã,ÚòVßvoÛe÷z˜Vr?wiİ†q·ÛZzyŞnÑïİ©*à÷•S½hY„ÅrV5¼”Á†²1â¶-A‡©¯¤*ö2Ùƒ^…$à±şÑ7¯˜Éö0|‚Î·J¢
+ÿY=Fö>oäş”È š…VºÏ‡¾!ä Ğ¼²+'=_õëÌ^ÿÅvËr®§_øğgõ½ü%„?Û,ÑñÖ_ü†Kã4F““;~NeÆ¡ª¡šPB"k³Åm>Ü­$½{TŸe:özÊÒÈÄbæÔ¡(Aµ]yÖÏ1¶æ×*$£‹cÚşİ>ÒÂ:AñÖ| éÏ²†(çœÈV=11¼gß•aDV›€¸¹úy|åV	^È&ˆ¶¤®öüxFÇ
+Î¸"İÄÏÒ?G
+ ßo~!H
+W0Jº¬Û÷äèşAfÉ v/£g~ŞÈë^£¯ç±hú¬eç·Ê³[	ÊuŒbÑ­rŸ <KÚVĞeÕşëHÃÿöW‘jUj‹É.´3JªÎ¿÷º(ÜSl3]¾ó»Bf\v´â÷zÈŞJ²œr­{äW#‡¬oœvW.ıŠ”æ‰÷Yö¬|—ƒ<Z§9ü@ÓŒ]Îï`P>G?£Ô+¨ØsÊ¿Ñ¹eVñ"¿uªç­E/õU>á?h.ÓµaÙÓk§aõìŞ»?7OÜ¹¢@2á¼èw”¬+Vœ&âur‘ìÏ`1@×Õ±$GñÿO(ü_œ?QÚÆM»¸‚ı¦¥µ(6ç1Å¿‰†p	Cé!ûÀ¯İàæi9 ?kÙ¥ıÀ3MŸøe5Íê/ü~Â3§úô{j~à±øÅa¸€<Ÿz)oÃ/Ä
+•øÊR¤³Zgü¬7ÿTÅã|(ó
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/4c/5f5c14e4eedc8daf17254a75c1b77ce7c44a6c squashfs-tools-patched/.git/objects/4c/5f5c14e4eedc8daf17254a75c1b77ce7c44a6c
--- squashfs-tools/.git/objects/4c/5f5c14e4eedc8daf17254a75c1b77ce7c44a6c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/4c/5f5c14e4eedc8daf17254a75c1b77ce7c44a6c	2022-01-01 15:09:15.633172589 +0800
@@ -0,0 +1,13 @@
+xíZmOÛJŞÏù³·r(…$}Q/´Hm(m´" [íE(2É,;k;-,·ûÛ÷9çÌŒÇN´Û/+-ê½ŠgÎœ9ïoöEœ^¨v»óüå_¶¶ÔÁıw[’Q:ÖÙæU£ñ$š$c=QÃ!í?vö>?5`5Jôâ$£x>Öê·ÍÍ-ù×M§Ó4ÙêßâÇæÕo÷€¼‹ãt´¤×’j‡şØêõÃbtµN\Û?“KÍG·ÊŸï£â4Óš€=RˆA^JÂ©ÎgáH«CĞ;Ët«»†·JXi·3MÂ9,QoowİğÍõá|ÚO¿j,å»ªÛ¿-÷vQs÷}˜ë“",tã®1ËÒB
+=Şn(ÕåU5Ìisïo}ÒyNO´ú¹—Ï;j˜éÙ^Ød¤ó3ºùØ[8'È¯i4V½$*‚&îğŸ2Ø7e•€°äß Şª–,OÒ,0wE´ªvT¤Ş¨úMX}ú”ğ3ª
+QÑ¹Åö½ñÈ‹l>*T÷hVDÓ0ÿif J]¤i¬à¹İË»WaFÄ¸µƒªiNpXsBy®eÉ!|8‹Fz‡V½5AÀ«‡˜¥ù¡¾)–à°ò4İuŸàûáµ~Ç,Mu§,i‰<k7w|N±3	ãT~Ç-¬<Áqr•f´[ÇÓÚN<QU°Ğzyåp¦‹y–¨ $Š¢Ÿ×Øf»»î‡yŸµ[°§(‰) y~Ô´w§…5H®É*&*Àl%h«7oT»Õû0·—˜Å†ºpâ÷{N¨İ]õû¹zªÚ¯IKËHû5Á<µÓøŞXI{çaâ_=@Ê+&…°ÎFçågÛ/™Fv¸U|@öàãx£4É«‚ë"rTÜÈ´ÉÓnöåbMÁ>—FBndÃÑA‡±	aqJ?r©¡–üŸµn·ZĞØl~G#ŠYËB‡
+¢¤@¸ `ÂQƒOVC…Ã{áÈ™¾Tc­¡R­gçÍÓ†l~;½Hã&ÙS%»œ,ôøğL)½,âõlŸd°‹1|ÙÊÀ¯8¯X%Ğ"iG2AUô"ùêZG­97çÄÉt˜Ì§äò”b*kin—•CxW?Ì¯}uu«èƒæ¶2øƒ‚	ÿß0Hjù3à@a¤+€¿£€ªTÿ–W6Ö2‹ĞÎf (BÏ"ëf)m„ØÒ7˜?½2i‘c9\”ŠşüSåIø‡Lıõ­ĞDt¾À ÈraSIXºc”åÑ<)1ç&ç<«ï%uĞŸ£T5YBÍş-×<„Æ ^Wyô/N ›FŒ$7 õ~Ë—*§$.Ú†¬%ê–ĞMõLµ…¸Š0‰gK.˜:aC’H¸Ş¹e­œX)¥ÊMU±)%Ìq/P8±Tƒ…ÒÙB¨0X˜^87Ş8#şàÌMñ?–äMç©5'¼&¥+Ÿò&,&°((«¯!Ì
+„qŠEMMó®Eï!«JĞš±3ÇÔº¡,Ís©¶ÖqÌr‹nFVŒ‘S¼E»aİ…WM5„=DĞ¦‰ÓÕ€lcqi7?IïŠxûßĞÏg•ò0WZß@iyœW«xCbŞ¥	C¼©	Ôcœ¼K–OÙÇïltrY\QocR’I©Ëª€ÑUJ%4H«46ïx‡K jºFF¢ÆË ­´GÜH¤ß(kíIœ~c_áV)A‚#’Ë~xÃ•ââïGc‹=şOÑå•½à
+¿ù?á–õ‘±	ËÂ\½Vù!7‹Ü°v¯f¤Œs…m®:R)Mê…ãÉLN¸´¢Hİ”fò¤lÊÚ†íñ4¼ˆ­ö·•TªëÛ˜¡-(lKº)ƒê4-Âøü~k°§ºçI”¬Ó.Òy‚ÒV®0¨Z!{¢&™PY‡v¸©‰º'ÈÂıFgHùñ§¤^ót#‡œ~~fµjâ>[ÓçÙÅÓii´`eÅäg×X'\)úüæÑ¯y7—cÑ»G­Æ¶·] Ò’os¬ÄíõÿŞuàÕÕ¹e£â ¾cáø¬XÄÂ{zcÊ!q«GXÉ›wåüÒUAb•¿Äé¥àöeYrATí>{¶TšT±P`mÔ8¢ OÍ¢tÆİÔ6eyãƒ˜®É ‹ÖÆ’¸ÂÑE*õéŠ}>;ÈÒ™ÎŠHçË ¾dè.WÃ•³0ï0²Ëçä:I¿%½éL‘©aJ“£ù”£u´œp ìŠì?ÜUCN2(ÜQ˜íÍsT€Ûj±úêë™n¡¡BsÈ×‹­ŸpİŞ¦Ğ8X•·ª)ˆ0ÎñÑ,¦UùØzTûQPÇ@µÒäÒ|‡2}0õ“¨0=’ìIİ=Mğõëiê
+M/ê§Ì	‰òûó8v3Qê×’10Ps÷0/ş©â]]&%™ühn%­çÖºYuN<è{A1<eû:w„˜®6í@YÙ°`lÒc“w"8»f|(€­L[¤È=øp‚ñI†˜•ixc,>„dRcÀã»ÃHàM–\‘2[.ÇQ¥IM&¹ÆHÕÛ4ı°^ˆ{ÎluçY¦“Âl;ı‹¿„ù>RÎ¸‚ÙXkB¬¼û†tvMòáüIyŞV–c;V¿	¼½bn"ZËDHFc³É¸9f-Âu)yV8!2Ü©ÊñH/	È*}ÑÙuû”"…Á–,!º)ª¦öËÊãhÄÚÌn¥ĞªÈËß ãö‰òMHöÌÑW/2”#ïG1æË— ĞÆ>² ^½ %cµyæW:Wªw¢ÿ9‡D!¼[Ræe‘ùÉÔóÈŒBò€³6¼è¢W9İ£şàøÃÉÉ°¿?ìŸº[¦ó¸ˆN¯üø¢':G²_!â¥5Øn?Ì0^sË‰Öãck¼àéï=D&ş}ÂŸNÕ1²Ï8µµÏâjw–^$y 1Öj{¤˜v›­,0/r2‹Å¦À?îpó¸Ã§0„¥¹ik¼^7<ep>qÊ’äàƒ—%ªØ®–Ä V5–XÇ÷9ZÁÿ†}ö8.¦™Ó1Løt$ÀNù€÷ûQ¹-)»K”zë
+-
+'¾å)êYò²/w„F¼Ó_íÄ£D×¶ÇIxJi¼â?H…Cƒ™1ŠIŸ­¶­üØ~%G­Í—ğ¹
+GÓâÕåW—”?S'X‘üßLHXÖÖèx:fŒƒŒ9Í¡îÎ€$ÖfhªVş>!¯)'„"mû6gWºŞJ°·B4×WŞÄˆşíè¦KZÜZÑ+¯2pæ´jfYu"aåùJVØ‡`Ën“8„T³‚ÃešDƒÑAnåùÑ¼^*±~¸K] •kDB†g\îğLÊBf8?«İRÙØ¡®IB5¾Gv9ôs0öÕšºæLLÙ‘“°„rß
+•àÖûCé¨>d›c²müÎä€Òı&W™]PÔQkkÔÓ*˜bëæµkW[ßÿ•üë•-±ÒÛóoa6¶ª]»ÀÂ1:`0šgì)6íÃRÑ­Rçj@›•SîÈ*€s*Ê˜à!U[ß¹$ñ¸=WŸˆëÕvÙü.røp­şñ¾<¡ á·ädÔÃ%%“ÄV‰Áğb¯x{¶k°Kmes%€– A“¯)8$b$b¸¯ É=¨—Ğd–İ@Dnf|VÅûñ<¿²‘²•Ug†0<1h2!ìÙù}ËK·•#It~•cA	>¢£ÜËÛ@åı-½Á­«	”k¢„„S–ıœdŠ^µŒ|®RYÙ<Ş1u°v_¹ˆÀ’K¼gJ˜1U1P÷)/Õı
+œ‚ zÓ<ô—ß*ÿIgôjpV!æ3øÂbÿÃÏ‡;<úr8ìõÏÆ‡ÂÁêÓ.ºÎßdVG]f£dîÚ=ÂÊO¯°ˆ©”»‡ÏÓKpMğ5šwä‰ÉçÁÒÇ¶<4EcºÊÆÈÙ¬ZOıy•‰ ÕZ´ÃµU:„åJ"BıŸî]³ÉûÇ)FÒ³9¸ĞèsµuúV…7QˆÓP¡)Š_6ıÿ cNdÖ åKú°—LRµôøI¨¾_['§{ı§ŸöPó‡%²HîŒ¤G®˜`ÉT
+üùgÖ½8½(,pÍ;:0Õ÷â~A¾uz{¬ˆYo)Ö˜x¹û÷wÇ½w‡§bFÑ6£i.½–mÇ}-®pÜ’²e Õ.s0@‰Ä/9ì‹¦{š@ÁÅ×(+æaŒhoš]ú:P¾ãû@hFÿĞNb
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/4c/a4170ca502b2d9b9ac9db4b6b753f5da94ce54 squashfs-tools-patched/.git/objects/4c/a4170ca502b2d9b9ac9db4b6b753f5da94ce54
--- squashfs-tools/.git/objects/4c/a4170ca502b2d9b9ac9db4b6b753f5da94ce54	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/4c/a4170ca502b2d9b9ac9db4b6b753f5da94ce54	2022-01-01 15:09:15.609172588 +0800
@@ -0,0 +1,4 @@
+xuPÍ
+‚@î<O1ĞE÷ A„#ˆ 
+„uê²¨;â‚­â®AFïŞúwHè4Ì|¿LR”	®×›…Ï0h÷EQ¦^ÌXÊL	ÊóàÎ÷Qt9ğ,íE*ú=ZªJ‹Fnµ–áå; óª¨ÓkS7©A~¾öğÄg)2‡õ®£eKÜ`7Üp‚v¬‰\gàÆBÔ¤µ¢m:.˜Æ
+ÂUWøƒSB0hÆÄ™}]ÛÎ|î=ŞèQı÷è¬œ})!3øm¹
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/4f/0c78b49d8ee9dca4fbfbf5f29ed07bc9d19072 squashfs-tools-patched/.git/objects/4f/0c78b49d8ee9dca4fbfbf5f29ed07bc9d19072
--- squashfs-tools/.git/objects/4f/0c78b49d8ee9dca4fbfbf5f29ed07bc9d19072	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/4f/0c78b49d8ee9dca4fbfbf5f29ed07bc9d19072	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1,8 @@
+xÍW[OQîóşŠ©&ÈEÑ¦I”R%4ˆ}1„p9ÖM–]²»Ø6ÈïÌ9³çìÁQcSÂËÎå›™o†‘ŒàóÁÑ—ûûĞ¦³PDÑ~wèÿ`"ÂÔã©÷B!Ê÷³ëŞùqƒAã²}Õm^_º'³fãò[³;8mõ½n³98wvñ–ë‹ç/¢HìÍ'vŒrÔX¾ßÉ<ºœÉ#ÇNE4tëa‘Ş5Òpß‰Åtæc5×ÁŸOÛÁƒ@5Qh£3ŸââB</ª;coEĞ`¿›ş˜ qÈ=^×RBêĞÆ+^t[ZÍÖ¯:³ùÈsÇ_ñí‡À@Ëwã\W$à.s7-?>:¡RÅŸäÊãA¡@ïÑ‡Õ¹ı²WÅı%~¥e`®Á†Â^HQåUX[ôg:
+<coOÉ‘ù·´&±rÓÈ“£4bUsğñ ªÌT‚>,•ÈLú°.‡JrÊ¨×õÍ<|B$ø2ûjë—ÙCÛ/”–OŞ1—IAj…á©äá‘4©»„Ú’%t]Ì€0b¬ŞAŠñŠ± î"#†èŸ¡ ƒB9)M’HáïLÄW¡;Iör>Á8ğ£¯)?XÌ#F!#¥¥\–7#a¹ûëŞõ„ÎL«ŠTêzá8)m/Túemï"n:5ôEË1€PÄóĞ)—&wÙ4Î
+-•·•¤üŠÇÙîğn*µzd U]”+ITO˜.¥’í=‹SdœTÊ
+(ÇÀ fLIáõúÊëê-ÄûMØÄËëÿ’x9 ÊÄ\ƒMeêåÕV\ÛmZì£?Nº²¨?lO½†‰W3»¼‰x&)’R2÷úevH2mâF’ehêY³‡M?—j…Å,)Wa0*¦ô«d¦
+@)ß/n®ÏµÇ\ˆÆ
+(­#IÜ=)ü†°<®*ª¿ÄÎçƒ•Š¤:¤=˜ƒ¤‡/¤P Œ‹UÌm5Hï7ÇÀk­¦YEJ6R¨ğuÏ“gì13Ñ6ÆÄvM•:À‡/pªPLšˆf­a›PøKg#“Ôtï>UÓj2á’'›7öĞEqX7+­Î†O¦'
+#Ç/6GÁböM]_%ƒ•«¤®Ì½5J‚ÌÕÌrOÍ@¬«^g»ïÄ]wØP®8\wGš›·€œ…¤Ş&t­ñ`;ÄÓ¢iä²zé¯Âòâºmˆíñãø'Ä‡è3QoLx¾cw¨§†òòoÏZ¼ù€‘b®´[XFÛ'U”ŞÄ‘kÒ>Hó#°GëÙñ}¹‘2b¥1r‚(ÃªT¡Küî
+âŞ9¯KÇ”
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/4f/dd69b0d5c094797e9469be12def3a7ad9c5603 squashfs-tools-patched/.git/objects/4f/dd69b0d5c094797e9469be12def3a7ad9c5603
--- squashfs-tools/.git/objects/4f/dd69b0d5c094797e9469be12def3a7ad9c5603	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/4f/dd69b0d5c094797e9469be12def3a7ad9c5603	2022-01-01 15:09:15.609172588 +0800
@@ -0,0 +1,7 @@
+xVmoÛ6ŞgıŠk²á4NŠm²tğ¥1æÈ-/í'¶ØXƒLå&+òßw|ÑÇÃ
+8@tä=w÷ğ¹#—9_ÂÛÓá¯?÷!^JÒâÍ
+`Sæ2“Ú’±{È³¥ âÑ;ß©ß;o|ÏÜ’]ÎwŞm¹Ì³¤|C2ıcÏû9c«¼L)¼®`×¯ão[ÁW´(Ş¬?z^!‰Dç»-à•¡\ø=ï»py7]‚À…µ4!Eµ|«‚ÊR0ğq½¿ƒ¯zæëNÎ½'ÏÓ ×„¥9¹úğ¯GÑå$„u¾× kxuC…1„³Vçğdş˜N'Ö_ı»–÷n¯›SÕÍcó‚š<ªúkScöü¾Î ZL&=¬@Ù^µ}p³Y©«n˜RT À(ÿ/Ã†sI€,©˜Oè›ó@|=G—ÉÕ"
+’Y'ñ—Ûü¶5M&ÆÜÇãr”¦È:²½ãY
+ıŞ &·MÇ—°%‚l¨¤ÂW²"»g4jœ*í.c)ÿVÀ=şğşøÃ»³z¹ñ‡yÆ%,©.PXÉ’ŞgÌ@Ñ‡cS-ækÉV2ã¬Pòxôq­Ï.4­ºíã€¿vAƒ&½öK•wïÜàØóë¹ÉøŠüÿW%„eb…ß(v\!¡,(P!‡5t ËRöÊ’,óÇN@V ÉÓ?ß˜Ül?8r7ùW<ôIÜ‘LN—Ó•¬iõXu•î&µëŠ‹9Î€œÚíëŒ£«q4Ã9†D9tÖèÜÍ.Œf²m\ìÛZã­]Ïçqu³ìlİ&´»‡˜pG™¬[EA; İøÂJ’ã¡r€Š”ø—ÉŒäsT9ÉijJİV°Ø”FpÆjÄÁğ; 8LâÙ"Ä1t5šÌCl,=Z¤8Ç[Gj1rÓäèÖÒ]Ğeí-šáè@ *;Uº[v=)»1,‘—E~Ğİƒy(	Ôó¸»^FbVc}TJ®OÂI1pÍ?T£¦ş@‘nˆ}%º;ºº«/”gªšSl'ı¯i8jİH¸Eoğ1h–ôİgP4Mÿ…Ópy Éô÷„Z½ÚäQËÂ¤a›tw§9]{Ïé†l×\ĞŠ° ¶èS^Œ™|{ZI3xÉ°K­yC´á¥­±l—ú“iô©gu^ƒk…õÍY‡If4§¤ÀÛ¸6é*TX|˜è5[6õ·‚î2^­*ìdkiÁ‚ÖÍI: .œZ0µk•`ÔÍĞÚÎÑjÓy†àcãâÚ>5yöõÌíÄ|8F¤‚œ´¦`g$[»}tX¶µSb¥[\”ÃòÕ¼'æ
+o
+¼qñ™’Œq‚úAÇªPõÃ_*jŞ,Ù?´»iE’áS3|ÌãQ¼˜'Ñ4¹	o¦³/@Vt«‚˜gA’H|¹ã|ÕOaı-²§Ÿ‡bX:ßfLkP1®æ±~o=¡k’˜Èà‡Ÿƒğ6O£$ü‹8LÌ³{Öš`'j8ÔW½y¬ş´üg
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/50/3c3eced073f878ecce3f3fe59ba6ef68cab3f4 squashfs-tools-patched/.git/objects/50/3c3eced073f878ecce3f3fe59ba6ef68cab3f4
--- squashfs-tools/.git/objects/50/3c3eced073f878ecce3f3fe59ba6ef68cab3f4	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/50/3c3eced073f878ecce3f3fe59ba6ef68cab3f4	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1,4 @@
+x+)JMU020d040031QğpÖË`°´Ş±şk­t‚úü5'ºfÅ›iŸ€Ë¼ü¤'ñãEŞôU·~ÿøü/´ó»\1PÁÊõ—»eæO›i^³¡ïV«Ğî•ap&@+:4®v
+ì
+ÙRyö¼uë†­%d
+’€*İ·û²TâışùÅÛÎßWq˜k¸Ş®Â713¨æ_ú“¯3Ât¯oyµç”)¿Æ¹iÂ {­R¨
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/50/47359f375e9d3bfca8288ab4c2d7c4a5b86305 squashfs-tools-patched/.git/objects/50/47359f375e9d3bfca8288ab4c2d7c4a5b86305
--- squashfs-tools/.git/objects/50/47359f375e9d3bfca8288ab4c2d7c4a5b86305	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/50/47359f375e9d3bfca8288ab4c2d7c4a5b86305	2022-01-01 15:09:15.617172589 +0800
@@ -0,0 +1,3 @@
+xUŒÍ
+‚@F[ß§ø²?•)A„D¶pÑªe´uÄAiÒÑ»7b¢íîá»ç$²Jào÷3×Æ®½òº¨²8Z§°]¢…(SÙdÆd*"QÖ8)Ş¿¿.Ï†Ió<È°™·Ä}‹Şt–º#‡É¼Õ1n¢å˜‡`ş@–ŞÅëF•Øtßy¥`
+„š pÀhjvœ^“wñ‹úı?ùË{}è*F¨
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/51/40a178e195695d00646820c81400a3c06f6bf7 squashfs-tools-patched/.git/objects/51/40a178e195695d00646820c81400a3c06f6bf7
--- squashfs-tools/.git/objects/51/40a178e195695d00646820c81400a3c06f6bf7	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/51/40a178e195695d00646820c81400a3c06f6bf7	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1,3 @@
+x]±‚@D­ï+6Ğ¨!\ÄÂ‚
+®ÁBcˆÖà¹vœüzÏÄXXÎ›7ÉÔ=×°Ù%)!+jº¬<Ä¡mÉ`ZçevT…ö\"ôÌşc¯SÓßB x˜äy¾áw—=¹mŸ½bzàè–ùìÖ¦rUßz²/üâç‰§,9@jØXº®R
+ÉØV¼w¤7â
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/51/53362f273937d6d9ff95bb21e0cb21d8890e88 squashfs-tools-patched/.git/objects/51/53362f273937d6d9ff95bb21e0cb21d8890e88
--- squashfs-tools/.git/objects/51/53362f273937d6d9ff95bb21e0cb21d8890e88	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/51/53362f273937d6d9ff95bb21e0cb21d8890e88	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1 @@
+x}MkÂ@†=ï¯ˆ½¬‡^Omº~@“€M)BaÑİ	Yˆ³²YÑ şwWD«U„9½ó¼‹Ê.àµßoõzÛeî^2™‚4 eœ%2ŸÎä˜EA0„7Z’ªÖ¡4?†´İÔ¼l³ğìÏ[…+o,İ9)nÆsÒº£u!œ™ïb4IÁ»vwH?`jîUÙåœ¿Àúµ#2ûÎ³a"’l:À„‹Nae©öôetÔ”¿šÚãòªWç¬‹­Æ@¿©ÿ:|›|²I›‚ ~‰{
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/53/87fdb82a3c9bed5db44e281cb14dfd469df131 squashfs-tools-patched/.git/objects/53/87fdb82a3c9bed5db44e281cb14dfd469df131
--- squashfs-tools/.git/objects/53/87fdb82a3c9bed5db44e281cb14dfd469df131	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/53/87fdb82a3c9bed5db44e281cb14dfd469df131	2022-01-01 15:09:15.629172589 +0800
@@ -0,0 +1,3 @@
+xS[oÚ0Ş³ÅiyIJ!¥“ú ¢MÙŠ„ S«*"‰£X36Jœ¶ñßwl“¤´l“„sù.ç8!—!t:7×_<F“B-™ˆåk;%¤ÁÓ‚`ôLó`9ßO–Ái`˜	z"ƒM"âELá¼İöğg*£«u;=ÿ”òåz-…‡œwE’ĞL×ï¢æO‚ÁO0'ã‰ø*ÏÁ'rğÑbRÙ!gQ— <üÌ£9²Lf¾Œiƒ'Ûœ²”–¥n·nsê(ìödß#*b–¨í†êÑø•øJËiª9¡¿Võ;˜#'/’Å0L9¡”rÉñ’Ï©«]áÁµÅ,W+Q¸íÃÕ%p*àV?`Öôùr³½ã2úå,†B}½®.áÀ«wø2¶‘9rú§UuàcG°CÎ 4ë›±ßT£”8¶æ,/4»g‘²9Ï¨*2a}X4 Õ<Â²™½AŒå'`£ï¨¡&09¸*±Ÿ´™fóYÛ²’Ÿl ¬ÓŒá>Vp¶fj*óõ/òtÉTê§‡éöÌ ¬Ä×”qê´Zzüg¸³ Ê«Ê
+su-³Ù)^ü­¢ş‚PóìŒËR\-7´
+ÿ©ï´ºŸ¡øN-ß‡[àB$E®*úCÚÎğ¿öÿ÷m6_:Dç‡y½Ê÷ëÈØ[w
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/55/61299bcfbe5813dce75f48c07716c66dceadee squashfs-tools-patched/.git/objects/55/61299bcfbe5813dce75f48c07716c66dceadee
--- squashfs-tools/.git/objects/55/61299bcfbe5813dce75f48c07716c66dceadee	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/55/61299bcfbe5813dce75f48c07716c66dceadee	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1,2 @@
+xKÊÉOR040fĞ×WpòÕËàâRÎLËKIMSˆ
+Ä{p)9™y©p>PA^rNiJª‚’SQb^r†s~Jj‘^†—o¥sNbq±£†“3H³‚A…©‚¡&ĞÔÔ¼”Ì4. îà
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/55/a68132e723fb7052b8a1eba9314f4b1be67413 squashfs-tools-patched/.git/objects/55/a68132e723fb7052b8a1eba9314f4b1be67413
--- squashfs-tools/.git/objects/55/a68132e723fb7052b8a1eba9314f4b1be67413	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/55/a68132e723fb7052b8a1eba9314f4b1be67413	2022-01-01 15:09:15.657172590 +0800
@@ -0,0 +1,3 @@
+x¥WÛnÛ8İWû+f[ °S×‰“¦·4Áº­Ó›Ø†/è¶‹Â%:""‹ZŠJâ^ş}ÏR,;½m÷¥©†ÃÃ3Ã™3ô,R3Úöäà·í*mÓ+•,µ¼Õü:íí¶vüï>¯BE2¡3•]„BÓ‹ÄşHÿÉ¼4œ§M¥/šÙå1œÙÊ”­.´· üw®… TÍÍµ§Å!-UF¾“L–³Ì’†¼8ØQš*ó%Û²8À&d„^¤¤æöãMoBoD,´Ñ ›EÒ§3é‹8¼İÃélLCĞliwœ0‡QÎN€=#U|HB^Ó•Ğ)¾i¯ÁJSÍ3LU“JØ±~KŠ<ğ(|›ğdçÍxWa$c{|¨„A]#4”¥bEö<ä€ŞvÇ§ıÉ˜Ú½wô¶=¶{ãw‡p6¡Âª¸J.’H"0$S{±Y"'Lâ¼3|uŠ-í—İ³îøGpÒ÷:£ô‡Ô¦A{8î¾šœµ‡4˜ıQ§I4BV>|;§4ØBiA0ŒÒ"ğw¸Éì¢€BïJàF}!¯ÀÍ#õô“·©øÂ†	&«Â9$9§X™]k‰1Ê&rí™öê*tğŒÆé4ˆ<_ĞCe¼wÕüR¥FÅ:oÓî^«ÕzØÚß}Ò É¨]„}\xÓ›Ókí%‰ĞMø|Ä(K¥MÃÙûóvÑ--R[0Y*Áÿ¯÷41HErÆ8“<ßÙ1Ù¥çÅ’;dçæãàvªÕû2ö£,ô"5TÍğxÍ¤¸ncD¶¬Üî½7Eû…÷J7¥Ù^½ˆ¹Œ1ñé`ØŒ¦£îû¬¯Lz¯úç·ôt}é´Ó~İº¥Ú&Ì\Ú^ß8³?wû½QéÀóÎùY÷¼;¦ÚşÒÛÚİ{”ÿÁŞÔ /}ô!{E8µ+%Ú²ÅbÙ üC¤¨÷ÿTû²ÛRùQ4ªF˜EÊ¿œZƒ]ÚZ+]¯~ªV²8•1jÕ=\:¢Ú†­zOÍaµb‰8H§övñQØ!a:‡?`ØüŒÆÃNû|ÚíuÇğb"(–ÃjdÑ¸|„©m¨á6åyªcŒÍ@úÆ2è*ÁNØ,Š‡ŞSû
+2YÛbbLF‘ó»ş“êÿY§OÕŠFÄsgÇÊ…BwÍÑÙ"ÀçœÁHÍXÜ˜)kÏQ‘kö®à™ÛËÌJ› zG„Zi‹³âv6¢`öy›¿dntÊÔl”e²·a­çºÓ{íÂÃ8«P……U6—ß§ĞHq ÄüÉ6×Æ¨®šK)“1R :L‡Bá!½PK“òL7>÷ÿ•ˆx(èl†HMé XÔ­¤ÁŸÁPÚ˜::(£òÔ£ëPú¡CM„o@g¶\q¸:4'.4(H¥ü½ÑŠ8åÅíğµŞq¡Ôb·šõ;>¦§õï{ï­y·ÿÀ}Í}ïÑÜ±ûî·˜|wõñwWŸä«H‚&Ó1ÕĞ…uÛ¤M£Œgë's­ç}RúÛnË¨Ÿ™÷8ËæsL~…gÂ<R×(†¡æşÀ«$_OÌâ–nGŒU×^Ï«y›Ú¨Ne_V“RH„%Ê~™{ü¶lŠ*ÅÛˆË2E‰È9$Òî³eÁeî¤=vª÷ìZİ)rğ°uXEÀw$vÕ…Ènê*KØJE²ı@ê`/iªíV4üõpu¤
+•ÃŒvt×eØ‚ºt%_šG6”Äéa Öô°7ÿWbá'ËZ‰Oƒ5.—ï+>èk–vŞmŞÏ(º2ö¦‡ëİ/¸gÂ_îØŸpFßÂıÊéD;Ü%Lù¥;‘u#È¶îİÙ<ñh+Eîb…yæÊo&ğ³³'g„d¯vØS:¹Xt3Ë®Z&¥ÛÚ(¡;Ãh8éyY§ôù³”[pŒÚİ_²–j©HÔ½¯P¼mÿk ¿6U9JûXé#mm¡XmÒoµ”Öªkê­­d·Îúš«İJÃmÜ*åTLg¾¹}ŠcúÚ{gµœª„ŸHŸª•¦Œñƒëˆz“³3¼	›…–Âtë[MymÅ¥X]YxÏ*üdà-K=şÕ7¨ù«„ÓCüöÂË—·ÆŞ‚ıîñ™÷ØºŸ˜ôGÔª~AÔÿjŠÙ3
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/55/c03fa4a8a4142882a2e4e9115013fa6f61e360 squashfs-tools-patched/.git/objects/55/c03fa4a8a4142882a2e4e9115013fa6f61e360
--- squashfs-tools/.git/objects/55/c03fa4a8a4142882a2e4e9115013fa6f61e360	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/55/c03fa4a8a4142882a2e4e9115013fa6f61e360	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,4 @@
+xTa“@õ3¿br&´èAié ‰gÒä¾cÎOMc(İó¶×‚­VkıíÎì.»p^¼DBØ}3ïÍ›Ö»jál¿¸¼„ë:/‹û›·ñäuá8/yYìõûÇ)ª²pıC0xP[·ùzÇ–Ñx8'p ÿÉûŸ;ğå­âg>Ì|ŒQ;jÍ>ƒsNçÓM)¢1êÏïªò«…+µ7¹È}ĞûÿÉÌKY}ÿP5>ğR +‹jÃË/sB&æ	>ßU5¸K
+à0‚0†4J$ß3\ğFa6­©oÙşë.G{2 K¾‚ÇpAYtŸ7ˆèYÈ»á«|ÍjÆ€©ZVê°€fW	%R>¥%rm4òA2˜„¤µUÀïÀu]©a>—xE†dX¯‚{-xy`ŠÓh_có•WS`’È{Œââ##ÉC&ÌZ72;`Ğ³C!xU"vèêå¡ç’{h<™¯{Åmrjì¶}‘Nm•E[H!N`;Ù»üè”æWìKâŞZş•i
+îa‹Z¤¥Ê-æ}Uï‘ª›­AĞ‰Vò MÖÍÈıà¸Pş§4Cê ;Õ¿QX¡^Y$:*ÁK£…×GµuŸƒ>óM] põÒ'#­n—é  EüBÃzê¢X$ôilV&E¥8H“ÖÎ–²a°»d—ÒÖ B¡b5Ìú˜`rÈv3U<ñ¿×†u*2h™{>Z¥58ƒßú¸¸ÁñŠìÁbáè˜•aàä•:Ü®Ì/;ş1a@—:‰QŒÅŒ¯ÃgŠ âv°È’4u=Œ
+û[$©4’m€ã9{fHû`#Ÿ›Dì‘ü^>š9LG_t©ªU‰C£§ĞT~–…Ó?ıj&u	<qÎÎï˜¸¨
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/56/ff817c6793c6bccc438fe9e06fa77339ece8f0 squashfs-tools-patched/.git/objects/56/ff817c6793c6bccc438fe9e06fa77339ece8f0
--- squashfs-tools/.git/objects/56/ff817c6793c6bccc438fe9e06fa77339ece8f0	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/56/ff817c6793c6bccc438fe9e06fa77339ece8f0	2022-01-01 15:09:15.609172588 +0800
@@ -0,0 +1,9 @@
+xµYmoÛF¾ÏüÓ~‰|—ª’œØ‰İ Ë6N@âµÛâ %­#%ÒåR±•Â÷Ûï™™}!Eùò)¬pgv^vvö™Yfº,¦t8xÛûÛáW:/ÊUZÑÜØY™İWY‘SgĞİïÑ‰©R¼ŞK~úö“$W‹ÌÒm¶44+ò*ÍrÛPYÜl¥ål‘}1t+6»”Ôh³4÷¢¢Çb´º/µfNYµ 4ßĞÊT‹bŞM.¡?ÈÀv«ÇêGÖÙ°¨ãÛ,‡¸×”åŸÛM’Ä-İVåzV­KC¿˜òKf_r’\+, 3Ë9<„ÏSC…„-]BçĞ­0èLş»ı%—Ùç<e‹ÿ2éÜ”ÉäS:»3óËª4éÊ^oá¦ÎcNB¤Â–Œß¿ğG¤*S(:oœß>%×XqâdŸwŞ±>·OeqoÊ*3–ióyÆù‘.£ EÛÎ'©CŸ
+äçb½b£$/³¯ÆNš¬k'0úu´›õ$Fg[F¡ë¼X2Ë©q#6â^½uİù¦êœQÔÎ‚:òrq…,;>B²Èqî–xÜ¤\W;1¾ŠšDdLâ+Ï‰^hœÿ'Y>ÿ”faÙDÂ1âUBTC€…äã|nënÃç-Z´©év6“ä`?<÷·\¶ŞN|ÌıK@­õ™Îb·Ûk?[¡Ú.×S·]{í,©¶q¾c³ız¢Ovâ fuÀÆøï«iOcÔ¹LqìSKYŞ>{NøğçSRÅ8ë˜(Šé<Ğ9µª%ÁiZ¥"¥=ù£ËQ „O«.@9Àßpú’ä¢¨Œ¥tZ¬+Â{*àŸæs2ù¬˜,ŸÇA_†ğµ…šeVU@ƒŒ *z€ÄÆ“¹Ö,G™´´T-ÀIÂ«´"Ö	Â¤xÅoÉ¯gÃ÷7¿/®^ÄS å’”;Ï±Ô_Dª—Ÿå²xàb`g³2G	"Í±'”)ï9YóçƒªrU¡º•Å
+È_ÚŠ¦›
+RDç<º9Áˆèì±*Sy·šÕD¿§Ë5ŸêÎ4ËÓr³:F½G}ü,÷ïu¨ÍáÜê;	xòï«3ÚLú×D,à$è—_¨ó†şNı½=úmXÈIÕ„^H¥‚Ğ u»]íãé=ÖD‚(ƒèAe<½šĞ¡1a×£NªóİÊŞ|CyëÒàk)š$½Ç^ŞÑİY>)£>4‹”0`B«¼½Ä²±9ßşv©ãc÷’Ù¯˜½…ÂxÍŒ€ QßÓƒŠC¦(Ú¦5±Nİ}+ä¦ò°¥¼)æ)a$l©ŒïDğ”9@£:`ªÌsÎV÷ÕFqO¦Ÿ"¯ˆIØXÌæU&b}‰ë@Q˜ÔÎ#CÈUæ¨Ê÷©­†3	èC¦ÿQf•	d‰àY>¬ª2›®M¢[8*V+“Wj[xÆeæakg<¾(¤4RC İÛVçµÕœ!$ïÂ¼	2ÿıõâğÅKzñ?½Ç“ÿÏùwpÈ¿ıÑÓ1cˆK«ßÑ~  (Â‹ÊéŠòIöóÏ”PÚ“œSf–o1`ªRÆµı]ViYéj‘ b®F
+¶ê(yaÄÇÛ[k*±·{B¨<ÎZ…1vÇàğÜnëHµkS"k½ŸµO upº{ÉÃ×A3{RÈDÆŸø«Í½9†;Ù-uRĞ;Ä‘1’hŠô»c¦+^†—Æä†".¯¾³ÚğŒëã„×xš}6¶²ÔÁYq}À^{!œ5^ãp¹–æÔÈMDv­A.j2 GÊÙu87¾¢¨ƒk¾ÛéQàŒc¢&L~yw4º~
+J¢zÀòQiWîĞ-İšöPœÅÒÔ¶J*#|dUo·T1oW›Î»­	‹‘ÕŠª!«Š¦]äwÜTWÍ!€;Â Àç‚ˆõh¿Î{`ËV*…ê&ˆ2ŒüEùh.ŠE®—Ëîø”—(S‰^qÍ×§G?ÑØ^f«û¥ç¢æ
+Ç»"[ç¼nÊ]1.hdá«…A„|jO8lê`ø$õQzÒeeJÜ)q»¾QêÍûÌê‰g‡£ri±
+XH£ˆ¿‹/OÜ£¸ã²;"“İd9F"ËgàzŒsÌºÖM)²¶/K|ôdí°<é]Ótcº‡lmëH€«­Ç¼Æ%hÛÍfa9nO n£‡Whœ—Øº¾@²O¸0=æœ[^ãåhĞ.Z@¡p[ŸÔhˆ˜·Y÷‹Óãª(úO4…?‡<îÎÍ	¾h	ÂYÓóƒ;"¾%ÔJ&»Z;—±§Q°8Üƒhc†Yå°í¸çÊâ›’hD7Í	½ÄØâëÏlÑñ”ÑYj.¦ğã´nú2«ïg9ƒŒÿŠï²X¨`ôw¶¥@é’c¥NØ:ÒYÓøE‚»ß†Ò!9›QRj¶qVÑ‘QV Q§×`Ñ™¼VQü‡ô“ØE¶ö«V¶T$Îå­=\~ƒ]k;‡´rşK¡Ğ©§Í-¬OÀ=xÇ†p’2œï0ÀG¯]cbÌôÚşŒ°„.D®³©)ùRgµºéwÄu~‡,ç¯µX6òTCév±Æà?Ÿ%9Íeiîì`4ãí‚±Ãr¸GÄÓ†Éµ£& £äuã3mã0ÉGêİ”á:üm|Gµ»§
+]Tı¼SváhúV‹•é‰ğ0\¿YAûz¦SX£ƒ$YM¤b¥h‡Æ¶v+áˆó£úx>kS}çQ’õÕ¤lä4t²|ĞÈwUæ5ö]GÉãokdyQ(âZ<	Ÿ†Mwõ+‘[~=®ÎÔ)Íûîô¸Nì·§„«Ôğ”W~ŠK‹FËéü¿fT]ğÛÄ£çöB#Ç·´Ø ª´–e~o@6r}²Û€Úµ­¼{V†À¢¾²Kb=WfÕØPÖ€‹{,aG¹ã+ª¹Òw¥ÕGŸ·ò¹å‡Ù"-oğ½ıšğ¯ô1f8³nJ/c¤ 58w±‡t9!  LYÜ÷Î‰è@ã¤D—¿c CrDWâ¹PÀB†Dæv°“\øİgFmm@—µD*K€É¤Xû¶«À±kò­ÿ5‰•V¹+2µbÑÖ±õ½‰¿"ˆCÏ*,lè­¹¥N'sb[ç×Ø˜=‹[¤ö÷ÑÜá£©ÿòÒ8¬ä>ÊÄÿ…âtåï0	ìq!³5ÈIş‰_
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/59/9e2da3f782c8f51baefb67185711c6cbdcc485 squashfs-tools-patched/.git/objects/59/9e2da3f782c8f51baefb67185711c6cbdcc485
--- squashfs-tools/.git/objects/59/9e2da3f782c8f51baefb67185711c6cbdcc485	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/59/9e2da3f782c8f51baefb67185711c6cbdcc485	2022-01-01 15:09:15.653172590 +0800
@@ -0,0 +1,10 @@
+xÕkoÛÈ±_©_1pp8IP?Î½æÜÊÈ´,DU’jbœE.%"ÉrIÇj.ÿıfv—/ÙJE¿0èå¼vŞ3Ô:N×puuuñ§WQ˜,}ìLÍ…{×{…oQÂÀ›a†0Î™W0ğ€ÿ«ôø6äF1ã{^°İ)€³8àŸÛh³÷à§»,gœ³ 3€4‰÷$§Å…¯Bršísd* ïàâìü|DÏñ¼Ïˆn¹â8Ê`––›-Ëá¯™ü½Òè4Í7§å§Ÿ•\¡R–§›ÜÛ‘jaÎğ4,>{9»†}Z‚ï%¨]ñ"Ö%šà%Á›4§wi…{‚•è¢Š-ƒ‚å;i(^&‹LXÂr/†e¹#f‘ÏÎˆİãoÑë½à¸%l¥Ü¦(Ø+¢4¹¡øYÎñ.F$"Í¡ï¤jiF„Ôo1†¢¦==bocV Q"®ß¦š°E‘hÔgt'¬”œ…e,îCÀ‡©sg®Ğ÷ğA·,}áÜ_#q±MË™í²8BÃĞ™¹—{ô	i<7¬ñ²èï¦³©sOÜN…aÛpkZ ÃR·œéx5Ó-X®¬¥i˜=6zÍ'Ç}
+!
+Û¥9ƒ€^óÊğ{Œ$Gíâ ¶Ş#Ãˆú,zDİ<ÌÂŒ4Æ—L÷zqšl„™HŒÙ¢ç¢’´Áç<Â)R!«GboB9‚«·à0tƒeìù^ƒ]ïååÙŞ¥¼H“Ìu8»8??}~yöãV¶^™ãùèÓ-Š}ÓëÉê›±§ÈÇ,ó/ŞsŒ½(Òˆ¹ «ªÖ1ß»æÒX¸ï,}üŞp´³º 	5¡ÃkÜy§/n4M»èÀLA—ĞÂtöC66çs]Ó®:@èşÜ}¸›:†k/õ±¡i?vP¶cMMûKj˜·(äm¯tL©ûærö ú_à¡§ù[/‡!¿¦3Çdõ·ˆ€ÄyœYÒ~"ÃßàßN½¶ÆõIıŠTªÓPÛ‡” ¯Œ‹†¢H?±Ä-¼uÌ~1—¿ROI6‡l_…‚ı:èõzHTúfñ²¤È÷ğ¥6F
+èiQ¢(®å™Gÿf×½¯×UrO¢ÓRÛÈ¼ü[Ùa.]ç~‰¾o¥…î˜smòaµĞ­{½h¼oßcetË2­¾=İšØ§§§•Ÿer½‹†eÖçØ¹|6^à¹ÿ‹_ænVäXó+’~ÿpö½ 3ôXöyİ6ÁÉ-V9–1Öœ°deÀÃÉwüáä!9))Rş3v{ŸŞ ¬4ÿ	NPßW¯Hã#ä“´ lÁ¬#?÷56î>Z Ş¾6qÛq;n!ˆğfçÿ“‡hFgûƒt¬—oà»@z,zısâíØHTFqÿ_:SUÃ<Æ¤n½¹iFõĞ‚À0Şr¬ƒ( *“4“…Q	ñŠt×’P0^¨2ÒÉÆ1D{ñí1âLöºrÊÄË÷/i#u%zx7¡ènQ¾ûKV+*R„UúıèÈ
+F|t•úßÂÔZTÄah:ƒ6¡p!¡ÉptH,Vs×ø‡¦5õNéVû'ĞÄ2tÇ°pTLÊİšå.åÚ"§xÈÆ$Æ`£š”
+•à`bäœ…—S4Y,	¤eŠ]Öşu¥‡|ue¤* ¸â ‹RÚ¢`
+]«ıa˜°Ñˆî+‚0Äf¢^Åü¢a8¨Dª×Œ­ûZì”rÄGaQãÛÁğãêˆÁáó£ÅÃ^y	)›A@Z?zqIˆD-Dµ$ëBÙgÒªuàÖÒ'scá¸r½‡f0>g«£B4©P±ØªÙ¦ûÛ,úìƒ~oŠš·Y÷%‚feÀbia
+7ÕÅÍî°Z<Ç6ëÃjZ³4ÛÃ¤¾­·‡I‹ô¼ñÅÜl9¢ñ„1_:÷•2çææ?¿aiÈíF~6}¦íš>r€bÅyş¶\²2˜âšßYÛÔ××ÍÔÛŞâÿZg…²Œ‰@áÿC”>›¹³Å{è+Vø­¢T§w³÷ê4¾³ÔÉ6Ç¤mH#¾é­©0(jğÂÿ•x%Wnq/R™á‡õJu…C¿Uª)HáX‘X>#P~²·‹ŠÇş0/WòÔ%-_¡)ç Ê©›ŠîB¨jòËŠmU©CÕxäõ™Wl; ^®	†ÔJ/0o†ë2ì¥Ï—Îéª Ì•”Ê=ªÕu‡›bsiHO$~6ğd2¯¢àÍG¡ºş?u­2
+Ü(	Sòñ‹9ê¶oVSĞ¹ |vüæˆí€\•Û<ğ×ÙıªWµAUC¢ÎmÃiµÁ6F¿¹¦úÛË˜CSÿmŒ9v ™ø‹“ƒ¡ÜİÀ†	{¢!G]½Òê¨ğX&<Ú$¸óÍÎãŸ&‚ø±3OŒ]†_ÜÔzÕÇf³–İf›+kl´Œ–`5nĞæªnñ{¶Ø×¦©¹ÔÑiMí«T»;©e,ôy[‰6’zmK^"ÊñKåÆÖ2X—ª:T¾«JQ„°"Y‡\ë@)Ù*N­)k<áï-øéa™¼<p1²H!Â¦A×—ˆÛ€"õ”»L5\·»¸!Ãï†¹·©)ZzW¨-m¸aE›¡/kº‘KÑRÙ“—˜¡2q¸R®j‘Íu¡lI¢6Â„p!­’r\½æb‘=ÇT¸^ºCÄû>¿ze«# #Hİ„MªÑï’îz{Y_«q`/V
+tÙ¿!YVËËlâV‰ri¬=KáµƒHáÍ¯p#ÂŞï»Úè
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/59/f4aae0a87f81a6e3fdd1ee3959a962206c7555 squashfs-tools-patched/.git/objects/59/f4aae0a87f81a6e3fdd1ee3959a962206c7555
--- squashfs-tools/.git/objects/59/f4aae0a87f81a6e3fdd1ee3959a962206c7555	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/59/f4aae0a87f81a6e3fdd1ee3959a962206c7555	2022-01-01 15:09:15.669172591 +0800
@@ -0,0 +1,4 @@
+xµXıG½_ÇEá`Ã¬÷¢»dÙ(f±ƒ…Ù5şH@¹“Õ;nÛ-ÆÓ“î™]|ÿı^uÏŒÇf‘NÑ!´Û®®®Wï•¹‰õ=?ûîŸ;~Ò '4Kìï¹°käXZZªXÚ­Íä¦C4]+Kø+h­VëxK‘Ş¤FZ+d¤XNâ-{ªİÂ¯|r©Ó­Á¥ŒZQ›ÎNNOBş÷Œ?­U«”†:_­¥¡©?ø©Œ¢£Íª“ü±ğåÂH^±áp–FJ²z™İ	#Ïi«sŠD‚ˆÊfFİä™$•‘HÇÚğƒ½PË-ŸåÉfkI™4Kzé~ùùjF?ËDÓ(¿‰UDCÉÄJ¾.,¥|h×Èûfënô9†Iõ5‹Léäœ¤‚{C·ÒXüNg!»Ğ†Z"ãPé”ÛˆoK±@¥mçùîÒZJÜók"…5\"©;”“n$åV.óØ½‡Ğ¯ƒéëëÙ”ºWè×îxÜ½š~8‡q¶ÖøTŞJïJmÒX!1Óˆ$Û¢&ñÛŞøò5®t_†ƒéÎ ?˜^õ&ê_©K£îx:¸œ»cÍÆ£ëIˆ™ *HŸ|»¦´„³6’2*¶eâĞI‹èâ­Å­DG#©n› òRÌ%ÿmÏü®ˆu²riÂh)€sNjI‰ÎBº3
+ É´óµ×G¾¾keHß}OS‰òHÅ"’tD“œï>{4¿Ô6ÓIHo»trvzzztúìä!Í&İ2¼˜¯¥Yf:8n4ş®’(Î’š;‹ÎºY;÷æ8Ú½ÀTç?â|!—*‘tu=u/{ó·İ÷tzÒhÈO T˜dd´ÎæÈ>ÂÀ×? NŒç[­Ğ|®‰?kEkaèI*²u"62ÄÌXµJĞvê"h7şh{Ç ;o˜¿<*¬æ˜˜Œ¸îg|Î.”³Ã´DÎc¢›§ˆH\\P¿;œôömğ>àRÄ|¿I¢mŠU^NZ –­ı«Ÿ?ûèâ‚&ïfİÉëşd>¸ú¥;¼š¿ïN§cúü¹}ìØ^-æ™¸‰åÜfÂd÷Ş}9|ÓÆ=#³Ü$üô.mÄ»’YQ\wÒ#W°NÛ\”e«n}AW³á°MÀ_o<¾·š}L	 Ì:ÚuÖàA”‹™—Ú%ÍÊ–±Ï*’à‚eK!L½À0q·H=}ê_á®€×—êlv¡ü¦şİÉ¶ šG»Z¹ÍGã^ğ ›¼á\9ƒ¨èÑ£ÒİƒZ™ıÕÙ¤7æJ‘N2•ä²tP‡+šPz¨7ªæÁUÇÁ	z„¨c+3y«¬Bx	¨1;Dóëµşpš·"ÎõıÜo­úOPO¾‚$İ[ttêëæÎ ÛD3&zW×ÓÉlT~@dù¡ ¤2ğÄµ);¨I&‹ˆ©2Æ4¤©Î|›ÑWÃrã²ªU–†¥7$°z
+b‡Z9Şóã¤le'±ú(¡â€ÑJ“¸[çÎûWÉª²´Ô-á‚U
+iA>Ú€OÄJVÖàX²€qÛš£coS€¸Æ1?Ğ²B´§ã¦7š.i ºnˆ[$ 0jRiÆ<-‡4€XäcM¢ TùâJ¢°*T»Ş€Êj·¼ğì#á ;AP‚Ìz\¤8`BŠÖ±Z—ÏAsï¡ƒ›S4Ä1q­wE¡ÃÊGÓ¦2âMæ(ÑG¹ô´Ït4Ï˜FñçIÌ°Õª£u2ºäAÛ½z7»ºáÄ%ñ>§¾¨‹Í}(ËÍ.IKŒ7B§ÎŸ?w’î«‹‰ˆÕFe@—ßAÄ†‰õİeUYa§@3Ö^ğ°â@r±æäÂ=T¶ÀS*1Ğ­¡Š7±>òÊòüM;ÄªXÙİÁ…[0’Ç¦§h?¯<FäÅ–_Çøl‘gb¼S¹u,ÌË0V Ì:^ãck‰F¿´`“äN0ÀmBMŞ¤ëà×ú`ı…ÓÂúz€È	èlFn„JÍ­²Ş\ÒĞ58ûn¶ÿüø ™OŸÀŒZ[nJTƒöß=§ÖèlWĞt|)!-sãxÉSaxĞ,« 7ğ—S¹İçL$eƒäâA-¯ R}¸|wÿLçÍBÛÿG>Ø3ãÒõ“ŞöäğŞv$p¸q+W1Ò^¶€SìË ‰ØçXÜKNc˜;s„0óÅ-JÊ_Ïv•‹»°<Ô±ƒIØëVq¥ê4Ëócª­U,z_‹Tqçk©zà?qu_‹°á+K‡#WlÖ ÍÚ¦Ui¾Ë=Şœ&2—†kUƒÌ··¿­•²§‘UÎ÷i‚ÿšélbtaà×ik2òäš<aZ+îìëaRÔ¦¿76UÜÀ•ÃÂ#²sTü§ §í=B¬# Ñ-¤X0ê±û~úÅ¾4şî
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/59/f88733f685a54539fb621900ce4efa20afa7f7 squashfs-tools-patched/.git/objects/59/f88733f685a54539fb621900ce4efa20afa7f7
--- squashfs-tools/.git/objects/59/f88733f685a54539fb621900ce4efa20afa7f7	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/59/f88733f685a54539fb621900ce4efa20afa7f7	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1,2 @@
+x•Î±
+ƒ0€áÎyŠC—VD‹:,cè(Ñœ°Ikb‡>}¥‚C:Şwÿ5ƒi =&»8æFwîÔ`£_uZbuÍª2;_xEVçÄŸQiÜø¼ Ûa’^Åt¹õ!y™1^TP¢ï)Ãç„Ú)1P½öû@/£$R8§Ú¥	XõÆu£iÑZ”læÃiÜFåp[¸Nî7Ñmİÿ!â£–ª#ÕKe¾
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/5a/e96c081c330197b1c9fe4c20ce08f6fd4670f1 squashfs-tools-patched/.git/objects/5a/e96c081c330197b1c9fe4c20ce08f6fd4670f1
--- squashfs-tools/.git/objects/5a/e96c081c330197b1c9fe4c20ce08f6fd4670f1	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/5a/e96c081c330197b1c9fe4c20ce08f6fd4670f1	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1,2 @@
+x+)JMU063b040031QpËÌI.)JMÌ-ÖK.(`èbàó“Û+³±k5¯WÂ±¼Â['±(Í`˜¬f®%Âê±®bRœ×¦mÆk7·Czæ9•¦¥¥dú´ö×öWN³¢«²¼öäÍòq}®.ƒµf•X¤qã’·r?÷µ­—Ü%4oö-¨*ÿÒ$ã¾¼‘28=ç©Qy^ãÄ¦˜ú\qŞz…<OıŸI)
+k-È)m-}`km"TYpIŠcZ…^ƒúòjïe:¿cY–DïWX™¹ ®"¡%™9PYzsß‡ú-5w.1˜ÿzäîÂõ³±(Í`ˆüÑnü­u©«åï$I†s~¿Ö/ÿ #ğ(
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/5b/5cb931a5e59541f6b14e3ec93262e87f6d3c56 squashfs-tools-patched/.git/objects/5b/5cb931a5e59541f6b14e3ec93262e87f6d3c56
--- squashfs-tools/.git/objects/5b/5cb931a5e59541f6b14e3ec93262e87f6d3c56	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/5b/5cb931a5e59541f6b14e3ec93262e87f6d3c56	2022-01-01 15:09:15.609172588 +0800
@@ -0,0 +1,6 @@
+xmVÛr£FÍ3_ÑRÅ8]í7	ÙY¥ÌF%y“ŠßF02³ĞÍ[ù÷ín„T¦T.æL_Of¼IÍüaßûeì¾©d²LL‹yÁıhØuÜÏÇyQ‘Év¹,
+e4˜¢ü¼+¢4Œ? ìµúo/a£´ÈÏp).:‹y÷ŞyM$¤R¿—	˜-ætÚœKY€*@äUæä²Ù— Jˆ„mJ§HÊF}Yb©“Êã9‹-œÍB—€¥ˆ8†Âd´<bø;ŞLÄABy4hu.^şÎU)!—XeQÂ[ij"Q*ıÎl`¨±ûÅò S³“yqïø]ø]j™ô¸UÙ‹ù£ã >ıgx{»ú…!à¯Ù%£æqa™Ë­:qî\èØdÕzÜZ—CŞÄæ¶¢®3´4À·‚º)Ô¡¸¶{à(MÎæ…áªºÃà¡tü:rUü?Hp=
+µ=#1$1 6ç…cÈ¯üí'E©¾šR>rµÕ|Àèôj&Q\±Œl"ŒOkˆE)@jzá¨P7äyÀy 1ªó¢p‚¨¥éÔhƒZşLÄ5ça§ÙÇóù5ËŒ¦]¯ë£ØÕ†.ø¼ô›õ€×ôë£ßøƒ}zøúòNk+ÖUÅ!Ä&d=Ã¹DIÛè4ÕË*5\ Ş*ÈÀÕ.—ÁÅÄ¢"Ğ™©wxÒ±º7ãÂ4İ%¢eOÅµ1o€Àb:ÜØ´ Î1]…7ÄaŒp4iPYˆ|ZÖ˜JX…ğšì³MË‡K[…¯5äMĞn½œ®nÛ­0²ââ—Ëpn]ÚÔ6~·½'Oø«Lê¿“êàÃoÇI,„ªˆ8*Éc%™dÌ …E½ÛHV>Ğ¡ƒi_È¸{Ï‚şáyÿãiV”R°#•H¾ë$Wú_ëNl-²]Šr¶µ:—ÛO=\ f8=Rë+ñ?I= ”‡ç_À‚!µ	@ ‹x%r»I¥â²7´ Y#à{ ğÀîDÚ4ÿn7É—ĞéİùwıF…„`Vké½‰†—ş <’„eœÃúÓ"^Á"ñˆ¯ëÅº®æ¬72ˆ£¥<AuIq^š¿p½OM¼âÓ§µÛó­ô`¿À‰…ü¡ıvƒªN7€%x
+fu'JÌ¬ˆOT_ğÜì£â’+jÓÀ Ê·á…M)8	µKğÎŠÎ|»¢Ó‘b¼ºÇDúnº•'Õqí˜¯gÙLŠ,.Z±âŞÏÛ›BÖ½Uš®ê%yP{­e#K-ü
+ÌÄj«ğœ^™º½&=u_ÍQ¬z@.rndL¬;¬–/Ø tŠıæ»ŒøÖ¡ß«^ø|gş˜ûê áÊ8!ïPa6"å"-Óº?¹è”ÖÃC<e¾f´î÷6.í/EQM¹Ód®X¸%¡M!õPW
+·Q83ıÁ3ÿisğà{ĞD{:äœŸÛR_†
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/5b/9cebfdffe41bfe2b7ec8dce30e5a3832fd7c01 squashfs-tools-patched/.git/objects/5b/9cebfdffe41bfe2b7ec8dce30e5a3832fd7c01
--- squashfs-tools/.git/objects/5b/9cebfdffe41bfe2b7ec8dce30e5a3832fd7c01	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/5b/9cebfdffe41bfe2b7ec8dce30e5a3832fd7c01	2022-01-01 15:09:15.601172588 +0800
@@ -0,0 +1,5 @@
+x¥VÛnÛFí3¿b?Tb%_›¢ˆ’–[Ç$×°Üp¼£­É¥Â]
+–‹ş{g–·¥D5êÛ;;3{æÌA’pq~~úİ‰³—k!£ãŒÇ0÷u¸‚˜Î˜Cœå0{?ùœåB¯RåœŸş<>;ŸşoÀ#1Üù›$ÛĞé®B”¥¾à8Î‘ˆÉMËåìñÚ»ıuyãÑYH´E¤&Ã¤ˆ^=l×¨W¯GÓlú‡'õÅ9\Í^î1´r¥ó"Ô°¼2x>æÎßÀt«Ü ˆcÌ't®¬3Õ=ÍD*´%"‡è§wµe¥Ö:
+·!E95ş»ÚöÍB¼àˆZ¡!-”† áVBé,ßò-ü gCÃRƒ1eêçşó%+cwå«•}V™¹®ãÛ¹¯¬PÂBğ“‰®.S_‘À[àO.LÄà–‘³\Håé7ıé«{ôÃFÆOõ\dá“‰ô+ÙâšES¤z1ì\\Æš“ÑZÈ"½!Üœ+“~89†Ú“ëÂ¤…Eg‘qÈL2¸'±fÑTh5aòJÌøÌî,
+,¢-i,1bÍ ˜C-ŠÔÒ&‹L|‹{T£*»dÂ<üxşú§Oç°ë"­ËÜ“	UûÒ*Òå{ÔwƒùCvUä9J:«Ázú5ş¥,İáW\xTğÏÌß`="jèĞµÿ8ğ¸q†ƒòîÓğk˜n‹ôrã‹Ä4yi5­c0©™È'Äì1šgØ\€»Nœ²)må,ì›n2uá'¦\…=ïì)SG^|_
+ª®¨ÇÂÙ3¹¢œ›áÒ§MuH÷‘Ğ‚´ŞPùÑUkğö\ÀûiyÁ}qEå¬(›ƒºŞêr:utLŸÀ[x}v6Ÿ:TŞ»_ÑŒ¢”ï°4ªÑB22¬>ÜÒØXpÙ>¨Ò·x¹Lˆzp}şC‰İcï:Ç|ß`x›å©ŸP^*ÔªÌ5“PhLUƒ’úÓcAŒ{ŒŠc…Zä«~<8Õ£.PešBEµXcxV£©wAó|XäF¯PWŒ äêé,¡>îNZ–öÆ Ğxê\ğ`²nªÙŞqäF´W|bë"5k„;qnÉÎcA{ı¾¼.dØ,«2Œ­-éÀ{ J;3m(£~LUVŠ{FšÑø¾›çB‘ßL&ÛÚ¹/·énî,.ıæÀ”ØÀ¥g<)´q:¡›ÑÊ  ë¯3gŒ.EØŒÈ›˜ñXMÎÖAUµ‹~’>o'j‡˜9èeCUŒ½AÔEÛäßâ¢åmA[ó?Ì¹HjËÉKÏ¼j}VÙôwå§S™ú.ÏÜ?„·i©ÔÏ$+ïİ´F‡¨c³»ÖĞæÌjèJ¡áø?ŞŞv¸ÄÆŞT+çî‡^ûÓÄ¶wc´˜Ô=7ÌÛ®9)VYœê‹GJ”Å<÷iÊ®Y3ÚŞo=İ„ÿÛ“ÁŞƒˆ;ˆE)0¦=¾ÁÔ9BZ®±ó/İè1”
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/5b/dfeed564cca27723e0b285488e8ff380c64acf squashfs-tools-patched/.git/objects/5b/dfeed564cca27723e0b285488e8ff380c64acf
--- squashfs-tools/.git/objects/5b/dfeed564cca27723e0b285488e8ff380c64acf	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/5b/dfeed564cca27723e0b285488e8ff380c64acf	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1 @@
+xKÊÉOR0´0bĞ×WpÎÏÍÍÏÓ÷­ôÌË,q/ÍLÑËàâRÎLËKIMSˆwö÷õõ÷‹÷ôôóqõt‰÷àRJeæ¥âië÷ô36òò’sJSRl2¤ƒ-°ãRNÍ)N…3¡XÉ·ä—Ô4½% ê¼”Ì4 ³ 4 b:ø
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/5c/9eeec73ca24aae401230b6d9a10124da217ad8 squashfs-tools-patched/.git/objects/5c/9eeec73ca24aae401230b6d9a10124da217ad8
--- squashfs-tools/.git/objects/5c/9eeec73ca24aae401230b6d9a10124da217ad8	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/5c/9eeec73ca24aae401230b6d9a10124da217ad8	2022-01-01 15:09:15.605172588 +0800
@@ -0,0 +1,3 @@
+x¥XYsGÎóşŠ.ù!€‰KRó€-S‚TIü`jÙ…©Ú+{èğ¯Ï×3³Ë¶ã”U¶¼KÓÇ×ß4ŞøÑ†ú½«Ë_Ît÷%°ïä¦½£V‹î>MGäËMb'/$ÃL$í«{qqİâ?k²šÛ~ôhÍó/r£À–!5Î-ë•ôBWx´^³§»ÉÛõë>¡8øŠ¡ãç® ³ÕK,ÒöîLk['öó”ÿZD…õôïõø¯Õxq¿~Gâ…töîÌz%üT|W*¡+=¸7qÀÓru;šO¨êÉò;$ëw£»»½:'²/fóåz9ù4¦e7¬ÅhJ‰ø'—‰D˜¥ä¡,¬zƒ`øÙ‰‚8i*£ğ†ˆj®t²¥ü"¨AN{@¯é’¦oëø7ÍìL¬SÈŒ©+ŒKË#UªXÒj}øª±ë7o¨æ;xóãz½NßÂ/Ñæ…P ;÷3–{Mˆ‡õæ¡—Î%ôÛ–¥€'Q,’LŠ”j8ÈDZçä;S.g—ŠŒTZt+R'‘q†„•è‚¥ÿò>ìĞ¥x`‘È®òÖ6úJ“ú¬_æ\óe–ùú®´ÃzÛb”¡şŒÚw¦ÄV«òcYQÍxªÂjißnB¶G
+Õ”Eê•«N‘G…mrÏÉïÔ(>Q^†ªµUi`ÂåÙÍ÷\?%È@„T)&ò/Üÿ¿‘ŒjÌXU/¡'éû”§‚;Ë}´ıÍbüÙáÅvb³Ò$é‘ÌHòDµPçBÃK¢à†|ñ(|4(R]j¢EMòğ7ÌƒÕ.¶ËfÜN6+Zƒ,eH­*Øµ³h¿êg~øíwúZ½p@¶¿àsÃÎé‚§„üø_z]%é(ÉeÀ<’tYÒ0d$=eìM%}-éŸJJ‚”£‰àRIzİSÉÕk!¶½Íeß"Ä½ØŠySmQÅ;S%8C#?PS5"ß@Ø!:g§³]äî…#yòüBl•uléÃ@0˜=&n…j€LMl[IûYy ¢q€ÀñÓé^sğàG÷ª®ÍT¸½nkØ<Š„yLuÃXÑ{›ŞEÕæ²jsZ@Wº<¸oœ˜±šd¿¦`X0!ø•™ËHç!æÌMªÙÎfX“o'[‘@j‡`àT£ãU>ŞrlßÉ}Ğ­K68Me|_' ºÖãìñÌµKÑ¨®+†`Ï 	P‘HĞ 'ÂÅøœJ';¹İéG¨€òe”#­ÂR›d8[…€¶p
+‰nñø¡÷HíZ·é1È«g,# BnpwŸ¶òìhËW/ÏåFnÉ“¾>şfğq”šÀıè©ŒÛÉ“×è1•\ZåÑäşpıo$qa’`àHŸdæì¸kÌÅª¹œ ®¡µ¨°kg6=íÀšœ¢°>.\HQ®îg?6NßÃT<ÛAì°^hqšëØñK”«n0œpvÛ4ó˜¡% §Ûµ l )"¾ßPñÅ ÊCçÊ4 ÜhÇPù±*ÿta»•Â"ŠŸ-l÷s¼A>çóg”¸šHjÜƒı(ŠÒ•5§ÜÕ­«Ş7Ñ+2xHÑYÿ¥I¶²9NÃÜæiâ%€¹È´¦²!a– ÙıÀ§ 6šWÕÀİë`Cnû+í¤gHSİum\€`Áx=™È"â÷Šª±ÄP­ ñz	«(ô_à&S·'å%ĞrEšİi8Û„&Â*ç™ªµµY„)ë.?­g5Û–¿[4û¨EãÅb¶XOÇÓBÖ¢©"?Ê9\,YI%Uıùˆ÷VõÓ¢	–L½ƒ©ç=¬x ;{XÍVëñì=¢51êíˆ"\ª\u½ú°nku07XK¤.ƒAPy¨¨¼©JÄó:-/˜ºÚîöûyuÉ«åa*·!êåìì„\Jì®`ëu¦ßPØ&s3nĞ#İ4qJU<³"B?R*6²Ró`lÒyãh)rœ„K« ÷!f³b•Ru€ÅÑÔ,áT•Q×y“ø¨vÕëqÒ1?å¯Y×ÕzT	+>µˆÙ¢_µÀÖUÁ;àÑ`˜c‹nÅ‚7Æ½¾†±Ûñïî¾lìÂURGd¢ç®ªkTëXÏõÒÿ ÔêoVk«eaÇG*Š´|™™=ƒfuË0‚ ,tì-´‘ÇÑXi¸@Tı\ÏêìgZ9W'Œ½>FÿS³Ã±¿­F¦Òİòey2êj€Î)7ØÇÜğp¿|˜Ïg‹ÕøašÇq”ğª´ÿæ‚B–4÷LîzPÅÉ(ÂM	¢æ¯Š<ş:IC5ók#¾oéOùİ\Qc?ä_åN(-ç\½±!£ÌügÁ¿^,'Í
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/5c/b21f8f7dd98b20643506deb22333cd142ec344 squashfs-tools-patched/.git/objects/5c/b21f8f7dd98b20643506deb22333cd142ec344
--- squashfs-tools/.git/objects/5c/b21f8f7dd98b20643506deb22333cd142ec344	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/5c/b21f8f7dd98b20643506deb22333cd142ec344	2022-01-01 15:09:15.653172590 +0800
@@ -0,0 +1 @@
+x…SïoÚ0İgÿ§ò%?Ö6´jehZh·fj¡*Thê2É¥XÛJ«ú¿ÏN€°Ri‘âDw¾÷Ş=Ÿg1ƒV³İz×`	1ét8º»üv3‡ı‹Áxp?š^‘†Î0o'Iƒñh‘Ç'aÈ¹ªé2óæ'„¨D›©4ŒE¡÷gü]8A$˜vtà>ì>~€[‘uÈK½¹C®¦¼ÈÕ´(Ñtv§OW!gÊ²á·Æ|.W8(ğ*Bè‚U*pì2©%jÙ^Lí×hMº Ye^Ş ü¾È³ù+Î½Cö‡¨¬CÑŞâ!¾Á]ï–"f	‹¨b‚	û×aÿV‚Å°ï®'ä& ÑS°Ñ“µ5^°LQáûô¹mĞïÎlp¤n£6oç…{+ı75[h`æp ö®[‘Z¬²…Á0„`®kXÍã;Ûp ÷óêFs„$Å8Şœ¤*šƒ S\!WácBó…Ê€qøÔ†S^P"Î•’ç¾_…Ç1OfbİöDúèk%ùÒ_1,”,òä\~•,î¶ZÍÖç=†¿ÓåË6ÑÂõNë¾&U[`â&íXÒe§û¶í*}à9C·[5®±õ\Ïâm®ƒB‹šõ?cùğ/¼ë!ea=+Góşkê‹¼®X´gÖ^5ø¯ÀZÕLl­Ÿ4ë	$*@¡
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/5c/cd0befe19e0198491acc2b0ff64236dbed04a1 squashfs-tools-patched/.git/objects/5c/cd0befe19e0198491acc2b0ff64236dbed04a1
--- squashfs-tools/.git/objects/5c/cd0befe19e0198491acc2b0ff64236dbed04a1	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/5c/cd0befe19e0198491acc2b0ff64236dbed04a1	2022-01-01 15:09:15.637172590 +0800
@@ -0,0 +1,15 @@
+x[ySGß¿ù¤âŒÂ’°cR\aU›Bòñn¹t0ËhF«™âï¾¿÷^Ÿ£A&K•Aê~ıî«Ó|¬:/^¿ìşåùæ†Rg¿ÏFƒrTÆÇñ$ŸÆÛûõü@É÷…ŠxV}E’gLˆÁñ/êÅv·£òùı"¹¾)U4i¨Îîîn«Ûn¿Tıë|¡.FŸÓü³Šh¤Õ~Õj¿&7e9óüùİİİö­ß“ùv¾¸~¾ácN
+•&“8+â©ZfÓx¡Ê»Üo Úi¨ÓwÔY\˜=³x1JÕÅrŒuêLÖªˆAN/Îˆj·^g³<[:€~©fñ(+Ty3*Õ}¾T“Q¦Š8'¥Ê³XåW˜Š‹8`F²)iå*OÓüN-–i\$h!¶I¸ÁÅÉQÿàLüãèäbØÿÄğ´´¥FD:V£eyİ15(â–ÙRñoódMïÕ<^Ì’²`ËœH0a2¥˜Äºé}6šé¯i’İà‚±¨Óãüï€â†"	$IVÆ‹«ÑÄpÊWI«»Ü,KU,Çÿ"’ìZjX‡¸ó° ÇL‹+è•2FØVÙ½šåÓä
+ì•p(@.Ôh:Mä¸`~4é-u“ßÅğ=hf±3˜•–¦º½±	'ú.É&é<}[uî›o1;¯Xòöİr6Ìç‡¤Çî7Œ±¿Òe¬¢èC?+wºzûÖo„H€áH‡y9J]§ãĞ³*²¸‚qZÕpkÀÙyş9f\/±Ë£O—'ÇŸÿ9<QÑæáòê*^4›;€è¿ëÅ"{ªİS—£ì:VøøÛÏú§§ş%?±UÒƒÏ.¢„ z*QoÕKüJÌ³U÷TÄ¡€×õ‡òYè©/_æŞ½¿<?8ëÿz¢’+	e(Î(”êÁ·{êuïIşôÑæbÂ’ê©qì 4Áı}6ÕªzÕ¦ÚÄjÈæD(Yëÿa>E"´d´ê˜@«&èÜ¸U‹gJ6†ëYsZ¬f±¶ö„¶V‚ûJ,*|èCR‹J8=~:ì»Ñ|KÍ’-uĞÆ?$E§)±´e€´×(üyOuzX ª8E:«@«	N ßÄ¢~ÓüûBÉ¢†a„Tå­§¶T¯¡Âg\ö]q Şá"Öõ(š/òq±¥²åìy ÅGäÀ†ïÃ°½íÑ,À$I4ÍÉ‘/€BmÎ1ÌÈ €VƒÄ7cı¢înğ¢V+Qß & BC8É&¼–&áÿV”O.òÜç£ß”—Qd‚Ë(O¹$àà½ ¾=‹3,9Ëï—ÚqìÄà~6ÎÓÂ¤;Nœ;kDçÉ´&jé+ˆşŠÏ˜^WY¢™ZTf‰'˜=ºÉQUÛ¢±c]ÙÏäoC#Ştwe|ó<Á5§U½S§ÛF€xåõ„gız£!·ˆ7¹Ì‚OŒ­iz
+j¨ŠÓˆc¨N×ªƒ‘%¥øÑó1-Jxœ>º¢ÀÑN²i8×	½ğçeš'E9Ê¨Ä‹F·+«É:PMÀğÒ¼dó¿
+f ë0§ij"ø}0{&×¯òXáÁáhœÆƒäwZ[-´Oı|TNnÎ“„T×aï#–0áyQ¿¸Œç*2Ú„š/]ÂÁ(qƒõŒÏOÛ´”0Àj°¦¬s ô:0ø±_Ö>ËÑJiHòç:ºZóL–<]´Á< ƒŠ½´b5§ceO=lì4*a3ô¥–Zq#§9Ğ¢z‹­„`‚Ğ(Ôï í'¡ˆ¯^ú,A×‡–?ò—UÑ^)‰¤N››O‡ƒ“O´*ƒ2ŸcO0OĞÌ^/ãÃ§ßÅÔç›êö2şï2YÄÓ~&ı{,Wœ1$Bƒ¾Ğ h¨æè‘Ç÷èªÔ]¾(JìŠøÕK•ÂØ1Ffì¶ÔSÛ¡©Êm‚»¥®5 7[bÙ8VéhqMû ìIê£õİ4ø({
+^(ÄdÃ^Æ}|¥"C—¾¾ˆF«z=VCºjÓ7×j$Š@vS’.¬ÒÃ=Q¦51t)MÕ}…_»õ½¥‹kP.âÑìï£âç$KŠ¨©½…r°Am+)Hš8öBeÑºï(ø˜C<£c˜`›QbY@>ìW&7£…>•£-n…d¢ÆÆÂ–vÃÔ6šdv¡‹Ë÷'—ÃşÉ€‰¶—Ô)”ËE& —'ƒgÃOÇÃƒO'——ï/	£“Nd^õíì2·Fcª|Iÿ…OBK|Óş1fÄníÏÇ „¯‚}‹Ólnijq˜r£A,­àK©…òñíú˜Òy€iWãp¤Ò‰–›Õ©?TÕ½ˆg#ìNáå`&°Dƒ%kÃ[Ö¡Vß«]aŞf=8ÄÏ±ÉañKæ ¾7ØM*jò°_â²gª,>N°%Î³Ñâ^ç-[ÃÛZ½­¯G ïlíWÖÓCo<Å–ì%„JòïíD±]ÛDÄˆä•N
+ª=ja¿Fše†©ñİ÷¿ĞÔ—¨ Œ»ˆWpÈé®Ë¥Úü\lñTmÈ%™Äõ–"Mwô×|Û”¯‹İ	N}QàjÇ!ğ‘èï,Ä=vıH%Ì.R½Äº(Úî’?Ã¼!±õœŞÓ}ì‘7T˜’Ê % ùBˆhP4Ü4±ÜC`‡’ı€"ŒmzRÒÉ†ENëÙ½¡€lã‚ù ˆ‚ú.M›@¤-Îu86úœäËâµÉ“lÏÛz!
+hLDÛ yÇëÈX×ëÊØ?¶ÃYLÌšåwÔrP®pjœëñ|TÜbJ7ŸZÃ·çcìy[âZı©Ôx \»2¥İ²^IZádSÁNŒUP-ó”oĞZx¬^ãˆt”Š„âÔ|÷`Lå<Kp§q™ÖšÇêüdj3…]aRG€Ú’:5$ln”yíBÇ»ÆXOe<›;˜/`FØ,ªÆbl°5#@ğeÌNQ*bÅîISSÃ­f”h(b€Â)IÄ×9ìÓØĞûy'Eø Zy:¹…°pu­×a(¿cÎøUqŞÅÔ&eJR;|Z€„ÌyLí«¶zöÌyÚpVš9Q,Wö£ËÍ&qFêç¨Ù±êLâæ„~«%°_XÄ¾CK'{!erlo~ÏcÛÔ!Ì›ê§Gºõ&˜ÒAÅƒÌbäÕAá¨„wÊhÇu}‰){Ü^õ‡ÜWqÅC479¹za@o8Õhó½Zz½ £LHÛ•=Úşö¸cã:Gê´ˆ?”	ñ‡’Ÿv-9|çCVCßÏ º ×DªÆÎÛ¤oÂ¼ÄmÍÄGçøì×ÈtÄ¹…D»N¿B_T.9!h@¶h¶ÈOuš~«tÉtn­Õ9ç$î(w-ÖˆĞ!#t¬ˆØOƒ~1‰v&œ”µ¶6Äï¤'0È’¬Şğr¹‘„Ñlº)À*t=nÀgÇ2˜Ñt"¡Cj
+3F§›(¿Œ†9ÌÖ:$&¬²û?e%Ñ"³r"ka¿cB‡jÚ˜ü…wäœ²¡Ë\4{}¡Ş-o1’Rİ.LDÏ†“×†±¤èÌyëšÎ'lˆ(;TÃÕ!«¬S"W ñÙ°"0ƒ4Sÿw®6& N5AÇà£ùz}Æ†Ò¸f˜œmòd2kEñûM˜˜MĞ)5ÆŞùVÄ–T@N­£±ê…;‰äA?°³šn	Zèt ÷ BŞ1×”-ÎhH4•MõÌÂQûçÔñ€yÇ#«{§uÒÉº£(sP(CL2àpÕk>v›ıû»„w`†	¯…ÅgÓÔ˜?Z‰¾„ÏpÁË§PˆK‘
+VŠkp´ ìQV¢×UÌáG+Bì-‚Ã4ÁÁ¯1¨X…LEjçÓÈÓ İ¨@GÚ¥"0¤kıjÊ& BôHÚ¦iËA@í#VÙ0¤›64Á;şEN‰iRÙëXfğg!¹¯²á´ÜtËé)~Öş­ÓÆ…4”ähøƒ0şÒê¦Gñ¸!Ü©Éâ-†C"-ä{!‰7È;m4fs!­‹/Ä5‘ ^%HƒÒ=XÁ¼ø„ÂœtUyœ4Ua‹†pà§+ç.¯f ¾rû(ŒJ¥–úMÏ[Ï=ıÊ\i¨³ÕÔœ;¯vÑ|rCào(Z¼†Šx×ùH½hØM¶m¸øÒÔê´ÑvŒ
+Lğ`ø•‹ÚyJB@~³ÄÆÌ6gá&hıš=ÙdÎK¾¬`ô†àJjôãÏ"ÅE°”Û\êh©¿5˜xPw»6•ò  ÒêÂ5ÀFcAÃ¡ÍÕI˜yõİ€¡j\Ò¶NµüW”`4—9p:1ˆñÎF?  Ém0=ØOÈ£Şõ¨UöF‹Œ¦
+'Üp¢C}»„ƒŒ8Yx„	_Fò×;îy|ƒ’Û+{½wÿ’ß5§|á	µş3ñ+«òn*“¢©=K¢0$0VQ'Ù…“t<O£UP!œÍ%ŠR"˜ŸX×Â5µA¼Ó²€x¥Ä¬ãìié‰Ö·"IÉ"GŠ”à¥*™~zZxĞ–I¶ôâÃ/XŞŞEÀı8ñ"e%}$&–+È|TÚÓßøîn£±†F5Òñ8û—¡6àWbmmLÆ$ãÎé¤ù\§ø(‰IV3Ë)]¯Èòhæ¨óŒ³’å#;Î!D&/ßÓ´/UÅn4íÛ¾¯3Í‡úóJ M>Rvh"dƒÊÒW, Õ²ÄèˆÛ°á¼Ã`UFş®¦¥×•´äùŞ¥»­6˜^§(jÚqşDua÷ÅWEì5¹~/ÇgÒŒ½‰7­ú‘ŒÁØ³Oª`çˆ«aÂ:2ú±Œ©U´{©<’ñ1ÿ@àeÄÃp¸Ô­4j©¸ÔC]õ•(y
+ïò(ğ`/æ-U]×:®I•Z½®ôÃ ]™ANbòb«-§–¼Ü
+á´{8ıit>”Ó`E‡JV¯ÇzÉè}’OmïHOZ°ù4y=€OÂ	ä>­#ñC@	¥4pn|£=k_|O†ğõ&t¬ó™ã<prJ> Î ™uó^@A¦g3ªi1ÑˆoCtB	Iı¤ˆß7‚:œÂ ßò¨toißæ8.ÖklËt¥f%®ú…W//rô(åŞVŞ˜…®¦Û1^ÇLäa¶="C¯Öñ(Ù|uñ–Ø÷âÏ @ûœAÕ‡j­1M†Y?§52g?÷²‰¶5`ÚpöıEÎQ¿ƒYz:Jä7OÕ(@‰t'%ÄÖC`x<v®Nñ¥ñ>lpIXX•Sš!ò•6–±óøZ$€*8¡¡÷ıÂŞŒ˜ûaZÔ0á««ZÒõil«ªJİrzvbúñ]£áÄcø‡j _§§EÓ0G¯ŒÅ¦^Õ§]·.Æ³$mïŞQcGº#ï¼é-µQzÅ¼î”èKfî‚¾ª{·È}òöåDŒÙ€’TÿäeÍ¦Ì"+H›ßˆÚú=-õŒ‡Iùƒ<›+øâÓü#y AğôCYö£;ÕšÛeG>8Õ¦…F [t½¸=wKÍrâ9ß·}#_Ùáá.¡¢Ÿ'm¢	Û´é‹!Ó‰Ê% „µjÀÄ%³†»À ! ¿Q&rîÍ¤§s½ñ‚á PÇåEÍşšä 8$Ş!›`Í¾Ú?ªVöÔÀS÷ÓâinIğè Ù®êw²P³»AdŞw”¾(Æ(Æ½pÉ*Kdı¦şcK6š»_âÿw€4óø])Àƒ··o_õQqÎlÂÔ¯áÜÕZÍ%‰ã Øé«OhšK	Á–Ô/­ä•• 9¶ï=Ø®¡ñˆkZgßç ¡‰§ÈŞA¡]•kÎ”\¹ˆ¢È ½”Q@I¹ å«wŒr1`i¶K—ÔåíˆİÑ£¼õ¥QtWü\‹ÛK‡V¿B
+ë»ò8Ó+YØaêŸåˆÜD¤ÆèÆ—ÿ|Ş‘)
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/5d/5d06d7b447b75174e992e3ace3210c4097fd47 squashfs-tools-patched/.git/objects/5d/5d06d7b447b75174e992e3ace3210c4097fd47
--- squashfs-tools/.git/objects/5d/5d06d7b447b75174e992e3ace3210c4097fd47	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/5d/5d06d7b447b75174e992e3ace3210c4097fd47	2022-01-01 15:09:15.593172588 +0800
@@ -0,0 +1,13 @@
+xXmoÛF¾ÏüéI²%'nœÎàÈN£«“•Ã”¸”!¹,¹´ìÚßŞgfw)2‘{1[Ú—Ùyyæ™Ù]ffI'OŸüãù:û¸˜Oft®V&Q=>;&{¢h·¼¬Ì­NTMÏ¿]~úpF	ï×ÅzÚYt«ªZ›‚tMµÎËL§Z%FKSY|M+“Óìà€øüi‰4ìHT7™¥¸Hh­
+UÅ–äe¥jš+»1	™*Pjª<¶‘.èùä“.{¡êºŠsn·ÛéóÉ]NMµMINjÙèõ†¢î	Ulµ‘ó¡ò=¥qmÅÌVh]ÎgÁe]—Â˜2®,«j7Ê»8ÿyêLÅ'vĞ¶ÒÖªB+³xÏÀ^_6ËL¯(1yŒ‘å=Í×¦¢_ãÛÌÜBƒw:Su8¾7VÆ)1Ñ„.Í–2u«2öYˆ]ÜÙ*^Y^5¡÷ìˆ}«Ş«ñ¢¦­×áì¢¶qakHš2Ó ‰×ÄÕj£o™R€/±*÷‹Ü’ÚVÍÊ6,f?ÀÈéŠ÷CÀ•‚ËãÈYq,
+øû=L¸2t]«ÍQôÓPŞp€Ì¶ÈLœx „àÊz €ëxÓ*.hU©Øªº[m7pÒTİAõ
+ŸbşxE>Slc3ÇÓÍiRÑ$¿ÃÿÇéòõñÉIÍSºÇ)›.Xê5M¾D–
+)Çcì=t(¡çÅ…â´`´)øí"bm›˜ ²ûIm2õ)”û?úåõë“'Ç?£(«œÈTfØÅ|xŒœUŞ‘[er4ïKîäefVŸë)-i+z×dM'IÈÙ=En’´c¦”8Á1@İ¬6ÁÉ+k+A¯Ù[«¦ªTa[òpißç® úyğ7ßĞ	Í-	bmœQã\i°Ğ_äï%Âño¤¨ºÒ˜Pf¿Í ãæ910†ÛNh§şº)™ôü9B?Ìn3SŞÓ°0]Ö‘ã7#ñíì_Cü9fáÄ„"û@O,´Òk]€%¯¯ŞM<£ëB3¥:e
+Ø#±áÉ{æ .ºÚ(`+ëx^¢¾dwÒ†5„JDÑu|2¡ô£ñMò~|Xh¼V§
+ş¢W`åzC¯|²Ü°=o¢èÕÌÏ0ö±Ş™Ø\;`ù˜ÏNéR#«à10-{,ˆÃ¬=ukL®éûîttá’á”°VYØŒü¢’ë}¢e–Yƒ÷¨ŞŸŞPT¸@8Ê«Ëœ‚L
+°OMÆÔëùL¼B¹l?àÚ(ú rƒÚgÈTG¡~ı#%ËËa¹€ÉÖ ~²±4&±<Á99ÀCEÇ#bªv_œ¼õj£r%ÅÇm…ø j|k@Ri¯sx]”×:• +Ï"0naU	o éM Uò·rf3Xp,C¬ÕV¸·AX˜Åİ¸ÒñÜËÑÅÂ"õs©7İ_Gcâ1Pæ—Æ|‡µŒ*E‰¦ñdÌ_Îª‹;J–/»ˆ ò¥$¶ñ2†¦m¹sÛçØÎ®p1šçe‚í>iS¬¸ü9×HÀ1Ø·Ÿ£äe<´å·HÂÁ\!f4«V?I«cG/)ÎpÔ…¶:ÎÀ‰òÛYÂ<ğ£—á¼q3ÇÒáÉòa	É²/ài_À/hXÀa¤CúApÌ¸ŸÙŞ«ÆıEğu&CKÕjÎsu˜¤Aº£qÇüém„!Ér0Ô4•K‰æ!1†À…¢ú…ÄQó ÕiĞx7°íp»Ê€÷ÓJq²µáhQs—çä²}=¹ÑÉÈ±˜S©8O˜˜ä˜’9%ä½„Çw¢ÿÉo¢ëya<&ıÒçÌjzM_’¦W€ôÿ>69—Äc#¿4ˆ şyr3hœb«Û#è`'š¨¬8épğèÉã„èQıßvˆ±Q:yÃuöğï(èó‡öå­|Ğ.ÉËŸn~»X\_^àÆïŠœÙ™ëEÏ}&"gÇÀ—Ìõ3| ‚¶‹ıåıÄ4=/uwÈƒòÃ<Á#Ìh<ír²İ1nëíéîètQaãÛ{t¢ã±iìÛ&MUÕ;ª4Â=Œ÷ÎG¬-KKYOÃ¯ğÙÂs¨áëK»3œóatóRxq_¸á6ç%¤i­ìNE‘`d@3·2ª*õ{£+îkÙI¨»Ó÷¨Å
+ıZ™®z*9dµDŸàã½Û[·ûĞ‚uœQ âê{si·áQ®4îjG(}Š›à¢mR¥šqû]+¤.îe`òÛ8kÁR·q/½Õ¦A€ã9ëÈÕ5{èµÿíeeÛ	¸·ëŠíËFÏJã/àšz;ª–à@},/úr!.]ğ-JïÌä–µ.qÙ {¥¨jİY0_9äVÅTÕU†7£ÖLßarØ*Ê¾}Ö§rY TŞÛ#¼-’eX(µG¹Üï´-ŒG+È)n¤;`Nx êwş­¬†»KÁ¥§„p=e»øÚÙ­.˜ö½”´'EÀ
+ ÍŠøúíø™Àÿè„PRuøİõ9rBÛ:í:4›"äBÇûÎ
+yĞ^:EiÑ»zÙN#†Ÿò-â1ÉÔÉEa”sÌ/¿™ê]}høbÏ’›ë3îªŒ­½ÒŞqş3ÉÓ0tbxl(Öv3B¹¬vJ¥`t÷>úÙ] C{…ö.<ëïcûråŸt ¤?¿#Pí™™]Jt ƒòˆ§iŸÃÖèkÒöB§8÷·h¿“)7dÄ½g™ ‚oEH¯ÍÉÙGON}E‚–)£¨×ã'FÕÅ?ñ°â;ğ¶Í6‚aoË	µE{ÄÂ-ú*G…B­_5ä®ŠWAaúH°ºT ß
+²Ì_9R|™á7œÚõè\¥ºØ=kEÑ
+ûÙåå/³›ó‹·×?	fñBˆEüò O2UmñÅµ1QËfíÌ;~A(yè1][/—)¹=l¬-OzCÑ¾Á£:ùÌÏ<Ù³îvïVü)¾ËÆ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/5d/f4e4386750f4e33a53eab1675e4b056f97b723 squashfs-tools-patched/.git/objects/5d/f4e4386750f4e33a53eab1675e4b056f97b723
--- squashfs-tools/.git/objects/5d/f4e4386750f4e33a53eab1675e4b056f97b723	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/5d/f4e4386750f4e33a53eab1675e4b056f97b723	2022-01-01 15:09:15.637172590 +0800
@@ -0,0 +1,12 @@
+x•XmO9¾Ïû+¦©î†MJ­ $JCTÕ•"´›8‰E²y½p”ö¿ßÌØŞ—æîP+ˆ_ÆÏ<3óxœxšÆğ¦ÓÙùíu¼“ï³èRGZ\‰L·ı‚h>ŸÊA¤ešÀ(Upòõô >ˆA:
+|^÷Be8xŞÕDf0’SJj-ˆ’!e¦•Œs-† S˜ç1š„a:‹dñ#Ñğyt?MïÛhj)éÈœzùálµ»oÁïnl¼iml·6º×|íy/e2˜æC»™Ê´=Ù¯Me¼8¦d2¦±ra£ğß¸×4<o&HÂ`)hŞF‰¾ÑğTdY4°‚$Õ pd2Ï5»ßè=ßùK¶SÒ\¯Ú|0¦…eû#;31KÕ#í½Š‘LÜ'ïóÑH¨Kù]€ßİ]è¼	Êù³\/]àåI&Ç	Æ‹]ß:C×5“7½g‹×wÅŸt:.õ2ü}«áô‘H<Â,ñOúĞ¤„	á>•Ch#…`WÒ¯ÀxB~u®0‰gß¬é˜e!ôà§çÉ¤jı NÄàîŸâWl%ª öö^yâ9æ’î+•*ß$JÌœ‡PM™É™À{B²9mùf!¬ÖÇT$ösBã[ÂßA#èı—Î<-¶\uz¥„êlÓ² ">Ã<fùh€«ÌàC5ø" Ïè‡6»­XjÌn-ÆXéTÂì™ÊŞnU'Y"ˆ2¦¨`ğç¯4‡Ö‰Âü¼çL§„øC'!È<âô0M^iH&Üşl}|Y>Ÿ§Jc•†Æ
+J­$Cìóq¢ßnQÙ1gH!²ÙÏWÎ@¶€0C½ Ş½Ùu»±7ˆ8²Y@œÂè?<DR÷Ï.q¸Ó£1$ª2Ä(ôD(¨]I
+yBp†£dF#0ÁFCÚY
+C+¦r:ek@'ø}NT¾K)?ƒÓHİ	ĞşªI3IhğIrƒ€â™Î«CÒ5«ØF¯3ù£—úUQŒ4BgkÅXãFÌFm®­dİ±YÀôÕÕa®Ò¹ÀP‰ìšn‡Ûó‹³óşÅÕqÿòöòøk+€‚t…Èî#9uÈêfšÒŠ•™&GFàkéÈ7¡	`¶HŠ$¯ÔQÚàëÉ1Jù”!_J	ÌTc‚ê	`àH„ÌÅR:ÀùûK‚Î‹R
+yq%Uš1Ê„°Ë¡ X…{ñj©ƒ|Ftƒnd_2a ‘œíÈõu–Lf©ÎpL‘0´®òc-¡cáşŠè%€é^`=ı}td†J…p• „Ö†Š:\ßi?Æ`ï’sMØfÓL°Å®Ñ%»p[Í{Q9æ¦Eš”…kÅ”„e¹î¯qµË‘Êp‡|Æb)D×ÈEÿòóÉÕíÙ§UYÑ8Fı0É‹%I2P`ïªd‚S¹û‡ô4ƒ;Ã°?
+ıg>ãÏA¶ÀxkÀDsÙUc8WÁä\XhPØr^³eU¢ıA¨ŸŒÔ#É]¨Ö¾a´œvBaÿÄÁ_²È¯çyAÀb„N¶iUb¬\€2§b­)!üÂbœÙİ++d+€Šù_æ¤¹$Šœ+óM'RÛÀ9N‡)n4¨œ¬b||Ë„TKÅ'[ï(àØÊlÂéWª/¯;§Êõ–Íî&Õs—ÜÚš«Us;"I`ÆŒ‰}7íjÑ8ãöª.­·Á3ª‹|aĞÅ”ªë;µ-{Ò°Şçq©Ü'åbs<E #Z#…
+¨8˜ ™¥æ&-#bƒa»’S{máío®·ÖdRÄ \8¾=sí6‡‰‰ÁÅÕˆ•«ëà,JUD
+k(~bOÊ–û³¢Äv[IvÔ¤¢Ÿ¿¿%š„‚,ã&öŒD@ŒrsWåÊ1ÓÚC7çÌ
+Ç  ?›dƒ„İ¤^Ó`çŠ¢™?ü?Øİ×x¡O´%´:ã2Í°Ğ°<U_…ÏTº¤›…×5¿MÆª¬X»5l¢¢YªŒVË0c‡ Ys[{}Ñ¯MóÃ]Š¡§ºƒÅ’Jn!=¢£€8­–,QÏ¸)màÇW¤\ÃœJÎ…gŒ,äÕÍÃ„¢è×.†`ÙI@ƒVM0h®"«¥ürˆ*3˜pVpíãW{Şt±tñ‘ÏÔûÀêË+Â‘ëãG¼{â˜÷wÍÔŞDnĞvÓŒÕ½Û–Yí‹şšâ0?*Lş €ÎÎÎN‹¾¸¨~İP~•%ÉnSô¬#Ø#u‰0÷q6)R&Î«À|¦ï'ŞL±õÇn˜ŸÈmú ×˜TG7î¸âşâ*àF©`e„}â3d°¡â¢[T(‘ÌBõß)T‡âKıª³û€_ç8ï,LŒBD—@<ÄëEQ,+eQx´
+PÅBÕ‡A0fwÓX(¨—$—¸ˆ@;|¥Ó4nÂd°2†xäéûoÙkåœÁ*»ŞŞØ¸Ab°˜’„”>ŞuÙEÎÂìqİÈg'
+ŠlıIt$®
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/5e/336b355273307fbe11eb8aca09ff00612cd13b squashfs-tools-patched/.git/objects/5e/336b355273307fbe11eb8aca09ff00612cd13b
--- squashfs-tools/.git/objects/5e/336b355273307fbe11eb8aca09ff00612cd13b	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/5e/336b355273307fbe11eb8aca09ff00612cd13b	2022-01-01 15:09:15.661172591 +0800
@@ -0,0 +1,6 @@
+x¥W{oÛ6ß¿ö§¸z@ ¸n'†Ám17pRcnø"Øƒ–(‹‹L:$•ÌX÷İwGJ¶ä8éÚm*Şû~¼3OÕ^wNO~h7ëĞ„3Í™åÀÀÜeÌ$±X¤Ü¬åË#€I"à_‰X$éBµ\in 5#P2]“’eµZkT²„‡prÜ9mÑÏ×Ä»NDšŠU¶H¸†7+OøµˆâHéÅQvû.·åÂXiµĞlIáÄšs0*¶Ló.¬U!“Q$ŒÕbaJÂ“Q[ir¸T‘ˆ×DËd„mÂÁr½4 bw¸¸œÂ—\³®³y*BŠKÃIXÑ$˜÷|í4Î)†qœ+4Ì¬P²\ y÷\<ÃI‹L(³ªµ"ÁCŒo)Â¿‘=z"ßmZéÜ'j…)$h“z@8aÎ!3<ÎRç1€OƒÉ‡«éz—7ğ©7õ.'7]¶‰B.¿çŞ”X®R‰!˜šI»FL(âıÑÙTé½“Êà|0¹ìÇp~5‚\÷F“ÁÙtØÁõtt}5îcÅŒLŸ<)Ähl©4‡ˆ[&RS$~ƒ7i0º4‚„İs¼Ñ‹{Œaå­(2—üÓ–É/K•\¸4Q«%/œ.ˆ¤²-xĞÄ*g«r¤¾½ÊüôL8ÂÃá:e!‡W0ÎH÷ôô¸ï•±J¶àcO:Î«ÎéñÏ-˜{E:Ø)³<
+Ñn»^ÿQÈ0Í"õnjŸ£ä]‰ˆ]×*´i•œI,ê]Q±lGÔ­Xòª6ª
+U%-™MªbØp•h¸ÖrGÅR1¯ŠEBsi«4ÉzÅÍc²±Ì	oÓn„,L¸yu—ñÿÃ&³¨×(	Caï0–·«ª€¡+]%¹À¹5g;!cÌ²—ñXHç½á¸Ç›ód4íC§^çc£JÈonfİüãzæo2/ªíqÉ„ÌyİÇºMt†¯¶òÍX³Åì	²÷±±ƒ3.-8Ä iU®Æ[îàª[ûo2ê¿€óŸe×áw³­1Š|#q¯MzWÆ±	7!-5ÙTÚtëuºYœšDÇxÙÊbã¾…ãnÁ+cç,n ª;?ÍÜ‘£À“°.ëÿÔkF,·;~,™¹mJ£}uë5ç´E,„D±gíåƒƒ\':‹¢2µãÁÅàròwÒ}|†=:Ä.RËİhwö~xuö[Šğ«5êµÜy<èfG±=0±×«9¹šˆƒ ùğöm.|şL¹æ!À‹îŞj­?]‚Æ ¸á#.‹iêb!p”@ƒ¨ÕÛ=şâÙ@ÿ°óç‘I`,š¦w8½Z*Å‚5@M„(Õj¡’VÈŒÓá_¡ÖnÂ-m/ª:œÇ4ÛJßº%M'||ÈM	ÒE°°J=£Òãk\º‹®K6OùŒz›JÖ»‰…6Ö;£õO¶7N¼İâñ-ò4ğy:Ã…À_JÈ*»—Óá°ğ…q‘ 	qš™Ä-šÂ¡Â¥ç›?Ï70‡€y…;Ùuá‘WŸ`{$İ®QÊÁá”fÎQ°E,¸ò¶Yï1è Å…×¬ àM¹³A¼|yˆ^6%£SXÊñù]üé ú
+CÅÇf¾
+Ê|á‹-–¸ˆAê±ô¸Ò{–¹íSù"¶å)ºàgúF İbğñ­ WMüo€ÛÅå´g¥\Çzt}pÕöX—ºÚ?R+…»Ù;Ûâ%…ıÀ–M9$‹fÌë‘øOöj‰YÍ~·IË^p¤mÊª@b[_ëá=Éït-)ïOü9³ßSREJßÙÀŞî»ë´
+sQ'•XÂºıL’¹®òÏvúİ&i>*}™ù'OÁùb{ñıhWMí+4/ñd©UØe&£ŞY?hôpÙùıÒŠ‹&å‘_›˜iå©…wd½(tM!…•^IDàG…LˆØà.<¨Êø0ZÅÖ§Ø£MhèÓfø²İÑé¢ïÿ ¶E
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/5e/5469592db723b71bc7c8632dfd09652539d42e squashfs-tools-patched/.git/objects/5e/5469592db723b71bc7c8632dfd09652539d42e
--- squashfs-tools/.git/objects/5e/5469592db723b71bc7c8632dfd09652539d42e	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/5e/5469592db723b71bc7c8632dfd09652539d42e	2022-01-01 15:09:15.601172588 +0800
@@ -0,0 +1,4 @@
+xÅ–m‹Ú@Çû:Ÿb¸‚$V{›ª­pJ_D¯¯Šr×åZïúÙ;³‰ÉI¥p“™İùıgw±Ş, á‡ìÍuúÉüıêulâ}”¤Q²…»M“Ñt ËÍ*rÆZuŸÕYŸ`t¶ñ|¿Şìñm¼[¬ùV›ŸsCõÚqŞòx¹Ş­"¸¢À?®gÊG·p3ùò]Íàö¥TWót^iİ¢O¾â´ ¨SˆbœÇ÷sp@9ò6şåwàÒè@èá;@¥»$FVa©w!®ğ®-úK‹r9tÑ8tºÂ‘ş¢ƒs¡(8¥öĞ˜A<~îËy¤èLWÑ6¥Ğô¨ä·É§p]ùê™HÁ:ğ?xğTbõ…µ%Œf›y:8Eí`Êş@YÚı‘ P>8;ÇEƒÎ€–ÃõÀh½TÆÆŸ¢×qorÃÌÜ"h¯—™Üdˆ‹ÂµR9=W¹Ñõ\Æ—Wğkİ˜u³;ûŒÙÒO•˜·çS·—ƒJğu
+ª€˜9ˆÍ¦rYªp;*Õë-è2¨T„Òú!}y¿ÖYÚˆEU
+MOPùÁËx³‹u!vı¼—ÌTY¥+cË6¤ñ	,ÓÊªÑö55—@ÛL®’2ùfÉÅŠ1¡^ƒ:î¨édÙJÃ/úQ‡Ñ"$rà&¾?#=«lÔÍT—8¡œñxp	áœRËQV*˜A¯Ò‰ NõÑF¿TÄV¦[e!ÑÀ‘ˆuæH-PèÆmy.xÉö‡¾à$âşiX\TDuvä
+ùŠ^Ÿv™şë²Ç0Ï"íSöLú¥21ê(92ÔU”´Qtì6tO0¡å©+Î9i:Áøt|3ùOÊU]ğÌ9ëÒqæraØh¹!¾U“0Å?Ãöc›jnhsxz(Æ¬òÄ	¨Oxòˆ•ÿU%bZd‰(T¦úÈ8ã6tæ-ˆ›,Í¦©¨$„š‹Ëèòdp°[UÀ÷ds/òP>Øj°¾tK£¾.¿Ò7ª½|Ú_¦J­-¬HAÙ£Jû•]Æş]ƒú`¢h/Ëí/¬«V
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/5e/f72270f72986e27fbe07a7a34c5ab685d83d18 squashfs-tools-patched/.git/objects/5e/f72270f72986e27fbe07a7a34c5ab685d83d18
--- squashfs-tools/.git/objects/5e/f72270f72986e27fbe07a7a34c5ab685d83d18	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/5e/f72270f72986e27fbe07a7a34c5ab685d83d18	2022-01-01 15:10:59.989176882 +0800
@@ -0,0 +1,2 @@
+x•ÎM
+1@a×=E÷¢$ı›D¼JšIµ0u¤TŞ^Áíƒï­Õ¡ºÃè"º ÅÂ1Iˆ%;çmğ˜‘¹¸E‚$K.0’zQ—çĞ™®+ÀI[c3yIÈ²£%ˆ)ÁGEïñØ»îõ#ı´U}Ùê·2o÷Fu;óŞ®ƒC0>é#D 5ëüò¿TT&S?°²Bh
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/5f/78415f1b6ca52951a0215a9c05b4df36950b04 squashfs-tools-patched/.git/objects/5f/78415f1b6ca52951a0215a9c05b4df36950b04
--- squashfs-tools/.git/objects/5f/78415f1b6ca52951a0215a9c05b4df36950b04	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/5f/78415f1b6ca52951a0215a9c05b4df36950b04	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1,3 @@
+xmTßOÛ0ŞsşŠSy¨-…jêÄ 1-Ò&!Ê¤m/•ã8ÄZbw¶ÓBÿú}ç¤mô¡JÎw¾ïÇ]òÚæt1ÿ¸øpÒbw÷œaZÑdBı‹6OT:Ûà˜„“•Ş¨är6û4¹¸˜\ÎéŠ²'ëè^lj»ÁÛ}›×ZRa¡¥çIr¢KS¨’V«ÅïÕİÏÇ‡ëÛÇÕ×ä1mÔÿa¤Y·…¢Ñb—™i5J’ó4!ZîÑ‘êPz*u­:l{`ÈKmnÚ²TšÖÊÍğWZ‡\í‘¢®	ï¤„¬È¨í×4Aı€¶Ä¹ºBŒ(+éÅ¶HVK…’¶Y;å=5|q¨„!6iS%"^™"–‡JyEQ·
+°YMo´m}DÓõ ö¼¶òO¹Ç±nHçmd©w*¦ı4î'­ñº óÑQ…	n&dKò¶ÖÅ6Ó”ÛÓ'í»ó®“´ÕP
+~8% ÿHZ[p[C‹)ÚG½>-Ò`rF@âÖÈ€Ô£¸¡Q.–cŞÃÚ§E^+o:h@/ÇÇGf}Æ¤|£†1ƒüám_×Ãûâ”N†0Ì	Ã\Iw>o…	ìsY·¾ê`Næå\î®İªŸ“ÓØ„…tËwÏ”y'aöÍZØ¹°¡T÷OİáÌ„ùeœ˜ÎqFØEÍ3À†ÅGg>è+†SÒĞ°b`1ïgÜ¼Ğ?ÎÄ¸/#.\[màÓ<Bùu‹íé6é+c¥˜ş­Å×ïØğ³}WVCAÙ¦Ø-ú[8'.ŞëË{‡ÊÖ!F6ãwbòş:õ·Õ˜¢Hü¹9ÌË;°Ğ½³K«Š13xö¿[ÁQfNéqïìëƒGÕ¬Ï>ã[‡…×eòCL²}
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/5f/f1f6c5b555efadf43c6d86505bead543154c08 squashfs-tools-patched/.git/objects/5f/f1f6c5b555efadf43c6d86505bead543154c08
--- squashfs-tools/.git/objects/5f/f1f6c5b555efadf43c6d86505bead543154c08	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/5f/f1f6c5b555efadf43c6d86505bead543154c08	2022-01-01 15:09:40.213173601 +0800
@@ -0,0 +1,2 @@
+x+)JMU°´`01 óªÌ]}_s9$bÓ=?ÜÛµ¤o©æÓŠLˆ´s~nn~Cóá¯Z‡ã–Íj°
+ùs4ä¬Ã·ø'á™y)ùåÅ«WÌ]23ªŞ˜™3qòéoì'Yª M‚*
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/60/1e40bfcce075bcb03eac70b03ba0c88176d540 squashfs-tools-patched/.git/objects/60/1e40bfcce075bcb03eac70b03ba0c88176d540
--- squashfs-tools/.git/objects/60/1e40bfcce075bcb03eac70b03ba0c88176d540	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/60/1e40bfcce075bcb03eac70b03ba0c88176d540	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1 @@
+xKÊÉOR042fĞ×WpòÉ(ÍMÒËàâRÎLËKIMSˆ‰z„ú:Å{p)E2óRQJó’sJSR”œŠó’3œóSR‹ô2”¸¸|+s‹‹5œœÁÆ€×Q0¨00×Q0ÔZ’š—’™Æ ,¶&ä
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/60/a52e89640f771fcae6915330c9cb0c46379776 squashfs-tools-patched/.git/objects/60/a52e89640f771fcae6915330c9cb0c46379776
--- squashfs-tools/.git/objects/60/a52e89640f771fcae6915330c9cb0c46379776	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/60/a52e89640f771fcae6915330c9cb0c46379776	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,3 @@
+xKÊÉOR0´´`Ğ×WpÊÌ)JM5ÒËàâRÎLËKIMSˆwòô	ru5Š÷àR
+eæ¥¢‰r)—‚Õ:…Äû9úº8:»Â•"*ø9…G‡ãáìå ²./9§4%UA	ê
+½%LAßÄÌ<ÌB$ı©y)™i\ ©ß=(
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/62/4f887c946ab4877359e96498487533088d08c0 squashfs-tools-patched/.git/objects/62/4f887c946ab4877359e96498487533088d08c0
--- squashfs-tools/.git/objects/62/4f887c946ab4877359e96498487533088d08c0	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/62/4f887c946ab4877359e96498487533088d08c0	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1,5 @@
+xÕVÛNÛ@í³¿bReL•(I¤ÆD©\”„¾TmäØbá¬#{Biş½³ß
+¼õ¯ÏÎ9³3sÖó0šÃÑ—ãÏÚmp¢Õ:&IÒ»ô8‘OâÒÏaÀ–†±,¨O0›9×—7ãÑd2½:9×g£ñlx1}3vPò"Q/L};İÁrÇ0¨»"ÉÚõ\eŠ`S^-ğ¸nxM”ÁıUºB•—(<œFÌñ!èC§sª`·”}:‚û
+fz=} ë´Îq=1ñS/ w‚¢G¾¸‰L–Á‚)Ô±F† q%Õ<tè&	8b}êÎC’cÎÃÀë 	sYàJî&æ™ü¬å9ˆëú1¢À‡0ó†
+%_Ù¢FVëĞezüĞiºâñx†ƒL'>ˆ"TD–ÔñÈ‚èvíc 5Õûäi5Büh·Ä?ØX(ñcLSÁ†ñY`I%^Y`Ö¥eÎ £ˆºÛ (yL}Ùåâ` Zm)X@&¥ß‡C.¼BP+-¨õ¢H˜òö,]z[*©f°‘©õë-ŞÆ…íëë7¢Ÿÿ.È.'«i¯t–ƒJ…¹ÏtÔ~hh?ëÎgê«`ö@nD6“-ƒÄğJíë's?«œ¬©Ä—[JqÉ×ª^ªÍ(yF)õùìçÜÂXx¿h»À‚šdPmõ7ªˆµ¸}ÈHå^(Eƒ=ÔÑh•‚M×€õä­–·Mƒ÷{ôÈ×ikº°Íêˆ‚XÌ\ñø’~µĞh©ÓhıÃS"£!Qy¯×‡“ìTòÂ:1iE2]²*á9‘[sÂ$WLXÓŠ‘u»¼©”EªZ™f©ßĞ92OøÎb›ht–ZACA·i”ª#†7Ö^5ºMKjÅ¡ı—Ê¢Y{6YD;ÔÎ¦ófR«¨»>9å*¯»ÎÈ›mEe$wšŠ -_†*n
+Íd+Œ=xßdçÛù·ôò1©ör’$/NÓ»Æ€V¦1ZYÃsKÈ±B8ZKu/ºş°	‹‰»:×>1’\%”fR¥ÿ@Ö½‡r‚Ÿq¥\‚¤q!Tk E?¾Ê–ş—sÃ¯S~ÒüÜä½İâw6¡~°0şàA‘Û
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/63/a63ae484b7abc52889c90158a0339028deb3d1 squashfs-tools-patched/.git/objects/63/a63ae484b7abc52889c90158a0339028deb3d1
--- squashfs-tools/.git/objects/63/a63ae484b7abc52889c90158a0339028deb3d1	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/63/a63ae484b7abc52889c90158a0339028deb3d1	2022-01-01 15:09:15.637172590 +0800
@@ -0,0 +1,2 @@
+x}TmoÚ0Ş×úW¸$•MCê’B›*ÅĞuBH(·ÍjlÂVí×ï.v /lR¤œŸ»ç|o¾•P+zÕë}úNØ-½¦âÏ&²ù;'Ş(ÜNi]jÑ¢ŸÚ¶£?ø®Ö¢`Q%x´Ï>vm‘¬è~ÇS-rîÆ7Ãe(¡à…„]ƒ×ğÑ"çÃ`:„#h‡ãTüN^/•P/Šv†w»˜và©shçvÚ¡†°dWÕÙÕAÓ­iº„Ç$µI·°pÖ³'üµGV'ÌîĞ[´.ñlâ±‡0À;©ö†Ö¡^ Ã¡İ.Œº§º%#°8md<AÀó‡Á’¹÷Xú¡L %¹­V?Ë ËeüZ'ÑÆ@ÆW8«ûƒ+nx¬Ö<­Ê2Œ‰=°q>BÅe¢7ñ*GµÙDr$’‡Q
+ƒRVN³4‘/MÄSòO³¦b¦|Y¿ó8S¹OB¾Ìıpy2H_ºûççêİlŸ5AˆG›Ç,;s9”­–q0÷åS"×êw9¾`+0!åÆ]Zié¦Àô£ KáP=­7™£h·îe%4˜˜&:J×é©æã…°ÏÊôI$_¸‡óá&•Ú»i÷£÷¹(U$DŞCñx,JH{BöÉYgÍu¾U´0ÌmÜ=8Õm{-„p¬sW‹±Ùj!å;-lãWpŞbà9y¦Re”¿'»Œ^´Øİ¼­“4Áä„Æà~lŠEÎD"ßàtXjŸõKÆ…!šàÂ#èêØBL³íZv¼İ’3Øm¸¬ƒEÑÓ>îO$9Më%ë"¡ÜïÜ\¯[^’'hÈiDAü/«ÔißlÑèvnDÿÅÃµT™¾>­Bñ¡P¸)¡wù&;Î¥‰öç ÓhÊ4¬[TÆ.giÄ9*š$ëÒ´ç4(µ©XY[k)[ R¿ˆ‚DıÒwQVIS§ “
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/64/8ca0288d2d9501eaed43148c2b0886a9ee6a65 squashfs-tools-patched/.git/objects/64/8ca0288d2d9501eaed43148c2b0886a9ee6a65
--- squashfs-tools/.git/objects/64/8ca0288d2d9501eaed43148c2b0886a9ee6a65	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/64/8ca0288d2d9501eaed43148c2b0886a9ee6a65	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1 @@
+x­VÁ›0í™¯°6jVÑFÚöĞ*ê!¥Ñ6 Ú@sDÙàlˆ]é*ªòïÅ1	¥½!Æ~oæÍøÙ/)}AŸ?~z7"‡”L×E–W‡’_8+–5Jö$Æ{Eïº¾­ƒç¥÷äøŞÅs}·Fe4!¸{A	Avé)ÆèÎ=oÓ·üáp§üÜ0œâjµòÔ{J‹äë¹ÀI²£1æ÷;JòÍëevíøç…K/@låjûŠÑä¬¢¹³Ï,± TRÔ˜‚º¦•”éÁÓyÛ¶YTÜ£'\ –ZÆOj-c¡ß(ÃÅ)#Dfè	êÜì.™;€éE ¶v¤.Ä³·$O¸Ô Vª¨7JY¯”Ó—í(úoìn¿Zb8ÆJBÿÒ@>s  ‹fXûĞÀqaãXã\6­DQz£Î`ó»•y=Õ ¶@oÍˆWl*ç®(¦Är¡Cõ$©‡na…thãã#. ›ü{UQ”hËí7AÅ–Rí¿‰2aÖè/\fLæş•ù‡ŞÒñ¿-Ê‘èt·õ9/„B7Í­ÓŞ.:…z0İ¥÷§\Jk a0?Ú­ÂÚ×ŸqPQ…BæâÄTÙ-K—¦V^§µ·PcU:;,¥9Œgk„Óë“%­ĞĞsC÷;iÜM€íPÔ’V†h€¾®¸F¤éi`ã™²ÛßÀÅƒHsi(«­D"c3‡hfÛ‘ø¿ğd©æÚëg¤_ùT¬Lp„Iœì•‡ğfé}xŒ6ÎB>Uåª»³S†ùu‚šdùø”Àœà¸ßŞ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/64/92880662e1006f2ff9af1ed55b7bccf380c08e squashfs-tools-patched/.git/objects/64/92880662e1006f2ff9af1ed55b7bccf380c08e
--- squashfs-tools/.git/objects/64/92880662e1006f2ff9af1ed55b7bccf380c08e	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/64/92880662e1006f2ff9af1ed55b7bccf380c08e	2022-01-01 15:09:15.629172589 +0800
@@ -0,0 +1,3 @@
+xVmOÛ0ŞçüŠ“¦¤ôÁ¤IİŠDÓ*Ê˜Ò¾Tië‹4î·Œ•ş÷İÙc·”­¢¢¶ï?w÷Ü%“LLàøÃÇ“7ò;ÏÄc{ºXÁ;O³åŒÁA,ggéïöı»é˜ãAmÜnwôß¹˜ÏEŞ¹zÂä»ßä,ËÄTÁ¯ŸÁyİí~)£` t»}şS­Ç“eš²¢Ÿ”,ú„'Îzpô)ØÁDˆÌ‡:/X"Yx;ÈåÉ1<0¶ˆùÖg©(X¶¶ÏRÉŠİ+Y±ÒtÆ>^ìo(bÕ–‚sLÔÚ³ĞĞ‰Ş Cm‚Yz Ê‘f‡ön}Q½®Qx
+¡—(Ì<?cò,îÛØE„¯ñ K@D(ÓÖØ±Õgú{`G¢İlÁ|Ø’‘*¨*>«üTA7è7^cnÄ0)eœ¤ì»(¹ä"G7C—UËÏ1ÛâÕ³¼
+&—E²X2²3K/I*¥§àëè"¾Şøšä\†ƒ˜ıZ²\ò$ä±D™Í¡QªÿF*z¼õºÍDàÇ¢¢Ä]T1i{|kç"Ÿİ%åˆ%Ó{6Ã³4ÉJ7<™õ)¥!æ»¡Óv{kÄ2†-+¦¦ÉÌms¦İDøÿÚ‚%@0È!–Ø|]Z€Õ!ê¶0‚Ï(}…Èóz)=”H9äs.Éµ–´À6§i4u-OCsİVúLş"CÏËû)"SEª×Ì:%SÃërí¡À°L•§ê,òËÊ²	4…ÙC^w˜‘n<¾¾$Ù<ŞóŒ…¤ëº‹Í)õüĞ+/ÛÈXÕˆbµıHÉ´a85T¨al'Ùæ©Ø¡•/ç*ìøR{ß®/«B´Né´âáé¡	tIŞ»‘Š‚»uS¯Å}uÑ ¦"/%è9dç¶™?^ˆO%±Êƒßq8}eXU#ĞgdBQøÊ”«Rİı²zí £Úl)€F©'èÃ¸©ÓØµº0	°Oó:–õ«~¡ùˆÀfN»“éJ¬˜_êÑ¯sÎ.±6ŠiZ2‰3Ğ×4ñp^L)]vÔAÂ´"hÖşË¶"‚¦@Hs†/=+V	šŞPš.¤¡›Tu›û­¦f—ô&øø.
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/66/8b9a5b0aa055bba58b500dc9e9eed2acc47333 squashfs-tools-patched/.git/objects/66/8b9a5b0aa055bba58b500dc9e9eed2acc47333
--- squashfs-tools/.git/objects/66/8b9a5b0aa055bba58b500dc9e9eed2acc47333	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/66/8b9a5b0aa055bba58b500dc9e9eed2acc47333	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1,5 @@
+x…’]o‚0†wÍ¯8‰70¿5Kœ 	"SƒèÅ²„à¨qÉâößwÚŠ“M	Ğ¦§ïûœ·]…É
+îïÚ7õ:hI´IÉv[·½ø…h‰OÒ“¡µÉj¯‚P
+Ö±OÖàºš5Ùú|îÚª9Ò5k¨Û®5sÜ±PÂ‚ &WkE¶æ¦á¸KÕ†'`aÄY»)e€ÿÉ3¥©ö™|ZGş”Qv2xĞêa²˜^Ì¤(kq“b•Åuj)TMËªãQgdÁD¯€™‡Úíšj¤İî›“l–^¸#Û°g²¨.RyPèHğù«ıy–/ªÙÄó%ù“¢ô #ÃWj¤;Ãi‰ñ.š&ïddÛ
+lÒdU(¨€ÚÀ·Éı÷yì«dû”‚7Ğï_îÀÜE(9EÚĞI2/¤úÜ2‚wL7÷R9w/ğr`[¡Œîc+8B•í 1OšÌÕ¢ cìAsa!“pKØ`}çÕ##ı™Ò  §"\±À
+4*c¤~©wÃËv¼gåü©H€Ûş97* K(Ib?Xß9ó$
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/67/d3f34b6c169cddfdd072f90bff8055626eafd4 squashfs-tools-patched/.git/objects/67/d3f34b6c169cddfdd072f90bff8055626eafd4
--- squashfs-tools/.git/objects/67/d3f34b6c169cddfdd072f90bff8055626eafd4	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/67/d3f34b6c169cddfdd072f90bff8055626eafd4	2022-01-01 15:09:40.213173601 +0800
@@ -0,0 +1,2 @@
+x+)JMU0²°d040031Q0¯rÖ+©(aØuhúŸïGÖ•n}­Í¼+İûŒ<N\‰[~Qnb	X]ØÿÆšôÉÇöœqîù y±å›L€@Á™!şã·£[Cß¯ıb“Ûıêª³¨Ôç ½Œ’Ü†W2*õ{*Ô–N|ñö÷·«”E÷BÕø¸Üâc1A¨ÖùıÙäæ=Gß\_£?áé¨ßÔ’Œü”b°2“‡KW*ïhŒYz¸îˆ°sØÏ†îİéPe™Å%ùE•`ek,e
+f„ª.)=¸ßåÔß¹ObÌ ÊrªrÁjÜ™”œ;íj%ÔşÒOˆGG1‹ Ö´y\
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/68/1ee9356e8fadc216f9074eea584ccfeddb3e29 squashfs-tools-patched/.git/objects/68/1ee9356e8fadc216f9074eea584ccfeddb3e29
--- squashfs-tools/.git/objects/68/1ee9356e8fadc216f9074eea584ccfeddb3e29	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/68/1ee9356e8fadc216f9074eea584ccfeddb3e29	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1,2 @@
+xKÊÉOR044dĞ×W.IqL«ĞËàâRÎLËKIMSˆqqt‹ˆ÷àRò3óR‘…¸€z”3ó’sJSR”|+Ã3óRòË‹õ2”€À„ıRË=óRrR‹@â\Ê©y)™i
+\ gØ$(
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/69/8f30bbd8aae82944bda4a254cce533831e02a9 squashfs-tools-patched/.git/objects/69/8f30bbd8aae82944bda4a254cce533831e02a9
--- squashfs-tools/.git/objects/69/8f30bbd8aae82944bda4a254cce533831e02a9	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/69/8f30bbd8aae82944bda4a254cce533831e02a9	2022-01-01 15:09:15.649172590 +0800
@@ -0,0 +1 @@
+xT]oÚ0İs~Å]«I e@×M£íÀ”¨ù¨Œ³©OV Ö‚Så£¢šößw4!Q™¶<$Ö9÷\ßsleÅKè÷?÷ßœËZ‹p~ïSfÂçÆ9"R‰6h˜æ˜N\ØÇk¹‘«0“±2P^¨çş‚qæû"jåkWi–Hµı°»1Î…BQWOf„ÿW!¿#Ô#oVGRåóusÓ\®ö8d5¿õ‚	ç P€ÕTÙó£HÍ§Ó_?ZëùPôâØöÛ#fhoRáfBÓ"J…¡¥Úíj&`{ìË¨†r•Ê­ë’Údº‹“Lú—'%«%MZªB1œPhN×7I1ÿQ}x³rÒ)ç¥WLZ»-«²ÅjÅ÷¼¼a¢Õcšğ˜ìBµE÷›$ŞÃY-8{OÍt·ö¨›±Âø‘c(enğÃ§Ó68À´Dk}}HZÄï=†5³œuxŒúxc_ÒšS²†7"«±÷ïÂmï»åØS‹ŞB¯_—îÌŸ¹ÄõéôbfÙô†Ão9œPêSè]´¸¢ıÔbô>gsŸ]©:¾‡%tp…«oøıª‘VaxhŞœ.üéå{7~c™¥ĞØ‰PÛ3îùŒkÿC~A•ç!ie®©ÈM§¾½-êB"²<Qø©êGğç,ïİy[k
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/69/abf39710fc51602e9a4f04fe4ea9cb8e469ec7 squashfs-tools-patched/.git/objects/69/abf39710fc51602e9a4f04fe4ea9cb8e469ec7
--- squashfs-tools/.git/objects/69/abf39710fc51602e9a4f04fe4ea9cb8e469ec7	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/69/abf39710fc51602e9a4f04fe4ea9cb8e469ec7	2022-01-01 15:09:15.649172590 +0800
@@ -0,0 +1,6 @@
+xuSïo›0İ×ú¯8•/„6ë¤õCÔH‰ÆT¤,©ù0©Rä„£µDÍ¦¿¢şï³1v0K äîİù½»Ç.Ëwğõúæû‡¥<Á¶Û0\®6q¯ƒÙ¯h{Gf2Äa|ŸU	Âù}^ºËğêéœñşU¯RÕ^@áß
+¹`4y$
+¤Ïä@Î*^²G	ìŸháAB´¢PŸŸ)ãŒ?Îß–ò9ÔmB¾	,øPßJ"òR	—‹pÀKÎ0\BÎ„{B<˜):—`Ã³’}àˆ(N‡ú­~ÙÎW
+­"Í¹Õõ“ä© HÕY#?	¹[Ñf[rk¤‰[ÓõèšÒ&\Æß®F²ìô?è}‘ï±,1Qñ‘”*
+>™ÿƒ“fj®Ì;˜•hæ1ŒØxVso)¸69vuŞ‚¯+ÌŒ
+•Ü˜ÿæŒ©[?AM¡«HZ„ÆSµ…‹3KyÂR"Ïÿı¸ªÄÑÚ‡šŸjÕq£ŞÓÙ|µZùi–¿v"4ëxÕŞ4hV›…¼G»šOÏ¦k¯6ŞÔ–„rbt,Õ~4.ì§•k½~ÚÈ’Ÿ³ELúZ¢Ìû*'}Ûcªl¡p9¾ªÛFMÃµÃ×´kĞæB…’6v[Ê4rÚÛî¯*ÔiU´ÔÄë#IË ¶È?ô“%
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/6a/44d272f898216cb8b6f3c19b572b18a2a2038b squashfs-tools-patched/.git/objects/6a/44d272f898216cb8b6f3c19b572b18a2a2038b
--- squashfs-tools/.git/objects/6a/44d272f898216cb8b6f3c19b572b18a2a2038b	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/6a/44d272f898216cb8b6f3c19b572b18a2a2038b	2022-01-01 15:09:15.653172590 +0800
@@ -0,0 +1,9 @@
+x­WmOãFîWü+¦âK9@àN—mÁAB”PUE{¯Îñúví@8õ¿wv×>Û!á¥­„¿ì<ó<3³3Ë<s8yzúÓ>b8¿½.ÆãÛÑìÊÙ§7<ÆúËÃ–úÎE²–|¦Ğğšp|ttêÒµsd®s=6×s}§m†!"@_d‹%üšØ¿«oSa „\d_Ïr“+H¤XH¶º$"(¤÷LbÖ"Å Ñç*•|¥<û‡Bj‡Káó`­ße¤OB"¤(—
+D`>¦ğc”,‚a6¸}îa¬P›3ò®_ª}˜¯Å¥æ0Î9À¥ `–rw9ÁKX¡TôÇ®†,ÕT%ˆD/l¿5DŒxkvè-eùÀcã>	I	’DİS8a)²Èø£À—ëÉÕít½Á|éF½Áä®K‹ÓPĞW\¡…âË$â$Œ‚)Yœ®)&šñÍÅèüŠLzŸ®û×“;­àòz2 ª€ËÛô`ØM®Ï§ıŞ†ÓÑğv|q 0¦¨|°;¦ØRHSÆ#U¿£L*bù²RF=ä+âÆÀ£:{e¶"/ŒLbRNx ±H]¸—œ
+$&µ<jÚe*]x
+¤ğ #æ!´aœiÛ“ªïOB¥"vá¦GÇN§İ99úÅ…é¸WÈñÄ2‘¨”!A:•gæ¥$¦ø ß=Sı®³ç…LB+fK¤ıVeI"dŠú£~n´xÌÓfc%¸­–KÕ@zèÒü± €.¹`—¿…1„VišÅ»wÙbVÍ†%o9•˜ùçYBÁj6r¦–Q£ågËdö pQ¥„©d^º±¨P”ÃÑEÆÑûúüBcGn¹J"¶.×nàåË2ÅØl–¿»CLPÆğ4­Hˆ¯Y2+b'd
+2|ƒÑŒûyxr#Ã¢ Z‚«İğÒËƒ™ÑQr¢¤FåQÕDº«ëà•è3]_-"õ’¢„ZôÙÒµ59Å]ñG´Em™wMç;­Ú´}¦áãGLûı¦³·'1Í(GT¸ùm¹NĞ Š]âRB½•‘Q(zI
+9Ò:lø¨h7Ù{%=+§V%££ÖB)…4*k
+ª¾IƒE5x«Šc!¬ C¦\}€¢O-ÏôÇH,(Uº]¨z¤°,mjèéAâRWİóhØ¤úÏ§Üç/…Çp/ÂóBRñøÊpP³Ü¨Ì
+ÆõùïòH{Ü1§š ö„ˆ(÷œ†I@Îu¨é!Stø°c¢GáÒåz|y’Î)6oKŒ©…>0=JÌ™#÷zú¬0zlûzd>Ÿ¶¼QîÎ™mL.Vş•oNzğêû0GÙ²Û
+A}3.5¦K\	ì›/·2=7[Şr+l%i¶0}Ò4j+ ÛÈÚı]¦iVB;énïu-½£ëÔ«h[¨ëö·Ùòª&’½}›†­±1%ß ÂcÊ²ßÕm o¥yÂoĞîÀ‡§}Ã¼&°püZ¡µÿ?Ë¬aoù¤èjo“eÂ^-Áú‰äe¯IXqh(¶úÏåÔÕ>ÛgOÒ°1ıÃäü‚ÉÃº
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/6b/4f1b796b6b105978e4db3c0bf13bd75f2f965f squashfs-tools-patched/.git/objects/6b/4f1b796b6b105978e4db3c0bf13bd75f2f965f
--- squashfs-tools/.git/objects/6b/4f1b796b6b105978e4db3c0bf13bd75f2f965f	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/6b/4f1b796b6b105978e4db3c0bf13bd75f2f965f	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1,3 @@
+x}R[OÂ0õÕşŠ/ğÒ2pD&>8£ò€$|1ºìÒI“Ò‘­#âÂ·í:n÷°.=ç;=çt!KCè÷oÎÚmğÒÅ"åmïÕ³ç5iÂc’€ï{“ñxòâË}ÿ5ååäx[ÒyÄŠ˜Àm.bÉ±çw»½Æt½$¹=o ± ÏÁ“b¨D ³İø«€ÄEË"d4 ó\‚F5<BFŞ;×Î‡»…V)aÄ©Ğ ¶\$å”.¶`ñå÷£y¬rãJÂv
+[PaÇsaSÓfË8ä~-V/XÉ3ŒB)óW®–Óp·£añä´ÓÓ°Óûã(å¹¨_H#ArúC|¡mÅ”÷DÄı"¹™ª¡2"ŠŒ×?‚ŒqX°°¨`2­úÿl9®î®ª¢,R½€ú°«bğÎ¯6
+µEÙ³«æTİÆL˜¦ŞHF“µñaÆ:^Ë¤Ówx¢)TÙ2áñqª=W0B¥ªnü;P“ğ˜&èÂêõ!
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/6b/fa2a7093573773211e48a727ce1d331b6dc185 squashfs-tools-patched/.git/objects/6b/fa2a7093573773211e48a727ce1d331b6dc185
--- squashfs-tools/.git/objects/6b/fa2a7093573773211e48a727ce1d331b6dc185	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/6b/fa2a7093573773211e48a727ce1d331b6dc185	2022-01-01 15:09:15.617172589 +0800
@@ -0,0 +1,5 @@
+x•TQo›0Ş3¿âÔ¼$¥Û:-Ò¢>dm²"µ[UÚ—¾ ‡â•ØÌ˜.MÕÿ¾³ ëª!òùî»ówß9)d>:ywìÃdŠñücÏğ\d˜COîãğ{|áhÉ¶,ä$Ò¢Î&›dªñò¨c5®ú¶YQÈÔÁÓO%š,•Vuª!>ÅL¥Kşˆ¡È¥÷ìœ-xß Dš)}-+®¹³\£r9§Ğq;gšu\§ŞKwê&Ş¦5Á	«p¾vÉ{fhö§&e§XhnvïB¡O>‚¿ñâ
+béC¤²UHÜ®-Æîtşõn·S}õ
+˜	ÜÁì’5Æ[éòZ+Vzg™SŞ£äD›™:OæëPp=<t?KFÓ®ëB!¾â€ú9ù,j‘†Öà¤ÕM›ôê† Ãu÷UÔísË§=WĞÌ¡pHÿÊ²¨‹ÂòLzúDy ˜0¢aqİ´R¡±óry53sö•DİÇ7óèîò†şÈhHFó8FdòS8“ıÒ–’Ò6h	­Àu…EnfÓ¹;?©óU‚d­¿´aœüæz		|R±†[ßà¯š+ÌÌ¤@ dµ5‚ñ3Q²ƒh¿T2ÅªrÁ£©‰&Çvv?6cúÆ³‹°Ÿ2	BAØ —´èÕ9~0Ì÷UXÌÓSx
+óQŒ^!a%éÿ6^ò¤±.ÌEz;2XTHÁ‡íîöÙ­š–R‰|óì—}.	t€"ãy=B|hæªQÑ~¶JY‘d_Úú!ƒGÂ²ÃnoØ%
+'Ç¶Ì|¾uàØøûuX¦(ÎŞåà3s¥_1.¶Q½[\•TxÛ³ü¢y¨
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/6d/f08d6f148c251e4395bec17fa50a3cdb96a3d6 squashfs-tools-patched/.git/objects/6d/f08d6f148c251e4395bec17fa50a3cdb96a3d6
--- squashfs-tools/.git/objects/6d/f08d6f148c251e4395bec17fa50a3cdb96a3d6	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/6d/f08d6f148c251e4395bec17fa50a3cdb96a3d6	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1,7 @@
+xWÛRÛHİ×ø+º²/6E_HÂÙT	IUtqd	/O*ÙƒvDé‚C(ş}»gFÒÈa“¥*0}úôE3==õ._ÃìtzòÛ»wà<®Ò,É÷åÛÛÁà÷t›%lQä\¯,×ğVËèrğ;BiÆP"s.gS²Í6»:ağiß8üŒ(Û•LU–U‚Voo?ßæì7·qUŠ}YivƒÅîµóxQ§‰A¦¯ƒêñQp²ıRóÏZ¨ÎÊô&c‰Ğ…?S_æYç¬¼Í‹
+–—¼àNhÃŸ«Wot¶ÂäJó-Í¢sÏ³•hiVå*‘¬¬šM	šM;í×=ìñCa@ jÁE°=÷â€6™–ÇÒˆ³Jîê²‚5ƒÙôÍ:­ÚİŞ»ËB¢ÜRùLàÃ	÷ÏÃ)N¸‚‡šV…g[o*°5ÿÂŒ0UóÂôá©õ_ë8YÄEuÏ=N—‹ô…==úhÃuNT#)¹oò7€ªì…¾”âhĞ¯Áç 7z²ˆaÕ7â"x¶Ù‡…/¡¤à«/I‡£ó,ŒZ%šáºÇPtêpß£¹e›å˜ƒ§ÈJHöv¾7âŠé;SàËôæ¶ÃŸSÜÄ¦#\úæ2´~|-8×0†1\VqU—#%kÔ@ŸÆ£6/Q–ß[XÊÅáµºÔ=ƒ®gly_°¢‡ãocùcÚ\³—æK´‰B3#×£úóçšŞ'Ÿ¢Ï“ñxÚ#kçØz>%í¤G£o‰õ^a-ƒ‹ˆjÿJ³-cºz`yî¡Ñ“è§ë…7wLÇó¯É‘l*ZïXû/pßDnÛ¾¥]™~·á˜Á¥gèšm×û>6íM¼Ûlçí‰ü@EB–¤[åĞJ4¬a;‚‡´¨êxØhUhûcC4i‰QSJäéG®å,0
+¾# ß]àE“Æí›bí>aú&ü	ãq,ÃæÍ‹ÏğÛdSäÂ
+³²|ŸñkÖæ?üZ³â»&+¶ñÓúæÜ²HÓäò4££¼®¼õßlS€"Ó…lDC~_AKŸmGÃŸq|¶cqÉ:Ò³Òşš©—…î×[¹ÊUk¬Àén4"½`£7“nëEsã™ñ–XVß¢¦:ƒ§Wø-WAd:‹àúîèñàŠnhÛ(M„dMq=•ë\ÏÄÚ§õ‰\Ÿâú½XëäéƒXZ`¢ôQHÔ>Q:•:k¹Ğ°}#ò‡@Lß÷ˆ0‘yPÒ$ÊDä·"Ó‘ûDˆLÊ0uËÑ¸•LÍšZæ
+IæòO›È|B‹>h"s±è‹¦2‘PHÍ†¸éš°g‘(¸ò,ƒD]/!r{š¦Ğ‡“ZídÑN)tÙ»w–O	Ô˜q#¢…fLş[¥Ì+‡V3¥æäİ¨âé–Æ"~C0ï4•»ö>+YñÀŒßSM;Æï©f
+ãÔYšg€‹'üâÑß\Å;ÒğÖ­Ì'<H[YŒ|PwvËuàÎk€ZEzS	ÜvÌ¾¢î4²ù	ë<ï¢ñwÊMğ× 9sØ¦;VÉG€î¬ñd4,†çf¯é$”“RÎğ¸dì® :Œ.·0nFr	4
+|‚Ğ±s™ácëFºÈcùXj»]¾YòYÿü±b6Ë†bƒûò;¬´i;–Î~e=<Êï6¼³bÄyÁ˜8l7ã€Ê£"µŸ×ÿcÓ¨Ì^Şbê¾`•—•Yy1<-//\ÅEg•İ»hZ/=äG÷E~ÿ›üş±g’°Ÿ]y$ÜIYl|ğêÕó»û¸`s¬å–6•tÛjrbŸUpŠ¾ÚWU_Dš¾ +5V1ÏttÿÑâ¯Ö¤©9ÑÒ4¿ˆÇA¥F‡-‘Ş¿–é!ïÙ‡°éò>ˆ­)71È?ÿ]ÜZ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/6e/f872c31069876bc5426fff5ce6e820e073bd8e squashfs-tools-patched/.git/objects/6e/f872c31069876bc5426fff5ce6e820e073bd8e
--- squashfs-tools/.git/objects/6e/f872c31069876bc5426fff5ce6e820e073bd8e	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/6e/f872c31069876bc5426fff5ce6e820e073bd8e	2022-01-01 15:09:15.613172589 +0800
@@ -0,0 +1,7 @@
+xVMoÛHİ³Ó ¤Ø©ÓzÈÆ€ã…Ñ8¬¸@†,¶BT)äEê6ÿ}ÉáŒf$ÛØõ!‘f4äã#9›4ßÀÇËşåï=ø´›¼VEV!xï;Ó$Óm$àÙùş®±<a‰‹Öê¨i©ã[/'şêö|ít 37ËüªÁğõÔ¹7á÷ä1ª`”bò
+^´éÊ½Õ,«>~€8IÅ,‹ÄkcÕÛ¤yøl­ßü¬x^¾­n¶q,
+e Lvb]Y÷q‘ê­8.Eµÿ=}y_ä¡(K©mŒe˜¢eğú7’ŒÁZâÇ‹Ûù…qè(ò4…ô®!ÚôS×C>5›óàå±øé
+¯…(ñ,¾/>Ó†—KÇq©Ï¯Ûªá²ŞHbpbc®¯Áa¯ÜŞ¥‹@ä&@ºVáÊ\‚G{†r„¶ÕvM½6L.êtgf½Õ¶ÈL(o´@~šäf~ÿn˜=iØ5¾˜AğØ+4DkQ]ğn	çû^(Ò¹mv„ÏÊOÇgşÕª^W,*:N“UÃúöÛ|¸İ­G7’&ƒøbã‹ñÑvºMSmÍA½Û~)xÖs’±šu%úE“æœŠ,Jâÿ“ªÿNu7cX/gw‹Ï.âŞÀâ¹~íbå7Âä¢¿ÏËvŒ]è»®
+Tâ#“4QÓˆÙïSÎµbQ2†‡	selT~½ÁJÔq˜1WÃ(³¬7Pc~­ÏÉz±zXLç“ùbù•i~“p-"–"ˆ,"4nÚæ»pÖÈr‡•˜ªÀáìßFßÆb2È]n“õt8»İSC»É¡)9¥}mÅ#2cf•<Rù0±kµÓÈ
+uËvV\—ƒ@‡ÊÙÑáî%€ÓÃ6¡à—LÁ¨JB©còRSG–‰<”¯ÕMtáR?©Á€{ºl³~•üJ=Ùô¹3Éç']ïj¨A ,Cí„7µĞxØğÚ©HKa9`4g-ZMO™tmš$ :->º<ä0Ó8Î¬-şÊ‚’SGU¢1§“B®™ÄĞi–)ëV²–£±ˆ“LDö©ö9>y‚—’/¢HâŸãäoQVûP]k6"Âm!—U­ÓO«®ıÜJÑqÀÿùï±¦hµ89©uâUÕ)'”CµÏL«‹Ir¥nbò>R	¼£Éû=µÇ(J9DõÍ…5Ñº‡ ³ÂIÔaw²"¤ºÈ5já
+øÓ\òğõü\s¯‘ÏÍ¥Q‰„X>&O¦xIŞôV_Ü¨	)İé¸plÕC“ø©ÍHM4O,ĞvÍš¦çj	KñIHbo0+ÉÏ}ùê¯I¶PÇmÉbëQ^ójÃé†v«ÖÈŒT0øéUç­ó/Pƒ^
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/6e/fa37d568b0bf831558eca830bf92d6c6f5a554 squashfs-tools-patched/.git/objects/6e/fa37d568b0bf831558eca830bf92d6c6f5a554
--- squashfs-tools/.git/objects/6e/fa37d568b0bf831558eca830bf92d6c6f5a554	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/6e/fa37d568b0bf831558eca830bf92d6c6f5a554	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1,4 @@
+x+)JMU°°4d040031Q0¯rÌÉÉOÖKfPÜmpüÉ|Î­“^5<«
+UL±MQƒÏq¥L›nî\3wË¶íÁ_oM9WäTš––Z4ÊÆ»ğÓß#ê¡ôæ©¥~•°Ş^åŒ®*ƒAüé„„SVrîÈşçY¹q×læ“pUÎE 7M/naQ7¸(“T¸zŸïœåÆŸ‚P”d0¬=fõãõ;cv†{÷|­sé„+qIMÎOI´Eÿ§z9[F‰İ£ß»ç¿ÉŒèÎÛ…®*ƒ¡d·ÿİ“»×~3«üm–ğ§Êıp	\•kEIQbr	Ğ°¼E‡2Û³:åÿyöBáAñŞ>e/—üö³Õû¦ö¸”ç{g¶³ûÏ—Á•y¤&¦€ÃÊúÉõWk¢¿½××8;íóDsã,QtUÌa«–í="àTvéj`Ëóşíÿ‹¸àª<ó€Ò{.Ş¯'~gªËÚ÷lñì©•¶Q~È*2²iL7/V”óX®~NÖX:÷`+BEIj.Ğ-‡†€¢«¦e‹–rï•<ñÒêSªš†öTË•]&A1{¦Æİ.ìı1®Æ71äš«GßNäk“š²hë=ı¹2/!Ô¤–dä§xº Õ¸›Î7›kıg…F×–C×,İ‘ÌŠ©.ƒALÿ¬è.ƒ¹‰¯u„%
+Š^ª\
+WRYZ¬—Áğ÷½H„€ÄÛoL‡Wî3âk*J;£ÚWï¬—R\À ×.ª°xñ™ç";×´…\œzm¶ ªšr†üËÓÕZ%„–¾Ş>kGÍ{‘ƒÓïMªÉMÌNMËÌIe˜óè°[ıÍy·hØj>ßup‘Ó45zéÉÀ\µı¾{¼„QãÛ•JnË>¿½	 Î^¦
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/6f/6bdf2df26a7bf2e94346d63f34c33c45839afa squashfs-tools-patched/.git/objects/6f/6bdf2df26a7bf2e94346d63f34c33c45839afa
--- squashfs-tools/.git/objects/6f/6bdf2df26a7bf2e94346d63f34c33c45839afa	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/6f/6bdf2df26a7bf2e94346d63f34c33c45839afa	2022-01-01 15:09:15.661172591 +0800
@@ -0,0 +1,3 @@
+xuS]oÚ0İ3¿âH•&¨(…vš˜¦e
+”U<!“Ük‰Ùmşı®Ó¯MZ£¼øÚçÜs¯…>`4}zw&3•R†M¸L£h?ƒ›Ûé*öóÎoHEÿİ»<ïàCÂìïZØ<³ÈdA¶±ÊçÒ‚\ó¢A¢ËÊµ”‚‘)´*ÏóŠ—-³®Ã ‡nÒÃÕpôÁW7¹,
+Ya©ëcN_«ÇÂ÷çşmƒú×·'–V@eôÑˆÒÉ¬ÎÜ½04F£k$B±–TZgä¡f3ÒA¨ôRß°Ô©Ì_«9&—™ÒBgíâfµÅ)2¢À¦>2ÁR&¤,y¸°¨|ÑæìøĞ´ˆ™×=iÀL3±pR«1H2½Á‰Œå5®úBt…óRtåöX_ƒ‚ƒ9;xÃï«­Rµís]±…œ)ÙÔ=Ç‰¡¶”ÕEÛ3Àİ"¯·1‚ÕwA«x7æÃ.×¼K'z¤’eUH6Æa¡\Ã™xÅ·Óp2gHğc±\Ä;ï`¶ˆW<]˜­CØa¼˜l—AˆÍ6Ü¬£)ÏJÄ©°}Oğv¦È˜¬Ô†’²°ÏÆw|“–Õ)rq"¾Ñ„ä‰µ	¹Ê+kÍ¿ÍìûŠB«ck“ó´<Î2ƒÒ®{#y@œn¹ş¹G½Ê>>~AL?B$„DµÇ^_ûø¡­ÓªÛ Ã«Ñht1º~îcÏv¸sÂÏdŸq,I9;È¹ÃeçåIşÜnöó šwEÇï1|Èøëu:ôÀs¡pÒ2Å¹Çï]nÒîãº7îœ‘â‘îü?ßK¢
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/6f/af33365e4850c8bb5bdb38493fc849eff1cc4b squashfs-tools-patched/.git/objects/6f/af33365e4850c8bb5bdb38493fc849eff1cc4b
--- squashfs-tools/.git/objects/6f/af33365e4850c8bb5bdb38493fc849eff1cc4b	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/6f/af33365e4850c8bb5bdb38493fc849eff1cc4b	2022-01-01 15:09:15.605172588 +0800
@@ -0,0 +1,2 @@
+xµ‘Akƒ@…{Ş_ñ¯­mJ‘qM¥Ö•zée5Û²ÉÈj[¨øß#$”zLçôø˜á}0eM%fÎÃÕ³®µôÖÁW_ª¦FdİçF
+2Û¶‘•B ku€ÌNvxQ¦Õ´Ç½í8ÌB±Lã0^»ğb‘ƒûa‘ÂçÏ9òÇ0C!Ò§,Y®8‚0âÆ¬Ëc‰¡Uu.¦ÑÏNFºœzöë)Ú›¶ÁYmå»‚øŞ+ãÍïãÕyóÙ‚õ}Ï†a8ƒãÆ/¼¬¯ÅØz|€¬İ³º?nÿÓá ôµu
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/6f/d3962126851812a5ebb79ab87cef14c197de94 squashfs-tools-patched/.git/objects/6f/d3962126851812a5ebb79ab87cef14c197de94
--- squashfs-tools/.git/objects/6f/d3962126851812a5ebb79ab87cef14c197de94	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/6f/d3962126851812a5ebb79ab87cef14c197de94	2022-01-01 15:09:15.617172589 +0800
@@ -0,0 +1 @@
+xµÁJÃ@E]ÏW\›­† V!4…ÒLj°fBÌFiú”ØØ&QÁoD.ºlßæÂáÂ=¼UÅ+Œ«³Ç²0ÜğkŸ¾¨âšÒös]2r6›¦Ö!(+º@ÀæC·x"Ó”¼Å­í8ÂB>K¢0Z¸ğ"•Aúa•À—K™Id÷aŠ\%i<›KáRa÷„ˆ¿SÑºİı¼ÌGıü›öº©q‰XıFPß[2Şäf:ôÿ7OE×u¢ïû=84şáqM-!ÃëuåîÍt¸>¥Ã•ırÉ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/71/5792d6c176e2ece1049978d375ac4fb2b768f8 squashfs-tools-patched/.git/objects/71/5792d6c176e2ece1049978d375ac4fb2b768f8
--- squashfs-tools/.git/objects/71/5792d6c176e2ece1049978d375ac4fb2b768f8	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/71/5792d6c176e2ece1049978d375ac4fb2b768f8	2022-01-01 15:09:15.609172588 +0800
@@ -0,0 +1,32 @@
+xÅ\ûsÛÈ‘¾_ƒ¿bÎ©KH›¤~È‘×[EQòšYQR‰Röv7H‚"b` Ğ²´·÷·ß÷uÏ Ã‡¼Î&UÇ*Ë 0ÓÓİÓïp”d#³÷§W/_şÇéƒ®k^t^½Úş'ª‡‹<ûO¢Â”³ÈL²ñr¥eXÆYÚ2E8_$QÑ2³(œD¹™Æò-‰Gy˜Ç|„éÄ”Y–æ>[š4ŠøÕL¢Q’-L¸X$ñX q°4Ë"2²ö8›/ò¨(°PÇ¢˜8—Iiö6J£<LŒ7ÒÌ£r–ML65fšåó°âÔ´ˆ+AÖmÎMãîî®sĞ~ˆ,¿mvtñŠèY|;3¿BNleıQ~o¦aQ+o„‡m˜šTdA5F“¢6çÙ²ÀJ+8…Ém–ÇålŞ1A¿4waQOwá=gÏÃOñ|97q:Î£°ˆÓ[Şõ0‚b+øE>VP4Å‚A&&Ù˜6Ï@Jıcç÷· ïLàMJoAö¡ß;98iñä›säË(¸‹$c	 M¹Y,GØgˆÏ<ÄÑ½éƒRs~L²„[I[/K¡,ÜµPzƒ@y²„H1mÓ=öÛ½Ş³g;½ßïü9üš"[æãL™DBÉªD'$}…:ÔƒÌA„'"Èí¯)ÎkÂ˜Şî¬L3NÈ¯ïât’İ¦¸/Êh²®Ïúÿ½s§ËOÕöoÖ®2Ù>®"ª¡”ÜóñˆR„=m™ÛLôû5.±y©?€ïêÍi¾é&Y©Ã$ğ|ˆ8Ó”V—‡ ]î·)\".Ú¹Í8‰ Á˜ı<Gf“"Uìùjà@
+·ï È¦ ¥›Ê t|Z·h‰c]ZÈÛ‘ykÚÉÜ´¸úømŠJ<ÌÃNù©4ü´uóhâ -ã<^Ğl™F9ƒ°’ÊfpğğNŒ„ÌiÓhèwõ*˜ ŠA*ræ\¤İó j
+Ğ6n;¸°5NıcU¯ÎÁƒâ}Š,¾¼6P6>ÊEøÄÒÖâ€Š€[Ñ~¥Q ê9Õã†Ve¾—Ë<Ú"ddĞÛ!{jÓ!!ú+òñÓÎS|ÃÃË¨Xõ´›$ÙXâé@­
+Ä'So¦ËtÌ(ª	Gy¨ÀûZÂHŠÂ~zıªeúİö«-Ó½ÈŸöÕl9µÌEvå=ÑááEw‰Ó‡wĞC‹â ,Ç3Ğ:¦ş`dIÓX–¦ÂFgJÌú_0“J?‡;‚¨ÃS1*.< ïÃbÖ™	Çº“ILÀkQş¬m‚ÖÕXzç!Œ„XA¦åá"+CNRˆ3+CNã‘ßàá¹€üñé©¡]ğ^İ/¢BğÅºGp0cSò–LÓB•›ÎØ
+Æï®„ôB¸‚ÀUFw•30ó¡S((0¨hrØ4:Ä…8Y+Ú”áÕœë2Nx—÷¦An˜ÇZKšvÍn>Å#Lç„Æ/	K(ì`(jò¡ÛülQrhÄÅÅiCì/.,ñÀ;‡jc¬¯t	B[÷ğwXhJ¼ó[FºG1²ì¢AWt6×ˆæBÁ+k*Ûp‘áÕ0qÛØ\Ğåû¹,Õ©$wq/R´ä«Ø@Ù(c.Ãô6ê‰Q$Oä+&Qû:Æ±ÄkğÊ«!Ëêbºõ¨îcuàQx[<8Õ:?â±.(B±Óa—RØıüË–I€~‘Úå?·“*±‘™!„ñôÖ
+®]Šù¾c”îàÑ³ øÀÄe“%¿Hàæ‘Ù§ØUó¹ Z3‰'ªµÌÁCŞ;4Ã8…qxÑîÁŸê"År±Èr„—YšÜC¼%HÙ9êı™ÿöíïÄ#<\*ûU®1I’CsM–,WõYô©ÌCxiÕÃ$CÍe¥ˆ©øŸ>·Ô§µÌ4Ïæ+XÓsİwD´Íu-è#¾Í§ˆ­	qƒ{IŒøn›«1•—!‰u<xZ4‚g«ÂxSx¬	±Õ€´Èà|°5SÀá•yÏJWh!èaîLï÷Õdš#áÉ§D…àöªéSsCÚ0ô7Xå
+|5?[Ì¶xñh¾ˆ$v›yÚdñªÍ¢,¹ÿ”qsà¥4t®Ö÷ıè}ÄL
+Âÿ.+0—‘0L’·‡C$ÏéõV8TáÕ¯!k¹¬˜ÿ?ğúßä2±Òìù©ì˜ì>3 „ü‹0/éxÔwZ×Ü	ô«?éÇˆÕ»4ÉPÙ@<.:Î*Â£q4ÌÔ-2Ûğ6’<tV–‹Ã÷uÒ¨ÜqÀNÁ]ƒíPµ«i2 _Ke mó”OÂôqKÄÌx­ˆ"ÓX.hÏöÌ7Gô’msR”1ÂG Xí3Lä÷‡&eËÒì›ÁÑM.®¾yÿ€øåzm*K+Ñõd«
+m³¿Û~¾»#ƒ»Ø7ˆrºƒcÓ-g°úæÕ‹jÎ^Û[u³±®ÄñƒşÅ°á1_M:	È½ì{‚Ûp¨ôÑÂÄ*¾½WæÛ#óÌWÌ‚WÊDO¨d`¶2ıĞ¼l¿Æ|»)|ÆhÙ§õR1,ö-îdT›$}‘ÌÃÊH ˆ³f‚-@m#Lï¼f”§æù~{—d·iĞÔì½ªîhòË”¦W“‚‚ñêPn¡‚²Xâ¯©Nz:E4)y–pœ„{$e)ú½&Ö
+ÎG‚Dä‹äÏ÷›flE¸#)@È¢‹ù	ÂëyV”ğÒ“7&ÿ©‹67FI!‰ÒÛrF?çJBW1‹§Zšƒø¢Œ1÷¯ÙLÅ’·mE²Oæt›Q*„ªciò0e
+8ı9‚´ÇSV}cÇ"I“°‘é€@Ô$QCİ01wª{blL!ßÅxV$|òm™-ÂŞïQ,»ÊèÈ½¬e)Â‰NÛ¤rÇ‰"Ÿñ²¤*{3ê¢Öæ¡Ñ¤Øè÷«è&_‡Å²|Ç„úì.üª€qË¾ît:?1¾Ã4E@\6ïLEÚéå1wF‡æƒfó0ÿĞ1Ø(2c¿ò%DÅáŠ%Ù(”Ù@EäWHÖª˜ï šbÆ*•{
+ Î›Æle8à§Z`9À@³LÅK'(À^ê¼a²Œhµ¡ã¥&l"‚:{^ÀxN¼R&2¢oıŸÁ‘W£İS‹{‹„½è(”nRdâ`æøĞÉPv¦õ…ùäÌ‰ò<Ce¢qÙXüíPG¡’°@¾f‚äÊ¨bQIV ^)¤7Úá^Ë´'ûü;=ßÇóé¨|ùß£HNË2Fxï"ar{BÏ‚ÏQÊ°ÀÄYQ÷c1“¢BB[5E]Ï™«9ù$…z‰ô`ÊëG#+l#ó|WÁÛ2û6pdòŞ.Ôá«¡“?L¢hµÃŸÏ~ä‚ŞZ†°ã´‡fu<Ë[p^oí.ébB-ìâiC·°)ò«Í0BÒPÛwµåmóãn8ÿÔ‚K_àĞì?7×qhu\Ñ\¥Jœ@å,©‚WnûF÷P+%h}ñUÉ„¡©Ğûœ3ÆnšÀAØ°ê€D3+~ÑßkÔbË…"Å4Ò¬!ğ˜&!Á±]ªê¯¨×?Öµ)
+ÖºQzµ$©¾r£ê-–V†Ğ¸âÇ—-³ğÜgíŞşkoíëb	z/ØÂ¸E‘¥0!Ê½e	í¡çAô!Uxi'êSAS ±6‘ÓulI¤ÚÉxÂXÇ6€ ã¨ùbÁ‚¨C(^ûˆ?÷Ğ¦EÄ<“ñÛFQ¾eW‚BAo"a¶]uñ™Ua%ü_ø+Z5’OF5‡µH”Xf/FA^üÓİÍ½É±ÖèÌ`ĞşßÎ:¬O›Hõ¹¥
+­Î·ñB7¼éÏ[_ÁY'“,ŞîwÌù”›¸„…´{…ğ’r‘ŒÁFõ«Î0UD)£Ûäésr¹>9´})ƒ<tÖxU3HÑ|úóàİMÿÖˆ´h-—eaZPkÜL®³§²SüÓuÙ£xfã§æ6ÏvO²¨HÿX²¤Ç†(:0h4ú‚íaGH"ç-ÔT$^cëœ¾Ërz˜za›‡=@Å©—ê´Ö@‰fŠ…ïØueM.¢­4ğ4lÓ¨Í³b2ÖÀ7*÷bLĞcKÄ€VÂ)‘¥+á­Ü±+¯<•/ÇuÃec:¿ÏAóÔ˜?u^"t182æ<€»Ê£HÙ°omâ¸¼u< è¹´·÷@ÏĞ‹/d•Œ‘åvŒfã
+9¨1zñ¦7£{¾¤µ£Á—‘6j„òİÊ‰š:sø¯üe÷ˆñ¸¶À%ørBÉÖ+Úe¤A?€e'¡MÖ6‚\\ú!eˆ†~ŒÍûHÑkyØTÂm`ÜaWMİ”6úUé‹˜Ø¢"¢—ÊøZÂ³¢D‹Â4`û%VÄ¶1ÍE&@¾ü
+íO9A ‹€Û.ìô"¡Ñ[é@_ôBpkOéÀIìBV+’ Áˆye$`Êµ–xõ‚9£§ı¿í½zûêÅ·M3tI»ôcş¥£ËÀõ‘€¡ é|ìŠ
+4ò+™ óú!¤¡,ö¿”˜7‰-M±ŒUkeU›‘­Ûÿ1ª¼rfğ3ë¥aA6§‚å1Ì±1ğÀÖuìÅ¦Â+&TŞº²­§¯éO\²ş€ûÏ|`=UBâ˜Aå¸ÉÌ™«œ'H˜ ^=bîA·†ælœK1% ³ ä·)d[ä­Ï&]Øß”ü>dj° ó¥™2"X,Ñ&Èrø•–KBª ¥xoqª?lÁËy¬SáŞı 
+ñ ÏLPu<gŒ<@™ÇŸ`™œMÃHK¯—–AÈıcwR[ñ0pÅğOj¹‚4üZ(‚`É Y±ôm°ß„· f{{ÀÌû/W+Ü¤àÎg7rò²½·û_Ï¹8Éƒ0…y|Ø…e¾ )Ü2Ò#İìı¢í—÷Ë¾9‚°½ÛŠ¦PõlÉ9‰{<0±.Ş)Ú°'È­â	•Ô=Ñ¹ÃàLŒXËl•ÿĞ„{8`B1]íùî[š­ ø'*t¡avjCHÀÈş*0Ç!Šù ³NÖ²;-!‰fàŠcU‡µCğykÛó7R`€XÀiSßªïÁñJä±8şNäçÆİñì mÖ´³±W[?÷r¨©ˆŠª£Acº¶ÑlÆûÃ½úñe$H/K@-¨·5ß´•á€4ÊgR*Œ«+õ‡j:#»®{Cb¡ÿ<u-E/O<PäÀÒ¨
+vÑînØŞ;cJ4µPÏh‚¯0ˆK•¶0ØÙt
+{/n'¡_³„Ï'v>xØÜÁ‘ Xií‚[¯0FY8Q]EÛ©Yè£ûÚË/t	@…†õMW&ß"šÖl‰Õ@O‹hzVì/Lø!İ%Ô§×Mº_ø
+Î…,#i³7ø`~öğoh¬vÁ³•8ahÉ¸•,ZL" ÁZı’ìjÎÚ$gÃˆì¸N %ĞiØ$Uµ‡c_ÊØ×ø{½­F°'UG†P¥`£=fOÂQÔ«#+îØc	ÇØ8à7?ApsWH´m›2k”¦!œ.vÇC‰¬¦XªE«	t=Ôùòu'èK5GSd!™œ©Ê¬ º”Ğ5;˜›|Œy>rêN,:¨*k=Ğ^R¨®ş2½³ŸpŞÓŒÁÕ„‚Ø¡,x‚c'0+özŒk{%à=ûØq8€%sÕï’ºc¤ìk[ÃÌJNàÊÇ+!Ù)ÄQÿål/™^£N_†ãà'jµ,±¬À¨:©™Æñ§Ä|´(k”¥	’="z9ïıİİö´IlÕI5ÉÊˆ¶"¼Hu´D ‹)ûÈÓD<‡B£;Ô…çoy§“8ÃË)2éFÔá­Aıà™i0‰úê+j¾%‹f³ÉÖ*R.ëÀ“·Ï[,ì6aq¸¬ƒ m2Ú–ÉÉRÛüØÎMk6±+>VøšàÕìŒ=6°ïI®ÈÍb„3@´£r¯êb1Ìğh–>Ãv?\¤aI<j'1NDVú€¢#9ÎÈ"	ÊJÊFü8Æ–Á3Ú¤ä0ø˜ÅHa‡]>kè7˜"2ô¦”ÿšæg³€+\¼£A³µPÔà˜æó‹Â>¼CÎ[CPPÖ²{0¦ånsvß.ÎCšÙılìBÔüò¦fH‘EGÛ2~X…I\H|Læ@#s˜‹œÑšÇ9¼}?q7ø…,578±Ñ´¿fá¼–À–øBüƒØ€Jé3 4§9Dû	Ñ z?öÚ)ö¥w~™QP‡-Ğ,A†úR·5à™ÔZcÄ¹ôSª!	±€å®
+¹œüÛ.$ŠÓ—›¡$§úÈsÄâæ†h¡Öl"OAq|Á¸Ò/§QÊñ Ò~(òq5 ×|`üø£è%=X¦…æ9¼EÀ-sBû‰BX\ÌXØ]VÅ>B}xJ—-*A{*’Ö|ƒ…û)br®NÌù?ø©ı)IOªGÀsí‘ã?LP>–™˜*M®z¦(@ë'õDG%&Êöx!i¼´¥PAÁ‘ÜvZëj²5¥«j`
+âcvm‹Q2H™„RåÌ'*4lÃ9â“xÀ²!
+Ú‘•ıNcáwı³şğıM÷ì{ VƒgşÎƒÓd ¹dÍÿêğ“³cwu ÇÑÅ’¢ªˆ³uŞbÊÏ­]ND;@®İXŒ°„¤¯©8j4tKğQ[¡èÍñ2ÏÑõvD[NX£¶F-¹1€—–-µª¥ŒõÂƒeCôÄÊÊ6Œ½ ĞkLvRĞóä¤¥£ƒ&5ä7çßÊ•:À¥kËá™ğdxÕ½ºZÖœß|×¿z3è^ºI«ÃÎÎ¯ª¡5¿|@ƒî÷G'Õw~}UCB'——ç—7Çİ«.ƒ¥4i/:|õñàd°É46T·Œ½>^_\œ_^Pv®áñÅ‚}W¡÷Ï.€ÔÉù;Œ‡ÌóE›;ˆPB;­‚:•ßYo€ğ£ÈbAVßhÍÒ•DIôÙ-±)=caÎ¿…“dw–Vù ©=;È‘S),B	<ÊáE¼Tã›qUs/úRoO@0d–V/œ›ŞZ	bp‹Bä½ÕªéQ…çµôd…œ­èq:JŸDWp}¢–òIèi±Qˆ}R4–&üµïpÔBÃ¸0$%Ï’!
+uºMÀª„ëâœhòÔÕud%úgĞqœ7Qk£}\‚ĞÂwÇ<İo~S õhøğ™(‚ø¡ó{.ÏÛ&ÈØ?]<Bàü»ÆÚôêÖ¦ˆ-ÃÑ*œóû²š<KŒlre¦•N5ƒ_0UÚ¿o â¥ïZ0gş$g„ëÄ±¶ö•>ÄÃÈÎ ‡…ç¨œ¦È¿/È–1¯Õ Y~°-T5jAr¤ ‰ÍíƒÅ~^\_o†ıN‹¼ş‰!‡4Şa×qÊÿÜ›‡tgÓ†ÖP¼®†ì(!ÚŒ’È†n8.Á3¯ĞÔzç:¡´qäÄÄ‚¼é1>ËpÁ†Aİs‡„Q#¼FbËüáÖÅXıç[uX,P ¥¨9 ¨‡è§46ˆs—"šFwJóÁ]ØUÉ–‚‡\etù$Ë¤Ø=æ>uÔ„Æ›7ÄçgÁ	ugõ{jWi÷@7*>E†ô¹€W€şÎhaÕÖÃŞÏÄ±Â>Ãr8 ıãô¢i˜]1EÒ4	;ˆ sÄJ¦[¹²R/o 5—ªf}0ˆ“zUY¢º@}‚c½tØY\q·9­ˆ2ËÑÂˆàu‚÷{\RÄk¯*b¡.ò/;ñ¦½Ô±¼‹™êûø¢OØ‰ìÌªjÈfÒ$v‚^İYÛT}…ÓŸM,!B.é>²v$î9…Ä ’‡Èìi°[f-ğÈWX%ÊÉó<¼GŠ	M•‡G8{¡Ïy
+Ã=ÖW§gä‰'	`Y?av‰÷Ho¡*8eı´Wá Ë[£H‘¹cÎªR›{‡AÿV¯:Ş©İy¢œ®®ùï³RŠøEs^¾-ò¦Å•~F5XŠ†Ÿ\3Ã…şHÉMÊÉTÓªLU/g›Ìx÷ >•l—FĞS±ñ‹İ(?y.õŠb@ˆ™§EB$(­S¢4ı£ŸÅ]Ê—óeé¾9R/ø6H®êA@Ã©ÑßRZÜw)sumÅ‡õ«%WÜ‹ğ«,N•[Cıh¹ş‚ÎÉc ¤Ri§ëp+†0|uñÜíğ}É+Vf:—tÀoÍà„Q¡¹x‹ï\‘O*XŞtí®s¾\­S˜§ ÄwöàòQr««ó‚‹u²_fƒïÔÿúI”å6ş·ÎÏnJcÃ³É¨·fwÅ«UyÀ¢Cq¢Äc´En=ˆÌ‚çg\#«Z\äÙz,(à€êCFg9ìÁJi~ÔP°’Fµ…sĞN8!ò˜õx€J.±(”>–¨ıÉF¥ Ò ğ#*/›Fw÷1ÓOÆê ˆã(>Ì<Iœ…J£“m»nuèÄ½FGÑ$N<Ğ­p˜Ş¤Ã…Cë–$A3E¥CW=õrÖ×:°"¡ßD"GHÜq>Ü†inc‡£vß˜Ø|e^ã¿gÏTŒ£¶†şìÙO+Õ±¦¼ê)~ı5xÂ5ÅMÕ
+5…Á˜À†æ:Úª¡"6|…Ü	¶U£_¦¤îÅd­¬sC÷ÙnæõKjut*[•ÓŒ9»>=­Ã‰ú
+øM‚ t™=ó©kåæ\4{gEûÆ²XX´
+‹Íç3*’\Ì(/•‰KZ`]^	İC/%§æ	^_|UÕrGıás­=ñN«nnöDğHŒ–Á®§¥UE+àq:ê2”JNá-2q:ÒÕÒYâ÷`0YéóƒÍ<JUÃ¡¢÷—,‹Aîo©ÄjÎ­…ØU#õTßE»òE™=©ÂY¹I±F!ÚxÇSP'ˆÜpÚË
+Pß1ãÂúJC°â57ª²7RQÈ.5mà†RÂ¥F«à}P	g}Ë·Áîéz®*91ì¯&à=|DbòaİİUäd!<IîEù«.6A¡ê"½aùpŠî ?üêıåI÷Ø‚öÎİ³»S¿xït œšg¤6(]Z_5šPÍX{é*n$c®ys~q…8ô$¥ãÕ&y†ß˜Çz8‰®BÌ¿f7"°ìŠKP‹òWıÆ‡Ó …“|ôœÇ¥¾Æ våPŒ=í`f£~uµwŠ¼ªµß(A¨òÚû+^ù/ü_c‘·Øğã+p6ÎÅIáÆQ|İ?»z¾ÓŞ\ŸŸ}Cì¥ÃÂ³HBÅGàd¼¾¸„b#tOsÃÜjo~ÉÅ~Sé=;¿~?¼:HsµšZ<Éx¢ÖïNP¸4@b€Ì7ú|gëŞf6Û:çÒK¯§PŞ%SèÖÚ|E/ñÙW…V–Ñ‚	\¬P”Ë	¸ó'PÜŸÀÙ9?=é¬-ã%Uü»mh0…2ì÷èL2ŠÇñ†õæÂLmd+Iº€~9
+Ğ¬Ù7WKNŞ8ü.Î¡¡,o†7[B‰ş4‹dR¸ê´°‡ãû<ü£Fö	jOìëZ¬Åëk‘TÑXÛoöšÁğ/=óª³«1“;ƒ
+]DãàIôiÉ­<Ñ¡ëpÁxJó¿¦ğWØ8¼?ü×³èNÍ¼3^,(tœ¯Ô–ŸYtT-L .A¿kº?Ã|Øv,"ˆÃÃ•¦+±º‚>h*æ=¬âoHta.‹7z­õş†½¿(v2“™•¥YÒ UDë_´±LvÃì™àÉÅ"•È6p2Ÿx@*ƒc“éâw[¾ ş¨¯BÊ!œÕ~É+aRŸ¬±‚èˆ›ä ‘),9ŠÁ’³!°²ÃëÓ+yŞÁ{ˆ"ª îg»Ğ ÇqÇ>Áq)_èV©!º;¢3²ÕĞ DA`ß‘]ùÉ­­7wŠÉ‡Î¬œ'<Õv†ø?vÅˆ˜
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/71/5bb238666a4af7bf436965a759379aecaa1172 squashfs-tools-patched/.git/objects/71/5bb238666a4af7bf436965a759379aecaa1172
--- squashfs-tools/.git/objects/71/5bb238666a4af7bf436965a759379aecaa1172	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/71/5bb238666a4af7bf436965a759379aecaa1172	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1 @@
+x+)JMU06d01 óªxg†¼_æW36ìox³Â`ÿ¤kÇ¾. öv
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/71/962b2c28d04562e78c7ee6eec0cf2909b54cd0 squashfs-tools-patched/.git/objects/71/962b2c28d04562e78c7ee6eec0cf2909b54cd0
--- squashfs-tools/.git/objects/71/962b2c28d04562e78c7ee6eec0cf2909b54cd0	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/71/962b2c28d04562e78c7ee6eec0cf2909b54cd0	2022-01-01 15:09:15.593172588 +0800
@@ -0,0 +1,4 @@
+x}RïKƒPíóû+†Ú,ÛX	Ö`³-+F¹`D‰ÓW½eOqNúAıíİ§®FÑË½çÜsÏ}o'ÙÇïnî‡0M¸Wn§0ˆÃuä"‘¬mY¶©Ş.?&¦A'›®±%/0Û2Œ×G£ê÷Ô \Ä„äx&i¿Ázl»Ó¶Øl,sÒzô©æ‹˜ß¶»GwcE""\ÌıQÿÚóİşdBœsÉ³ ç%RS}0 î"Šh<Mà–P?
+öötª)ì:#LÉ „Ì±Täš¾¬èK¢Û–YUGËĞëáPÇ=´KM|iThª¼I½ê¶åKÜ7SéOöÉ6Æÿ:œ¥ùÓjCEa"W9ÊmT
+ZX‰wîçå¯r_Ao9‡‘ª·º")Õr/NICªĞ4[H7ş
+"ÓÙû³éYßúƒ¹7Ôh#-İd<_g…óÏø.İ™Zşß‘ë^t¤µa%;¾{şMÒÂ¯QµeëuT?Jú’”Ã-
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/73/84b0c32ae9c4d0b6dff1b3b34152f35e6099d4 squashfs-tools-patched/.git/objects/73/84b0c32ae9c4d0b6dff1b3b34152f35e6099d4
--- squashfs-tools/.git/objects/73/84b0c32ae9c4d0b6dff1b3b34152f35e6099d4	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/73/84b0c32ae9c4d0b6dff1b3b34152f35e6099d4	2022-01-01 15:09:15.601172588 +0800
@@ -0,0 +1,4 @@
+xTKã@½¿ó)Mz6i/Ôó´µh@‹¨½<YÒf[“İl­bï»ß$›Ä$ÅR¦Ï73oŞÛ©/¦`u¾¶`.ûÑìùàY³ÚíŞäûSs"‚÷Õ¯ÚÍrê³x"p‡Ö¡¦í°9÷èŞLú·ÃKr©í`qZ©i‡-íÊ¹¿¿‘ÑøÜéÉdÜ¿r.ÆP—Ç¿4 Ó ä Cˆ¿X0¹ƒëûbE=÷…Â’»>[p¬4Ñ;¸³ckl^%)º!;Ô„Ş>òª@>»Vwã{^¸XiîT,%ş@c
+a$BIFcs}WÎEh™9¡N®‰óĞ³X¯Ëµ»[/õ¯ÏëEÂ:=›*’¼aÍîb¹¶¢O¾š¶C¹ÇæéI’‹4ƒ
+*'Ì´õĞ ½¥Ï%L.MZV?»¥ÈµìXH»»´»uä]Ò=áÜÏ€–tÎùàtÏ8ÆE¨Sü“Ù©<±M<x—4ã~l?Áô”Ê´&„ù''ĞÃİª¤Ùrğ½Vú4Q`“ì³ÎàªcÇÚÒ[âhŠ}+ÜJÄé¿ï¤p«»±PvƒÒåreĞryµa=øèSÔ×)‰T½ÖGê¼y#Ù­Šİj÷ÀK&‘Ç¼HÑº³3ÔªŠÚÔ¡(T3…©cQ¥cø—˜ªHIĞÆ¨°»[ Ègœ¤Kñ»!ù=º…³S0;ív"T¹‹ÀÆeÄxÌf:™âŞñÊÉÒ|al‡àÿ!{Ù”ªLYã©DUFE·$|•FY¡D“öªğ¨xnò40K/®©’Ûh~Ì
+Z	…ÿš›U:¿l~••r´òdâ#°±Ì#Z¢ähÌÀ€f)Q‰TÁÈ÷SÀ¹S ¢2KÂ™;êóĞìeİú)}Ò·¡şÑ|ú$ÿæÈ$·
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/74/bb180fddc9bbadf0163679fb3660fc7a47c374 squashfs-tools-patched/.git/objects/74/bb180fddc9bbadf0163679fb3660fc7a47c374
--- squashfs-tools/.git/objects/74/bb180fddc9bbadf0163679fb3660fc7a47c374	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/74/bb180fddc9bbadf0163679fb3660fc7a47c374	2022-01-01 15:09:15.613172589 +0800
@@ -0,0 +1 @@
+x]‘?oÃ Å;ó)NÉÒ"+Q«J:ÅªZJÚª¤‹äÀ¡ ¨êO_Œ!aıîñîq;ÂóãÓİšÂf(Q8‰«Ğ5!K­¬Dœo^VÅGYñ7²ŒH[¼¡Ql…é%Âb3ÔÏ«ÓâŠmqb‚*™îšı–×ï¼È¯tµM"´R+BXÃ¿*ö½; ›³İg}€âUdz@ ¿­øO>ƒKÍ‰P•öŒ@\ñ1·mG\³¡¶,tØú´Ïz4ÓÍÉ4ÿ±—¶y¯vMJ9úLe×‡¹>&â"³e¬fHgúÙ9Ş£ÌÆiB@ÛqPûVÛ‡—øÓşaıç
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/75/dfdcba323215076e5e356287a12ba381427584 squashfs-tools-patched/.git/objects/75/dfdcba323215076e5e356287a12ba381427584
--- squashfs-tools/.git/objects/75/dfdcba323215076e5e356287a12ba381427584	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/75/dfdcba323215076e5e356287a12ba381427584	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1 @@
+xµK‚@F[Ï¯¸ØFC|d´˜Vjîi-^Qg¢ı÷|´Z·=÷|÷°V0|oåº„ûSt!ë†­.ŒT•auwjcÁ&o Éœõü`8\®‚-ÄQœ,;ñB”()M5;7­BiF…°)s•ÛğÕûæ‰y ‰JK”NëXğJeÎòhÙ1]U(/¢·Á·äı=â?£Şı ÀÌa¼
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/76/fa536b01977d6a9dd23b77919ed1437fc6a51d squashfs-tools-patched/.git/objects/76/fa536b01977d6a9dd23b77919ed1437fc6a51d
--- squashfs-tools/.git/objects/76/fa536b01977d6a9dd23b77919ed1437fc6a51d	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/76/fa536b01977d6a9dd23b77919ed1437fc6a51d	2022-01-01 15:09:15.649172590 +0800
@@ -0,0 +1,2 @@
+xUmo›0Şg~…Õ|I£hQ³©Ú”OÉ¤ĞV@5©S…\¸4V‰ÓWõ¿ïl 8t[P„ğİ=ï=7™¸!'_¾?ôØŠ§°"q¼¼š^´ğç‘çÆ³¹{>›ñÂé¡–qè6pzŒ'Y‘9úÁx*Îõq}d‰—Wşô¸+Ro¤L¤ÙNã8êiÚ»\É"Qdù¼¡3H4ÒyqqÊo¡’Ml'6øÆT£ö)ãîZ°¤†ä?ïÎŠM¨¨‚üÚ|_ˆ¼<úôñzÒÂ ’u7E €í!˜“C@ãC@áZHÕlËL•šHBL²ÿlbËLÔù7$Kà‘ØålŠ÷ sÀRYlãŠÍĞT%,Ë…p; ËËúmèÚƒfì–WºBøC?š¶hZÛœtCÁÖ§XòFh\^Ú]…İµ»ãÒ;‹>?c‰b‚Sù²g¨.ßiëDø4¿›8¯v{›kÁ<¼\F¶Ü•€ÍÚ·²f*»pgê]Ôh”ã°„0éq'-—ÏŠ|İ?&/D‚*$'8éåÈWš	yÕmê™€f}}ıØ”ı¶cg4*U^¿
+àŠÑÌã¡Âl´1ã1.< ii¨S{ú¹ünŞÊ†°(w«ª1Ã¯(Tü`¶Øğo”¼æÔ)GÓ{ÁR;(Wğri	Ù·å{!›~ìÈX7rhzCµb«‚GIãZk1°©Y²RlA*ygohÑÇCPûíİÉQ:‹A÷&úvæj¨şÁÁ†¼ÆT+÷Iş‡Ë¢àQiİ;·ã`j‹ÿºÿHêy®Ø§<e+ç78/pı
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/77/05f139f3e2acd56231532f76ebacec33b36f2c squashfs-tools-patched/.git/objects/77/05f139f3e2acd56231532f76ebacec33b36f2c
--- squashfs-tools/.git/objects/77/05f139f3e2acd56231532f76ebacec33b36f2c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/77/05f139f3e2acd56231532f76ebacec33b36f2c	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1 @@
+x+)JMU021a040031QH,ÑË`øôêÁ<ÇÇ,mm¥ßÙmï¸¸ĞC¡À¨Byó©WÕu+Î–¨ì‘õä¿ÊmùI…PÉ]Ëäûárª›¤´fÉKê=Ù×¤$¨äÒ¥‰'Ş}~«Şüqæ“Ïnjõs·ì+F(1™Â/›µº¢÷„‰4…‘ÄdÏåWj]·"”˜€”Ìí=>“çÿûÏ_m¼6íĞxuÃ5$S|3ó€ŠxÙ>:2ş˜›ëœ–ğ¤ßSçâ»§_ÜKdv
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/79/21fe41a3ab6ba7582748f708e04d6b5d45b5d9 squashfs-tools-patched/.git/objects/79/21fe41a3ab6ba7582748f708e04d6b5d45b5d9
--- squashfs-tools/.git/objects/79/21fe41a3ab6ba7582748f708e04d6b5d45b5d9	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/79/21fe41a3ab6ba7582748f708e04d6b5d45b5d9	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1,5 @@
+xíXYoÛFî³~Å$
+R–-‹I*€B3† †è!†ZÅDdRàÇ±ıß3³¹¤©¸j£@õ"íîìÜßÌ¬>¬£ğêõË¿şh·Á®®¢°=Mã üxào6Æ‹ ô×Ù’Áóiºì­¾\>§ÍÕ’­À]ôG/­	]´£ğ3‹S¢|ÁÖ	+ıôfÃ.Oñ \+}Y6I©ˆ¡eÈÅÎG}{|æ4×ş¥»)olü1ßlXl¨=ßlÜ6 ‚>œœÀ¡‰+€˜¥YÂá®i3f	œ@Îcaƒ‹Åt61,L‚![B¦¦oÒ-âH!O¸»ƒn÷œ¥/I8bÃ¤g2O\»7¸£ñÌí/ÎĞÍœ³’JÙŠäN‚ü(LRŸŞd«‹§ÁW†z¾â‡h0$ïô“=è¼ç
+â0»"sÈ¬nw,­fÑ0[§Á››”ö…Û³/ZpØ‚?ıtZ´t9üä07¸à'­Î7Nõ[%ë|R&y§(ß£.Üíİnîé‘pİn®Ù,Rêê:¢rŠT˜ß“ÑDI÷ÕlD×ÿ:8ÿ³á+ûáÙÀ=ıC²¡‰ÕA´r}h&E@˜ìX DÚ>a)˜ï	UÁC°ÌÃÀ–LìèØÂ½ƒ¡÷‰	£t0(síhsc nQGòbgjP+‰0<ùh@*\WwÈR¸ƒï$œ~ß	«Öwª±µ› \!ã\¶Dìq/f–`6¨²Ç&ÜªÃ>XG€ “"Œëµ‡»Å+vuËÂŒæa!Æ¢¥	"…†L|cìM;Ÿ:÷ÌyÛ›f-˜'3»^tN?±# Œ}ê}›GÄ[µ~ÕƒóZk"jÁİ+æ€'íß•'ûBÕ‡¥t/!ªc¶È:ñÙNfBĞ	bzÁHå3	…Ü…í|'x>õìf9¹Va“J×&3G²'ù‚HQ¬Ï°Qd{‰Ê³Ÿ¡êh<ºısürìŞÔ»G3P(¯ Vƒ’’yÅ+<^l)§sî•İuÿÏ£Gúv;84m'ª"¨ÙFñWÂß™æ%DÒ(ã³>ä˜Ì¼Ö>¨˜»çÂõe°f`¤qÆh½åA¥ŒßÁ–ŒàİÛ£
+P<|‹ï[ÕıŒèõ‡‰´t3£›%
+)8	Èà2ËTía¿#®Ë³Sı¬|Ä‡uÜ÷è&áiñì*C‡7%Ù`~­‹òG¿ÌU<œhÏÔüV!&< ÎI¶"¿cğëı€g§ú™æRƒ†º~¨hİxk­F[ªbÔº@‘qã5kóıJ–ü,Ã~¤yøÆÀñŒ`*`³M-@D–(¨Eˆ˜3PBFîs€mÏ5äˆÿ7jÀRrë#y0‹ğŒ“¶Îâ	UÓí§¼ŒŞ«¿Q¾ée¼
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/79/2b29390eb65bab497cdb3fc67e670cc7c80a5d squashfs-tools-patched/.git/objects/79/2b29390eb65bab497cdb3fc67e670cc7c80a5d
--- squashfs-tools/.git/objects/79/2b29390eb65bab497cdb3fc67e670cc7c80a5d	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/79/2b29390eb65bab497cdb3fc67e670cc7c80a5d	2022-01-01 15:09:15.661172591 +0800
@@ -0,0 +1,12 @@
+xÕZisÇÍWàW´é½ ÀKÎeÑ¢CI Å˜€,EqR[ì ØâbŞCbû¿çuÏ±» ÄXù—,rçèkº{^÷hœê1={öÍï÷º´G¯r•Š"*~ª¢b>-hš¤ªX¥ZİÎ“‚ğ'¢y2›§+šèÅ2WE¡bÂÎ˜t–®˜Nc>…²^®rl*)˜ôèÙÑñïyôf¤i²¤K]Íæ*§o—fà/ÿÎgÕı©¥",s=Ë£2Í•¢BOË‡(W'´ÒM¢²ÄIQæÉ¸‚2IIQêœ.tœLW<Ve1–sE¥Êé©||ÿö¾W™Ê£”nªqšLè2™¨¬P¼=*hÉƒÅW²ãœeYè\ƒpT&:;!•€|NT^à›õ™„Î)ˆJ5'½ä…=È·¢†÷k>¡o­VLI&ìçz	æ 	¥`N+ª
+5­RáĞ»‹Û7×w·töö=½;ÏŞŞ¾?Áâr®1«>(C*Y,ÓŠÁ˜y”•+Ø„%¾_½Á–³——·ïYƒó‹Û·ƒÑˆÎ¯‡tF7gÃÛ‹Ww—gCº¹Ş\ğ•¬õ™À§mJS[è\Q¬Ê(I§ø{œdéÒ˜æÑ…¨äd‹àsK–L”ÿ4eæ¥:›‰šXo±sBÉ”2]öé!Oà ¥Z­säíõQöéßĞ­‚yİ¤ÑDÑ>*Şûõ×G}z©‹Rg}º:££gÇÇÇûÇ_ı©Ow£3§8O&á4f••ÅÁ»İ/“l’V±‚ç—s¡ƒùic‘w˜èI™¶‡«î½¾4™eÑÚ:Ş^&ÕŞÍ‘‘ÍÖÇâD·‡Q9o€g„plI¨ò<[Ûˆei2n/‹“j·ÇDºÕR›ÃE­-N2c…Ú:;“h2WÅşO•ªğQ	»Îw\	§k‹{7ÕŞ mtŞ§ÁÙ£µ‰$›Bñ&;—·X;}lë~«i’):?»èÈßïtÜíªHá´ªII¢$í•:lúÒÉÚªBıÖ+Q’ùIVR±ŒòB…’Oº]›ó‘Ã9Oÿ‘ÆH!/G¯	fÜÕ‚4r—RZÔç<jæ$nµ¶_æ3C¶d>nh–Væ«éD÷½îÏİN•ğ`DødazL/(XëÉ½b)ìŸ²L'È9óÉ_ĞæX˜ñªT¨5îŸÉ¿UßÚsló>}ˆÒJÁ.ÜB*0÷÷{ñ:n`Û¥ã}‡ëÌ0<=åï_èèãŸè¹„Ç!IGˆƒÕŞøéSşN¦êc)Ì‹;ğÇñé'X§ókº–*ÎØØkDÁæ\•ûœ÷I{ºãá<cœ@.ö€­4û$éRşbÕûr”b˜F'1DÇÙÉaéé4,‘„§`Ê+Øh·Ã³Wƒ`gøsÈ7¸«õ‚–ºHøÎƒ™¤éÇ¾='ñ?³>”6Œ…i‰ÂJi¡Ô}Àò_ŸFƒÁáhpÛ£/h&ÿÛÃáõpïKŞT‚ë¥(“Lîešâ¢áë[M"Ü“ô¤èÓÛ{ôU¾0¢±@|’Is=ruœÙÇ~%q§¢ºÈ.â²µ¬‚=úÖhÚwh ÓáÀ|ƒ¬aşÔ8ÑmÁ5S¥¿k|ôÙ»¡gƒÁM°q$Ù°2§>å˜-i—+=É¹<_ÑàÈ½„)¶‰bâ½O{.;ªØ²Â†ÚãàyS=¹Ç8{$p%@â4VûWs‚ïŸÊŠü¼IÅì.ÈhÜÜ—ZßWK¿œ„,&¹1dÍ…A¤]kUd_}ÄmÒçÔ—Œ)9°VÀA:!$~Í8RĞDnx0Hâğ`™¼+·@MDİ‚hsÀ0¾
+æÀ—åÃLAHC“¹`lÀPÆåÌe¢cõœ·òÿãºªÒ2adb D!¸H2¥«8=ƒNà¡†Œl&¢"Z(2GäğıBEC|3J™R1¤Ò+wŒ¥-`İlÜÀVc%1ü‰ĞJ †°¥ %òäæk„ãƒ1»^8UÁ»¸Ö”€Ì$g¬œ@BİÄêƒp{ X;şøâ
+ØUŒ$ùPÈf„üA¢Tìİyv@ïØÈÀ“le¬•YM«¥ÀcSHîXq¡£2`?`OÏV<«x.'“é|ªÁÏ	}·›¯Îˆ•P;Ö¹¤bp+ƒÖs .Òãö:;¢²©²H¸("„ß2Yª”İ±Ø/&dÙ. È¢$H›ÒÃÃ"dcœ€9^ç *{v;”†“NQ-ÃeUÌƒÀ\=r³À‡a•±wôiGÊ§°ö^´t£P
+Úº.1Fu¡ñØ§§R#I!#€—qHf„ükH˜Ûækdks–+Øîçô¸G3¸wü5†7¾ƒ(âøğÎW´ÈÊ"Zõ¨j¨XÕ"øæöo¤"§’Ñi•µLğ¶<â;aö¨}ìúPäáşkX&³u³U†o’³0›ŸQÄ¦—o3_‚úu›/š~Ã7_!™¦\ëEƒoëhø†àƒ+Ì¦µ`¬f[hÉk\GéC´*Lâ$C
+	@^Ê^î™Ùka½ÎzJÇğŠÌlÀOÜñ,æHuì­Ì²—]qÍ=ºoóˆ˜–êìœŒŠhª¬[\iÜ8'€œÃ)Æ×%”Ùó-Lıï1ˆÜwll3Œmd€`j®ÕväCş:µ|Vrra÷x†Ú\Õ‚:q×/)£qª~”û”gÄ‚ùÑßîÎFoÎGá«ë«›!z%ƒ×áèâƒğååõ«‚9Sğ™4Ph¬/jA$g\¯½^Çbœë6îŸfl2&c.»|‚5.dKsrİ8¨Æ;ŒùÄÖOÑWgÇ?óZx–
+HæÆt)7Ôv¯IÅYY!€ÂÎÈëQÿ¹ÁóÈL»N¬’*;¨nßá7“Şu;/Ï^‡ÖÑ¯euc4ËójYªø;¿ŞíoˆÉfãoõt&Ñ9®÷!VDM 5°±QŸ˜†U›)¤ğİ• ¶ä¿ÃCzõ×7ÏéµG“\LÉ*`6î£%Å2VH@lx`‚ ¦sxX›5“Œ4õ~Ìá…t÷iä‹´ÃC8N|ÿ4|ì›5|Ju)äö`Ÿy.Ôb²\Ù+Òi¿±ÒM°˜¨w ÏòŸ¦‰Åj8ÿ±gşÜÇÔ‡Úm½3|¦óØÌh2œE%6•CU3l ^»%æQ 3mËGĞÖWŠ†´+¥‘ÔèĞ_>‘IËÇW‹Ü«á—éÔ<V*öá;¶wcZ0{®%Ñ,"[|™g]Ú²1Z.Uf´g>`NK¾şƒPû§N`_v;zH1M­æ[ï1Ñæ/Ô¹ÿóMÒ„¹@ç‘ˆ®|âÆv7YìO¬2"túêlšé¶û§f,#¦±×£µ¾˜§yiÏY¼Úú&Ø€8jªk‡iÆ¨î\CDrP§-±!'hæÎm™¦4rMx w!(·Šs_S?lÖN“P}ˆ¡“£¦¶¾”‹<ñìæZîò±1Ú|·ÖœÈİ²æÛŠ®†Mˆ™ÂH†QíÆ¶Pjô¤ëf¢"™¡×„&"gq“@§qÈ¿AÂú´ê 1M:¶và)¢\a°k·sŠÃ¯Q7GÑ-»øşâíí#³·ƒáÕ#Ów£!ƒ
+oË. ]ƒdPƒÙ1üæTÀDDŒãÁãT¬ O×áğõõÛË÷LšıK¥™‡Ãi$ToH4S#îÊ0µv·%:_úˆ3“‘»‚H¬ÕÀ9üªÆCç—ƒğêìï‚Å,÷ÆÎb¼½»¼d§½\YX êlxÃç–Â®­l[–Ûze’7LÎ†ìÒÈ‘Ì‚µ®?ËıH¯gÙ[|KÙ…‹kÇ7Øl2)Ÿ»)á²Ì™Tİ£“}.£¬§	ûdÀ;Ä}§i4s’àæ–€ÇQ¡L÷™vw­Ñ5Û?„ÜJ…¸ÉÚi÷¼Ù3ø³¾_nÀÇÆRO¦EÜhÅ®Ş-ÕM¸
+İ²%÷I`Aó.èyÉí,oµ~È´@£ëÖexÈ¬Ë{×ÅÛãBõ•|­Ğ33;ÑY‹È7°Ğ{93órE((+~¯k½ÂXz¶©IÑ\ºÉèj¢5»í*šDî}›ş¡k‰%…é†·›Gf#?ŸÀißÿ“¯Våm„€™bM‘ÙéµÀ[Ş¸õ.İN¯‘´]¥d†ÎŞcÅ^&Z‚ŞÂó:†|b†l XÙMĞd3†ï±QÀa†Ö?ô£Gó€—ÔW{q*8FŒàß/øóD”İÂnšãwGšb`fËğœh š‚_9äŸ54Ä•y.ºí•gÓ.(ĞäN_lyo²NîßèĞM“Ğfk÷f¨¡ #ì½9~²uEM}¸Ÿø·ª‹nDÿúãë»›ğªU¹¿EşW²>é7û{í	s#7Àç©æ,m—D6V™^­_&u"É&ÿ[ƒR+yã‚½VÍcøåvÉcËB¶ —µµÙùÓeıOC”'º–Œ›ØC˜ËÂ­µ.<L‘¥m®Û 
+Ë&©‹3b
+qÓ×æ÷zË=g´Ìğ!ôğ+¼;$–%Æíb‰)Î>&XkÊ{±Æí»·ÉÁ>€9JOKÚ@6„²yöØ’0ıH˜°;v š•9¢xÈ¹Ì´Cı›3Ş£í¦‰äŸ ÒılImHk±ùkøkµY„¦æq®Ã/ø¯—xxÜu&•ëRâŞlDº›p|7ŠºfŒ·£\gøË?(:ZKZä&§4zMÕ§T›·«gtâ*[ˆµıßÔÜ\¸/–&=øP—®Eó‹
+M¾®f±IãĞ0]¯w›¦Áù	óF¿gd7”…yLYOƒ=öê£’%5®ƒÁZĞ-h;XÙJÄ¦+³Fq]èÆÁX óH*„¹y—]aÒÊ¦&OH>èŒ°\‘.Óo»F«c~íş8¡g
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/79/68c7796b172c9c66739b5d4d1a2ffb6619fe92 squashfs-tools-patched/.git/objects/79/68c7796b172c9c66739b5d4d1a2ffb6619fe92
--- squashfs-tools/.git/objects/79/68c7796b172c9c66739b5d4d1a2ffb6619fe92	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/79/68c7796b172c9c66739b5d4d1a2ffb6619fe92	2022-01-01 15:09:15.657172590 +0800
@@ -0,0 +1,11 @@
+x…WoÛF½¥O1Õ¡mÈ¶”¤(z>§¤ş!Ôµ]YB\ZaE.Å…)’á.¿{ß,wEQ¶[#ˆÍİ™yófggfi¾ ÷oßÿô¯ãƒ.ĞÇR
+#IşR	Äšb•J½ÖF®ˆ¦‰Ò„‚µLÒ5…ùª(¥Ö2"hF”géšíliáÓZÎ‹u	%CA¸OoÃw}şÿ=ïİ%*MUA×yµLdIÿ-ê…ÿy/òryT=œ9[Ö¢Ì—¥X±;q)%é<6_E)OhWŠEJ›R-*PR†Dç%®òHÅk^«²€&‘dd¹Ò”ÇöãòfF—2“¥Hé®Z¤*¤kÊLKVš
+^Ô	x/ÖVã‚}¸w>ĞEÃÂ¨<;!©`¾¤GYj|ÓÛ>›ÈK
+„aWKÊÜ‡kJşìÑ+|Z©ÌÂ'y
+	L‚ÔW„“’*-ã*µxˆı>^İÎ¦4ºùD¿&“ÑÍôÓ	„M’cW>ÊÚ”Z©1³™Y#&ìñ¯ç“WP}_§Ÿ˜ÁÅxzs~O·Ñİh2œ]&t7›ÜİŞŸ#cîĞg¯Ç”b[å¥¤H¡Rí‰ÂIjx—F”ˆG‰¥z„o™W°g–üë–W¤y¶´4!Œlq‰sB*¦,7}úZ*$ˆÉ­­Ö9²zs”}úá'šJ„GÒ]*BI‡t_±î»wƒ>}ÈµÉ³>ı:¢ÁÛápx8|7ø±O³û‘§£²8?
+aô¸Ûı·ÊÂ´Š$’İ$|w’³­E\¹c•‡&m/W2zWT-3±#ÇêF­d[ª*o/­„IÚ+¸m-odYf;ŠKÕ¢-©Rf¦½f=YR?_ÖFì
+ã¶f»	EÏy½­Õƒßj¯ÃÛ¼l/Ù3GZˆP„‰Ô‡_*Yá®´± ]ö—^e†4* ~ÒàÄ/£ªT¡!ğóÖA½3»¾>évİyÎqqŞóút±Ş}ÌU-©œó^°ßıÖíl+?y±ª@ùpR»hvKÙ­œt7úiæ\†3±’5Ğ+vÀ.ÀÁŠOéô”˜Î~·Ó)¥©Ê¬½x†Â5‡ğá™®’èÿƒ?è»Szóyğ†•Æ7·Aï{}ü½şœõú>TÏõ¶¶ØÓı$E™õ&pR¦Qµ*æ|\¥°?ò9Î<€ÙnÇÆ$z¿ñas7 |úÄÊ•&6_Ù/yúúO-Ùˆr¨iQÅ1Ê·Í&
+øVÛæb[ãáª[Ìõu†W½¿ïğ,«˜|îÄZ>WÙV«K±\qÚ¼äz#ÿôş	Á
+q=æ¬ØÂu(¹Ş¦İ|oØ(®„ÊvQ[,µü2ß0eé>[ˆ[<i>x¼gÁópÛ?¡Z(­x"|x!{çŒ3–'ÜĞ{æRË‡KÔ&Y˜—ôô¶h³¼FûUÅ¾b’´ªR£m@|›sèhÜÀŒÌ^@¯ì±rÂ´B°…Ø
+´¥½·¡»“µi‹h4NØîÉ#çô. ¡k‘¸½¶øRĞ:ëŠ®§IŒV,·¹C-ëVÙİ±y}ñZ5§º·; ]ÆMy á!°ö´!÷«wQK6À›šáÓÄÏ¡½À3ô¶6şRLkôx½I-o0×¶ Lr0nÇa½9èşïóÚ¹àjP|ÀÓ@–˜Ûœ/‚; 0UÈTe¶ğbPÅÆNÖB˜\±—¡,&áÃ‹§oíÏ­}{úhwÜ]w‹ÿ¦[ø¶`Ö±T«¥–M¬„~@pı’ç(]È6œÒ7:2sÅSöíŞü5 '¨ÖsÃ³¥»Åvz€IµÄühÖ€
+öüæuEÛ«}º_ş6OÿfûjvgIÛ÷éê=š¸å>Ì–áşgï#ŞÙ ÷m‹ïÓ'ÆP¾û6Šµ5L+ŞáZÏ"3šE8¥C‡ßÑxQ„I`gÆÚ¥N(´¤óÑåh|óÛ’x´Bnà}e#~‚`.ænÕŠ/@úbt}=½šÜÎ.¯œXms|34&cï~}›ÁvóâW€,ûèÑÆ¢AF˜7šnñÈa¡æV’ãĞÁ-¨ºµõ£Ÿçç“Éí$èmÇò>>ãé‚ªîR¸·¡ÀŒÜ„l²ƒ©Œuç	@ÈM{j.îØio¾s‘pQÜéx¦±ÁAŞàåû$A€Ÿ„.²…,Uõù†ıùyóxb%çw_ıxDæÄu"‹êûêæ¢úTšCrtÈMiíù;OÍª2e¶æ\?‡¨éÖöüMD…÷™è—ÜbôÔı|Wq
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/7a/d54e8de15708849f9c29b4ab239d3df5a895db squashfs-tools-patched/.git/objects/7a/d54e8de15708849f9c29b4ab239d3df5a895db
--- squashfs-tools/.git/objects/7a/d54e8de15708849f9c29b4ab239d3df5a895db	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/7a/d54e8de15708849f9c29b4ab239d3df5a895db	2022-01-01 15:09:15.653172590 +0800
@@ -0,0 +1,21 @@
+xÍ[isÇÍWàWLè’J %Z±“XJ!-VQGxÄ¥8.Ô[ZìÂ{ˆ¢íü÷¼×=3»‹ƒ"K¶Êeƒ¹ú~İ=%ÙÈì~ñ—‡_şáşİ®¹kæ6*­‰Lñc³ia¦qb‹«¢´ócÎfqağ_dfñÅ,¹2ãl¾ÈmQØ‰ÁÊ‰ÉÒäŠû4Vá£ìœ-®r,*Mo¼m>°û°Ïÿÿ‰ß½šÅI/ÌqV]Ìln¾^èÀßü-v²üb§z³çö’k,òì"æ¼Î4·ÖÙ´¼ŒrûÈ\e•G)n4‰‹2GHŠK¥“ûYÎçÙ$^q¬J'8°œYSÚ|^˜l*¾}qn¾µ©Í£Ä¼ªFI<6ÇñØ¦…åò¨03Ğ=º’‡¼Ã©»ƒ9Ì°qTÆYúÈØÛçæ­Í|6Ÿ÷¹E–›^Tòª¹Éœ¸û]™ìsw6Ğ[“51q*ÇÏ²H˜aKu	vš‘5Ua§U"çæ»£³g/ÏÏÌş‹×æ»ı““ıg¯ar9Ëğ­}ku«x¾HbfæQZ^'¼ñóƒ“§Ï°dÿÉÑñÑÙkRpxtöâàôÔ¾<1ûæÕşÉÙÑÓóãıóêüäÕËÓhÌ)¸ò¹Áfš)6›g¹5[FqRxÂ_C’n—LÌ,zk!Ñ±ßân4oÁ›	ñ›wæ¹Q’¥B&&C[œâ<2ñÔ¤YÙ7—y)3Ù«%G.¯EÙ7_üÕœY°ÇšWI4¶f`N+®}øğAß<ÉŠ2Kûæù¾yğùîîî`÷áƒ?÷Íùé¾'gg¶üXÙ
+? ?e±3Æ÷»İOâtœTİ/g4¥Ù^c°('I<ZËãôbylgª×nÙ<ÏòÙVchİE0¡kßAûRèŒe2fĞÙi’]ö0Ğçèö£æ”y•”ñ"¹Z;¯ûÉÄNãÔš³“ó³>îŸ˜İ.,³—F˜aîÊaœÆ%3Eü“İîşÜí¬™e›y”$Ù¸ÇYÙ´×œ³+v;ñ´§û>~l^œow;çÏ‡''/Oz~J‹DîÕ7»Ûæ—_0¹ÓY%3Ì=³Û—ÛáÜ·Y<1w··¹û“ı¿»İ·N9¯Ì2Ør~Ç“*BÜ¿Ó-9]n7Øƒ‹ˆVÈqÛBõ„@IªQ~ÙFÒÜærßÇrYîÜT¯uEıùù¦8íÎá3ß©<>uód¨¯ülÌgé¤=R^İd"œSæu;¹-+hŸ÷¨ûŸn·+¬ÏÃEU¶íT¦o”]ä¤(µ'…/¨šqb£´Z`“bÖór3ş[¥µJ¡Roú¦E.ùŞÆI½å9İÎ%"–íõäd°RÕo°çxKš;áÌ¶j:ÆŠ<¨Dş$aée[ğ)§ü'¹ğ²}ïvÓ#À%È“ZêAÌ;íÓŠø"’pˆ°I|à`¶èíâ‹ g¹v­xD$µ„~™4™Ü`º²ãz®;E^e»³[·5?yî‹,¨¹îmÍ+„~^Õ‡†‰ô—äAù_'`<*sJ‡† 
+ëŒ'ŒÌø¸Â‘#k'äølBÅ³öJNÉîòA#•èiB[o†ç1„è`iÜ1´ÕÏ›üûÉäLªùb(»ü¨Y r”ÓŞÖ¿ËçÑ;-w&ÍÉñ­ïi”ø3`¼4ğm->|½$gó_ä¼ÔÀV½ø
+øÜ¶­ıîùéº¼¿|^íkİşß˜-Ó;xşêìõö–‘İ{ŞBİŒU]qÙæ^b`³¥Ñ}E»Nóş]€\F…ıQ¯l[ÌLizäôtÿ˜púì`xzğá³ıÓg½Û¦u#İ.ö|
+DDÌ0/0¶Ş\‚…™Y`hì}ôâôàäL6Êô0T0†ßUÕúcüá˜eÁõtœ„ß¶×+ÈÒ´Ï<9xşòŸ¿Ê™pE‰¼jŒÄ.$\tS°e ÇÜ¿*T'°L´sØd-¾[´ĞCÊˆ9·óaQ4µo!Puk¼ÚÚofn ”Ú»5‘˜!ÌR.ĞÙáà&¨
+ƒX9ö0•ªéyé]›–ùÕGö 1²î¼ò‚4”¡Šçª^ˆq˜_>ö¦yt1ÇïîÎMø¡á‰yiîİC¼µ	²ù0cD`×øº¹!½§¬ıï+Èa)bSÑ®sëX1l`ª0Øb(Ùt%gÙ›Aµ0NFó¨Ï†›2aÃé!²Ş)«H¦	·ejMÆ*Åe\X$şR)ãDª&y”»à¼û`
+¸'îêñA_"Œ"TYG›hmPÿÀÀğûgÈuU’xÔ*õ=ıõê8ò³åç`r ~¦ôçé^VNg„ ö†‡Ùz“…×¡øT`[\;Î-µ™2tK¢jÅ,Õ‰B÷YÛ‚@çÈØQËæ*#Vt	$Wß m!Á–ld08+	³švÂ)ÜX~¯…v:O4@®tìét w:à‰ò™eåŠ3TFÖ‡ğ%Ô¤ PÅæÓb
+Ê‰!á‡5©O	‹<ô[Á“*ÿ À(s±aS†á¦IÒ<â«àÔéXŸ‰Í×† `xzô¯Ô·îİÛ—äîƒ½†¢ÇÌ´xS÷õ’ô@kÊ[J›98&5ğÇÃÖ0"¹Î•{„Œ„¡òãòQpåã¥ûÔÀ4ÜS#ÈWq6ø#÷]È(,ÄsT	Wp2O$Tå?=Æ‰Mhz;H©èKüóupòéşÓgŠÇÖ Ê$‰FÆoïV1¥Ü# J÷©®õù¬*Nì»¾ø«›Ÿ¸Š(ÿÇ!²+÷¤™@ÏÉx·Zë´6Äu,8>:=ëqƒ@{=İš¼÷íæK¨z¡»òCá-K£ÉP”L@ò<zçp\!Å\xÙbu}3L€ ªTQ2Î‹rH"È„&Pn²$ËœP„Õ›²|?ØkÜLö÷DrSÔ`JãS=ESË˜n LgaÓ®¡H·ö€G!Ë,íŸ\äÙ¥¬BĞiŞÑYl?ÑøZd §˜"(
+-'Tñğ1$_G“J­÷Ój>xF³BïZj¦	›aè<©£2$V‚ÓĞŒA“Nˆáü@ÁÂ6ú‘KŞ4õ%›Ø±î»ªHe#!Àı­+AÒ+CÓŠhİ®”!UÆ™²Ã›Èm¹Ê3¤0—À† †Ä†D"™™ ¼-Zc ï
+·ïKæœoC@N„)ég¨ä‹Š™E†:núRB3#:÷g~Ş(ßc¥b½A"œ‚6ÜxÚk=¾Eó1øÊ®V¢ç•¢à;F2Ê¯Ğš“ÓqS=÷”¶šŞí74»°§Ò/ä9İX²(ÎÒ|CYÇGh°Í&,µYfµ‡TÂõ#Ë.–Şp‘e9¨’°ÏY•÷@æ¼ó¤BnŒW4$!Ô("$ÑĞI%"/§ú)ÒÔÎƒDTii6TJ6ğ"+œÌ¼>¸³ñ¸Êû I”(hìJŒ^Ÿx³J”V¿@«(Ëqqhq’¸sF¦àPá‚œœÛ;gha¼vsoé1CÕ„‡mŞÈò1¤
+—9âá‡äj˜,ÏmUˆ‰®;º…UÎ½q´V€iËõAşíŠßåôNcjLµ&¿o¸~t‰`_~ñÅÃ/›U\‰!®wâv”¡Â×`µn²¸‰D¸CĞ)úV|£Cª¤Éõ]dc-¬Ëİäk*<¤“1£‘úÂ>«üO‚º„DWæ§LO)z¾ )D¡v.ªÊ_D,Ş¼kèJÄ©Rcèú´ië²&wsR²9;­ÑZ‹ &9ubù­Ê˜´÷>]šÓmå£îËZ¥Úù¨ËŒB&*ó|*Z×>„B¦¡N€–!õ³4…d©ç:á0–‰¡JÕğ
+»‡PD*è·ÛL=b%šàI†¼F8€7tsŞ_p9RŸÁÆij—»„2ëÀº0ÒW~Óï¿e)í ìt\Ê^Ş6ûs•ÆÍÆÀÛĞé¯3‡&pjy¹|‹“w H-‘¼˜´€”ëèf(B”U³’À¦QHÑ-5ğ‡¬vü”#›E4¨Y"aÍ3gariï¤şº™+®7¯e9Áyˆ÷²d-¢l0oÛÜsé’yR¼F5‹²Ë§z1',uÃ"<iz	5‡hiÒ¤ÙŸ®&!w+>Uú^“M+ÔsÊÓûÔo-^h(ns
+ xç^Ãè^bÿ?4C~İEX'5!3Ğ†^ÍJ…ä&Å99Pïnìÿ´kîŠsÛd	vÁ)°ÚC}—€lPŸ#¼ ÿ‚HÑËGvõ>âc¨n×v07Ÿ~ºb‚¬–8¿á4$Bº‹úÖÄˆüÆª_ûíÙ‚sgª\aK5¹•îçõ©6;ÄŒ?å¿öıİÖ?0Tá9aRš¥éå@õÑşıÿd.³l¯É2Ù^%àùANê©Á]ÊGqútñôèÁèemvÔ–P;ônRT"¨w]5t^ÂTËñZÃ¶l¹Ä¿Ë#¤ø
+\Be†ƒ¦æ°iĞSª¥|'5á«s-"ğÇò6Ç0KÎ*ï¤j¿$WËÒ¡‚7¨ÒÒ÷òÈ«1V‹¿²·ÛÛaõä¡ë¬õ×„¡;píeÓu^F¹©Ë?ç|jÃ[Ê&¡fäß¡\{Ü0ÍÈˆ!zã!è×=€y†¢fÍ%¿W#2¹ÎØŠën†<ÙÀ…BHÊ	EFûWüÁ¼îu¸¡6¬¹i£½-o}”U˜š-ÆU~mbùáíCX›à×Ú†})#…
+T7|Ù¤‘6°ªÀ—–æ'›‚jÁŠ	Å2-´“ºÒqÄW ­B˜³á~¨™xŒål™Á•K$?ÙGÊI»e…f!Ã‰ÆÌŠcôóÍÛ8Z¶¸<œÖË×ëÁ4Júá°ú’¹7Ü"zOáf4£••xâ¼Bƒ$E+4°F@_„e(Zi†¾Høçjë1“¥ ¼şh«¸JéIÁµ9V÷Ò†:¼,	Ô…a§àq_‡®—²
+m†ùÀI˜À]ôÃ…Qƒ=Wn:øÇ0ô¯`Qî’Îú¸·@IñŠÊH·N¡~gqLò°Õ0å›Ëî”V âù×¥6ÁƒI[FvğL¥«ù»ØâÇsB›…¦µŸù"(_=­òÒ¯Ÿ³ÄËoŒ¾>¢l—@¬ï‘†È'|¢IÆ­ª.ŒÙ:¤»ÃåuÏ)iÕcä¼ëŞâÆÏ£wñ¼B‹™c–Çcü‰Áo½%uå;yCõ^–èºpŸë½óû"%õjn\×Vİ:¢›K”œWµd¶`IØ¾å¼4ØlÔò¯\ –?_ĞGLR²s€hšD|Ñ€¹(*À±Éüm‹£™T`¹pYrp'iÉEn:e¾Œly}¸ÂÜ~¦…æ_ó7kSê4İHLğ—ÏDà:n›ïÔVu³lG)Ä%ê¶&×ñ9ˆSGõn›3övËyÛD¼¶$ÍÎŸâÒ·ËqÚÇĞh¥
+#û‹`G™£#d¿£û’€Fé~( tşq‘´œ†çŞ,Ê®Cé~Â2L÷ã¿h®¹àò <'êñx¦ì âş5ß†Á£x,Ù]ll”‰–ÖM¨a ]‚¾ÁĞüT¹€S5cÙ‡¨GÄ(
+Üòµ·P¿Ôö 1KêÆ©dsÍP¿ãsğ"@Ä,ÀëŸL©	E	ûoWJ¹¼=ıMKÒŞl?VA¸ã4·ÎÆT›Ş¨BÇD˜¸’"ŠĞ<İÇÒVˆTD±)õÁ]t°$“˜µ!ıƒ¥†Zópv-56Ëşƒ¯ô]©:´E—ÃÊ×Åø82 ÍA}?¨«F)
+³T¶ ı2æœÀ†Œô$Ø+ĞÑø­ç°!ÌC=r`ÅÏåohœ£EÊ—Ô@Ğ€Ï¾ÄƒÄ
+cÄ§rXèŠv+éô¥0Dè§V¼ÌòüÊÑ8âD‚ˆ‘à¼Ñâ…‹È‚BDI ß$Š£»Jµü	¡º T^­A±°#â¿G|œ	àcsíJYŒÇo.Ü†ŠìrYäªLkµWãjãOódÅæ²†çò×Uª#N(ºPö£û²Q¯¸JE÷èpÊ"uã$BE
+œ¥²½ÈW-Bûø…GO¨ÉuCIr(’—¿‚İû’^M¥<Ê³h‚ †ÇN¢¢lıª¨ßŸÿıL·l}
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/7b/c4c438af3c01e248965ea5612e83a83514f66b squashfs-tools-patched/.git/objects/7b/c4c438af3c01e248965ea5612e83a83514f66b
--- squashfs-tools/.git/objects/7b/c4c438af3c01e248965ea5612e83a83514f66b	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/7b/c4c438af3c01e248965ea5612e83a83514f66b	2022-01-01 15:09:15.633172589 +0800
@@ -0,0 +1,8 @@
+xUßoÚ0ŞsşŠ“ú#]è¯•ö¡¥İŠDĞ4Ú—MUVŒˆéÚ¡şï;;vˆ"MJ¤Ä÷İwçïîì)SèvÏ?ÁèWxóeáytÆ2ƒ—µòòààåd·àñhI²UÄrµ&YÛòªòÄ/<“ğ4ä²×…t¼Yş$«;šÉˆÇ$ƒk8é[åR&2’ÚtÛí»$¨$ëˆÉ›ÌA¿aşùŒ\ÛcŠ'ğ¡ëCÏ‡àß3|ÕÏéGßd•³†‘Œœ XÏ}¨?rß
+-î³‘TÓ^øPLÛ}+´“…XËFnÌö«õÇ¥T!Ö‹Y„eh½­·ÚL/= -Ì{à­¯‚&0äT¶Ú°Å\FYûğaO«k6XDk²§`Úû¹æªkàúVËÒà‰R¸~®6^VE×Õ®–êVöŸ
+Á`˜©mjÉĞ9ïî-¬‰Ü¬¹Ñæ
+ÎÕµÂºûmgÿÙ„	yK¥êü³>˜>Ôö;Ä|Bÿ’ò\ßs¤äïu«î™|Œ¦ŒhIK”¸ğ”K} G„?
+•š;5’”35ğfn¿é ZfŞÆÆÀ8¼Æ øMgĞRÿWzš¿¬v°j!Hávj”]0BĞ÷><çX!|.»ƒ¥,­Î_‰êíã6j‡O±ÍÒ
+à*O³0ÿvqôìpÏc‘P>ÿH.´!b	T<LËôì–lR!MšLt¾0¶ëV:†‘tò¾œ
+¦Z±Á„ÚƒÇH{ğ&ş¼?
+1Œ «»ÙÑ%Îì”±™+%°únõ±€‚­‚´ØpûÌÑ[nNËèŒq»çòR_ùîóu§*«í£sn¬õ’6óV–°p«¦¦a”¥ˆn¥L`Wx[&œÈµÄÎEB˜>‰Ğµ–Ê=Oª˜ Âá² Uğ´æti=\16#¤ù¶a¬|ëŞiÕ	 »Û‘ÕopgÒJ}_ŞZ	>\â}¯ê6s¥P¡x%¦N§ªe°gOèÌû0/Üd
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/7d/6a93be6fa972d19a9c326ae8c397f4cde5813b squashfs-tools-patched/.git/objects/7d/6a93be6fa972d19a9c326ae8c397f4cde5813b
--- squashfs-tools/.git/objects/7d/6a93be6fa972d19a9c326ae8c397f4cde5813b	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/7d/6a93be6fa972d19a9c326ae8c397f4cde5813b	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1 @@
+xmRMkÂ@íÕù£äà’`.­M‰nZ-…"ˆI¶mêêJcAúë;kŒ_}3óöÍ›Ù$R%xßjßÅ/|ˆ”«E_¤¶Ø	€zŒûƒ ¹Føñ+ğÑ¤“A}MRu0î‡Au€Dİá„Äˆ¸‡­µ’êS¡•¢(ƒ;h'¨sŞºdóÖ±â^U\€è¤_Â3}O½1Çí =SÜ>j	>3š:f >Å‘î‰¥v³£UJS`šÉ½MrÏHÄ¸M:(ğŞ“^ÇPûˆhÅSQlm•|Ÿçhí*‡,,¤ôÈU5C€TŠÅÚƒš•	‰ÎóE•tMıhºigR–@·Øgd”@ì6%øE	6é‰œ”ó\«-Š]^l±ağ®–Yş³‡D9¹!kœúëÁÔd¾^Rt|õ»õÎÈQSÂ]Ğİ.Ö '5{ÌN¡FÿŒ~VQN[ñĞ¶ú|µÚùÂ‰ŞGİ¹ï\_s—Á?!¶ˆ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/7d/9e00d0862a813eb1a29ee9231bf266421b12c9 squashfs-tools-patched/.git/objects/7d/9e00d0862a813eb1a29ee9231bf266421b12c9
--- squashfs-tools/.git/objects/7d/9e00d0862a813eb1a29ee9231bf266421b12c9	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/7d/9e00d0862a813eb1a29ee9231bf266421b12c9	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1,3 @@
+xSÛn›@í3_1M¤
+";jëW²	¬:¦ÂÒ<¡5,aU¼kÁ’(Müïİ[0ø"Õ/fgÏœ™3{fY°%\||ûĞëÏV+F{~üƒxç–uJhRÔ)†“mô¤¾ÊÊ‹óüûyUSRñTÆ,ŠV¸Z£ÃÌ‡×öQ–èF&¡8[KÆ
+ğåíUØóÂ5¦cBQùb'ŒV’•p&‰] ”CV ÇÊ±^-€S’¥8ƒ0Of£èADÔ%¼›Ø¥„aš’L|ø«°íÈXœ#šŠ†àyL”´u•ïB0(X‰y]ÒıqŸ/.­Í~Û†ZµE2»¡—	¨`¨xYcÙ ÉÀNT?ë€`ïw°**nèTù®İÜ`>Åô‘çöİ„òÁWøT¨£j¦ªK–e±˜n]şb•Ãã?vß…yüŒı»HÉ×»À«õ..˜]+œJÖT†a,ÔÎy¦gK&§ĞŠ¢¶ì ˜u4.C4ÁvËŒVâëóœ¥mi†ÕóÄø„*3=vZÙêQ{Ç~–\–	•.}z}Ò~İsª¶§i£¥¦ení·0®ÃÙôAÌJ¨¯*ò‹G1¥</Â(µŸIá,E¹` ò¯S£”À­Î«yÉê)]aÍÛÂÌÑó|AÊñ6ÔÊ&êvT<£³ÊÑ(ˆ—Öoí]wó‰Y½fçW¼»ŞlÀfë˜“ô£`´€7±úÁoª>î£ÃmŞ—¤Ñ÷?C~Vø£SŞl6Ö?`©
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/7e/0bbf8b4598f0626647e1e1f404a2e7bc8e0568 squashfs-tools-patched/.git/objects/7e/0bbf8b4598f0626647e1e1f404a2e7bc8e0568
--- squashfs-tools/.git/objects/7e/0bbf8b4598f0626647e1e1f404a2e7bc8e0568	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/7e/0bbf8b4598f0626647e1e1f404a2e7bc8e0568	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1,3 @@
+xeKkƒ@…»_qH7Ú¦1I|@-]tQ…®Š£“f@FĞIßùï½×ø
+œãwÏ=ÇMQn°Zyg³â*ÕÙîöéñ:â\é¬Øç“AŞM„x~Ğfá‚¨×»R¿ËÊXñ—‘¸ÈS“NÑ~®Õ·ì/ºüX—õJH•¹Òo¶øèhåÓû¶¬`)„p|(\b‰ û4×K› Ô¯{an‘ ¤¡Ïû˜é½ë*#Ïwæ76~Gê¼Q½SÑIlÆ»”Çí„¶g.kÓIœj¨wœ˜  Ç@q9²G‡»AYÔ²İÓó¼ğ
+ÖéX§1¢QşwP?®Ë[£ˆ{v[z‚ºï?à004;P6>•4ûJCùâ ş >>º
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/7e/641c5539d11c2fc1a055d4896e1274b5794b8b squashfs-tools-patched/.git/objects/7e/641c5539d11c2fc1a055d4896e1274b5794b8b
--- squashfs-tools/.git/objects/7e/641c5539d11c2fc1a055d4896e1274b5794b8b	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/7e/641c5539d11c2fc1a055d4896e1274b5794b8b	2022-01-01 15:09:15.637172590 +0800
@@ -0,0 +1,5 @@
+x¥SMÓ0åì_ñ¤H¢İ–öÀaAH¬øÚ]uµ!q©Üx²±”ØÅvØ_ÏØqC[ÊqòdæÍ›™7“mg·X.W«g‹
+·O½|ı;ª­¢y‹j!ÄL7FQƒÍæ(ºiÅŒİÚĞ™'™ºáµªÓÛyûFˆE%2ÅG
+_Lmû#ïI}ÖOt%€Oæ
+ü Ú\MC—lî† %ƒÌ‘fÈa}^!Ø!Œ¸K…öÀ
+ƒ3ˆSÆºÀæ[ß$sÉæ{ç¬ãÒhI*r^D!´	{Îô_¤äÚ¸¤×†êV:Tûi.Æáb³›Àì±Ã‹”–]Un»|%ÕŠë¥:/Ò‘‰oäƒ“	à:“Àl)<IÇ¹9ÛK¼²ëlıåX²ÑğGĞÖ ¨¥Á–Ğ'™à#Jh†GûOtôFìúts÷ÎÖé68u7Ù¹‘]é€àƒ#Ù§ÖVÌ{G½u?ÇAdĞæ÷.D8ú>hG=™à¡hGFñ¶íÈM¶Áí·»·™z.¾êĞ2¶‘CĞñïO!r{èğÜCnYS,_âæz~zU¿÷ü_Çtr}\oÜõÑ©±÷¯ç7i?fü°Z¡BQMÛ/‹|°ñ)óY'XQíw^c^yÆÒéFüïdà
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/7e/7668ea9754d4af9ffd302d900d2d7a3f5a5adb squashfs-tools-patched/.git/objects/7e/7668ea9754d4af9ffd302d900d2d7a3f5a5adb
--- squashfs-tools/.git/objects/7e/7668ea9754d4af9ffd302d900d2d7a3f5a5adb	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/7e/7668ea9754d4af9ffd302d900d2d7a3f5a5adb	2022-01-01 15:09:15.653172590 +0800
@@ -0,0 +1,7 @@
+x•Uıâ6í¯á¯˜‚*…Ë×¶ºv©ªf)´|5	º®tRdˆC¬vj'ì¡jÿ÷ÂÂ'„NÆoŞ›y3¬±‚n÷İÏßÕXÄCÁÀuçn0ªÔğÀ8=[w¸ƒ¾¤$£@@ı›G
+"–PµWİ6ü˜)À˜mâdk±M%UŠ†€7C<Ùkœ“[x4È"İK¼”½®C·İé6ô÷ƒùşQG,b–$,…‰È71•ğkZ<ø½äÒrÓÌ?ıv@4dR)6’l5©HR
+JDÙ‘´{‘Ãšpä2•I¶ÊQË€ğ°%¤N¸!‹öúY¥‘Å2*·
+DdïgKxO9•$E¾JØ&lM¹¢ú:Qê‡*Fõ«½¹1Ô¼
+&¼”!¼„•
+ÏĞmh!Á&™¦*A¤:°üö`±Ízßd…À¸I‹%Ä‰¢^°œ°¢+å‰É‡5€c4_úàÌáƒãºÎÌîap|Kw´€bÛ4a(‹)	ÏöXÍx:pû#¼â<'cÿY+ıÙÀó`8wÁ…ãúãşrâ¸°Xº‹¹7@ßxX”¯n×"Û
+I!¤a‰*…?c'²KBˆÉbG×”íAÿ¥š™Yç%‰à#ƒÑ-ãô€EÀEÖ€ÉĞ ™0Xg}Ô×ßZÙ€Ÿ~Ÿby(,²¦p^®ï><´ğ$T&x¦´»Nç¾óĞ~×€¥ç”r¨”B6cDmU*ô3všcÿ°ôŸY˜÷½ã«`!²¥i ìz¯¼sxşÇ\Y\´×1‘pmQR³ÙüJ8ã‘¸Œ®´ZĞÿsôË­‹EVº"è(ßuú$‚TqDpV^	…3¥@¥tÍ"m´¶#Ü[4HpÅT´¸CpáqéEäı½t¼ÑĞğq™“­@äFiğ±bY¡€ÿÌ‹Eö«^ôğ Ş¨©–«âªQ«”zOC¼Âîj·ëÜu5šà—Kğ")¾ç¸*ºEeĞx6œ_%¦Ñ-,‰ı½Â<«›–qØ)»¯0:&1ëùv–SLãz”i*t¢ó5ğ|œÍ«ØEiq¡UBƒ2I€¦B¿/#ÓùÈV®JÙ€oÈ;øg|=­©ZÉ>³~½lµõeÎêG^-ùX5˜şUÚèHôtkob\ğ¶,ÊoË~½]Ó/ó›HmT#ëtbÍ3½/{ôäü|s÷«CÇw&ÅŸøcµhŠœ²J—EÒ\®ZDËYÎŠr™äŒX­fàß¦b:˜h›I-õ—zÛKgTaÿ5¸··şìT{Û(¬†ÓdYAå|%W…œè8ÌëÿBö·z
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/7e/7772820583ceb5ee11e8940955445e19a9bed7 squashfs-tools-patched/.git/objects/7e/7772820583ceb5ee11e8940955445e19a9bed7
--- squashfs-tools/.git/objects/7e/7772820583ceb5ee11e8940955445e19a9bed7	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/7e/7772820583ceb5ee11e8940955445e19a9bed7	2022-01-01 15:09:15.649172590 +0800
@@ -0,0 +1 @@
+xEÊ;Â0…aWó+¾ÁA…¼ PÈPs)h i—’Æè’6PëÒ_oëâtà9ob»Óa!oTUŒ3Y !JÉË¹i…Êr),WëµÌj!¯µ†—õE–†œ3«¬Èùï3º*(¬÷ÙÒóÆÖ&@ÊN3ôŞ¶ïÔıš1ïâÃ÷IDÈo;HÑ²o?a;ÙkÏ/g
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/7e/d0a99a07545d841ca34231ce7c7428f8d7fd77 squashfs-tools-patched/.git/objects/7e/d0a99a07545d841ca34231ce7c7428f8d7fd77
--- squashfs-tools/.git/objects/7e/d0a99a07545d841ca34231ce7c7428f8d7fd77	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/7e/d0a99a07545d841ca34231ce7c7428f8d7fd77	2022-01-01 15:09:15.653172590 +0800
@@ -0,0 +1,14 @@
+x¥Z}OÛH¿ëO1[–Ü‘Dí²­.º!´ì†ÂĞv«•"ÇÄ'õV÷İï÷Ì›ÇCË•šÌÌ3ÏûëÀ<söÏwoŞÿmïe?Ş³?#±Zg<Ïc‘²y'!ë‹ÜB°=ïeèOÿÜvB¨ãtÉ–Oñšååz-²‚9 tƒ}pãœÍYÈ~™Œ§ş<áá!óÓgÃxñ¸æhF—W³ÓñÙğvrÓa@DT{’Äù‚=Š’…"ı±`?-ú)ça- O	ÿŠ§e!é}ør~Å¦·WW—×7,‰SBsˆb)ˆütÉ™K™‚‰”3±he8—ŒDş=aÊyÂƒ‚‡ŠÉËù},Ê<y<”0«2/4ó–pk³ïÇ	©GŠqÈ’§•Oÿ nª)'
+$ËÌÈrÌŞx®µ*[}şÒf©=i]6ùr1|ë¢W¬ãÎm'9T4'>ØATëA¿_”w¾ŸÆ=‘-ûO}ií<”¦¹ÚËœ<eS—Åi^øI"Õ	ü™Ÿ=J(Sm-L¾ñù‹•,¥ìDü9RlWî½JğÉ—ËvÉ•è7 A †#âf³é‰9Ï¢rÅ³Xê‹5OsQfïÃ¡•ÂRû.îïšD†à¸Õ&5ƒÇ“‹SìX=I­å¼—NÏ¯ÉU­bŸr CfXÄÄ§‹œ4·Gtñ˜õË<ë'"ğo‡M¾µ«Sšıw?MÙH$	/~ÌÁĞ˜p ?ãæ9ˆ<‰ÄŠ¯ı%0íU„‚ãâ½y"–ùZRûk(ı¨«D_W¦`_‹<.Döhñ"ä½¥Ë„WWë^ˆt/KpE6R<*OVşíh÷Í#°jïˆy~êÆs){Y+`_™û¨ÍpDÚ°G[ëúëÅĞèÊMªN¨¾ÙUŠàÚ6eÊÃèTT¥Ú”ox&]fÎ‹_š2ş;ÁQ?Ë#Q¢„Ì9+s¨ V.Ä3\¹û‰(¢íĞ6´•$H_D‰MO-G‘ö¾KIÒIŞI+wš>ƒğú?’
+±1sH=³lQR–Uœ³ƒ£Ş»Ÿ­NB~Â±¦òrÈ hôgT‚s¶òÁõFdwÖE™Ú¤‰ğCåÖ~pÇb\².ä2¸Ó‘\¦ı+'ÿ«ùö:\05 !KSTr=¹gàe
+`£_>Ø0Dj‘6š§câAÁšRD¯O·Õ¶JûÒì"uå½û¬:X¡š\†Z¯×S·‡“vZ1$…;^=úèrîyÔ/êt3!ùœMây•ÉØtÍƒxñH%É4#®Ë›F%d†”? FSÙÉåMd ¶‰â ªEŠŸ,EÑŠ‚NKÕì@	ˆœ‹»ükéçÑ"ï1f;i;—~…H¶	ÔO şx
+$¦©©	»èÁ
+°YëQeÏP‰kÄùÆ'°³ñCÁS2¾_Y</Î>on®óN³•D*{ÙÔ¦m%V›à"s”#]û65º’U“—±‘-Ñ¸"»Û~ágKÔ=ŞÇ™He‡
+S7hºR%)š”]×úÀÊ¼6áW–j0Ã6°05%YD5¾\Ûè“™}Me_á2%P›º‰óˆ=~smÄe*‡³4¨Âë2ŸZHÁi¥§‹†#A5Ö-àvÀø)ã\ö’”áK•8pÄº©èj^ÔŒ`t]¦å¡ÃUßaa#ÛmÉ»T‘fÖˆ&	éà·–/ÕõW`.75VzZ¥ºéGÎASûr§3CÏemûÉíùäÔD9:têŠÌÏËÚ;ÿ4šÜUì÷°1½N&[­T§wñëô?·ÃéÇ³éìòä—)¤ZUIA ñÃÒƒ`0<8Ã—|ã£&²uÎËPà‹É"ÃâïU±‹Î3±¤©oîÓ¾Â£õH<º‡Cr4 r¶Èü%‘¢Àœ»_K^â#‰s:ğ¼ÛOMá&	Ô-µè¾»xë.~RøíáÖZªš0`‘ÏÏ0·[;ºËCÖıgBŸª_÷Ôrvs=½ÑÙdøaÊşuÌºKÖ½|k6şqÌöÆŸ4S ¬+Ã¡,ŸÎÎÎ'ãÙåÙÙt|3;9¿™¿;"¥àd2¼ş0–ÇÓËÛëÑ˜ ?|ºÙ•›}ÿx½_Vÿx-ñüFSá~o‹uor~BŞĞMÖEDÖÃ·•/øWv°àNwÃ7G°î©{¸å_&åÙ&ó×kŒ0bËÛ’lw“'YY®ÇÓéåõ”iH%"^x–9·ÌÕ–P€¹JIHh'ºĞMI‡SÕ^Ç†DpuP×‡	føN}wòt§¡r±æÉÊ?åm7Vş8mßG£ Õ$ ùØ½ŸÅxZ@ZE/8Bà†>‰u^£^­uƒ!D%xÍ®"ÛIŠ¬iÔ@ªê´Yõ9prYÇ¬º-ôL…PV©ÖğT-­‘®ÿwè­Í3ªşzËs¿Kà‡§JæbÖ€*ÿ•rµÉÚ`ô«£6“Ôè63%œ¢vş<_OÛê³ã‹êì…ıºß[½Rtúq$eÈaÌË˜Ñ5K†£† 8Uºi*ƒ÷o™Â0â’£z*Ò2sÓ[œÇÊ-ÒÛ³6«àà[Œº †QJBGÛœ5íRkõ$o&O«óLÙLÔµ{¨"5h'9¯¥ƒøn«È¦	éO–|ÕAµgù€-Õ(¶ƒMõ”npÒDcFùV›ªcò 9£àyÀ9È »ËC¼Àˆ¡ñ· JúëÅŒ-‘kéù¨ƒAÆOrAS¦±ğuGó¬Ã™8—¯òN¹²[¨aG‡œŠ‚^5,ÛM–«ë5»häeÿ/Sncè>
+W]’Ò¶mã/™—ju«Òì'·m´—~0ó‰|xÎØ
+í!õÈÔPJ½â]‡¾]2´\è†ğxõƒåVÎ
+DÎ¼Ë[Wğ-	§[µú=Dé€ùÂ#&&ğF»D§N§£FŒ\cF¶ı?İƒÿêÙN+g@ı¯§-H!§fGŞÕÇËO¿àZôª(+.ü®áSk[`Ì§YI3L›€D£U•^R•K¯jò¯‘[;Ş+È<¢¦tr*[Xúªn;œÓDDĞG"ËB+ÿö²=1`xÓ\`&pG€™^Æ¨ZÉ=rA#ò 9mDf©@0è±Ÿzv‰˜ll¸Ã‰D#û{Ün9";Ñ75³H™%b§ÆŒ){é[U±ä0Á«•¥z‘ç©á
+†¦!«‰ÚU;$9Ä}g¦¹Ñd`¾ìDá0îÚÒÙœhƒp5ÃzÎò5zo	c¡Û¯îV¬A_5“jK˜ê£­¡—Mµ5)5{}‘jnb¨)¾élP®;
+CÃÎ20.i|GÈÆ{há@¨!t ègy0Îã’’~ŞêàD[ÏâDY}…ñZƒÁjK†gMrCµiÅ0¼ì4‚³½	ßÛÄí6~p¿mÛ*­õ¸ê3è >“6U[®§˜Fš¥ş>Áã9}ê÷_¾Wİß@Ùõs!"!ñ{i™Âævñ¡³õNœ˜.WË¦ÜîYSìZKKhªvMuÖDã°S:«&ç¨‰ck8vçÄê‡
+]c"úÎB×¼EUšÀªÊRéºONİ–OÃİØÉÓçÏ¡ú¶ñé2Ué‚
+”³ŠÜESó6àu"¦¢«ŸÛf”ìıÂ)\¦ 6mdˆÑ«ÜÒ8ÚIÚĞñ<‹/z»½}"¼îBôÓ‹áq¢£İˆ*­ZİURVÃ‹YHkµFyÕE™Î(Ì>bº˜¶«rÍqÛÒ™iNÕY-9©­÷Jş²º;2qbddòÒi±Ê¾¾}GR5\øK•Ô“ÿc7[±î‚áåÇ–QNÓè¨¬j–·¶¬0E`—DúØtéê•şúÈtêaTÿvŞÓŸN«êwxÅcİ5˜vë‘œ\LÍÃÿ„’èU
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/7e/dcc07edf3deb0e077e117b90e7bf95c7a8da22 squashfs-tools-patched/.git/objects/7e/dcc07edf3deb0e077e117b90e7bf95c7a8da22
--- squashfs-tools/.git/objects/7e/dcc07edf3deb0e077e117b90e7bf95c7a8da22	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/7e/dcc07edf3deb0e077e117b90e7bf95c7a8da22	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,2 @@
+xmÁ
+ƒ0{ÎWsWĞü@RéÁPb.=-µÙ`@¶Pğÿ«­-J{÷¦ï=¯es¨*®3…¢,ÆDN1q }rÁ#Á21“L¸‡LL¯§àTkº³:šïs¹ÓAÎæUbUgAy¯.PÿƒÍA·qŠÈ‹5­Š_Ø^3-Ã'd/~ÇmØâEŠ9±'eÉJ4
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/7e/e57bf286b2a4bd68878c2c34a31fe4df825e76 squashfs-tools-patched/.git/objects/7e/e57bf286b2a4bd68878c2c34a31fe4df825e76
--- squashfs-tools/.git/objects/7e/e57bf286b2a4bd68878c2c34a31fe4df825e76	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/7e/e57bf286b2a4bd68878c2c34a31fe4df825e76	2022-01-01 15:09:15.653172590 +0800
@@ -0,0 +1,12 @@
+x½YyoÛFß©O1IĞ®äĞŠ$±‘¦€"!jK†$7IA‘”É„"Y¶Õc?ûşŞ›’’½©±Ö@"iŞ›wÍ;gQ²G‡¯ÿñjGÜŞÏ×©ŸO"¯ˆ]‘DøùşC’}ÉE€ğüe‡E˜Ä"ğÏÏÄÎ«VGIºÎÂ› ıã£ıİşññkñ!Œ=1o5[ç…¿ÊMaÅnWíi­/\†®#É…y‘dëÖî#­ŞÀ5ûNysüÚt×+!Ïó=‘‡«¸y™¦IVtå™ƒÃ•“–—j¬yP®¢=œ^¾Ÿ\Zö¼ÓÜâšƒ£8¹=>lnngœÜOÌUnˆÌ_%·àş</ º+l;Œ£0ömû¹hÏ®¦âÅşA¯×8³?ø\FØæM¡ó$r²0×,€é˜ıcüÀônsQ±(2:ó—~æÇ®ŸCÅşïf¯O²ìKšËğ¢¸ÉjåÃN.R²öÕô…èô´amÂ.¾{¼g¦+_Ûd¸ÿ$–Î*ŒÖZB¾g‰c gY&à01ÖaÃ®Áuí$šÈÕÕ¨¹÷Îì.ioàÅGX&™°zÁå\–ş˜yhÌÑË—®’Ã·r‘,ÅÙõxt5ŸšÂ‡^	Wšı=:ªéÅwz[Ã#±éç‰u¢¡ÿú¨CèĞ?qìbf™ŸFË6‹=öd'N–”ğÕ[œKF¾	ƒÆya
+‹yx“¯%-±ıWşZÜ%ñ?±ğ……ä”wÃ'fó“‘mœ2Kè{İ‡û¥Û¶›FeNÿD‘Ô[!ƒtÏÍÁ€} Fù¿ô|6®ûò%Ğ2³Ç
+eáób……ä8wl`esF†àâÒºšåßÌŞkI™·h™”üdÄ©Ï¢­œ0.ğü-…¥a°@Xâ Û±ÄÈã•˜2Pfóáè'û|:ùÀ=ŸXÃ1©z{?ÌÜ `cbööäF–ÂœøÆŒÈ¾Ì’•ÎLİ€d•;*6¤N‘ùP5(—ËÈÆÊ¯ôÍ(ú"D»QÉ)c¿¢L–KB‘ÙÛ'çèK³¦NƒkÀn|Âpq^'©e~Ö2!veä½ğ£œ<ñÂÇq-%L§ˆ¹5şÄÀkú&aZ5vU2Bz›áìòb8>¿Ÿ²C4~o"ºUÒd"ÒûÒƒTès
+BÒQ“KWşNÑ‡§duGW×öÙğÒºøD¶ılzä}ónå‰æ¶ğw 'e¡<Zº’Š”fâ8!Sè8"i‰•v7Ä™„…ïeæ¯±IY½o:ŸëÙğj’Üî}!ä %`å¬|ãT‰LêÀ\K	Ë„E„së„‘³ˆàB"Íüİáxf­spì¤h5r•¤•ó­7K¤†óédü@ò%J‚$àùÑF.B¨ Ù¶6’ ÙQN9…RÂR<“éìóı÷Â>_#W@,Pİ§2Ğ7T­ñl>;Êê¬Šu|Ø#5|HñÙ‰ÿÅ«¤8yw¡r'3>»˜«Ÿ´ò€ü£'s¨vFrBHúôï]?-¤QØŠ0¾¡­®ÙS[ó b¶í‚d9NB2:Ù_äÅ:âãG}ìÑñ+adê¡¸Pƒ)
+
+ãšPÈÎwYX~ÜmÉ¶£ur:M­«¹5·æ’­êJ¨>¹.e+¨X…÷äst2yÑmõ;ì–Ôá°<ÜßÀrÑı®¸šÌ¬"NîDî¬‘ü(Ó¯Ê¼ˆr™ğì¢ÃÊÎà.Œ"*iàP¡(¹É¯t¢hİm:$ƒOÖ¦N€¼ñÆ/È°"ƒÁ!;‡¸s²˜ï‚Ğàs —%^Iåj±&!¨†À[ÄV)”Ìºâ}’úË|L`ÀZ„¯) —¥Œº½Ê;w8ˆ0É%È·™ˆ}Ÿ²$	x«ú¾<)3—Œ‰R²€Z8è)IÆÆ…uPi2á¤i¤º:KÄ I¤F·\(‰ÉÂq¿@iÉ¢âÈ¢Òmí£Mã®QX–Õ8’ì¦±ûùEGËKpZ^dÇ_£ƒ¥çn‹İåE¸¤”‡H´Æ£ºÑZ/Ty ha‹ÜQUè–
+‹ç£çâ–ÊùÀ“õ=a]_sc¬ÍÈE‡;_úª¼!3k<?zÓÒky€N–û‡õ*b×öoZj•q™Îõ&
+(	´I°e~òèıpZÉ‚²¡"õzö~2W`£kÊ¨ŞI¾f\_LÆçuXÇw“ÉEµÁà%4óëYµˆÃ-„a§çºŞÎUÔ0(w`ñ‘cSVÛÛ;*ÃtD»ÛívŞpg‡1&-P­ÄJìòT’ùIâ‹¤£épÂ4ŒöN#]UÄ¾Jˆw6(yIIŠhÕ™»"%¾JKîm[F	bšhÕiÿ‰´äVĞâ–¦RTÚ»i°Î´?_—ëiÆ‚Ù¿ªİS-EÇ÷UBO5ÓßjØˆš=Ã0À·Ñ¾Ãzô\Šò"+¹Óá2Ì)8‰¢ä<gÕSzTy®‡º@5âƒ²°U¶+A‹Óœ_m=†tÄŸ6«lÖ©¹Œ1wSd5úŸbT¤+Œ¶Å^‡•[ù[¬jÕÕËHjbh®D«òe)”€0E•G*@®¶HÊÕ²»±üKId¹o›ª«Ér&d	r%¯Økˆ[ªEE„r›Tcc½lnAÁ“„ØÛÉVŠ.~kªjIRÕxîÆjY£»¥‚°õI¬H‘¤MS­Iš¦»±\66¸%@l!p:RTB2q×k¥^¬ÄÕwÒÜ™)PêjòTm4ıjµõrÅ¡‚¹[0âQëXŞh.T¶4—jµõrÅ¥‚¹[0âRåN
+ {8½·/'?ŸÚ3ë—Sñ£Ø×<Ü×Ü÷%÷ŠMrC‚=NèHê´yC|İ"Ua‚ªVC}Ò‰4ø~f£»µ¦U#CÛ>›N.íÑÃCû¾c´e<uğ½B£Òµ&šÑKJ­:È£Ú%9ÖŸXSÃæª*Ãë|l_^N¦Ÿ4Vsm‘	lâñÒÚôô|¶‰E+•úÆøİ»OÆçæWhI‘Ia‘sgˆŞ±ğY(&¯6vek¿r
+tİ{z2_|z5±?`òã/Ó“SÚ&á¢<Û°ÃôtxBç¡ÿz•¸¦ÖüT/ã³_A®¯N†MĞ€ËÆÌ0t¸9É‹V;ÇÅ+„çq—0n¦¸%eE(Âq#ˆÁpÎˆjêW1Ò÷XhëK¨Ct–¡yl¸ahP}µÚv‚¼#§yfGœØ³Ó9{=Z}šiäyë„ÄËLˆ€N¼2L';¸‚IJÌTØöã[(pFüDêd¸É¯J+æ.‘…‹á£İ¼Á¶e’xŞt]–ÃZÊqFyI—B&nDÕôÃƒPLq‚/cr¶bƒf2‰æ‚;ÜaYh„%ÍF­¨>–Æ’188T@5¾Æeº¤30–M…U¢ÏNŞYó™ÑÎqc’,Û
+¡QÈ5;Dİ‘îji+ÑTR‰ ¹Ã®51Cınß›b0nW¡ßi·Ï/Ûíug·ßét^mA×;_KKE©©€!{	s¿àÄôÿ¯D†n¹M¢şK‹QÂJÏÎ¯2wı¥ÈÔ‰HÙ³›"%ÙÓÎîÅvÜy¥(ü*ş|+Ú}ñÃ¢eñ]EšV%Z£‹éh}ÿVüû	Ä¬Üü)äşN2r_N§¨g,~÷³¤]%Û´câş˜``hÃqŞ˜k¿6Ø’³êÁ°:vŠT£´é£Šê©‹û€ùó8œPüÿŒ¹´éã¨¢¬³¸l@2Â¨É¡úÙ]¾6Ixå@Ä7İÓŒaÌyÌãü¼EïHÍBPMá½ô°¡Ì35„
+Åo}mÉ1İøıöíåè=¡íWŸ¬€à;µ7,2ƒ·ëDòö·EÜµó#Ee=5·šºÊ&œgWh¨İŞØ@°[k3ë’qg×ãÉcÀ÷WWÃÿºgr1œZ³‡ÚÑá5•Ûpøtüê¡OuÃtÇ©¬üÛ)HôgÌÏT˜~<(ÅaÓàüûi^$ŸÃåó¨\ÃËÁñÇÊğíl¢XhöÜº´›Œ'¿æÌ¨†­† n‡Ç§ûğxmHÒ/´T2ÉcŞ¾­Ÿvµq÷†p­È±ñğ°peøÎ·ĞQwÔd™-e¤¢d ŸoÎ)Šßp©Œ')<•VÖy&k¤×øñ®ĞXmLüd6 4õêİAWXıba4/ªúËSÚnıQ¤D~ÃK†¼B#¶ø³¶¯VºCõOäT¤ÈºØkQ*&Ì½ú%5²óÓYÍê¬®m°eş†åä;(‹ÛX­íY©º­X|›‰LúÇ­¿”R(…ìDrjÛ¼è&QÿXU~‰
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/7f/6a4a32e7e5d10ed79fab30e116edac5bdd94c1 squashfs-tools-patched/.git/objects/7f/6a4a32e7e5d10ed79fab30e116edac5bdd94c1
--- squashfs-tools/.git/objects/7f/6a4a32e7e5d10ed79fab30e116edac5bdd94c1	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/7f/6a4a32e7e5d10ed79fab30e116edac5bdd94c1	2022-01-01 15:09:15.633172589 +0800
@@ -0,0 +1,14 @@
+xZûSãF¾ŸıWÌf+”ÆØlrÙÀBC\Á†²ÙÛKö(—°Ç Å–|’¼#üïùºgFš‹Ç•i=ıøº§»•ëYr-Şşòö—lm‰³?{ÇrœLdÚ/µÚë(Ï–)~æ“ƒé×æíö ½3åêfsKıw”ÌçI¼u,§ïÃ¹ÌáXŠ>¦©Ì2q_³F‰$Fjã$ÎrÅ¹¸;“qwrÅQv+'bOl¶wW¦ûRNºq”Óôön­ö9‰&âHË²³CSA½v_â^à—Ó$ˆz„­]üy'îúËù0s™á}c£Îëh‹^/‚÷İ8³->©=ŸÄ»=1Z$oê…Ùİ®ødöá ½SˆQ”õÂ||û1ºúøéª©˜Ùµ§rÑ:Kâ›Êz%È`–xÔøiëÑ™ö£3ÛşEÿJ-R{š‚U.“-¼­1ÖÈ,Éµòİ\ÚF¡é“ålveye&6Å]'à¤p9ëÆùÕ²´è³²ÕÃhö`İÄ×¥öG3é:¶¢]'#R¹`óAb‡È#ËgQ.Ópæ,!¢‘riYHg[WÀ“zl—ÛåãzlíÖjµßáû³KÚGĞÊp!ÇF—ãe:Œş'Ø£©FÉ2§ø`Ë	ÁZAS¹aúŸ?‰TÎ‰½J§ÇQ<I¾óT†óæ©Ì/ÒÉä„è¬!è}¨Ø':Êq„0ƒ{BuL’F!‡Ú¡çaC±boÏstE%•ù2Åptş;ídy*6÷/…¥a|™U0+.„ıl3@Và·%_­
+V°R˜°UØ¯uE4Ê™v1Óöf¶‹™moæM1ó†g8¼ÆMñsø-—!ôs”,3za}¹f2°Û-±¶VX¯¥–ìİD»ÂæD8 !µ¹WÖ\,s^cÓ2kSmnÇ&Ô+¿8ù«™¨ ©ÜUXÉæÄØ¦r–I>İ›\gQHVlPª40vwÏô„xM'r*FıóQçßG‹Ëîy¨çXmjOê¤i’’ßŠW{m0ÒÆ»‹^›R%—ñ$š>wÚ‡03—gP_9i8:98vI]M…º=æBÕu±æİyöùæ¢cŒ"Ğ!V_}4Ä®šÊƒ5G¼:ù¾ö1šHÑ4x¥édG·aÊÙü„/ôªã>Dù-Ço6­{vC%tœúÑQ´nÕpÎh<ã!öDªÀœ¢ë#¯’Ó~’ÎÃ™§ïdÑbaŞOx*q©”ı~1Á%E
+7æ´7¦!£¢ògú!ÙÕ“ş­ÇÓ°ÙËöÖ'0Ó.Á\RDã& ¥"Iz!ñDÃ&o1ªR6›à÷a]±çwÍ0¼MÒ| ¶)Ô.%%2aõª~Ğ›ıìÑ=Q»üD'\.ÅRsí¶ O˜ÅÑqb(Ã*¸G<–+.wúÎçÔ÷tûÿæÁç5±Vşx*¢	ŸŸÆŸ…ï]ßø³r€m¢Nk*5â.$©e|•ÑNõƒ	Ê;Œrm^l
+t	1V¬K\áš(õ3İÊ¨¨/ˆ:Òä;ŞÓã<ÎfÃ…òÀGqÉeùäXÁfœU)ÃUJÄp•Ò””6»àŞ®Ö–NyƒŠ–¬ ×G­‹µÅÕ‚U!×8³K(²Rı±+Ò>˜,Jê'²ûÈš‡y˜ævyTÆEßÎš«x9?R9Î£<o%½}=Hş='…>	kA°-ş*¯am]¼{'r*uÒ Å›]ÔØ~)góJ›ø¨=ÑPâDIRº³3ŸešIp{™JÔ¤Pe°4ƒ=.hm2VIY«!üûßçö™4h#’Ş³H·í4OqUj8¨àÍ9—jÜşrÎu*™„µêØ°&-8õ­ÖU%”­ä€h(ã(ã"<|=Ñ?¾M|±¹&.
+7¯nó%-95œ:Yı.=ŸŞí7ûyÅÚÊËMè³d'tá\å2÷MZc\l1© N}Üí¯V’«£dñí›ï¸XjEÇJ¸-E8)÷jûXfJ0Ò•©J6!Yòg37òç Q±Åhõˆu}ß[¸µ
+JîƒÕ¥
+q6Á]ÉWùÄêÓU’¾à}™Ÿ¨‘
+E®Ø ØTráÔH
+ô›ş‘Ğ®ãêB«¢b*0\˜.Kİ»!8Ò‰jˆ{8âª†¸—ƒ!N
+Ô÷t0ÄI„ªéS¾T¸ö,¤ÆT9¼<îu.;?îö.¼îÏ@¢hèå—2Î£-2%‡XôSƒi-9GKˆ»:bŠWºĞpºBëá¾Ójô~4AÓÂEy~C­Ün<MÄúB¿©ÔPæ†!4\ÕQ‡V¬‡•j:(xâ…/øåÆ“f‚'M÷d¶D{8Sõ7Èo£ 8Wñ"ÈÓ%šb&†ëø`¼hO´é"k¿UÀtûç¿EgM¯ªó7Ïu®àKP«…Šşşû³3tîÙ4E‚z˜õŞŠ}…Ï¿¸B~©ä4öÚÜ‡¦a%dÇ`Mñ‚+Ó7
+PnÄî£Maõ‰®™z¦Hé¡€D.CpFèN×ölR‡mİLC˜d)í$<Néü!ª:2µ×hÓ ıÉŸ8F—ƒ?F‡Ónu¸Ó?¾qV'yÈÓoÔ_¡ˆ­âAü|©Û(Ï9êÆ‡ËéT¦¯c¹€rc±&ëÀ¡á^6Ë°UµÿìO _iò»I4›Ízy’éõPVÇÅ'ËK‚
+ú©eä£aÅ Uî¨FŠ+ ù’ÈBŸŠ,Sp ¿å˜hÂMCyw|Râ ÆCÉĞàQÁ«¾Kx+ˆ»ğ{"ö-dšG2ÛÖ§>GA=Ş0áŒqNOBoøêô³B¾†rgÔíÿëà¬{|08%„Ó'ªÙ˜—š}/øQüJ³|’ê±"OÆª€Fê»xKüÊ‘‹i-°ªÜñ£øÙœ²¸vf¶ÔŒ““hLÈÓo¤<,äûßĞ„ÿí'ëÛŒ·éH`’*›Å6²÷èJ•A$ÖÅ[f×Ü€š„_‚Ù9Öæ»n ¶ÙSà‘³ÊpDN)šà…ƒ,ı%Ò•
+(?®@kû¢ó&¿İÙ¡”•*2|D¤D¾~}Ò¼î'$è‡¯¡ÅuQƒP*rMdZèÊ{b{'¿¿<?éuzçƒ?ØÆLÉë;)B$ğl¬sÕ‰•œBGog¦·[Ïì7öäO9{®º®NàZÖç&²>¬gt“ßÿêp|ÉmùÂósşÓñO±àŒÍ:…1±Çò3¢äL†™,¯:A¯Ñ§|uğVÄgòb­ŒZu.¡í8„š91£ `Rmrs‰c	ç“XBC¦ëW‰æCOãH'C(¿Ìù¶2—úğrÔ;?î<zk!ìOşö¿.vX¸/ÅÚâ…ÔWJà"ì«´@Ehoe6î^»9<÷c–¾„ÕyÜÊ2˜ª'ñÿ"À;çÇt±^'ØŞ^vJ²©ÌŒ‚ÅKx.‚ğÊÁ«ü¡5a²ÁV¤\«7¦É,jš
+à
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/7f/e715edd8f2c9ade5c9090c9337f1579c1eb02b squashfs-tools-patched/.git/objects/7f/e715edd8f2c9ade5c9090c9337f1579c1eb02b
--- squashfs-tools/.git/objects/7f/e715edd8f2c9ade5c9090c9337f1579c1eb02b	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/7f/e715edd8f2c9ade5c9090c9337f1579c1eb02b	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,2 @@
+xKÊÉOR040gĞ×Wğt43ÑËàâRÎLËKIMSˆ‰Ä{p)y™y© ’¼äœÒ”T%§¢Ä¼äçü”Ô"½%..ßJçœÄâbG'g°vƒ
+CM Á©y)™i\ aÃ 3
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/80/4e53c00e5f2bcbe5be6196e974ac551110fc31 squashfs-tools-patched/.git/objects/80/4e53c00e5f2bcbe5be6196e974ac551110fc31
--- squashfs-tools/.git/objects/80/4e53c00e5f2bcbe5be6196e974ac551110fc31	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/80/4e53c00e5f2bcbe5be6196e974ac551110fc31	2022-01-01 15:09:15.657172590 +0800
@@ -0,0 +1,7 @@
+x¥U[oâ8ŞWò+Ô`)˜™İŠiµi-…lÔvµRd‡Xcì¬@™Ñü÷=&\;Ûj¤}sñùü‹Of\Î Ón·9c‰ˆi£¿&á£ç¸nßï­341A_Y[uêàÿS&e£ŞÈl­Ø<Í¡ÕÓî«›2ÎY#YÌSªàsVşĞÛè¦Tófñåj‹¤LC¦ä\‘ ˜(JAË$_E{°–DD€¢1Ó¹b³"§Àr "nIe.\È˜%kc+0yJ!§j¡A&ån<…;*¨"ÜbÆY#Q¡©	'x»1ê”Æ0[o"†ƒ¿å ‰À$gRô€2„W°¤J£†
+ª$7TÈÌ¬!¿5p‚<vg›oä{H+&6×§2ÃR„Ä¤VXN˜Q(4M
+¾¹k Ãà~2À?Ã£ãyÎ8xîáá<•è¥KZB±EÆ&†ÅTDäk¬‰aüĞ÷nî1Ä¹†Á³É`0Æ}ß‡ÁÄ\Ç†7Ó‘ã;õÜ‰ßoøXLß ¼]SHl!…˜æ„q½Kü;©‘!%KŠ(["7NÒOv‹K1ß¤‰LƒÓ–€yVŠá€ärSÈ“>Ú‡V6àãËCÁå$¢p~ab»İv®¥Î¥hÀƒímÛçv·ı[¦¾³K‡•áJ‘,£ª™–½mYÖîQq&Š—ıc
+Ãëç N¼Û¾ñØ?¼ûãÛ¡3†ë½xäÇ.£şîÈ‰fQ£|ÆDÄ‹˜Âg*bFD3½BŠÉ†œp¸¼4úá"ú‚“*ği6Ø&pö„^‘,ä´Û©;j=Ün	ÿÏ©ãßüp8ö7¼™<¸áÄüª®Á7øÛª p~Eø\b_Ò\À:k½}@$™¢Ú¼1$°¤ü¿8´ø¾«ÇOPÜ¨U‡Ûrï™íq	'smfUÎÓ4nB½õcú¸Cí§Ğ®´ßt…¶]±ßñv*w¼+İ·¼•–Uf@
+ŸĞ/‹‡»c³Ûöí*ùbè;Ù ·ìçmàLGAåwËÂ\D9˜Ù7E
+qÛiøfUÌ¼ì›Ü+õ£*–=ìYßqt ö"J‰‚º º×ìëN¬Öw`5üÖH¡K
+³uN³Æ†MJé•1kX•Šá»”,Îpv_q@:?<HÀ€úJª/:Ã}€,JË¬HªÊÀİÜ›oæƒóöŸ\gì'ãªa[ÃiÇ?øÊÿØŸj¨}ú€?İše™2!û%4Åİnÿ›ĞnˆÿA2„
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/83/b0278fcd4425784e850073ab37255ecb8d711d squashfs-tools-patched/.git/objects/83/b0278fcd4425784e850073ab37255ecb8d711d
--- squashfs-tools/.git/objects/83/b0278fcd4425784e850073ab37255ecb8d711d	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/83/b0278fcd4425784e850073ab37255ecb8d711d	2022-01-01 15:09:15.665172591 +0800
@@ -0,0 +1,23 @@
+xİ]msÛ6¾¯ô¯ÀL§7Rì$–üÇN2§Är¢©ßÎ’¯çëu8´DY<K¤¤’ú:ıï·»  hÊ±:"‹v±X,,¨ËitÉÚÛ[[ù!‡#Ìú?ïô?ôİ'G§ÁÊğ0}íùËg+ìëÿwá%“qßñÏÑü&®&)k›¬½¾Ş^ÃÏúÜ¤Ï-úÜ¦ÏWô¹CŸ¯ñ³µNŸ›ÈëtL§ÁœF‹«‰³7sşàoIÖæ‹(¾z±¸~—µ=˜	›ÇÑUìÍ|Ç¾Ï’hœ~ñbİD6ôBû£ Iãàr‘ú,H™^F168‹FÁøŸ-@1K'>Kıx–°hL|<>gıĞ½);]\Nƒ!;†~˜øXİƒÖña2ñGìò†j`úYØAŒ½4ˆÂ=æÀ>fŸı8¿Y{YD1kx)v5fÑ	›Ğ¿6õ 9í‹¼R¬Bj~ÍA„	°¡¾€:Ù¥Ï‰?^L©=Ğû¹7øtr>`ãösçì¬s<¸ØâtA©ÿÙç¬‚Ù|€` ÌØÓĞ	öø¨{öáTé¼ïö(ÁAopÜí÷ÙÁÉë°ÓÎÙ ÷áü°sÆNÏÏNOúİŒõA+ >2°ë”Ù,Š}6òS/˜&¹à0’	ôn:bï³#:ôƒÏĞ7ÁşjÖ4
+¯HLè‰4œ=ŒY¥kìK€¤)²0Øm9”klë5ø ŸN½¡Ï³şënl€5¿’4
+×ØQ‡­·[­ÖóÖÆ:˜ıy¿“‹“›³;Œfs/}1ş/WVøü¢É %€Aƒ>ÀrÃtû`”!ƒ!¿†æ¦XLÊ6^üÆ«êSöS÷ÃOã´³‹ÜıÎ ÓO½«¤é8Â¼ïøÃ5öï¨ÿ‰²X¯‰İdGŞo,\Ì.ÁDa¢,‚Q‚“Š]áDëÍyo¿¬Ú[ÛzÙGQ¸µ²Â…eBAÉbîÇîå4^»ì÷g&ÁU#„©ã$îÌ»
+†{åçAüD{|y“ú‰³aä¶µBÂMR/NeWU…Ô˜›z—SßÊ`€É¦Q|s
+ôŸ(Şmmkıƒ"hÉXÄõ“ÿóİ–©*/ŸFW¦B²İ­½0rq`Í%¨^DãàÌ®Ç‰›3ŸuĞ¿`ã`ê'7IêÏØ0öÉ‚u@CbxIuGQêÒw­R4­h{W3?LõqÎK4e“ÀÇ‘¶ Œ•çb¤‹¥Ÿkƒ_,6{‘ÄÔÙ"Å4Š®sU˜½•?˜ëzi¶¨¹.k4æŞğÚ5›{ú,‚^€zGşo¦9DĞ`ifÑL í«eÃ‰Ã´KÓŸ†ŞÌÿeı×%ûvé%>{wâ{°›ûóÙMoæşî¦Ú0,âşnË8¡Æ‹I3ÃEc-±dÃ‡•»¸%
+æÃ?»<¥±§Ax½¤”#ÿóÓ”RÊEkH¢TïèËÒÍuöh É¤É¦5ŸãNötùûWzÅˆˆ<x4³»#‘;è’—pœh<NüT{ŒË[v‘™±e+1lG–×ëô)(¶¸ŠdE.ø÷¢neµ~(]ó?í¢$Yi®êâ ıì¶^k†Êíw·µ¡•TM‡9ì­C®•ãê@dúıéµıJÓŞİôÀnp¦¦½¨rpV¸#”›$%¼ƒÀÂ<£o)Ì"DB¸Aï¨¶^nÄ§9ø¤/“ê±Ck¬F˜/<ÅÖó•ÇÀY÷€<2|¥ƒÏ¤ºI:ğÈ@h0^ŸHõĞGe ­L``FÁŞĞ°ÃµÛEÃ†©±¹ßª,7­ly¿[´}U­¤èm¸ë[É*w¢v°:Ó—/Ìªö”µ¡ªÕòòL.tî‡£ );µÂæj°iÙì‹X…˜Z…Ç{ÖÚ¨Ù|&ê*í53SNlC¡“n¶’‘^fç£; ÉG/³ó1ûÉË\nç§»ÉK/³ó1xÉÈPhçÄ¸g”_-³ó1ø&¥Gz+vNH›{£BW²‡Õ5…o(TÍŸÚëjSYÔ/— ¼ÁqÒ™7Œ£áÚa¨Èµ7œ0ƒ°Ë >àÅ|–|
+§ÑŒMƒ4Øg:œ@åËà
+Ñİì¢˜Ÿà'äİÜz0ñŸAÈÃBf= á€Ç9œh2à³‹| ÑíB~°¸zº8Áƒ„Ö¹}à¤  âö1ÖÌğfØ€\ùp6C•°Bèq2¬ªıŸ;§n H;â´à½Pàd/ÿîÎ#úC¸gáÙgoŠd¢—ö¬HÍŸ@Õ–†ÏO»gîûÃÀ‘7É5ÙïÀT@Å²{êÓ£îQ¿; ú5†87*(€Yj}äÚh$Íçï2Ü^c€¸o´m„´º`‘¨ŠPÂ.Ğù6œ]Ùù
+”0£~§[vj	fä­6œ€ÙéùšX@”©O­íJaaêš@f^õu¥øîL¤í6ˆŞÚ¶©4Ã¡9é&tÈNÊw»8Òn‹Óon£œš¿‚.Û‰	·æ„; Í[3›Sâ8UQ®M¤ë +©À»9m«R¹ŞæÔ›Ày{ÓÖ_©4¢Ş\¯4•Ü=rßÄñ°ÛUN¬BÉ™En¢²í5åô Nm¡rì"ˆÙÁ‰·A;±œD½óÔN­M^	ÇÕ^É81¨â+œQöŠ&…Q½œ#öz:bÏk¡¡òZØ|ëûN¿ëöOö»pÖÍüë›ª+,¸ÒĞfJ™² ^¥æAT«Õ!ˆND WËêNa`‰¨U5p@‰
+udŸA¼Yµcæ2p$ÈsÇ\CŸº}X¨ø…*¬³JÑÚU5
+Ö¡ë~ÈF®Ğğ×·
+#Ï]¦—7–"MBˆH…rµ²Ê²ßıÇãË¢ï À §XğÀ$‰á}šÖ\¾œX¥î_öz|ÉÍ;küSWøœ-.Áµ•pÖıøø
+Ğ·_Vá•}½°f»+Î]8¿:€â`§¬—®JÄ1ñÅÓjZ‡ßD­†Í¨U¯µJ•pUa0[w ªÕª€¢SÓ´. Æ•·,¬û½³Ç7k}çıÕê/JÎ½Úk[ (´µ	IH­eyVİ²×P!éò„±Ïo2lä!¡ıÊ¦Zu¶ r™A¨ş³#îƒÖ+·bÚxµ1†»ÅgñáÚïşó¾wù|ZPBŠu(%Ñ*÷4e»­&ÅBˆQ$Å¦VcEá—ã
+¹ã@ésHÌ*>aé¹øÖ(º,}µ¹`Vœ«„Òr·X©…îñàìâ!L ƒ­:P&·Õw!"Ï¤[©ÄØWî^´ı†DC¬JâÛµPQ!\uO?ÒG_ìDZFiÖ>œ$a¶eA€”%¾ EŒÒD5ŒŒƒjØ\°ÊàI¾ÃƒôÒ±eoFQ0Å'²ŒÇRìÃìeüººZ¢Z}ËóD!®ÆMJAğFòUú•†FecIğR…BA|/|: gº”nq¾³y(kàîåş4‘ØRš¸-rÃTepAZ5İ|K}ï³Y³—fqê /¥ªóÚ:AÎ:À/CDËs·à0
+“Ğä}Â¦Åùœüt~Êı¥YZxŠ>È*’ïîò#+ëRR^(ÁİÙ·,b¥È±&	ÈlÎ›£lwñõpe/Í˜óß…Ş_h°:M§Ñè4Á[b„œ¹Ì°b¶d°º [1ü¢T6
+Ævÿ	ª£î ƒwÜ~ï_]Ó²$ØğFNà§N[?æmİ¹1©*Ñ]ÑE¨Õ¼!AU
+®K´š÷ ¹lÑ¤d9qX3-S¦4€vâø­I÷'ğ€p™k­ìš‡2.N»x±bKŸ|Fb±ã¬ë	ázV@K¿\!ÑãŠ¤kÌ÷‡Xxb‰	EpùC-RR€ÁPÉ( Ç{Şa|Öè>ÖkàSY¥2A£|¤¨!¤OKÖ’>-Iğ<TÆZJ7âúTusßÉÜO\*ğ9g÷ÒıÄÔCÈ™îzÜ’ú§rïnî—ÜC6·†>1•ŠÒ­ %oË3®9»mƒ'«ŸÁJº,¯†E¯vkk™ÖÖ2¬-K«n–´T}y¹¦5’[2ML‚r-{¢–A‰’ƒ¡ĞÎIï·d¤—Ùù–0‘<¦—Ùùä.“‡=>§¨Ç\nç§h)¼ô2;İ¤ô2kÎVùD»•ï¨›=+‘³’£õm¬9
+2± vo@eØ•ï3 WöwUZ"§4:í©]_Ûr-€7|÷€¼ã´Ÿ°lõÉbİ AM«ØöˆÎŠDh‰!²>¯­"‹óÿ8®ñøÿ1ä1û«L9¹À)jÈ¦??†\ºŸ³ÊDÁ!Å(ÇF¥[’Y,e O~íÔ".!Î˜~uêªP>†št7nUSQ ÷:‡¿›p0b??‘º¯ÖfY÷¨Ïvî–{E;ƒ5ÊšDÚ&Tw·®”Îí¶—İøî'l…DÜÊŸŞíŒè{ŠÇm–ız~i½~²³4~¢Õ¸Oüä;–U[X–¬ÒºïyâzPWÌ‡ÀC˜zjîÂUwÉ·ùÙ+W´2jÅjõøÉ±}+ü¤¼êêiRß‰F±B†–ÓÍ÷šs)é_©VáÊvYŸJs/·²i4Ê‘Ú˜V{L«½¦Õ®‹iAŒ÷§¶Xûªu[À_æ«Ö²c0î×—¸dázpy„Ğ(Æ5´¨ÚaÑ!PØXq»;Côï¾–—S‚iÍ©ó@ºò˜	{oº"­Ì‰2ˆ…É€€±Ûj]r0Ú9ipI[2ÒËì|¡¢w¬,M
+¸£Ò's¹½_Ú[á¥—Ùùè©ã
+#C¡uå"³ÂH/³ó1x9t†B;'uRÊA“3µº¦ğ …ªùS{]mÚ‰úå’:Ğ&İkW0‹é~¶´dy¾OàÇTU6tyĞÛazî‚Å•ÂŞù—d±ŠËkò[úX«mcFˆ–×AÌ5d5ïÆ]!ì\ø*0Y÷j EN¤Uhs®oÉè4B«!Ù}Zñµœ\@«5dÓ ÕÇKwåV™$¼wKr|ébÌ~3±¹Ï"ç!ošH•…[n¾‹#qUî ØÏÊ×zCùúªeU~Q"²¦:€í\˜¯ØV‘Æ‰a€­Ùëjøc(Ô°z/¡ÑZWo¶àuãu4Z}¾¬ÑŞ„ç*5Y¾zC§ÎTyãf	­–{ËÂÃ-–‚l«b7nì:-« ït·Ú´p¤x´İ¸1[ráæ„ÏÃ3«ôw¾psË„B±xîóH•í,­B)â;»ùã¶‹»ÜånĞXİ²ÈÓ}Ñóµ'ßY[å/Û*(Á~X(LU.“·Ë—çıòÁ¥—ˆd
+
+ãzÇ…»,ôşô¼ÿ_™GŞ¦„ïeòÈÍá¦,âÍÙ
+)D)O€ÆÒ{È¦ÎòÈk´u/yä™ª*…zÔ<r›àÒyä€:Â~¡ğş+|›=¾C*ùâÍù°8…o¼"ï°iÓ×ø¢)¨1oH~3Ğá’	½"‹¿»_y=Uşê¬9ü¶V¤÷k…ü	è'ğEVôÒ+åeUø{ ğæø-×ECqOÎàİìí[ü»÷\à~¯s¼â@"xş¾.z!¼ú™¿«øz.ÓO	Ğö^bµ 5‡ÿ#¸”Ò}æŠÑµÁõ!¼â`ü)ü†‡Ö›bû /¥{Ï^2óN­ñİÙŞ„ë	ÔøWôô1–ÛÂZrõ?õ<ÑˆØÀ>”ıÈvğ~ ônôÁ×¾4Øˆ8"{Öœ³UÖ@úüöÓ©42öW`ÔÚWÈoH¡æ‰3İË‚«‚.Ìj&Ì÷whÿì<=%««YÇ>¶…=|÷5¸M0“¿BZìÍ›|xñü| nÜµ ¢…MgæÏàÕÌ€Ç‡46oÒéÿy—
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/83/f813f52ac35ea69a803a54fcc554cd40f65fe4 squashfs-tools-patched/.git/objects/83/f813f52ac35ea69a803a54fcc554cd40f65fe4
--- squashfs-tools/.git/objects/83/f813f52ac35ea69a803a54fcc554cd40f65fe4	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/83/f813f52ac35ea69a803a54fcc554cd40f65fe4	2022-01-01 15:09:40.213173601 +0800
@@ -0,0 +1,3 @@
+x+)JMU040±d040031QpÌÉÉOÖK.(`x´ãğ¥ÎÇ_šxB¹¬°>ØÑ|şŠ¢†+.ß'ó6>>è%Rau]X¢×Oë?T‰s3ØÓ‡Ûª'%«¬ĞyøÓ)Ğ§ş+’’†léÊìlÈŠ'·m¸?Z_×ŸSï–™“êé6¨vÃ…6­F»‹æ½T–ş”æ$-t]]ƒÖ…Âôy½Õß
+túqfïµˆ°ã‡©ÊÏ)ªÔË`6ÓW·4¿vóÿÔİŠN+Şèäë@¨ÉMÌKñÉÌKH,*N-[­¾ørë*Ù¨HÑ¤K"%fwÙÕLÂ©!ƒáá?gyK³µ…ëÜïô^[H¼ªÜ%5­è‚[—×õ^le:»G³óÒlnç˜îÅP¾•Îù¹@%/™=„Æôİ»ñ¿‹åÅí)÷àJÜK3S€F•éLõo|õrÑûÃ\šçYU´©™åÂ•yæe–€”ÕEßw5åÌ¢rå›Z=úú?7ó:Wš——_Tv©·Õ)Ì6¾ìg!Ç¶õéét
+À•…gæ¥ä—ƒÜŸû¡7_¤GUÎyê¾ƒõK¹lnO[|ªÌ/µÜ‚9Ğ ›9E³æãµªÎ¿6eíŸCBmfÁÂIeÃÄµ&‡l÷<U&³zÃkŞïÎGWBM.IqL« Úš!÷Ò4¯í!±Ÿì~¯"|Î¿½m§	WS”™—¬JÅ‹Wg/P÷øÎñÀ7;ÖuëMTUGÔkd”#?zY½|ò.şdÀæCPÔ8çç•¥•€¼v!6çoLëÌyIår­~°›Ú©‹UqCJÏ^İ©Œ¯Ş:‹ôhs´­|—•Š¢4$ß3bªüŠ÷Š-W£‚¼/J1}é¬àĞß‰êLˆÒ†İÓå“ŠÿVLü¼_jeyqú£­~×ŞBÍ©,HE÷·<ì©C—gÅ<š” ôÜÔGšª$,5¹$’ŠOÛ¶åFµ®1<Í¹ôlÃéË8PUe0Ìğ¿{puîÙ]qSÂòr*ŸÿIù[ -Øœ¬
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/84/5545db9a90066361549ee45536953879a232f0 squashfs-tools-patched/.git/objects/84/5545db9a90066361549ee45536953879a232f0
--- squashfs-tools/.git/objects/84/5545db9a90066361549ee45536953879a232f0	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/84/5545db9a90066361549ee45536953879a232f0	2022-01-01 15:09:15.605172588 +0800
@@ -0,0 +1 @@
+xE‹[KÃ0 …}Î¯8à‹u«Ã‡éT¨¶` kKİ|KÛàYR’^¼°ÿnö0úöóS*Sb±|¸šOÀ~œÉ2ùnŒmİ¬B€}®#(YZn3†D·#uKa¸îÂ ¼Ç#è—±Èy¯LïSŞ•JV¨Í‘KÉœk©+ÕÕOƒÔµÜìğBÈk–1ìiå±Rk¿¾y§éÇ&Jß¨v-×•˜"ŞgEŒz(wFOÁò]Fc¨¦NØ^Ô·ä`|àyä•—§ï/x®Ç¿c8++ÚÎjlŠm²"'òç]ğ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/84/8d13cb100962f72fdde64f0cf8bb7e84dd6473 squashfs-tools-patched/.git/objects/84/8d13cb100962f72fdde64f0cf8bb7e84dd6473
--- squashfs-tools/.git/objects/84/8d13cb100962f72fdde64f0cf8bb7e84dd6473	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/84/8d13cb100962f72fdde64f0cf8bb7e84dd6473	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1,3 @@
+xµAKÃ@„=¿_16W…V[CS(fSƒm6$Á\¼lÓµÄÆ¾°‰
+ùïÒƒÇ:Çù˜MÉŒ¦Wë"7\ó[Oé’+m4ŸÛ‚‘±Ù×•Ê5ü¢Ô7ğÙ|¨/ÚÔpo‡d![Äa.x¡L!¼ …Œá‰•HÒ§ A&ãç$Z<
+øÁJ\Y—Qdø]çƒÁä8pí×ÉÑŞÖn©|¯vòû ;ÏûîrgwsjÛ–º®;ƒ}ã^ÖÒ"Zö·«Ò9›ûÓaôŸ'n€q“
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/86/232aa3411ffb08975cc8cb2ac3f7b1fa868e86 squashfs-tools-patched/.git/objects/86/232aa3411ffb08975cc8cb2ac3f7b1fa868e86
--- squashfs-tools/.git/objects/86/232aa3411ffb08975cc8cb2ac3f7b1fa868e86	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/86/232aa3411ffb08975cc8cb2ac3f7b1fa868e86	2022-01-01 15:09:15.593172588 +0800
@@ -0,0 +1,8 @@
+xíW[oÚHŞg~ÅÙ®„šĞİí*%¢’•ªD˜ô!/–!±bl×6i“ªÿ½ç2NiµR¥>˜33ç|ç;·É"JğüÕ‹şxÖ…·^‘©`3XB¿+%¬·ñ²“8o^öûÃçğÜ‹$ƒÓà:J®quº]DáVÉ&cè>kµş
+ãe´])x›Y_.Ç–ğÉü&UùàòI«åÍTúìÆbĞŸ©`5t\K]ÔĞzp„+è.¶ëäá­òşê+QY–d¤¸ÓúÖørF
+:à ƒ2’Cy5Í’¥Êsµ‚‹ŞğæÌı8=qÄ`L`ô¢l·m®u:r#\ƒc„0Ò¦ÈP¦Šmƒ&çQZtÄ—ãİ
+º?£H+gøıQ%'ßñOëöÎıéÉ›Ö÷"Å£ğV*Ş	IC?ò~îOf³éÌw?ÍıÉô=ÂnÂB~6à
+P±@Ğ±5\ ]‡ä÷cc£]©Gç°ïøôw×
+ÿ‡$¹2Yé)u5O×VyyæÆÅ¿C²^çªDR t‘~§L.Òi’«]0Şdrâ{“¹Å£mÒ§'e’İ
+é›‚I6#Tq´] J]Ş·Ò¶Œ¿$Ö]ÒÉ~…Y«’j”zØ¨Í2½q8IÌ¶`ØGÁU˜uå©2È–	€n¶¬â×krúw_0µhÓÆ¶)“÷3Yë;º†&‚hy8*¸c“¦yB‘å¼æà’Z®ÀHÓ²å×z¾•Ñ¬&Ã	2’’¦;®ÔB7¥V[“tÒ”NéC_C<“öÇôúô+Mò²:ô>6uh·1áèÌØ&r5ĞÑK
++şÑÙ{ßsÏ'r@ĞâµL‘ÇƒMÏ™š¬G@˜Ï6cĞó …ŒAFÖTÒ4 B¨o$M;Ğx­³Ä£xK?pÜguÙ#:î€÷…iò5X¿pˆª®7Ş&¡®"ï¿‹$EÈšëvŞ$Vÿw<=ê¿U±@|TÙs¬V;Õ$yO÷L»ê…ÒS<Î*»Èª÷‡¡ÑndjsOeó®y¬éôG?~V–¦Çq$)—HÓØ.;1Ì°) öHDvåõğM°aEƒ(¡[ÒkFt€–õ±Œ#²M~TTlÊ3¤‹­ï–v!ÉÂ‹0–ş0B5¸ªMêv·Ÿ5†Pc›Ğ†¹Á0D«´‘÷B}š‹HÕ60. ÂaÁÃA€£ş|@÷1ÄfŞqÛ»¬éL5YàuÃ	njD4+¦º¨7q’˜mJÙú6IÌ6³\$Ùë¶‡ÅwÈ™•¿Lù¸{j9OØA²oòıEd®•óÑèñ¨#KºÍŒlçNlíŠ@€lÛhôë5r4mÍšP³Ëo”AÄÛtT0U–?À]¶ ŸFşÛ%¯ı‰ü(g×gµágù}³? é‘İ:
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/86/f82bb9280455c32ffa0adb5e0dfe89c2188585 squashfs-tools-patched/.git/objects/86/f82bb9280455c32ffa0adb5e0dfe89c2188585
--- squashfs-tools/.git/objects/86/f82bb9280455c32ffa0adb5e0dfe89c2188585	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/86/f82bb9280455c32ffa0adb5e0dfe89c2188585	2022-01-01 15:09:15.661172591 +0800
@@ -0,0 +1,180 @@
+xì½mw[G-ü|•Å‰gÅ¡dËoé¤{âØ=-'ZñÛXò¤s“¾\´DIS¤š¤bëfz~û³÷P/‡‡’œ¤{æŞéLÌsN
+…P(
+õf<}ÓÜùìÎïïüóÿwkãJ³Ñ<š‹a3hæ9ÌæÍÁh<œŸÍÃã›M³{4š7øß 9Ïš½éñÉl8Ÿ÷ÔÜo¦“ñáµğ(ÈÓ“³*-šŞŞzs÷öí»7ø÷Sıış~¦¿Ÿëïïõ÷úûÏü{ç¶şŞ¹A`xTõ;ª~çw|÷òh4Nš§ÓÓÃ£á¬ùòÄ^üKtåætvxóôíGH}9™Mgƒcöé`66óéÁâİ`6¼×œMO›½ÁİÚÍ³Ñ›SĞe´h“ı[Ó<îÎøît²GÃf1œÏ›é¾~şºùz8Îãæåé›ñh¯y:ÚNæCVÌ›¾œxoÎTã	qØqš'S ,FÓÉ½f8øYóÓp6ÇssWd˜ÎšŞ`ATgÍô„×ßY3Æ¦²7Wô7wk¿MÔüÑô]8HtêÈÙ¼6§óáÁéXíÍwÛ»ß¼x½Û<|ş}óİÃW¯>ßış
+/¦ø:üih FÇ'ã:bÎ“ÅhÂN?ÛzõèTyøÕöÓíİïôàÉöîó­æÉ‹WÍÃæåÃW»Û^?}øªyùúÕË;[`»Pİ'€Õ4m ìx:6ûÃÅ`4GÇ¿ÇHÎİx¿9ü4ÄˆîG?·Ø÷„˜©ó«!k´ÆÓÉ¡º‰Âàgœ{Íè ™L7šw³d1¬jY=åæ³nv‡ Ï°y9ì›Ífç”u?ı,şÕt¾˜Nn4Ï6·ïŞ¹sgóÎ§·!¯wFwß&†Şè[W®üÓşğ`46O>İÙjn§çİW¯·š;éñÙÃ?õŸn?Ç«Ï?ıÃïPm4ÙŸî!)ïöo=(^ÎNê‹Ññ°~s:X´ªáÅhZÃ+`×zw6¿µ8;Î—_ÏƒEıö`o²×¯†³Ù¤ÕÌşh6œ´jRj'‡uU 3½i½N­&æÃÅ¿·h -¸
+íããÁ¤z²8¢B¬_Î†‡Ã÷õ«ƒÉñ`±wT¿dKï£VÆ£ãÑ¢E³=Ò‘•1xĞBÍx49}ŸÆ¼ßÿêûİ­ş‹W·^5ùgù}ûëşÖóÇÛŸ7_¥ŸÅwˆéîÓ­(R=CŒñÿ{>TÃ1t\æ¯ádÔ&×Ml(Yæ `Ê«Áåıôùj†–?Ìß0Då§B6ª÷óéÄ,KÌ‡§ûh¹|“ÙtV¿?X,Z¯{Ô¶u1°e»¦´¦Ç7ƒV}ëvÕø`ïh8ßüËéğÿ`ZàP—ÈNK´ÀÜ»€Ê«K¢Õ=4Ú?˜!te4Y@3‡Ğ4÷MUÜÓ»ƒı{W *§{‹4é÷ç§'ÃYÿÍxº÷¶™5~{ïÊ•[å¤ŞŒ‡˜2¡qßœÆû3j"6A"ö1ÍëV&Ó¾ÈÈ×z¸»ûªÿxë‰!0™ş©.»Š¹csX$Ù{Kà÷*³(ÿ¤.Ø©«õ—ÁøİàlŞÇ¶ªÄdº]W™L×/æ0€Ğ¯ƒáû0ÔàTxùz~2˜±%ZLÕ‡éx¿?|oÊ¶¬@¼¤ê'Ó˜RÕ ßıé¤/ËŸ®hVÒŸCØrƒqÿtÄš›wn4şâĞ_Øj`m\ÉÔ²jæ1tzßŸş»µó¯¯î|ód§ÿdâ¿³ı¿¶n4V`<=¼wåt2‡ÚÄ$Ê1í÷÷`«H·©@ƒüîF3?;.÷‡?U£Yùx0:˜ÏWÖæàÃüÂzbóíÉt>¢$jf†s	¶ëPÒÉneú¼9[hT0Ç.¦P*½0x¨|<„ùpÖp.ÙƒTÁ$Óo6he>zS›» ¾w4˜5©x?8âùë§O[Ê…R³7rCAó„[GqÃrZb?×t;!%ú*Q9#Êä(ñ²OÎZjL¨Ñd
+ëáRDRÑód
+âØ‹h:­U¬"Š¾-ä2,u¾îòtl3Ÿ55NßäÓŒeŸ7¬ª•jõ½&dnã_Œf˜tÛıG/^?ß•ü­­İ¹û‡ôåñö+LÊ»¯¶·vÖÖ>½›Şo?ñx«ÿd×+}şÙgŸ~ŞõùÙÃo×Öz­
+0Gï¬wïAfEõµ:Ö\kŠŠµ~%¦‘p¿^õG°IŞ7?C„[3Lú¸¦"÷®¬QšÖğßÆdp<¼wå¯[¯”É@¥âYØÁla@´¾A‘•/­7§¯OÊwPjkkĞú³3ùò›ƒ)¾ö—ë–ë	æH¢pŞµ6©ÖÀ4 XG{zoP»Ú—NNßgíŒin4ÎüıC1vTí6A:Â’ßØyÎeß>—3ûÓæ`0‡é“2Ôë`F[…š ¿ÕTM•ë=ã,ˆág»,ôƒØíp¾À‹4KºV‰é‘Õ°L›ÀL7›‡ÆWiQü0¿e³lnÏ?Z“?_YãƒA¡ûø	‚‚ñ?H!f[zôô5Ä†´hşpçŸï
+ÍhO³šw«jf#N‹#Nù¦gÙÅbÊßïÙDAŒÉÛ˜]°ØiÈë™×	©/Ş¢ÔXEˆ5Y
+}Ô€Ç3p°k°Ş‹jôÓ7À"V,‡eUolYê¢îœˆ°²¦øºrn÷‡Û[ÈlPôåÃİovúŸ>}ñÈ¨zçv’çÙPN„sºÄwëÑê¯óÅhïíK§2ÄÓ%ÈNÉ4lşœw}Ø˜ßqD«´+É©Ñ½'¯~mıúôîï?ÿCêZš¢b7=×FBÕF(4,„dñ²½ú;íqHe²9‹ìÎ¸ôµyª1 Ã<´æ’
+˜ğR@\İ´á;ˆN©/}¢ƒf¿ßÜiY/³étÁâDèH$Ø|Èæ>(ø2jÑ$öşAŒ7ìUŸ€.@ØNÂñ¬¡SyfÓc¸‹F‡#,Öÿb¯8áµJ©­>%aª<fœŠ¬2©3öm.rÖì´Q¿´.ùÂL·¦®ÄƒfprÂU/z>ø¿¥Øäp…W’¾#x!÷†ã1CF’æz‰Œ²ólôİh6æ1ÚgıUïcÅ;Ä°°•ç²Ã(ÙRFŠ]æF¦(YØQ¨—[¶ïĞ8ùÕª¢3FoPO	º){—á¥&¬XZ‰ ÒÒæL<¤5Œ¨T(¯=X#­;X%&-›Ãæ!ÑĞ§ó÷àÍåqóîh(Ÿí>Öè`Z-Sˆ9Ğm<àµõ•¿Kc› Âà²˜L°Å,Ö³Ù,rŠq9ÔƒD³7_à^ ;§?t	?iu®íå. <¨[y‚ÕŠJšÊ“&¶X?Má©>/KŞL¦³c.²—y8ŒZ5<ÒÖ¿ ó„¥íÖ4[Ì¾şaûqÅ˜\f½”ïiY»ıxçÏÔïøÒR€XU‡ ,Ò«çVYB,y°*>jW4%Í•}/°R‡3 l–ß@µg?¯¹L½ôêo´..ëW/Rqù™šÅ6ˆ–ğDîØƒU
+Óã¾?]Yc9"…6%×ŠU+½O©¹ùğ/ıÜäñ`4¹wÅ]¤°h¼Ï&BîJŸõã‘¥ı¡¬´aÈNsAÑÊû°ôÚ U \G;ìÄÁ×1v|ŞÃdL# (ör÷›W[÷Ÿ½ŞİúSûùöîöÃ§°_eèQƒş/¨F]s‰j”5Øé±ù3‡‚E¹7Å¼97ğF0m`†6İã³‡ÏtFƒuS=%,Ø†ëmSa¡é\Á¶ĞL0d5¸XEè‰şNô#¼ü‘¾@LõpŒ†ËOS
+% ±÷f3{#!æü‡À·šqô­ôSØDĞzí
+Ø]ŸœY¥s¡p¨É´¬öli âl*)q3ÉÌ{©¿764¯8H4H|±¹gš‘Ì ì°½íeJÍ°QTõiğvª¬O09E–Áş~¿¶(|ıà†¬oÌš=fV×ånº†i¯¸; ¸Şa—dr±øé3àF“‘ÉµÂzcÃ=0YÊÂQu1Ú‹A Áü§ætùšÕši9(9ÎÓ¡òˆ¸àÃ:OÍbo¶¢?x~zìİ‹Ç>çÛÜOÎçŞMüšÃ~ºã$¼ác5lK°b=Qc}šÔ=)G<®÷¼|½.¢Ç ñ=º»\ŸrsÚuÀÚCÿ¶+º\™mªÇ¯våß-Wî(õÙ¥J}ŞKëÙTî:èFD¤ÎÄ/˜ŒœŒUGÚì—±Y7—­b²‚ÇV±M›Ÿ¢Šm4¬`,“®Ìk`å`¸,'‡ÜçíÙ4iÜd;Su‚Q=Äøù$t0ïeæóB…r0s&fŸ¾á+Csˆé+`kÎ6O‹†×<x r¹İ³Áıƒ¥}ÀjQóp¸HôêÃgîhQ|­têQYøäèle3fa¸ÕÙÑ+¦ëàÉ8ÁÎÈhÑ[¿B/ÃA¯“×é{àë˜“çÃñAo½¹Ÿ†’¶¾|ö¶’kˆbÏ‹¦WC,ŒçØæ‡÷j4>…,¥gÌ
+^½Xn}äUŸO±Ão…àü‚7$õÆ‡³w£9 ?A„Ä¿ŸÎ^‘sv ¬C…Ë(|báˆ¦ĞBnŞkjqÀaéºåÜ{w4Ú;âzáİ‘MŞ!hR5Ü'¡½îŞ ¸À;†•üt³)Â^öR§á¢{–âÖ­Æ-ş#¢ßÁH¬­ıµáv­(ú5Ü×¡nØˆÄ¾¶)©†¹@bTŞ"T¤×ÍÎö×¯w^Y©¨Ú¥›Ìš¾­cŒms2ùÒ
+ãÚµæ£r…¤îœNà(|‹ºi%~'tï—˜ÊÖ#ö	˜{­jÅ*_’i5cs0¾£7glqél¸8M8Îwûˆ©€Ã|°Ş|Ù¼ÉõçG£l×u@Ğ—N(€KP Õ—ãÓñbt2>ëçGÃY'Ì[MQ Áí‹ÌÚÌû[Ô¦xFÇáÔ{şµº¾¢ğ’=ûV~æŞCì´¦”õŞÒ÷@I{4_~‰0•õæG²Ùõ…Í¸Z¸zgwÆú:¶L—Š”Èn½zõâUïê”…yÓ¿;¼Hı8ùqr,peÍÚ¿ß˜|­µwrÖËb,
+LFhlLÉ¤KµcS±òÅ^‘"ú\|hÁÃ<`»“¶şKöpw _8Oˆ^ñˆZêvëÕ½+ÍrÌ‰y=ûê&£—BaYUJ•š%D®Õ.XV˜®)v«xL‹®æ"ÅËT07”¨ĞédB«ë{§fxÆeû¤où	õ’ó‰˜¤|H(~Hü “2ÁJø]T¬’ŸØJrX©™ôDpá¾R;ñ@pnšs½S:µÖ
+?Fòi |Ì»ÎÁÉ|m•qÍl‰°#ò¤CE+Ã“6{†3³ ¶ş´¥úmxi=”2B¬ÇÃ»½´v<³¡û?MMkÃ¡òu„öÜìÓé$V¦6‡ÂİÌbM+f‚ ’\]€)^Uèˆ§òQYÛæ©T&ÀÂï?{ü!›˜Gn6hue“˜c	kåš$!ÙJ€äâ\SÜWp5¸6s|ñEóñ<­±5ÙcuÍLwÓ]¥Ú\»ºÇıù÷¡ÙĞ ³ùÀÖ©=Ğ¶nòvóÿ ~ ¾ÖÑP‚©B×gkş£1©Ş5Ì$^<{ù
+[û_at¿Â–Ğ·ÍÄ0†›Üe‚&fİÒfŸ:Ç^ËáŠÊä…rôŒZcïí£Á˜‚{båĞÕğĞš!kœJXZC–Ä0QUö.°R-DíU{Õ¾Ü’û`‡½b*h0:‰|Ï¶v>~¸ûP;RÉ€B{Ü±Ñàl–“+LñG¯×A“ïúzs½¹kÀÖ¬'ğÜŞ§¯n¿Ÿ×D@b¦–®èó 0¹¼G æ³¯=ÛzæÜ.s…kÎ}Ä%[½¢½ûÍ¹İ`c¬C†ZÙjlŒËN œõÂ¦€ëø´ÿâÉ“­]Î`6¾Ø¶U‘^ÅV|ÂşÛöæ¶:µûêá£­ŞÕmöÂ\Í¿4·ßüŞ4DˆlOh#UO-ì|÷ğeç›¯vwz×¬o11CW0Ì/^5˜f´B¹îŠˆlP’‚´´ÉqœŠ$µ¡JaW•¤@´E…„QIÄ-% qÓ£ U‹NV Ñ²EAğ·™KM†`Á¯Eá/!.Í¶z¢–qù0±»U­AA›ßnşHN‚55Wvw½¹¦¢ÿ¹Š»§³Ş|‘ph6U>ãG½±æ¢»¿Wˆn&6Ø*ãg’[â/JªÓ¨~–P’ŠP¯É.…ä ‹ı='{A[òaP„h»&Îˆ‚LeqZóFù<- ñ}³¥h03˜Új;&BóÂá´ˆ¸E6‰ı.LØÄhï¹ªcØà=–ØQûBm#é~M±"IxR°á¦=ŠŠàÖÀªÆUª¿ S˜â;œÂ- Šò:ŠpZ˜£$&llÌt¿ÙÂ¢ó•Cˆ%Î+t<l€7Ã½\Ü08é‹!3ÓŒo`ÖmTƒÆÜÀÙbY¬g0z¨4) )ÌÚ1)İğUËIÿ`Ş¢^P„Í¹VÌ®éÁöğ4e	4nÂD"Ã+k®3«†Èüm Ë’‚A¡JÇc(SµåÚ½1$ô4¸’|{ãá`‹øät~Ôsûr½	ç†måÀc kúFs-íèŒu–èÕ0vğ­ßŠGĞ=Ì[[ßö1¥È‰OÌäæ]«sOY“›¥…wcy o4²ö®:N-Ü·¾Ëäk;|W5
+Şå—>’$>ÁÏN@97ÈĞ®¯Èu¸ÙBºj¥‹ØÓ“æ#g(p]–e[Ph¤şÂ¬V?Dš!¼1‚Ô’çJéw:Dg$Lõ_.¦=W=…€†PâRjÏHXpN"ä¯‘ÊÌò;¡èÔ,õô‹¦SrLL–F@bqäê!<Årìå1÷ŒçÑ7¸`eÆS(ğ|‚WYÛbÄ#;şØ\µE’=_Å$~•Î‰Á1Kz¡d–€
+Ö5“ƒ%©4îjFOŒ¿0“¨*]¶¿—!wÑ%¯ef2\eb/ƒ“lkß ÖqÒìÅÆ'ºë1%XŠs9Oûø”Ğ¾Í0>K0Úfyidj
+Ô3uyıs©å&ó»°¯Ğ°¡>dù³Êh£[ÓVRÄäôË-€ÔØÉ°®Òú¨^4a._+¨–ÕƒÆ´¬İ†6ø¶ Á†ñúJc~"ƒ¥Àqå:ë¿ÉbªA—W­‚~åjª 8±½ £„œĞh.Š‰şÙ÷Ül¶¿B\İSWÎ
+R+œİcå(ms£ñÕ°xˆ¼ª×l²è0ÅÏ§ïB8mÊrëúyd~ktşBíà Î¤"â¡p§ÉÜhÏ²²ÈşŞ‚“ÚÈ_]uäF„ËxO–ÕÇ~é=É E`³ÔóK“vl{¬<©
+:öF ¥8ôT%lâ¼eZ»Ëª“\/TÊ¾ü0Ë*%—,(ÛüBåÒ	Ll®Y ãênœ\Ğğ[Ú˜h´¶-¥¨8åm!FŠn²ßèP;ƒÏñãdôL¶8Z¦)5r©±.wËæú+ºw“
+é’&iMÀWê#¶PR†€:w?Zú¦K-1ºtSF®d-u¾’Ê`Œ˜Å”¨SéªVáÑWÚRV\•â“Ñ·ğ+!ğ”Ç«wz±kB<’ÄZ'?Ä'„¦Ê_×ºõäÁ¨_ 9®ĞÉÑ–»ñFşÂ†è¼An#|QO×¯›^[Ùô9hY[ø[#5ıyóÁhŸmdo½ø8ÑRYîFƒ‘g}ñ#'Ÿ:Ãc¼k¨Çè‘ˆ¡5š–X¾òP2#åCßïUôVáÉÑ¹¥ûÆ€çŞ0Ä·¨Î#g °-b…ùCaÔC†òPVØ0¾_Ğ?íêo€”,[‡à¼Á’§££Ÿ¤şJá4óè×÷ !Ôt¾s~˜Dpa‡År¨½éEĞT‰bÑÇ\`×¯çvÔ[»`QDYENn¶‰ä$’Á0eÓ.
+8Ã„¬Fœ€ˆêšğB¼Ğ1äÁ9â‰ÉÀ§‚¶+¡ŞÑ(¬¶ÒC‹sÄh­fTAŠaVs±ŠÎ1JâàäÎÃşëíÇò İ6ñtjX‰ÿ +[l-ÇkT
+¡*Ih"³D*›×´â›ˆ¥"dê%ú…ÔÂôó¨åíG®¯/&Š\æûæÓ+UÊsj8cëgtB‰;¦!h˜N,0ÔÀ}¬#à9"Šg
+°k*İ„À5Dæé<Ef"a~F1®ås™Â¤«å™¼@Õï¯ÚĞFşäÉO
+bó‰œ…Ïo}<‡–§úò~l>Àé-×İ|­ÊJŸıÄ–:òG,ûÒ¾Â€ŒÍÁmîìBdæK¸.“­$	b šCÀÆ¦QĞÖŞ)¢/ê0n16sRÆ»ãˆ@D¬!^
+ÛhSvq€ÈqåKèˆâÂ)8NƒC·ï
+cSs_uàzSN9ÿg/?ël4™l-!“v;Òx9¥5Œ¤J.ZŒc{›3»ß}F‘0¸.&ã5Ë­bMñ".=  £vL3¤>“gµà¸_tİÄ[úÆò˜§”G>ªÙ~’*GÇñÜrÅY`‘ÀD#0\Zàg—uõØ¬üÏé¸Ç÷§ˆ–GÛ+]v°eÊ/­Ÿj;ËJÓËÕ:+)Xı•…Uk°XRBgŠ¹çõÉ·?Ñ4lS¡Nz^*¢jB±Q<;[*šsİ…XXhÖº ¾©ÍvuTü Õçx°ñÚOœßR~^ë·×}.ø ú•¬ùi]fAJ$•+xáƒÔ00bœ/¢©Ë´3)²§B˜wÊNè·DÃ•”^`=#ïhJ– -Ìnè8·#« ÏÑOGKJĞø°ù@Á÷}ª³/Áã†¦PG‚‰0}j5ìG¢×
+—Å	`V·5Q…†Â|]|ÒJLCk‹9<ñ$PyT‡XmĞ£â’×Ì¶:+ZÛîbq G–mkğxn?â	óÑÅmÏ¬Ã¬9À»ÄÈ²'¹&³tT˜Ÿ”Zì+ 7>z›°á™Yè°İ’2Q°5‰CqåŠ:yRÙ7°
+,0«ï6øŠm•5oò%ª{ÇO6	sÓ†‚Œ:1s…6Ó‚tWx:¾·Ñ×{ "íĞ›äiß³d`€9"ûöz:ÌE½ ˆÿäØQ~¦İï_n1¤r×Ù\pwÚ'İ˜†1d½;OŸ2ŞëS„zùww’	V•Ğy>†
+nïô•Í«§> ²O<Ñã„àÓW[_÷‰ ºæV˜Ì¦ÕJ$Šl2ï#ÃØìÒÍ°ÕÍí|ÿ‰¿-›¼TGÊz«¡õôÛÇ[ÿöÁÀ‹j«a?ú™ü>vQm5ì'ÛO^|0Ö©Òj¸;ˆ÷ÜÚı`ÈEµ6}ÎkØ€Tn>@
+ÖŠÕ!÷QšaóÒ¾ğ#ÅĞŠbY¦÷Aµ&^\i*Ã=}íz¾ı¢(’ašp~ç?©5®B½9şìu·§ÜlKíñmj¹½c¦áØÀLÏ©MÃ&%èhOB…öD™y†y!ªI—äõäˆÄoëN$ i©N¼bµæ´45k´
+RpÍ#Ùw•Ôq$‚O¨úœ\„¯í´9QÕ×pƒáäÑ!7U6}lM”˜m’ àæÅå»İ“t!{©¯¥öC t•_ÊJ¤	î~JÃYÉÒ6YÇ¤,`¯ØLRŒò£R9z6&œ)ßzKGëÕ?|«´¼®™0^ĞúªæşŞ'˜¡Øt³HDDGÁµ\ôÁ§1EšÏ=¢ˆ>áÔY>x·øSôsŸt"¢œØ¨‘Á8¡ÊTU£1ˆ/](ì~Ë³íT”__Ã{ş•&«6^ğCgRÁ“M€PT·Äıi¢º€ûÇ¢K°?‹±ìËÅü¿´D˜˜â7€°IÂq¶«x ªçRøæßI,¸d0»ıü”Ä\²-ü}ñš>RÙ°4 [ıHïÃÂÒ¿|[Ë şo'„O™:šZçC$Ñ¢•Ä¿¶Â¡­šeIÄÎ	OBrı[»ŠÅ¥Åï™•_Jûj±dÍhNAE–²JVö†şşÒv]K:“–wÇ˜DÎ¬E®Ú-‰¥EÙ°X¬¨®}Ê2á†í•™5?šZ?!A{Ş“ÿ¼5‹ræ‘&ìVIéÑ² _˜´ôïÓ¿C3ıîï%…wMøšêP»LÌC´õwÿ÷İßÃ!„p½£ñÕ`8…Z~B-Ş°ƒ0¢úná$¡yCÁ©\¨<˜¡·øgY`…Tcå,¬šÎß÷}ÊIµŠÉä-R‰Lü‚è‚	•ÀÅ|I÷Jâî„Ê$héô8ÑA¸ˆQ)À*gpÆ«X£a¢t˜?KJ0)ºÄ,:–ww[(qx¶Ÿ?Şú6h	sßMı€‡U ×´AoDî@†ÄğòÉI‡@±W›`òcñ¨÷7ÅÑ×="ÁJê3šón«HM¢igg‘Ê'MKËV‹iº°]œgğˆĞïP†-5ˆÖ`Ì¦œ¡Y¦ñÇ-;ÛŒKºg<„H˜vjÌFQÊRøğfIÿàİ=J˜%‹ğÉKãÎ½ÅŸ6òI:25‹)4}ıåR÷á²U‘q¬2×šŒN”2ä,ò8ºöá3ée¸£T(2H­’b…ÎWkqG± §cÉô,ÿ+	ëL'ş´Ì@ÊtZÏ1ÇƒGŠ&ÆJáß´8!öXª šÑ„ÊòßvYÈl4÷ +†œ&07µ_x¦–>Æ± Û$ÇÅ‡´yp~AYî8— &Ú,¬]Å$=ñ|vØÆóÅ„à›ØK½Pb×¬ÑkŞ(ù5^!.ˆğU	TÁ%õñ×¢H K(
+²£èç,Ö—kd¦HaîÔ£»Ó>41’šıä>ü)¸]bÊ·;¨¬‚?Àw‡Ç¼ázéí’N8Ê ä»ø– Â«TObîÙ|(¡£ÛH
+çéĞ·ÀÏ°,lÅótçÓ‹Äãé…ò1F›—#k®ÿ‡„@ BˆÅEÿ0‰Ø¸eş-[ÿ•‚S:¤»ç¤š ‘Ğ»4ø{J2\=ğ·VVp:Dïy‚"½M3(ƒée=](Á¡dˆB5¡A6ä° apœƒhÆ&±¸Ñ(™¸´¾.b‰“û;»_íö®æ1„Í`Âò8À
+’	@Ÿ(zø¦Í8f‹ÁUM¸¾ÊÑ‹-ÛÀĞa‘^Ã®˜—ë#çFnµ^S_®ùÁÍÕØ5vOÛ‡`·rÂ	ºcñGBŠş®cşI_üGé0"§Ô“J°g5±xÍÒºƒµ<aŠM+áÌ´‘N8¹¸svüfÊ›Ôdúú<T!C/à’õ/kNoÙÁsç¢@šûQÿ©8®ü™rTHüeeÊN`Šu#¯4>ÌØsşo%pµ([¸·&C—\“SWqáï%¥iÛ±s5UlvKğèd¯5#âÍÒlˆw,ÇQÂ?:¯EÂ—j•J-è´ÃÛXİj™ÈS¥Ï|ñm›Õm¦—2%”•2ÔpÉìrš/éZ¢>½ª¸}ó2de±_GW Ø|p‘a¶ıßÜJ­ˆ‘*¶¯'pÏLq}"‚ÛŒk«ä2üGn+4¦+¤ÜfğØ3òé©'2ı(¢Óq’Gòüğ?a~äî4çImSûÂÛ#ŒX†³eÚ5Ç.‚öÚYVØx0•¥bçA…Æ0g"œ6í¸%Ÿ¡K•gDÅBík}ZÂ ®Å %g–â™”`™ÃŸvHÑåqƒ»á¾#À@Tm>@ĞÕFï|Ş.˜\bV&Ö÷íbrzÒ!=ƒ¡Úcg8<|‹?>ö-¸.W¡aµÚ]ìˆBy|îùÃg[ı§[Ï]­ñk±}_Ñt,ç¸å¼dp‚çH?\dˆ+eq½VòÅ|ÔÜ¼y³ØCJJ, ³gŒYz ,BÆ1øÌ¶r¸· ¾è Ş9¥Í»µNå†=Áç £º~³¦õ]osb*)gm óÀZÂ¾JüÃ.Èb'èˆÌg›U°*^xálñ_H>É>³uöÉ™/ÑBChÙ?YûÍÕ{™«ß ÍbP#ÄTMÊw ¢ãe!á–F%Ç·¾	’âîgŸsN-1¸‚Q¾³X±^W?P\	^›kÊ`äe>ˆK”Êh¹ƒë¥(ÔÑk½œÅt½R4LÊ‘3•iQ2„Çû{~Ï¡G§?¬2+}Ùlê ãÉˆ‚¤ä‚ŸY²K4Ü•¼|[@Ó"™)Øí$ËÒ?uğ
+zI
+k¡&á—X86Ğ>nÊËçÈ~V	òĞ€§0ÕèK~©ÕŠY/àõ
+ î%1¬Â*vµ7]Í¾° ®ä Z|¬äÏr—xş`Ø™üøn˜í‰5÷8	6	Á¾†´4?U±‡"¬¬sıúŸoR»ƒhü‡¢em!…unTÏ¥yî›KÜèk«‡ ´«ç²›‘çJ].˜5u ¢l)ôËz@ğ‹Ò¥teÅ}¯·&I'kÿ”[?ßØ¦ÏµÉX¨ ¤I"B«Ã)W ß÷Ì ˜’ˆ—*×èO©D ky§š­®”©®¶QÏ1ŸÍP^po&ƒÂ~àÓˆ¯ešİ—í¯ÄRg©d‰ş0ØËÔç5’ßó,/÷ÜÔwíC å•‰ÔËş	³^4f«X0§T«Ëi÷šˆŞaD¥rxl\¦1Z6,‹¶b[Ø‰XÑé¶Am^LÁAù›ï)3ì¼¶!iâeø±¼ÅDÊÑ`¦‰ET.k’ÄkNŸ§:Õkz¢¦¶<Ñ‚RlO‘‡€&"òaIhbÌµ¡&Óµ”:1#öeê‰OGÀÛ•sÑ¿
+Eã1°½åyÑ¼ãªh•édy	/LK˜ˆ
+º$%¼I_g$LDQYÍÒ ™Z–4@ø^¯z¶GMZ3B7 4y©Ï*²°(cÂ¤…6©¸Ùy,Å±²ßİózşr¡.Š*Ë8±Í)€ÁQeİÒ S<,¾,ÿÚ×d½Ji^ìºz.ô.*•Y7l´$ ®R8¡Æù€±ÀÑ	4c~U€Aéü^¢S	bÈZ.SÔ¥FÂ‡ä0HLÛ»=±‚İÍ¨0$[>^wÚC@•¦/7‚M5ª©¼`m„ iƒÂ}0@ei8èûÍbìİpÉ=@aAo¬^ıH
+‘+e úH‘8¤¶‰ZÊwFª\–P°"Ñ0òvÃ´LÃ˜QZ©¶~I®œóZ êJ•C%ùÁ™rÎ/ y,I8Îsä Év^¬váRtl,k™—¥œ)²n2;©¹•é³Då|ÄCÿgä²é&˜±¤:Ç6%,úI§ºGÅÖïİ”5J¥õ[wMq™gªZ«\@œ6géT´ı5µ/[)ÿ²ƒVP÷ËD@9mKy‚8Ÿ–ø¯4aè ğŒ.VİR__ù§Ñ®íËF>ï+k?£P2rÌ­‡&eÅÓøÒzEZË}ä™SyøxÏáYs79;å@51¨—V±¶3½Í† ôğÖ¾XOŞÃY¾12ü_ Â¦ğé^ÓkÎ”Ï‰ FÑ‹0EW˜	G—¿½.ŠÃ­]µ7Ö‰º¥Î[ãŠ·?·bwäöğÖ'–¿ÀHO‚r¢ÿ¸Ø¡ááÊÁÂ~¬ó ³(9å¨œ¤<Ã2pâgOcÏ`àÍM§µÖ?›Î^9½“Â¾Ã€±ŒˆÌü×h@ªk	Ãç—*‚,¾í¡­ºf‘©	K2·5ï0;Ï [ë‰?.´”çöŒÌ®8c„ÑzN^TÄâÇ9™_:,í(_bpDEkg4Eü5ÏåŒXV½òO¼6ì@†“-)šX[ÁŒà…n¼2ÒÀ¯ß³\Kq †$ó™Şêœn„ÙG1ÆJÂñÕÖümºOäëj.†FwHâ>vETè<™Œ÷T
+(k+OÒŸöNyÚJoPP‚ÌÃAºáX×ƒá|ØÓéôíéI>Ûdæ$·`¸œ»y…‰C¶”P$ºä\¿?Î'Ÿğñ¯>Ä%Y)TÑ¸÷Û:¸ùiƒÉ”îöRŠ¯™µ;ˆÈ/İ9’J31É>6…qÚ±!¡ Ú»Gˆ™! ’§ß‘W©Y¼›¢5„~ğR°nc5DğNiŞÙÅ;?p˜ŞµfcíÎÍæ™] Å¯Œ€Á½!80ñn§Ád8=#íX¹e“Á¨rÓ ¶Ş*"İgd‘,·ùÛf2&â7q¹ÙU£4ØM£¶®\CâÔz3d´
+éyğ5ĞÛŸÀ)v¥ZBô
+ v›1 &¸#œ9„İÒ¿"Eß»fÙ_ƒ4|¸şÆ‰¤‹üˆÆaËğ]Ç¢÷Úİ›Íw$2.#•ÅAevÓ{) xÂÑ´’T»!nêæL”šgÍ¿`9`¦Ó7ÁDÉƒæ*aànß«Î‰M³«KáôÒ9İÕ%¦‹ÔÉ #Æõt2î‡¿“Ñ	.Û@Ø‘)Çî¿¸n öàÅ
+ìÑ÷İeÃ:Ü½nA¥cà¸Ò”ÉöóÃÍ¸ûO^=üšKß:´ü3‰…/“€=İK…Ù•€½,pE¹~ ÆÃĞf<ÃcW•=L](® EO0•?³!tÔ@Ø¬U·kÉá{×Ê–µÌğúTÎˆ˜C†ÿ,7- 3TÄTøÇî×3\‰bß›p€Ğšî8aùˆÊMÖ¡x€³cT¬¿P‘T+ü@Nt.³oTcçÒÇËÛc®nÿï¤0â$¤‡q¹ñyF¹¦'ù¡|D¢š~]$âùêsùÇÙæ£’o”Í
+³¶óqµ+.j·['ÜÃJû8ıü'Ó	”Ï|JtßAŸ6ƒñ»ÁÙÜô–y({ ›6©ò˜„X·¸õf :?±
+ø“4,èÄhŞqV]æÈj±GÑ÷.Ş)‰©ºN	`òõ.{ÔÀÖğÆèm)^—(“óeÛ´e¿K1ÿûœšŒŠ–èØ¬\K>ğÏà?(Ñ}°İŞM:Ôš‚
+¡wm¹Te)Ç\ÄÓkRµrÑaÛ¼€j¥uµÛµ°ïV^ù45†y¶°ËÎĞF»PşX zï9ß¥	ÓB¥h]‹æÎ†McÒdÓ-$A_âÁ/¾¨¥Ò>ı±ö(b½ªº–»É60½,Mƒâúí¢ËyŸÂ\@‚{Õ?«4‘²èZÖ¥ÒäöÓ^1Ä–¸?qkíóÂn …m¥Ğ™Ùìôd1Üÿcª †–úÆüÈä}Ñ]Ü%—ï,óÛäL­ÿX‰£nYZ¨C;‹Ø!‰¬i–+¢‘ŠœÛˆ}ÅMrÅr¢q‹Tj!ß"¨'yã0ºÓ¸F}©dô‰N´Ó¥´F×¸a†YË—†‘JZa¤V×cóÚ9´ÂÂC"m°!¶,k§‹±KVğ2ì
+Ë¦ó¥™Ü^ÛØ³4Ğès^¡'Wb¢‡)¥MŞ+–’Ğl-yUlëˆŠ;úš.qN«<.m}.—x|N+DÈk4_Ôñòã	$›{À ¦…ZZ¢á;Rpø“n3¢`OÙØ¸›½ÂDriËÛ·úÍÍJTvvó"j"(ú€8[©èrY¨k$™9Y}PxÜdxüXĞàË!ÕA‰L^ZjäC©qĞ†Ô»Ó?Æ#ì…40¾×ø€û¿(e/ )˜?Y
+š¬¶xâsM›H9 ú‰s|²[U˜ŸY´Í;oÁ8¶9BÚåtUyA:ÓpæÅ¶«+¶Uùû‰eÛr`‘)Å84‰¤İe“|½(áäJÈb—tH’,OMw¡¬Å^æ¸Ë;ªZË9íZâ…K®l½ãIØ¯T(AÂb_^°‚§ıF‡_ÄiãC-¦¨‡ä`rïdª,¡Q\W£½gÓÀI:öäÏƒrï8[u9«,K{è×Ê]F¶óìñ•ğ^á~úaó—Óáé°¯³I=ºa‘0Á¢ŞxsÔyf·ÁB‡œ`‡8Ê÷Ng,A—ƒÕ×êƒŞ|6œsŠêE#-<âš*ÜtÅÄÑI
+°FÀêI ê~¸7
+”SNØ°é§Zf•^'¸ˆÌ£ Ô‹YşÔ³[¹gÁ=Å•İ´qNÃæ—ó”C°
+{ÄÒë—‹SS`|Q¦¬‚PN¼·†¯®nº¬[^ˆé¶uê¶Yæ ùg¹Š)I)yŠgÅ·Ù°Fãi“¶‹ò³oZ(M	zŞ‡y’l››üf½¦h/¦}†³»l@È¹ë:uÀ‡å8®ñ^‘áÙ<“<Ôie’˜,Œ›¨YÈâ“‡Ow¶ğõaÄzğ½o~s1x"¡`¢·$‡‹oñ$CÌid Ù4¬•íb‚Ùl”=§»;Hº±[Y&åƒC¬¤‘×ÿçŒ{1ûfcŠ±šèI	Ô¹Ÿ£ëœ—ó(´xoi,ZáM¤³3ñQØrfrÛ©Œv1#áÛ>ò5R÷íœ:¾y:‘§Òâ,¢‘š•£=ìËr8šé½\5?ÑL"»´´ÂQyáB ±;<ºŠF	´&Ijx™œñbF;Xúoªô‹G¨†T]óÌá÷5T”÷Æ627šÔ§¹mM'0ë˜¨÷:$$•Ù™ŸsÿÕ¡­8«T)¢ A#$¾xl~ÍËDØAíäˆpË8à?T[!+š(?`´NZ¾ôQë’ÛE»¦qfÃ‚‹‚èF4½$š¿V7IÛ‘ĞÒ@´ø7Á¤ÉŠ)™©qB¸[1ÀDM{kØäî[Êş[-âR#Ğà–èPÔl¤N‘øn{+¡qx>€ö±¿%?¢—>,­şZäş4°Şõq Í9CÅ‰¸$Íö¸ùZS<zs×;PxàùşdÉkÑaJ;.  ÷k©	 ä)ñÅ¨ Şt^µ$¤Êæ°ÃJD¿¢‘\¬x	÷-f‹Z[‰X€œ¶Têş›ÅzªHZS½3¡VÄ›¥1C÷ÍTuåI»^·Iv`>ºœOdë6+`×*€j1xK%ÙÑctÆD8oúvŞæÆ«ÃÅQy‰°6÷Ó—»˜èM)šEp×Œ€ìèæ»ƒ‡ìEézëh¬
+“~¨‚à!¿ŞĞ#Şı=Ïèo(1vø©<XÖHög]‘©’e-Æ¬Wà”Ôs‚Kò¶—¼2oğ^Õ=ëõçİ!Û3‚îèP^’“šk¦fŠfÓ•]˜:¡îû`Ü‹` =Éò“úE´!1ö5‹BKbZù>J—YâÊ64æØüÂ‹æ¬6ğ[
+ÔsR‚XePX8ñzdÇXº¹¡¹üÍr%oZ¬TÁbŠÚùæÅ+^¹å¦lã¨ÅÉkÒyŞ@‹´ÂÈ6|0VB³pÜsiÓ3 `
+Ğ`é68_7HH°hş%¥‹Í-Ä*.R›eœ+81—dƒóoxkU@‘ñ³j¦eQ«¡Ú­u©DÁ!üê,Òqá'BmŒPD’[¥i -?_„µ—Ö°K	ÿÚeşÂ]€âxÆösK/øâù×ı§ø³#Ñ¹Q*RÄf¸7z&á3ıÂò¥P8xÙ¢\ªFıì£ß¡‹Ö0EhA±€Åø#MÃœ}d	tÍ5†³©éàDË –[Õ“ÏÅ ´'†zZ7#×Œü¤c¡·|UmßgóûbJ§q¯åá¨èuWC_¤ÅINÌê­x WÉ~óÁ>³–~K%íæ?¿i-Ò‹$’vrW3®ciŒf|¡†tEUIiG	ß‡É3sd¢ŸŸZªÊ~ÒòqìàYÁF”6rÕU€O Š«<Mkyg¯°#rx¦r—?{ø'­0³¡‡q³­Æ\—»ùŒ¨MÎ­k-
+Åa–=¦ø´ÌX¡‚X±Uk{/…€mŠ¸ÙDÚ@¯ĞE¦ÄÉA1ş˜1.z{5î®&GîşB
+ò—S‰dÉˆ§Àöì©S8Eï|Ş¼ATÄW;1ìC9Ô•¦Š.Kí•¢ğ­+IEä-±(íGİ8ß˜É(mY°‡À:¢ç_¼‘€}ß€;rŞy{·î§®ãÔˆiàˆİ,Vó_×haş1=2+Óûİ~ÿ‡Û·oãb /Æ÷à%X|Úî€u½ñFÎ”Bòì›Q*!ºÜkämè’‰l¡"R}*Ö3˜k
+”´Ax’²ª¤~ãe×ªÓ”Íó”´1ÒÄ€'¿Øtì*RS±Ñ°ˆ4k4î«54=õ;åÎëÉuÿ£¥	÷ØN¹B@ùhrª¥+ôÈ<D:Ö{£3kß¦t³™²¢Ù1N¶_—ø­,àÂQJÙ+	*nLA-[©h§¬ª¾ÿ3PğÕÏ9!>h`lEİ,o~†!‚ÿ–öÊo	fKÙ^ùoÁÖ±[Ó¢ÓL\Ş¾(9$ÑÉõkc^zlfFãÜãÍ/,»u‚X?Mpy—QQ‚aşÂ!r±ğ¡	g¢‹¼<6ÙŞ¤W	—Láx¡Üùf]ø³I0\õÊ¤x\ùøõK»[w°Şô¸QYWÖ³c@–§“¬CÔˆo½~¯”…iİş¡ŒÓ~ì !ßU±°= .Ô±•Ëß+’…ÂÉî/y¿*@E{tékÔŒúôsøcD÷OL•‹mŞñ‰<©—ë
+Ö²³É¶¡[…Fè¡4!PóA&?"lEvÛ>17iÂõ&¯¶ B_ŞND/ÿrDù²Ú“wf4¦ùğ~Ùæ³­×$‹…R¤åşÆœwóİ¦sN¶$Ÿru½"S"/ëST«‹Ç[wx]T1-cKß­Ü„îûè>›^Ëøä¼è(+‹’*v¥UÙ	*ŒÕ‰Ü—tÒ«¸ÚïQzû[4R»øùxm<êeÁ:hn“á¶Î>z¯0cøî¸Ä…zâ Š¿}â¢]ÜÂ}›3vïn4ú*LÜH±uk”L¿Â™Z	jñêb¥ŒSÑk“›²Yctÿ”"V¢”OIk„²¤$af2N…‚0{ÒÔ$²Pu‚"^á~â/UÀ¶N–ØüødF.î#Ï/¤Yzù`#iIæ»³ààjÍ”[É?-UÍ^–wö]¤ºË²R	d7åkjçE¥¦¤Ùğ…Î·Q9…Ï¸úó¤Ï{´}ã××ÚJÑûjJèTéİÿ(JV•@ıÏaÔ(RèÓàG’,˜K˜:ÊÖJñ%I+*gÑ­j›F´ =YÕ— ö°úDÃ÷øY}J‰Ø ô®ª±WÀÎ±\'Ú¯Šc(Iğ¥@‚Ëìº‚†iOç‘ô_ Z«•	ï÷ÜóÅª)~å7ô! YG5åÛ®ærgÚ›š¹j)£…ŸËÈ:¸Èn¤¡<˜aKS1—H Ğ!%ÏÛ¢L÷pâeëcaJÿX%˜4(‚';”	y)7Rˆ	ÚIöY­ÚU‚iPƒZÚ545JÀ‰X¶sÛœDÅÑ» ¤pÉ)ó±ANõÃ¦M4[4L×Û{ù½soÑ,7i8«Ú|c:´»¨µÁñ2Í§åY7ô<ÿ\­wAŠ•`Y9br’Òq]ÅÛ2pªI‰6–Ú¤íŸo~Ÿ¥©‰i*ÀcNèiö‚V=ß0“`ãÌó vRH½€¿Nõœèi•òq–²nª’Oô§‡^?n•»I•ø[øå“m¡œg{º)&‹ƒ…ÿÚK{ƒç£‡¥·ÅãŠx„*KÅ´^Ğ²ÖmôŸİ×oS¶Ñ|Ç;ù÷…(\ò¶$A‹™ƒ<Â‰À2“<b€+!H†Ëry³ÏJ…•u’iÇµSÚ%İ6L±,oˆŠVLÚÑG¯Jdl(aådeäE­¡–L› e—EsŞ¾@š©9iC¤@	şÆâÉ#,¾¨]x+L/´ZTU©âyóAtKç¨•+`”•ÄÈÆV¤§^Ci¸éT*½’pI«ı.Keæ”4švÈü[Š
+ÂÇ¼g?Ğ¶˜6íÇ–ätà¨Ò\Á#®¢1QñRæàlÉù‚l)‰²ÒÈˆvår[6}±¦ö†‚È2pI([¹¹¶‹¯À›İ‰GsûG‡ óµaWB©-kÀ‰yÈünìkR>²5ÜıYHz|‰Ä‹Ë8eé5Ã5©8‹«bÙƒAÆhn²óô1&41Xzë·bkQ£‰~á:X+'‘ô5Í&æAhYÉY §‚&Ê‡8¯oßs×ô—öï<¯_²’éL:ò¢¼Ón4D\Uf»õô[÷¢‚f]jËñt-fŞ›³ºJSB:Ššõé Ì»Á¢üiÀØ7Ü€¸Éº”¾ G·ÕyyëwIï<¯VpL´¶ùÃ›ª„ùKãt:-£cU¬=˜Õ1Ä²}™‚¨&•cĞØe/bP’#ŞÁ-yâ	?{áİıT#î—NnK¬ş-[+`tQ4[Ãıì’¯<Ò“Ÿ£-QÎ´Ï¼â„ ßço«H^®)}—rçÛi×¢s®úßÈ•ÙY°Î}ºôÀÁT:ºµATñîŠ2Ôemæ¹¦°6C64’‘@È8½zÓTÒìúÌóĞ]]*Ä,ã,ç‡˜¨“VÍ#z¦†•æ}Ó¡ºåØiº;‹­Ç…_L$B2P«ºô«j©çLSÚ¤nÃÚh2wÕ’VÙp*h&›¿~²m™…zuš ËÔ4…ÅÕ1Æ`i÷vxdú(¿.m‚o¹BàFşiÎ«â‹Ş¢N5Í:ç–F‰©ïCÏ\—ÚdZ•Q?ãs [•ˆ—^¨½"ãçZP"lƒÛmøO¬¾´[ªÆbôèDíÒ×š,İ´}XÌÕH&fƒU9L±I.Òè@2@2¹;”6ˆÉæG¼„W3b›}ÏáG²,¢¶ŒÒo-<X8¡ÚéL¯ÓÉ§ 2Á"2”=	§ÒLòñ£AÙ˜’ö¬ácœ‹n¤ 2‡óã„é.µ‚éMpŒl|™lñ¸~Gh2}BSÿpbqG‰»>İ?J…SïçµûËŠ¼{‚üpÆf²K¤V¢9Ë¾ÑÇA—•3èl¹Â bº9ŠQ†C®ŠA(QÕêQcáT~<ÜáJMdöa®dÑÀá(Åº°²†W.(DÛEPŞè>a{h3QZ=ÃudRQÁÊW:)Î­ŒâÄˆn&Š—E=­Hú†Ö«:L<¤s€ª„œFL}3%¤a<ŒEÇqoÂl6ÅÅÔ?c$«÷	yÉø8ş¥_""èØóÒlB5’òøĞÚÌWz °tÒëRğËQÀ‰'¯î‹‰	xU89±Ä'K¸ù–}UÁ¢]–¬eÀè6™ÿÃ¿@A±‰9œõùOß–ê<’W»Òú)Ö’ßóÖoêL;¨AUTc j×4Î”TÙ@´l¥Õ„:zqÊıHLŸ¸N”[“{G£1Ó…ºA‹'óáéş´?|?Ü“¤Èãç/IùE5Ú_GúÁÁ K5|ÄbKlĞ¦ç¹€›L‘]í®6‘¯°‰ª±_œ*ÉvZ@v\Y&&ìJ6C£–éĞ ~«6ğ²NnRie‘¦x+¼4´âÒŠ—ÌÖ‰íàdJ‚¡­rJ¢ü;ÑC„ŞµÅQjÑ¶®Ğÿ–¨R6¼À¦BÖ*Ü%áÀ39§«¯…œ§êLÄõ—aóä4Å‘péõ	VC¦AÂµ‹È±÷"DªH"‡íl¦®Ã”ƒÌtHeÓ×l€	ˆ¹Ş,)2¢a™Î“;¾.·éÍ*“L‹=\šäGpÕ£EÖÆe;Fs@ıE
+:«¬Ì+<¼^°Õw¸&J*İo×=8™Îqv—‰‰öñàÌNt3{'¹@]^=Vá[¼›&¨Ñ54D=Ë>ÁÙ´`-ĞÚÓTùc^<c4‹At`¤&‘ô0mÂbæ¾`Ú>Ø2)Š[ÿı3¤Ù„¦3á`ÍG°)Ş¢Ò¤@æèC:‡†=ß”3=!âX¹ËHa´ Y1É\â“Ñ>â¾ ‰ I¨j©¤µ¶7Îqˆê„5@(U¢¤06ç£ï¶ŸğÑ­ÇPº¬Æ{išïø
+÷‘î¾ŞI¯c…U‰–ƒ¬h™CFª×-'Ä’åJñ+ÔÕ–Ã- V“`P¤UÀw´@±ÒhIIšó9$L/t1)Ø&=ãŞ·8PÀ¥»V* `[tSÌX~v¥Ü¥ÙîEÁÉèd²ÚˆjL³,rîë3$9Bû¨hMWÀúõiTv4ñé´kçŒZàœÍn3…®Éï[³9_Ã <e°°&u€AdSZ,Ê™7|SÍá”gÚÙÌ²Ô8J¡k\o.nt"ì9ÂuZŠtøë ‚œíÕxª  °¦ÈĞ;VÖE$0œ¥¤7šıW_<ú=™|d•òıÀ%ë·· 8‚4ö§m»õ4'dEŸÊ},kî4KŠ~v™­iº5C£ÇÔùĞòz¢Dz1N6Ş9o"GÈ&LÍ3Tê˜Mß3	t³•îYæZe/Äbéµ°@d9ªíÛ øœ Q\ 1Û:'[­{YÇ&}„ıÆÔ¼‡3Ì
+Vui •z–Â‡Ä¥—¦XJbú ¬`ZïaºĞŞÖbaueOò- –ª—”»š’±m&ZÆVÙ&[–á›ĞC‹¢<7L¾;:¥|’k÷e÷q«<..Æf˜Á0}òäi5®%kˆ¸+­<Ô,ÄQ6B8|zğm?,6ïhÊ_ššòá±%¨O=™ã^57}™õ‘«Mœ-‰}:+Á –ƒ¹ûÖÃnÄÊ5¸ğÃ›#£ökÒtÙK“TÑ‘³â_™Ê}sÓco,¿úòv!í>Ñì5>µœ8ìwìx°@ZfwJdí†	_DÔ²¸¬×ÓôBäJ—´ÑâT:%DsÇ˜JŒÆ¦ø¹z¿˜n’Ål‰ƒ°HdO8•KF¥`Š¤à4ÆøL
+€‘‘ùÇX5° j¶^<ÁNõM|‹R
+Ø˜»¢³ @›8ªfÕ–Yb´bÇŒ,u±dØkV:³Š$:#µ’½HR5Q¥‹ÁÍËr(áK™/EepFËR©¬#f>ëØŸ\Ù§Ö9'ôF#è:Ì£Å:\Xßb£¼>2/}<÷Ó“k«§;XRŞ=üLI´ Oá¥ÏG—‘\¸î©Ê+ó6Â
+fióO©B€¶µW+[Tœ/8‰‚´©Ğ_ çU¦á]|èlì™osxKËÍCGp ÉÍ¶¶Û„W›x^•ŒáæAØ®gà(<%9	Ş%-AÃå ’ˆ”ÁË­/ı—£Ò­øöNÿåÎÖëÇ/ú/_½x´µ³Óà³À¨Ùve©7%Xí¶Ò’Y›cÚ;âÙÙpÇ0ÿpd§¿ıäÙ®±\ßPA|ójëkŒş+›á6ÖF±¯”ªâÊ‘ªª†'?ÚU©­³M¾a-ö,õ´”ù­›0ŸÎ0ù“h” ›¯ºY³ìƒ¸9­¥he8>l'³ÑÉ²Îâ~Øï³3Í<] X‘¼ÁókŸöÙ§Ÿá [ƒKm±«?Âé?ÒˆŸEpò¬İƒ¦xÒÿE9ıë‘u„]bÌ=æ%œ^ÀˆyÅµ‹½q dZÊXº¬Y‹l•Ëû_^å“öìhœ›;¸E&ğt	š‘F,|¥´&S3GÍüîûĞ ‹¦ˆ	¢¶¢Ï)«áe†áPIÃíôŠ\›ô®•%@~ôh<ßö˜‘øà­­oû;[³¤¬s®ï2_4OY‡~¦âà~dßİo[zWyÁ ãfÀû¶K¨PSŒH©ôUÄ¤£ÈMûr6}3x‡ô Ã³l£U;´	nm’qKcøÓF3®‘—UùŒëäÅkE2Ü«jNêDğÓˆÜ)ªAaLƒí V¯iC•½À<§ç`Ú$sİš]‰pÓBM,ñDŠ»^ŞºƒÆ*ü&¦f¨`ıõÿÏp6y£èR%iÓlE u9år¤PÒ¢[İ·dQbjeIRV56t/ı\¯4Ù‡†ZÛTÑ¬È¥±/×¯ær+Ê"ı’abª;tÔ2R×šÿT$N ¥ì7Tkklª£¼ÇïbÀŞy—ªæx@g-NgØÓ#2KpĞÙÊË`c#«*ÛÖ¬u|—~rôP‚åu~}€—$7˜”¬òÇFJ(9L;’Ï,¼ØICznÜ¾`ùšå&d½Ò™î¶,ˆŠÔ÷ƒGG¾ÀnÏäğ\@Ê5d¿Fûş‘àpìí¸³D ‡$V.†€F‚î-/Ş!ŠSQ£b3#ü—Øn‹ı¶ŸY¥Şñ`r8Ş¥0‘z,Ù**åQ3É9ú¤¢¿ UıÀNI¬0ZÍ.”ªF¼Û×P9_€WuÒ‡J¦U[\¯—…x:n·:²/°Kçóé Ù¹*®û¥‰cv\.R+¢„K	«ÇM,yß–¥º 2òØ~ˆOKü=%¸ÂãB1^šy.cÄX%“¤µ¯HÕ”ÒAÕ9ÅHì.­Xğ)È_YmlMƒÔU¯IÌJC·t‡FÑ†d¦’i	}•©6ö$+ Ià«·”JŞôâZ)€/%E‘‹„+;^±¤¦ ËÅ –GÉ–ÆL6b¼Írëíø™T³ñá\ÎG‹ÕƒoÈœW‰^éÆù[–ÄĞ[ ;äïúÅ=ÖU9Ú­3¹Z&âMâV–¨’8ªÀ˜û-ç&-üSß-e)Fj)ŸÈšS.ĞZ»ºüI¶sÅDR½+ŒSD#ÔR%ñ(NW!Y{WNâ’ Cs§5Qû.Ô¶éÅËÓêğ"}Lë)x3-`êFV‡.W{f;Ë¦ÕU° X&[¾fàÄİÍ·¢xaÈ…ôÍr˜§«-µé„›3—nw‡Íš²š‚˜ f‡lfîØ–Lr5j÷V*|£U}Šyï‚ıÆ®«U-ÒÅ]ÅeªJNµûıË-?coÇìebÂt¬SÅú½©ò9'Ë· e©÷÷£'™‹ŒœWH9Fú"b±D±:¬‘Ï	¡†œÇqXUkœ€‹:øYœ|-@€Q‡"µ<¬…ÂWÃéÑWA¹ŠÂr
+Şª)aÉ.`e6S÷ÚAs_Ê!21Ød…Æ"øèˆ%‚,¦&èÌ¼¡i¶@qf#éø.U?S	gqe1 ;Ÿk—rı/T¬,hp²Çø1EË0>¤‡&04°Ò‘X[ÒiaWÑ¡sy>:O¢$äş;IÔG¦›œu2æ¨Jri!#áÖüMÄ};IW«-ÒõGÅ­Ç6BtŠÀuÎ©”¾”¬°;Eô/„…4Bm~ˆ%(ÉƒS¬M‹Ïie;ğÑXæ”,›u|GwYf\>†Íqc†ÄRPÙ;àÇ0Lu¿ÃĞÚµAP‘|`‰.(Q´ˆ<2zıÑåRdÔ‹²¬\·î¢/Õšc–eÃåK¤D72â6¼u?wÇ1[:vG¨DJ¥uÄŒ>†0Z«ò×¢h.g§«#È¤¬±úÈŸŒ`æÚM»³1ìA]6&âÃL«`¸Hã»é‚Øè <*$¼4‚‹Ey7O.€Úi¸¬ÊLr¦¼S#MÂepÀ¦O·^JlÃ¾3üÛws `Ã±dí°ûmÖÓ:X£ÜÚ	—F^¾E0‚A½‰YÄÙ9EI Ü«f’ò˜€:²¬^2ß¹ª)&m1á„ôàĞoM…yZWS‘@Š–&— G¾5“´sË&ôÅt’`DWÑAÓŠ±4îÅe\(İÕIjJ¶:&&ÙLW±õÊIH<‘]–)È~s\í\O¥IâL}·Õƒø”4éÎ9]€óG†ù¼KÎîŸì^RIW9ç±ÇR-f bÿÙ·áp¢§¢‚?@âDµ.`w`İ%ÜôURcÉÀ$+…“3{ñ£®ö;døulqsj,75"¿BĞ–Æ¦Í›…Ä’MÌ˜Fƒh;WŞ¬¿Ÿİ&tÒG@µÃ–hóˆ¤Ì}.^Ú0¢âäºæeÀkÀ…6›Å7Îé9ƒ‚²ÈVÁt³íE{Ùøo48Î”ë¤Õ¼ML¸ŠÂ~hÒE‚ˆÑ+Hô+ìŒºåYŸŒ	ÃvYà÷²^¶jK —áN~¢Ú+úµºá¬ÒtÓö4›wÉ©0ø@›-±±¥ ŠCúŒƒ
+÷¬FÿÖ­9¶…ª÷E¦õ –O²»òZeíÙ®i&›U(Ngò'·‘Ï˜C­B cn¦‘›Ó\ÒÔÁ¦°6š.k2·V€Ì&aK#¦%C|û­lº,ãôÏUH¸> 
+løWc_ÏF=Ğ½€Ò+ÜxZš$‚š$ÏŠÁ+ªh„Jò_„ÄßÃ¼¼~İ˜9r18
+´ÁMvåCdÃr)P‹×û\+•NÃ{/µÅAS<”SÆfiuF›ç„^¤øAíkÙŠ_ÉôT5lhezŒ¶­‡+…³"W…O^¾8"	+\2–WVC·éÒQ˜¼=q‚•]æ)àÄO€/o¹ïföá]o['+ºÖ¶ùÈ;®†±aÛaşiZû¯›ŠÉ $°‹,ÀµNğĞ8¼0Ë­îËX~|ıjƒàÇ®ø)N{°MŞOgvÖ—Ï¬ »ŞqvÍn¯s+º¥]€[u³JÔöSGˆP±»/›°Q÷m*Ày6<AÀíÔ ™ÓÚ@ğ¹©ƒ…¸š7Øu`Ú[¢Âçy°]CèªÈÍÁ,Ç#Ü²€Ø”swóF-Ü(ôhh ¸}ñ¥ˆç5 „Ü€VtŠ/,D>ÇüZT>âŞG\ö!lÎæ‹á±…¤ùb:C°q›b¯p—ş¢Cï­[ˆJÂé· §e´bA@cè¸“a‰<8Ö3Îì<bC§a4vÜ+Af"ì0EQ‚öjÚ¯ùòËæŸ×–—”+õ‘W—[ë{=D®¤³Vv«©\ªBmÃv¯U—‘»!ªÆÖi W§µ|r£uè¹*‰†zh¤N_QRH—ĞGêĞ¡ûÿ›­Hc2$jÕl8ô>2	(G®­³
+İdVæ\©™:õıÿyÚ§*kC+~¾ìò÷·ÙY*Ï.sm¿åÅjĞ«(_ûƒsq*¸2æ2Ú´ïÔZz‚|#âôôîC—¸ÃRi¤µ¶°¶ ´”#0páÕF:p[ll%â(}˜^±ÁaÚK¾
+ß*M0-•)H
+tNşüÌ;xûÛ.}?pá‹ÍÒ˜üÍ—‹¡]3å*#şvB€Æà­ıÖëA“ûÿ!>ş¿ï"¬ÓÒV‚Ü¬Ø(®}âÁújS.¯Fºñ³Ü,şÕÅÿ«ùVó¾§h	Û6MU±ÏĞ/âcÒÌ·´¹WE¶.²˜—¥ì»;ÿ÷ØÒ¿…y«`àl2}€aÛ2Yi¦‡.·|1»cÅ58D¶ıŠ·>W˜	+cP;k‹¢~|’«8ØV¢k±PT¡y/WuÛĞP{rÕccÓvÄS“™0)MT6$«0"/Ñ†²ï-¶ï—ÁM*,á‹¾&ë	6[Ñ'åˆG‚vY?ªu‘ÀÌé‹ CBeâ×ÂFnV:S>#54À"º[ñgºŸì;‰;8R¡áÑ™7YT°8ïK÷Eq¦WÌ…ñv'ebâS-î#İÌ«İŞÕì|#dÛyıx;z—á«}êˆ¾+Ò‹xiUÑ¤Tt_`®íÇØ©©¸Dì«×OèvÎæ³;wíNÏfğ¸ç¿ßà©eôP|‘¥†Å÷~[`­¥$2İğù&›ö¾äŸµ°‹ğ„HhğáJ@2·Ä·õ´•ß¦•’àQî(¤ù{ŞlÅÑ¥_äAµèãU>¹õIÚP B¦1öŞí'è˜ür«¶¦°‚Ö(ó`_a2%´­WŸ½EµQ:úz¸ Ä8g÷›×–¥‘á`8™58k|¬TJ	ËëÍÕ[Wqåõ'?Şş¤AFŠcøáÓûcÎÙ`´$&Ğ’¸Ø8åhÑmãÍ—÷…ÖZ6›Q,”¹x†ÌCAü'>Chn]En·ÀHô4p6r®{8ˆ+Áhá€M	£ m.úÉY½†›ÀrìH˜¯lÏÔ
+Jà”’®atÒ{ İBä1ªê¦ã-Í5Æ“»x‰-?¥(- ­€à«V›ÎB¥Dé¤¥<oLI%Ú"%®eoŞ¼ª·K‡ƒK’G–º"$†&Ce3¼ËŞrÙ~qƒŸb8®È wE»'÷îÃÓßbZ@Â$@mF6{³{he*©1áÊÈ£àÃü‚òÅf,eßQõÀ„ÀN¬SÂ u´™ğ
+¢WoBGNœbä½òp2¡îG<W/ëã+A¬õzŠ(Ô`4×ó&'$qˆvrëEK"	Ÿr1¨m¨SÒèÛ)2Óh®ö »éÔ‚}uB¨U•ÄÊŒ$KËf¿G8aÿ³4Àôé’ ªÛÏ_<Ş²Ë#áàTş „/ûıEÉõí²‹¯!ŸN§o7áÆÒ{î¨…N8cCt¤´>ƒ1§¹3¤2Í±ß‚Ì$Ìÿ}îÜà¤ıM$¾}‹•Åõ1Å1Ó07)&Ä}ë›:”c§Ïhœ&¨úxÊÌ'ÈèÄ²¤ñ€ÇŠk{lñ`wé8¸V«ò©AÁ(Š
+¨6*šŞª¬
+`o¦S@NzÓå©ĞTĞ(ı€Ÿ¢4ò½ìŸ(T^ÁCÑñ+)@|ì«ÿğæ
+Â]|8ÊĞÆ‚”ÏÚ¡\Š‚ı¬eò˜T°maë%ğè¼NMÕƒˆiñây
+mE³s¨ë
+é•˜ƒ¡/%)sÇgz›2i ÁÖ·"³(>ÚS†ç_GÌ|6²D¥J†½MKÚ¸›ò«§ßæÚF=iÁ@Å(19=~ƒı@ßpr†4=9+ŒFdƒÂèãèã ¶'0U[9ª°'™íK1\]œÙ!™9yŒ©æ)¶Óºg4Ùı4Ú?ÅÆu ª»ŒoÎ I‘‹9†˜JÉš¸±ÈOˆ'ûZ8p`8Å¤Ì‹ÇÜóÎ<É¸iQÉÅêôÉ¹’%6ÅßòÕP	ıÜd[%>`]ÏFÂI¤<É  ‹ìôóÙ Ÿrg‡ïiœÙ¨1P®@/ÔÌ(M ¡VH¸8¸ TÜê¯T¿¥\JûJÓ:´²à]ÒÃkNÑë[«aì,O÷L¡#ám Í}Iç®ªÍæ¶fNRÓîMäÛµzÁ¹T ´óDı­	È+ñ…Ó–*µH¢Ó z’	Vš?lâÏ³3_pÚf`^i7ŸÎö†}½
+k{ÆP_“}hû~˜tô%i~#°œå§¸°3µ?V(.ÿZ+•^©·¼±küìœ^] §Oe¡®>I–»ZVupË®)1TjÔo64›*±¥®Åø§ı#†¡ eu(o™ÆóÓ7¬—ë-±šM­qH„.&”½/.ö™ç?qp¸y©ì±ZQT«åWT%ñ]6‘š; sÆ'~³ìO=ƒç.\´Øz™‚w[N¾$•‘,É I_Á¦nèbOí{Psâ.àŠ}œ´@Ç¹£P¦:K÷^g5ó¹nÊÁÄ“Ü¡İó<š|ë,”^Y®Q~dÅ^¶ìêğ=Ó÷KAI,-DÑ4ü|^,©A1
+±²´d9…}07u4³¯¨<ùi–,ïM³ÑS*+<®/·Å3×a1
+—fÙõ˜;ÀÉ…|'´Miš8½;ime†»“°,Š¶ı~©Ôhã
+Qâ¬0YkeŠñ²9”v#èålºÇ¡ÇSårDKíÁä¬Ì
+-»Ä‚¼TOÉ—¹IgF[OKÛ 0n
+òæoh#/•él›‹ˆlşX3ÇÓŸ†ıÔ–YéıÓz´vAĞ´_×ÃKzZ½5¯ÛR“z]´I€Î0¿K-’Á› ¸ƒÀ³j•ÂÕµŸê†^Â5…ÍâAÃ€ùY3”"ÔŞ’Z p³w†zÿ‰[úLÙ¨=–ãÿÃÍ@:ƒ	bŠşá6¶¾ì—ƒi”¥rÿôø˜—„œ SìOÃqêÍ™V})—ªIê¼0X#1:º‹±}DÄy†wŒïBN­Ê^òÍİŠS®;Ù’¯¾ûÓëæ?hUâ××é×ûÅ…Ç×«j ŞÃ;Eãã~T#9søOähKà°bÕÏ•Ş`ØâGâånx[„ÖCÏ¨¶»ßl½â÷r”;cL5†„¡Å ‡ÅÏÓÁfdÎƒÀU8æ¼3}€•Eø‹s@e–Ë¥êp™ÇÂ¹Èí\¡I«}((±»ÇRuÖ²xkRÁuÇu $ oÀz©~€š|¤–ò/üÙik`æ§Á8	§C	6Ï)©‰²8E­íOûÿA’5²#…G9Â«æÊÆ lwÕóÈ¹¤f>:[#ç~æv%\vŒ¾„¯] ._Fèêò­1#jIÇH4i‚Ûê1·•¯‘Ş`ûëíç»ç}Şİzõì¼ï¯w^ñÊ5)ÃË3!ŞôşWO_<úlèïLÇ”YpYŞê –ì>7ŞI‚zß¢È¸§“liÁ®“Íï  ~¼mÿ§wÔÎU#i8ÄS0: M–‡˜¿,ÍVzÇR¦áUqQLÃº}r7Ä¥và$!têÎÏ‹])ña|Ì"ŸåÀòfxí²Àâì„£ÔYh«>óQ˜­OU»¡şH[C,N±'…¨ã›7ùa÷‘¶?ÉÿÕaº¾ä‹€FÂıM·:ÂI\) [fêÄÚ@ODø”·½Ä´„¼tÊSl6İ•Ö‰Ih
+¸áƒYæà‘|Ç,àpZ¿	R|£Ü-ÜÓZî©cijYQ±š<}C½cFÒş)TJ)†[YH8äx’vº·¢l±L¤#§åÚjÍ‚tlÓù-y$.6&§ï­¹˜HCA’Ü–*Ëy[¶Ó6«Ê†ÂÖ~òØ‘ÃÕN E·@@„P¤©À™î[£Q.á/Rf·ÉJ@ñG.Ò3´¯?õ‘Œyl]ó³ªä÷IƒÃA»cñÂˆÔr%kœ]ğ,Pc\á(ŒÕe;íùÈ§[–à)¾GëŒ©Nô¶¾~ÙLÇûı”œò`CGS{ÄâÚï©²’4¶‹Ãu{ıºÕ!èêó(ŞÔuÓd¸Cˆ¹j‘!¨y©"¶;j«ØİlYg\ñW€¯­@(Vx‰‡lÅ(õ¥
+Ö-“·Ø'%‚ûìè->ø–dÏ”Œ8ğ°övM­–/,àCåÎ6oÿ;ˆŠõmSÛ7Ã¿ÂxKyaËşª™ª+Z\+÷ÅqÔqşvtrÂq(Ç˜Yàõ"w8±Ë­ úÃ‹Ş¹TÅ	$û±V®½Ä¯,É2CrÎic©œlÚ¶\¹íãÌİds”–ÂÜ–ıhø$˜f9*C55‰³¶µ™V¹Ëêñ;r½qÒ0†SRQ’>]Û„Óoÿ#P{¢ —§³m`üWİg‹HNeƒ®à“(*Ü|²XÔ«kúV ‘sØS“ÅAO¶“152èö?ŞG³–k”ùVİdã–g—^±gG•º4Iâ§‘fŠN¨Ar„;n—VQQ°À•YâLpÚŸ“ô Ã3¡¢Gµ[íq>F=G-§öbò4”`XI¡aÈ Àİ]8İP)ˆ¤ÿ´c…AñÔ´íBÿ¯h=£·ê+h+òÄ´4HGçCµaè‡v×¿b£nEø]Òü”‰EÉo©Rj)ı¨wÔ€EÉI4ş.©?‚¹í"÷İAÕ>üBq@DÅZ*8u{Ë.?„¶[RŠİ2î&3Vˆ€R”g(oª)iÚ¿(±Zá…>û—¾¨°Â‰/}#€6ş-U›ˆ¡…Û÷òs™o3‘;n0g×m´:oÆW
+‹’—pê¿^Á Ô+ ŒUàc†5Y¢İ:ºMƒ [¾i-£õEec=Òå>’âJEÖ•ö¥ÓL]šSğî¸5US3Š=Í®Ó]IS0ÃmºæøXZñÅn&PûVø¸ãUAûÉğ@aÌµ¿TÂ‡(hHW#ºT›tc¿ñÁIhfYØ¬@+L67U"‹ñB_ã³¯È×Å¾œ·!Äªx$Š8Í,óîEŸjï­ë¡¼ğr·œ3Dà¼ä¬«h¬­'—™&Åö¡½àwòÌæ[H ¯¾áÀ/ZMˆ§:·$\ —,ùôù·—,ùè›ËÂDXÈ%an?yqÉ’;p–9kTùÄC“é©=À^ŸNp¯¨…kUIûX4ËCÙI;YÌµÿúñ¤aè›aè¨ŒÉØSK“¹¢¹£C<{µ*¥
+!s¶-©këĞÚ‰,‹š¬|(:„äê¸ÕÂ7b^b^é‹5"I”§¸&£G!”³14*›7ß”½õŠ^i«r•z¨ôƒGm¡Ú²O_…£±hêo¹PL/¹¿Û¡4Ù|!b®51#íõ_9|g\é›HnF`å#WS7Š!ƒXÚÙ¶P\I{Ü! mŠOà¸Ê¥bû&uglîÀ»ÊİPlx—4¶]!J„¨³këÈ T6™ÑA¤vŞŞ]vŞÂ7êşX¬‘/ŞFm¹Oe“»iÖõé”üšLmÔ0@”oÍú³2dH¶èe+ïF$²­>f7I eNj	:ÃË¦ı‘äŒ;Ë>’rFW‹–2pÖDĞ¢{EçmÌ:mÈˆF¢¸·ìàŠÆïÙ‹³ÔbÊGËáÃØÂS“-S¦«GêPX"yI³åá³mpX¢ºtı‚Ş¸±ä³*Ä» @dMea€ñ§_`ïõlG“7„ÇY‰Ì22^3uó"¡­öâÚ‘±M=ë_ñ»`½¥è{!Çœs&‹2yËbfëq0:í¹•›¡TúÜº:­ĞªhA+Q‹Kû`*Ó`ô¡ÑóQˆwÚ` ®p9ô‡X}Ùc›^.:(nBî|.ghÆ‹ÒRĞ¶å{lMo>×ô'ÇqŒ¥MTéXTMÍÕŠº²W^ª»PUû£€m~„ïÇ«ˆ«†
+
+ôÆöSøu9sÎ•ö$)b?x¨˜Ô‘µÊ2ÅÍ°n™f·n{N ´Ü…eò%{Å<H½A:›Mõ†¾evƒ½b¸yîR*kWÚÚÎ/Ì¸Å”I{˜9hBš Ê÷êÖ÷«¢!‚wyÜà·%„Šg"^k¨ñofx$¬³ÕnJÌÄO“
+ŒÅS,•Ãëª˜EW,Ãk«=ó QMºü"õ(Ï%ç¯FÌ¹ô7×ß€‰‹àxßyirV¢î'Àz!e¾aRp¡õò\ù
+Ñó0µz‹¬	,ì¨á“»fEÎ1ùSosxksˆà¹*ˆ·šÍŸ”ÎôJHµÔı°Ğ%n	æËry>ëy¡óÏÍ,Œçxğvˆ_ËZôxğïSËÖ:Ë³•]é°ÎBá¬şùÀ)c÷¥Ş&Õ½ßRİ¡©éİ“sŸ˜-ûçJˆ65Ñ,pèÔ¾ië"&U·ø9Ù¶³¿ ¸ïø¼BœlrGQ_K˜¹äŒ2s0*aB½ìÚ¡RâÙ­eşÉˆ<Hßş
+&5é¸¼ºíôù—ãï³•šãé—íT¬¯U\aB8aZz_"o Ñ2Ş…+qB¹Š¹ëtafj.ŸX.FÌXğ X°Z@İ­$¥Íb%´˜Şİ9|),ı®\ã‘˜Pšï#tô*{ò3ÁÿMQ{&tß/¯?½`H«‚A¨Z£€™jğéò2‡³`µÆKK‡K­’
+"š2¹´I2Ë¶®Âf†QA!Lİ¡+ÒÜÊ’!®ÙèXauÚ« Êöæ€w‘øw— qÃù-¢W1“˜Ø`©ÅÊÇ«p2‹ANˆYlªĞ§2ì	p#ëôt&KF¶£	›/0Äeì!T9bjˆï3Ÿ  «/Ø,Âw™~·Ì”„z¿Gcšg
+¶u.2}c¨öğØJ%†N~ç_4tæ±&*~–‘OìÄd	ó´!ÇÂYr×EÓaÎS
+ê7‹cÃõRHÑÔwt8"tÚuEŒz<€âoÎPà€á•8*'ıƒ*FXN~V¾:E >Û|ºK*¦qˆ.¥Ğ«U¼Ï@ûmbïrKâ,¿"ªxjÿÅ‡ÔK,ïà‘L¢qÄÖU'ç¸¾Ë§`|A )ƒàl°K²¡„  úµhÓyë-w+È] ~z‚Ëş<½*6Ä¾¢’QÛgª˜ÕºEbÅ+jåe7ïòl)kÑÙÓiB¬&O—*ø¬S0"‹|"Ñôà{¤x…Æd^Dß³¿îÏûjºX`ÔpÌQ°mü‡³Cğ`3Ì‘ş¯|\S/zÄ68›>òºò£c„ÎŞâ44nr?BüålpfÅµĞX0LÑsÍ>Kí ô`k2 ó()»bÅ˜c– !\‹ÂZgÒX„„z›=ìA€˜5—šªÁPS†ê2Qìy\xÀitÔ€PíqUì0q¸Z‹ã“ñ`oˆy™İ H
+`j­ìO¨O¡ÅSÜÃ9OgÏ†9ÅÀ 	Gài´o5WlMÓ¼4Î»¼&Ü;…‡jcŒµñ]üqñbÔvƒññª‡gz=-$M…(™ÆäN ^F¬á]
+¦í‘R7ù¹‘ï 2 &¸s œá¶ì™)N¼ãàŒM6Ç\&Kñ.pkh.tÚE9ü[ƒ=œÆt¤aÀĞáXçFßI#6Äğíÿ;F`²°ê%@ªG³È`åË˜5w7¼ÕøŠ¦€8†ıD ŞY¶`‘‘¾Óc8{0Hà OC[1BÖzÕÚ¦²Åœy}5áo(13Bìú²
+yjH«üJ½ør¾ƒã– pT°²:¼o¹»TäFƒ äÑ‘‘±Í€51"yß-Õa»@ÂÉ ]€&åø®iQw7ĞŸGLİÄÁT3ÎPs›†ÄTÒËòfxø…é~ê&1Átu[#K41°ÈõBÒ0ou
+\pPo\	àÅ¤öHà }2Å³2W ¦Œ úÉ »=âAàôìa_ egÃOæ /ª‡dGñğ€¹(Ö®Ññ	¾C[1\/?]à(“X‚‚aô0cì	šÖÆw@ñ]Moô¹SñqiÀ»zFÀª8/ùùúuÈ(‡b|×¦?›vñ/½(‰ê¦¨‚f2	F3ˆ÷…d#Î‘æàpò€1f1Í¢ƒÎöÅH ÍŠŞI"Ë>DO¢ÓœÇ&ÆwÌ}ËÙ¯u$ãÉ©Ö|zÓùÎÿŒ`¬•¬‚5Q%&ØÊ§”ª……ƒn’„KÕE8bÎ3l¿­E¸hØ˜;¿È;oš©C]R:ÊŠr‰ãc3c&Ów&%Øºa’2¬Í_äÀ ¼Z7ùmó†TqÙÜ}ÅiN¸èØ9İL7äãñü.z)uĞ±Hƒ/\Hè6÷šµ|É]@à“!ãñ\lÌ‰ÿUÓúæ·WlóÈ¸N>û+uæxHåç/‹Y¢ÆEmµ$ıìòs/¦K·R«4L4\AÀ®T=¹£QÒÔa€¡4ùR‰¦ÄôÃ¾²-ë´xÑR;¡{à‘€‡rpi!Y«•r%ÎûzÓ³3³ŠÍ(°Fd-"§IÊ^"#={µõ‚o<ó‡R šQr¨´V¶“¡ê¹‘Ã%ÀæÀà»ŸıÊ© É—ùÒ³­İ‡î>TN¸8›+;¿8âÉY–Ÿwšİq¸Î¬ëÂi}<\x¸æ]e”
+Ùã¢8FĞí?XUŸÃÓˆãrègÁƒ¾lN¡b»‡~$(¶ª;
+Ş·1ÕÎ"ÊûN†¥u.H0•Ÿ¤8ôQ,ò+ı8ˆ`\ŞO/‰V”ÄÍòIœ»Ÿ}ŞñA5]|Ş7ÄŞš%Y²"–ÓM‡8Xàû*€kôÏ;"
+:v»—äæ…w®­R(ä‡¸LxoæJ’Óe¹¤-È”Ó¬QàÆP -ùÁ’¸IêÒ.vòXéµF•OÒ10Í±\¾Óp–±!Ò€Ï`ÑŸKo <‡ƒ55äT/
+JAç-èâ9o–´õç—È¶šˆG·q%HŸ=Cc\2åd¾”h¼ÌÌàü«×ì~º.ÃëÜŒšµ@óœ»´Â?™9–úÄ;C{7İ«b	P³Rß š”°¹:Ôûà¤ÛuÄ
+Âú××w¾y‚X¬çÿöğéöc‘ıÖ9Öö{G«vZÆXb‚Fr¹ˆ“DZşW¤Jj+%e}ø_Î·ZI¡c…WO•×­{½íçO^ô®j—ñcäáI¾Ã™F J»}<ïÇ&ßÚU]€Àaˆ`ØÈáK”Šo½tÃzÊ)G¨ñ½Æ		ˆš«_¿|ºıèáîÖUÅŒ³oHJ@6àùÎØ‚\½ˆ\ùH­ÀpÅl-b%·òÊ¶nzQ[;ß?{ºıü[?Â«ö<n^ŒM’ë«AªñVê\ †ÿ©°‘`Í*Ú_¥	`6ó³ã7SŒ²VŒ<îe¬yû=FñıEcæiL‚Ô€å³ˆ[A}„Õ^Dy¼õoÿa\Üúpº`Çh´§$À%M|cpí*‰ÃåŞJV¶ÓÛA@»q  ."ŠüG‰•Wæ™å²ô@¼ôEôx‚2ÿ¬r0:˜şJ‘!ˆK±ƒÁ/¢ËlíşWPât2zOì1R¥Ã¶÷’*IóËt
+oª7gi§Rñü‰Nš"Ú_
+oÌ¼J14„î¨/Ôt®H1×§0(l-ÛWLï®5µ‹Ø&ù’y´Ö”¾Ó ¥9+MäÖ¥àVê¿£¤›]°Ìœ¨Ê‡KÃÌˆ0E’¡àD…ù‘ûWç™ AÜµ«Ù0€S\şZ¨¯Ô¢k…EàÍ3+†-„~M	cšî”“«÷èS_6`ˆö…º¾5®D¦˜×*\.šu>zêY‰M1‘TØœ§æÿ6˜$^áÑ¥`›g†NŞ¹ìp³jøôÙ¯Ã'<mèL¬,mì,‹™Ä¹=kõaÑ+¶
+Q iQI6Ê 
+eƒ3õñ",I‚³…O3‘À{_%õµö’±CæàáÊiâ»X™Å
+Õ›áÊ²òâÍ±¹Ù«Şˆ÷ÒòqkwæÛ¸s‡Ìéê¾Ë3è×uë”“q+ü.½;¼ÿq$ß“ï©1cGüD¾¶ÏhqÜhé\g{Ñ×Œƒ÷}éŸ^œ¢N›3áÂaîp½šëp¥qÜÖ:ËcäËòx¬ºåÉUüpeáU‹Û>~Üßz¾ûê{. ×ƒRùq³õ§GO_#‘÷ÎöÿÚb;ÌÍBkî 9¢Í•ç¾z£I ®W ÔØ@Áœ:*“a4ª†2:Ê
+¢„\¡8ˆÒwÆòåŸ€c„õ§L^R×i­6:‹#×Ëˆ¾Q÷_P½¦³›+™ ušV² Ó¢¬yğn}â‡@•3_˜Ğı–Øáá øQ8@ªJ¨È§VÄ¦k Îyİ>èÔ§÷Š>ğ[¾~Ít×êËg¨£°&|øÓù1®U¦v«‘6K]ˆú‰Î¹"¡Å(	%(²íŒ ì€é[Â»J¬Œ7¶’ÕIA
+;±#'µCÁ˜üed$Âç¦Ë„z¶%ƒBõ@7ß­ç/ „ùòÕ.|qÈĞ-x÷£âŒn×h¹ùt5g©ÛÎ!«EtØ•+·` Ro«ğ–Y.²4´(V.Õ­Ü•¤&©š·:ªœ¹iê‚ Ò"ç_KÛ¥ŸÙJF E+i¬ºªşÀy‰†bVGõwóWb;·Î£Ä<h<’Hb`Pë:”X)+À.5x¹.øCõ˜¾I¦²+fäÒš¨ÊuT%,ujëé«9£¶?^ˆ/Y|EqÂT³†rs´lš!ñ…"ëpâG2Ã9,Êú`ÿ/Æ LEï?ßÈŒ‰÷ş€ÁAò&”bœÜ+ö~”·¯RŞH%Èt})¥âY–\QÀÓ?âÔğ&ä Çj/ xÉßDüêKÅ< Çp··\q§orlñN~÷øhbá3öò¬’²pæº>|îf¥H¡çŒIcŒ)¶À¹í-äÍ‹¾Q²CÅq >ÕCwˆëR#'GgsÜ^‰ÌŠÊöÇwzÿC^ µYL‘Å‹¦„v2EÀ7ˆİ°ÛNyE9¿H•y:„7˜‡!`~j3gŸ 0Ù1"¢-G¸!€ÀÎÙè'xjxä€Ğ5ŠABXOªÃ?öÒĞØ}‘MT(ó="2 #4ÇĞíöNÇˆ­E[‹éÔúîÊ<â}=â1éêÖœ÷~›öØù-ƒÿ6-:0·KrçX®dgò<R>"±²æ2˜è]İ¥89e&jZ”ÎòxågoC·#TñŠÃ÷GƒSDÒ´ªiñKH‘ ´‡•,\"M—/ğx„Š Q–âx“ø£™÷Á7Õ{q©	‚uœíw->‰ñ„‡Ò5n-Î„W	gµ!·VÆñ:§ˆàL†d‚È3ÿ¡y‰½jÃùêá³XÌMİâú$4×/½»·‘eM˜õ±:âüSé”Ã®([i,8ŒV6¾pµ¸çN´†öDĞ¡gde€èx8›+(”
+B>@Ëı™ì‡ƒÉ©*ŞZ”EÙBOë\$TşA“2àRßˆ²UÈ#Ë4´âËXkœå6*†tß† j	„d4+Õ~Ğ®Uó¿5‹wtôã¬DfÖ•¦‹Ó›ªOÓÈ¢òYïĞ:ŞR›ÒÎøj„¹a1„üÈÄyŒ$'uà­Ø4â(97Û„.DDdM9{ow²q?˜AêıÑ„BrA»ÉyZR¶DŒ>¢¡2…YŒh3C/)‹MÑ¡Ì—¿";ğê$Eë+9Æ™¹…ÿõõönŒÚ7¯_s0ÀÒZKDâ2¡|~Šãõ"w°c†Ù¡|«$ÆlèœÏh›_¡ì‘€”m|PŠâB+­ÌPëÿckaØØÄ“„ˆE"<z6Âäd° Óò"Ë`Œ™Á¤d
+ÛT\aÅ8Ò¦JÖ"n=ÆiË	æÜğB
+ºÒXÇyÄ?„¢¸uÑ;²B¯øI¡/Kpå'¥9¦E¯e*ÿÕTgã–Äx
+]ëp1ÉıÓè 6Üü<}Ï…"Ì¼ãÑ›îş¢UìD¬3¡s}	‘¡€‰P†¥™ê¾y´û´ÿÍw÷’¿ù®ÿğßn?}ôòµ—ºÃRÅkõ3„_Ÿ£¿ ½şáqè½Å¸‡Rp`ÁŸQÀ‹Üiğá¤Á­TxÌ¼
+[Î¯`òà§ÿ¿»¯mŠëHÒıŒ~E›	I-Y`IÖ½Ù{‘ ™k	´€®qHÔ#ÔÍĞ`™ğìşö}'3ëåœÓ²½1wb×¢Ï©“U•••™••/û£–\@ìTDBu|ìõV­^•èlÒ{gc–d"ëvåÃcÌ¯zÇÙLÆGıÁÎÓÁ¦Gëmmï¶6Ÿo¢CŸyøŸy9€ËAHábïõ`±Bóšád÷%“N€±å‘gšt™ôe@CÏ€SÖğè„Å1sÆu÷	+f†^ĞS»c5-3Ï”í°6;¼Õxô:wMZÕWÎ2‘ï¢HıÅ…ó‰ü· ×kšÂ£ó¾’ğàõÇ“ªÔ&{Y¨,$4óa¨dØUmídT·ªÔ•Ï]1…„=PŸ³„ë3†É™Öù„… u(#ÄŸ â&5»¢5æ$æ‰?üû ˜;Aùüaâ;Şà6?4Ô˜ÂÆõ·rÅ®Ù™G¿™^õq´3P©~¸:…¹8îŒ”zŠ·Ô0?W¤B¤ ÈwšÅğ¥RÔ59c™>iFÉŸÇ4ÁÖ¿å(5ÚVfíçİüÈÑPdóGróÄ01âé iùUAO©ağ¬6=æQ—æÇ¬*Ä¨›»qs£ù×Ä¹LÉf2#6P®ç-„dtÕ¹—sÕks
+23:3DÿA½q““T§xzhöeä»{§TèÍğ¢<GŸ6
+ê¸3³ÕŸOlÕ<-ôâKøêœœ ˆÌ‡tÎü¦÷Š)W{7#wræ‰›óâjØù'åæø’-Âƒ¬·8¥à“îº]L1Ãñfú¾ë¬#EµX=4gS•½ØYÛ}±²ÃÂ4šñ±‡ËëZe
+fëú u;[­¤A-9Îõ´À•`EÅ	ròşât ²ªıl£q¯­L
+¢¬™S§Áç[[?¼z9xòÓîÚ]š37¥-ú(‰@sÕ >±ì@¿I Çœu˜ÔÆj¯6,Y%˜»^wMí‘×dç@5Œfè§ÓE®9yÀ·¡6v|.h«Ë0l{™&Úf]Á•â'0ì…€Õ™
+ö ğ§ÿosH‚}µe„ñGÃ²(pa!9oîü¸òrğ|kó™ş³“ê¦ê+Û„äª\p³L‹£Âl`Êw¦zMçzà&Ü­ør¿˜ v*)%¨¨ì³r>O6Ğ©ÓÒmAùEàä3†€ö+€ó}Á&Óí]ş”QœéöÜoÏDeb¢&ØX|uÆd„§EQk İ‚Tê¯˜—qğ 8Ejà
+P
+€Æ4×8®3Ëà/Ë=W÷2cl×£]D¯kĞpåæÕ•.
+,‡pŞ¸\¼³íÔÊ§©•ßğZÅŒsÅÇ¹	f×=·qYÁİ×x[Ê±íÏ1áw¶ äNĞúo0‹6N@¾Ù­!††aşš²¸0\Ç/0{ ŒyñA¢wÿF8JŸMà€×ÖYu,
+Â˜·âSí©@JâJ²¢
+O  ÎÂ21Ë¤Ô@d5®—ÏW`U¢x†Gäˆ˜ˆëjJAè¸Uñš\ˆ#u­;§e
+Er©Æ§¸¶µdÊAF0üˆ—3øŸ™˜µdØóL%ÈpÇbÄ¸fC:£ê&² h¯ğf00ÚßšwzlG‡ÄYa14«âÓ´$ü°ÂhÕ/w€FjÜƒ6F–öHÆ3SÇÃ_|]ë¼Ã5	¨ı Qv1cGUãn|Ad*\“©vm¸¼~&$¶×Ööv×6W×VÿÁ›[;¯¤!¢ÏÁ˜/HãõƒûA¬aMãŞ›î¹’:7¼>ä½72^éŞİÉ!fø9Ş’uVêÄ£1®PHO1ÇQÖa£)Ü$Ô	"	†¸; C6´åbb¤4ß‘Ö]Y'¼¶Îİ‹b»±Œ%\6X´‰ IË´í¥¬á¸»r!fä\Òs‰Dr€‚ƒÕÅföE5õ Q“VÁQ21rd4ÇÊ‰•N<£1d+›À©N¤è2,Ù @D”°×b'ŠUW|¬‹­×¶ÌÓ€7¡Ñ•‰SÜæıæ~šaûÆÿÑŠIä•°dÌÑüD|Î“.¥Gèé’ø‡„€B†ÎÓv:ä|€—á!µZ-:dÇª9šM+Ÿ&9gíôßZ@aÛÇ¬ë(İyİõƒ˜èÚSÏ #¦vyû—¬ÏÛÍáÀ`ÌZœS’Ñ_‘áw½)8VŞ×&ÈDy] %æ­(*{pG_‘eçÓªÔ@Šåí­X{OùfŸë?•ÛTT@qaKşâ^oùİI,ã_âÑèÜÕøÀ,åÉWÜJ.a·JbF‹K0¿ $9œõ–ŒqMN•åDGù‹IÄ…«<ºŠ-³lÒ#™k%Q§Èûş’8*÷x~ø…ô{TşM$“µ 7q òkB‹¶ñ/Ú'•5>q[vi”D½G™ôÄ§yèáç…My¼©abZÓRBÙZ__C¥KÓ:\)ÇŒg*?üù¹;aQÆ¨ú‹oÎÍ¿o~"À‡¬˜JDæËakTSL‰Ûò‰ÌÍèµ;)År'¡SbÁƒJİÏ-lß‰+S}~.Î
+•ÀãõT8ãÂÌEH5³Ø=¤gòÓ0[³OØÂŠ
+BªœUl” ZÎ*‘û0ÌWÕÃ–>B<^yéq$”Ä6MF†HßåöK-ü’Mëá	ÓJ‚\aì¹[ x|»¯”5¿Ù{¹²ûıÎ`å9J–V^²¾ÕˆêJGMWÍazz€¾ş¼êl\4>íİ­uÙ¼´’Z‹¥²ï“á?¯Õ/œø4UNOm,T¦ñ®Í¢IMÎi¯bª•H,3ğİzŒÅC¤iF3CÇÉİ«WŒ4iÖ=V’ªùËğ@¤•w<àK\Ÿvs¨Õ^uwÁƒírkN(Gc›±’¡Ø÷ú/-¬o¾
+6W^¬ıC?Ö¶7¶Võ'tè+»O¿7Î™‘#
+ª«Ïdı5|­A¬!}By0Âé),XÒ4mŞ¼¤73©KLm„œHÚ
+òÑ‡3!‡Ùƒ·5ôjGÅ-ÿô
+÷À)"ÖÑÕXípÑÍyß 
+'ã%©¼å ‘Öp|)äh«±Èeƒà¤h¸œHá£Æ×nÇ@Z7¢B½!Æct¤¬z±ëùÄ˜F^)aR,Ş­NÂ…|IÂóˆT*hW’/¤SàaU³\¦)ğëûÄˆ(7)®|†ù:›»ô3Ê 0ŠAı$iØàğ=úWüçõf>`M2®î4)«MÉÉ,8²İ^rÇ}4“%Æ=¬ÖàÖ4<ÃöÁŠ.õàÒ—Oœ3€UŒw_çgH(ÅNûgÔæiã›œÅ÷JÌsf~R";@ç¨%eb¤®ÀöúèOäèmm‚àµÎï½F¿Ù¿kÓ<pk…3XI6ÌL÷.I:}Ü‚½ÚQmgšØ­|·4Ë‚àdÇó+…PmuâÔK’0şzcáu½»GLa.¦j×p¯_¬ìÚ´F¦<ã°íjE¸i‹Ÿb·1IrŸ@ÜŸI[Â²áUf.…0Ïªés$ØHÌ_µI+*ô‘Â!˜áó6Üiªú‚AÙ´îõÊyáò°Q<‘ûÔ,,µNÌN°¹İôöÛÛ$Ú¼æ;šµ­¼Û8×áÏA.wtæR àyz?ÁéQ‰êxåÈ£¤Y;°‚Kšéö…û%oªK™$I1c›rVT·-‰çí7ãÛpù2×.sÚÂ=†¹öúäâ',™Í	 íø®àíØqØRV ‚ƒÌwjLËšc¬K ~ÇÆmZjÉ2È‚\ÕHä`Û	1Xçóáô)Ÿ¶î£©õï<ùU$èn“§îi%¼™×ìÀpÙƒÎ´súD{ûO6Æ*R 7îvçŞã¨{ğ~
+´ñ¼3Av\v3aŞQÃ`ŒÌLÌÇ¦‚%ˆRİpÅş—Ø¬GöæM¾z‚¢;Š´HHfi€S]¼ÜaÍ‹ß‚°>U8 ¢x…èÄ©uäïò4³÷»Ó¬TÎ0Üc4b¶}í;vC>…U©ô"û±ƒh«m¯=İúkÛƒÕŞâ'Îs> ¹Ñ+†üü`ù>öØö'¦?üÚ¯Rìò3>0ITœÂŠS¸g˜Ûİİé““÷IIÅ	ˆ"L=AšÅ…(!ÁrMòçÄÕÙ›®W~Oµp::„Ûş6¶ˆ?äy`*td®
+öÏlÃ³×ÔÕ3¸	±.>n	Iãq†õ-¦ÙS.,3@ôÜÔ„*!q,‹/¸§Uìzºÿ3y]úœDƒÖÑŞä"FHúˆc€nÀH_b~›eMu4áùÂKğÁq ıw#Ğ‘Î´•–ãË{òÃ)#±=İ¿<Ë2òo÷l-á S+„Àzòéc:;»8EÑÿğvœ¸;¾ôT1‚”T‡¤Mä”^xijËÎúÔıÂY×" ÊHş¶¼@L·[HsÚ%ŞS'\«{½­ÁÓíµ„–á/h”›Oõ×öêÛğllÿ¸÷*õ’ E_%àÿ“ø¦û£D?î·7²»šñkå-ìa  JZsC#p-Ùö¡­¶Ãä¢¹ß+h]û7\ºÎÁ	ZM¯ “êB Ÿ2³1!zÆXH€˜yúÙ;-jÁ#‘–éŸ7º \ßÿ‹c0®œ‰t£“BŒ€`Bp{ÕvÅ—½F1|>$IìóÒßÆ—G½"dŸd×ù·(…BÆr‰ë½åá2"Œ>BÇ:]"„‘îgÁ—NvöA*±T¥6X‘y6â6VÂcÛ¯ oÒ¨›]ÿÜ]æèì¬À.éÉapËçL@‚ÅXzzf[Ó¶v>uj»ÜşE’0@ÒúÃ±it<pjÍ¢uK–2æP BE6*áÑx†œ1Höòáë,´+áYJ6˜øÇN´½
+çİŸ>‘İèì˜³¹ş~† =o±Ö:z#á§¥›Z‹Í‘„g±©ÍÕ%C&óu$ØÙkïºf_ ù˜\5Î`¯ğo¬dZœBât²2‰ÑjY®ÇgC=nõ\¯ÄvÅ=ë³‡|l@˜ª`ü#UüğĞ…0Ôì
+]„ØpBmÏ'Àû=*ÄÅ¬6qTÚ½fz¤AÙŞÃ[×—Ø\RÓş÷±z)UÏş0]á£ÒÑHî=Ó³1XTMisµ5‰XÓÂuQê™™KlW?ÅšnY‚ğÜ†WÌ26}æTãgÄ2Ò§¥ïædÛà²ÂÏ+´âi¸^ië_­Àê€û»p±-Æ×À:.ˆ[»™áyˆŸaÂ7¥Jv­ Nmk°xY?ÊC‡ÅU›;^œ9şX5½ÅVB]äŸG÷Jc_7p<‡¤Ü7ï®èìqmºÑÈÌ¥pìb1Ó¦½¦ê™}2Á‰à,Ä)7JqÎjÒÎÅCi.¨}<›À…Ê?ªªg²°Ã/¨•`Š8è6%½‹	SÑA¯ı¤Ä˜*œ·‘Ñôê#2½+X_ätÆ¦_M•1ÄĞÒw,À£^ú3´·ãÉ`„»rxÊšGpzÓ:?£‘Qo¦:9”œ¨$ıÔ<ŞÂf\|Céü¤~Y|Uú³ÚC7æ‘¤X©ÿ(‡Øp±ÖSòÛ-Òºæ)Ã:@0	²Ï×ãøeÿü‰šºÛë¥æzcaw{åéZÑğÔFi™ÃI«ÕjBb¬€:/«±f@ ·9«ÒW£Úg¡¹- «AAÆfì“TCíX­Yü\sn7è Ğ‚ÉÂtME~Ç0è\S”°ğğÁ|#»golÊA{çÕKX±àÊø‡>±ƒTG³P¢e~IRÖ¬Qø©¯Ñ¦ş™6ïš”$G£Cù³ş£ûÿşgZ¿Ê&“ˆÎŒ+}Í74(ızÿ¿€½HÿÕ`‚7ƒ¯W~JlS€VŒI*{È9¸ˆ‚G!£àféHÅ˜0fÏ°A"·‚ı4zó‡ş,S˜?ÔkèÒÓ6‡¾åZÄáğÍøæ4Ùo.ÃNŸ¹İ=µ‚\OzŒÉnf*û¦,^„i‚˜åKéøã~q-ÿR”¤5|±ò·¶yjÈOV KŒ‹İ	ª—”–†{qZ–³x»Iü²íÎ¡Ÿñd•á*eîe*HuxˆáÁù^ù‘­8ÅF»7%Ôñ„°Æ“õ.º>¶‘•_î]ı%	-ã eu†= ñà7§VòÌÖ!½ÈôOÃ¥…êp0Ô¤¤$°õt€—æÚ»¹üğ¨÷ƒ‘X_?,!Ä­±=ÿB©Ë÷‰ÚxÒ§¯êò}ÜÀØrÅˆNŞœÒÍ›¡-Ñ[šõn=Z÷ê=ôûHt²…èªØ2wÔß}Å©<Úø 
+¬m(øÄè“´Ë)kİÕi±#jc6è™ÓD?0`X}ö£ÓÖäŠ{_´Ù@(0Òb%u¬ ØÀ6ƒ
+¹ßè¶×5×gQÊlá|)Ö»ìfæœ´²ÿÙóNÍS_6»Æóù7[`­Áy[Ì®¾Ø£ŠPl.f
+¦yÏXJf¦°bcÎ s){má#SyÑe"„âY…§„òµÑf”C±#7/> ±÷cjg›Ñœ§S˜Ú[Â×h,uYş~[–@NZ°2[*I'÷-¢G>ac\¶äkÕİ\‚)Zç¡±±ÉıÌ˜»çšDDâÁ½šOšHÂM•í}Ú‹¯Râöîa"Y%ó£ß¤¹¥ôİİŸ(skõAÎtİı…§®¾á3[­îobÇĞOÄqGó¾à)ùFGˆëî¡8S¼¡Ö÷ôN|ç“îşô…w„¿SG7š6ñ®Ç
+ENª80ìO¡Æmì¬^m¬Ú®+ğéştúÉOpÕÈ¸w^"~D‡ı
+‚İ#å- †Éİ<4ÉfŸÚ¥œ‰ã÷¸•C´“îøUJ?L9éì¾Um*"ÆaÇ$5ñpŒŠvğ°„‡ã3ôş)xğog"Bï—¾;>»
+<Bó|
+ƒeÎœ¸yIW¿ŒR…r¢ÿÜ…†iGfÊI˜ÍfÌØŞ¹¡RƒÅÍ¼œäw‰]pŸÀğ”Á2
+|á÷"îW€Ìm'ô¸±bIa1=Ÿ`\>¢[èq7 è”{&{Pxcè0¸ƒVú5øC¤ ¸X^-}TZÑªªÉõJ÷l¬ (ÿ°«"ëåöÊæ³5XbXßöàH‹èÕ›ò|4„[5¼²‡CŒåòp8´­D†p_Ş	î³…¸7…hŸÿÑG³cÜõ0Õœ Cd%+¢Æç€[[	/µH:E…›ÉÓäfâÉEFØŠø@iÑÎ>Ç½¿]Œßcş@@ï	êNY‰@Ã-<„hzö.İ»çíïÊÖce¸úQr˜X/Ş6jùÈôaÖ‘«™&YÜÑQJ~ìÃ=sïöñmîkyµİ~¦¿	¬•„aƒ"M|õåW|ˆ,õSt„^}èwŸÚå1F&¬)gå»ZaÆ)4OF±äõÃÿ€0Ğ-\dàüb–«³h®0ê”Ió-±¡ôŞÂ‡ZŒ•S‚s›ÿ‡/®‰‹G_ÿÛW¾
+jô¯‚…÷~¸&®¦…‡şUæ*‰ºDÈÌ±qr®‡`°]ÔTÏ½XĞ˜ùÂ¢è+všmQÆäpå6¦p £·Ş üœñ»„L-b(‚:„K—@ÁP?kH«
+ÁÄ÷¸ıóğÄWÁgO€1^`Îí%ñÀŒCUÄàèû®‡„a¸AÖ€o,ø¼™ãõÎµfŸ}gM–€d©·œ`y³±oâ
+ºÓ ²M¦—4`cÍ‡¸6³ƒ»àä<L7ÑòH~¹²á×ûòáÒÛ“ÂŠQ”V¢ùİ>„NÎöøèÙA¢CO«j"ºZ"Ä]‹Ê|X/¿ÿi!ÏÖv¨æöl+Ëˆ¦jÏ¦ÈàÎÖRMÈÓ×b)¼‹»ĞXâóï¾cî|°qÇ¨ÆEÇç[?Â‰ËV\i>^d{j3nÎR~±¸³­”ZÌ/æ™GÇÅ­ô¤jÅÕ¯'\"YZ*`\ã¥¥OIïòÜówî.uiOé¢â™,E+ |	ÔN ÉFÿ©Õÿ`¾ÀŞ]‡ÒnõäÇíİµÔ.Rd¶ ­7Úq„m‰–CÀÑştPµ+$Ü w6¶6ûJƒªwáğH¢-ÉL¡}qÿß¾xğ:ÿ¿ E~|Â:¸¸’}wŞë?½ƒEğ¨÷¡Æ'p¹}Î*ÑPf™ïññ©=ş?áù´<9;^¾xÿû¿0ï~ UzTø¸Ÿíà½+½„¨ğèü#¬vé]N.T¶œ™w!¿G÷à—*gÿÅäÌºkº££K¶’ª8ºG#°ÒÒ?Û|Õ{6#iğIï%‹+ôã4:»Bñ;UæwàMusãÜñqöÖ¨ Ï ¿D4@`Õ@>¼×%´â>4:Lê±Â<ï˜o4Hö¬ç_‡å„e¼oj²ïà
+Br½WVGxBØ8Àp	ØĞÚûqc÷û­W»½•ÍŸz?®lCáŞıé/
+ `	Tä„6à,³ÍôÌXŸ3„4\:àÉQs‚/Ö¶Ÿ~ +O6oìşÄ¨ÖõİÍµŞúÖvoQkÛ»O_=_Ùî½|µırkg÷;@+\Ö»böÂÁ$ã‘‡pñL9Úp¹s™ù‰òvàãƒˆ°¤_ıë¿j3ƒ®!9&ï&Ü”`M†ÌˆæLP`„vŞz{»vyĞÅ†ôhvñ~8<ì#¯ö(,Œîg‹c7X¶",Sú—Õ^ö¿ÅˆüoßÚñF·z÷_fÅ#²\"Á:“D*ÓîÊkş6î*ğ™GlqàÀ¦\¼ó8”0È”dÂ#Qš¼Ø?ñÛûi¯pÆre[hf Å%'éE‹o³ƒFbM[¾YÖu‘İm [1úPI—ú²£›½'œÀ}D8Å¿ÎØoSÇÃ#ÈãÃ}ø?L_7a(Õr0¢ÎBÃı5T³¥Ûf}!&™§ä1ÒEbàÊC%†¶eñÚx_À‡‡ôÏFàİ¨Ğ;Œ`c´nR>ğT(ÏÒõïVz¿üò‹3
+ò#â‰˜£Õ’3šoi/]FáË”"ÀÉ1ä[‡%Ç$ô¦ƒ7}•yä;‹©‚ÆJ´dŒ¦'ß3ùÄ¼©!Fj7š\RüUÒ¾-jB!°ÙçŸxL%¹é*\²oN¿q$|@pÊÑ1/PY= »İ¥µ–Yvï4¥ü“R¸qœ%*¿ädÓô¥¶ï0šÏø%Á"V¿cHOÑ¬J#ÈIq`%ñÑgÒ[ 9>£¦û@@ÕW9ÉêcäQı¦üØçQÑyÓş"ºxºõâå`um}åÕs%,îB&—×
+'²/{õ€;¦l¤è'p’êøâ“&%[ ˜¯Sê4(ô†•ĞDÙÑŞë œ‘åÔgnºx »¯¥¯lŸEm–W¡óVÛVh€ ív6:\b#‚<r®6…ƒ<IFé¼Çµv{Êƒ%xO·èŸºñ‰”v_t’ÿğèÊ&§W7Ù¿º	W±œ*\a_ğ6ŞC0™à{â{ËxD±bæŞ o3rÓ›œANÃÒíN0½¼@‰
+gFÊ>ÒñÒFOq‚"ñöbt‚ØMr9$¥şh\Èâ$Y±B¼	áÉ^&J¤²y³#Çˆhgûİ±·»Âø˜Kzpf+&ŞSp¹NŞ…h.p+p_-ÜYñjö;{ğ6ë ÅÑ‚mĞ?c&{±cZv†58Aw‰±©Iäİ2¡	ü’9¢M²‰Øœ)\Í¯‘Û(fDÚ ®ÔÁÈäNV2h ¦äØèu“–¦ÀÅ¶¨¥š¹_±—›» ÇtçëQÈÜ‚6À]ÎÂÅæİ›õ[Ó-åßÓ!ğH^Øõï†'Õ^,ÔÜú„$!Ÿy9,tËõl¿Fê‡§F O´< eŒÒ2ëSZ¦e‚Ö°Z$*§x,eÏ«1½ıÇH0oÙ£Œq:Ÿ†‹ó‡NŞ¬`^\B9#&½K€¶˜ï­\Õñ*¢ÚxÎƒ²Ë
+ö~t‰>MZÃù2’*É1™Ÿi°şËi^(´[©rŠÈö
+5§šKîèr¬mËV KñHãC÷Kù£â(—¾»˜Â:â%ô}C˜˜:B¼mÅ#¹êaa˜g¬C}A¶:iHFóX A¤W*X§¿oÃN‡‡“ëmØù²7m#İ«YÍiâ46]ÓS )œw¢"[¼L5İèuæãs„+yÏü©pKáà2øºòÏÒ´üw
+8¸®+>ŸZØªæO\Ø!…Û¸óèi<‰x¨Ë˜Q#ÍÇÜ’w6ô”â* >Šøc0»8xêBÙR –OçQI³>v$.™ÓGt7ÔÇ ÏÉÛóö(ÇXH &ÎØ% xv= Ñº„ æYŸßcRsÇbşˆ¡°Š.ŠÅZÌ†‚Áx•†N"òúD‡ì4ùê ¶Îç€;VÂèŠ*¡Nà¼±qŠH­üàššFúlŠ³¼Êw-x °NE‹œ çY–¹!‹¤ù¬emqŸ.©,ÀoD¡LØË /éÀú–÷İ5ñ¦g¡¬è³DÙÜ§Ó?¸‹eË84†4óÜ>}²æü.ü¹i¨ƒô?…aµLeòWI§’îÊn3âÂÁ°èW"0-T¤xò]Côûš¥pÈ5«Xo)íâãyˆ+àïÂ½Ìs˜¯Áÿ¡ÈW§³è·ÑoÆşƒD·±
+5¸ùóP	3n½÷óM]\ér 
+5™ª(g!sV¸,Â##Éù[q-Ÿş2£ù¸ƒ­ò1/Ì2w»bn¼ú4Ç/˜gÀ°1z­<;^%û,ßìÒqÖ l‚¹
+×¥›5»Flš´gÎ)/ÚÍÃÂ\¾ãÕUı™ß:´~ª5Z‹Öi‘¿ãŞÖDrµfü6­nH¸&¯Hª ¨l‡gæÿ.¢z›Äó'wj•×Y¤Ò4û—7µ”~ëÏH³0hÁ£Nÿ¼ïû8)ß½¤Ja*4A=fZÿí’<ö®}èB]¯ØŸ`%™ÇJ b&åJ³KOsĞCÒğ@³U<@XD^zå2æ™‘N>î_N—pÙr_ïšúÉ a†GZWšˆÂæqõöà74şá‡¶Dk°e¶X&cøÏ"²Æ‡M¶`e|ğJıüSñÃÜõf/“ Kø0À%EüŠ›•ôaB{»Ä2œ]w[H6Uƒ‡Qn£Yáân£HÀq÷-Öé6óQ¹LÂRßÂlE—ÎâÉwâ˜té'Éx7(nú%ô'…¬9¨J}ÏSÓ”p‘€{ëcÅeİõÕL˜iJo¦ßq¦¨af–SÖ]ªm­èQ+g°J‡…™¡k·ô3BÒÑ¡Ü¥ñ¯‹:ƒY3&ÇM&©ÑˆÚ’'vZ°†´ÎV^ÎX¦%şg1Äğ~1‘bƒ¯ño“¼¢5õÿ6jâ·55ñÉï£&BàÿÓ-â¤&ó*¿KÈî–ŞILx_“@b‚Ç9~]‡˜øQÿÎºQ&¦´`¿Ÿš7x%;DzD<uSx¾cÑtyXˆ˜Ù\qŒ×èjá‘3{Z½nOë×èiİÃgfö¶~İŞö®ÑÛc·fvµwİ®–.Õööğz0æpxĞ¼…D^ Ÿ²“ \¯wÖÍ*?òŠõÀ®ÓqeâK…iæÔ
+L—=z%†k‘,†–ö§)Gme`íò(JšÖlìQ‚-!á²b*ÊñÅ`2èÅõ°Ùq·}mı¶üö›$â2Ğ¤ú}{-#|­\™ ›'¾ºœ*o£R †—`ŠvÙ%‡E7–ç»&¿ Òı’ºóİö¾Á-®ÙÔø¿{ËË¸RbŞkƒ9ı«›_/áäƒ7"óŠôM¿àQ`ú×öAÍ{{3^gU‡×]:¸]ZÑWÄojÀU¿{sşæÜ®Àzö ],‚Ù6?dã7çÁJX„·rH±N:İPìËNg”ÔÛŞã|Œôq!‡˜rT®ö$6p&-“«îŒğàá×‚İ=p[#å€ÛÇMŞÊpÍ?PÒ½Ké[W!ÌåÜˆÊ3§Ã¸bÕ5yñæ2g˜Õr‘áhÈØ ´mà‡%·ªˆù4|€„\»´®¶l¬0·ÿ<Úïm®ïtA´‹†Nô×²Ç”Úõ™1áü™å£ş‚´z(nƒDîQ;µÁlním½ÜììnÃ©³9¯D¤¼v]pzA;»bÜpë‹H—¼#6oHÿmu‘ŞıQ&ÖoªéÉº?Š#«QZ×‡{İ¦ùúÒeôut·æ³Åy*§`h}dgßúlüæ¼üÆ‡,gW„(ªÊ"]Ù\š8)LÅ¸ºúş‡"6Ù¡ËÎ]cµC.ˆº5hcÑ‰–nÒdÛ­«¿fbÿøØâga4ÄùfÆ—TVñÿ­/ñL9ßø®M
+PøEZ*Å^Dû½äÔæs·xôCVKV¿9‡SÏûejöü°……EwÃdvO‰ŠrØñ1&ßa&j†ó2½ëäÎ`ÃÄ6Ø’óÃ]\aø«9\H0P’ÿ{Ój^Êà‡è3Ëiï±]“/å‹v°òTt(oá} ¹M³Ó%ø$®‰ÃÁ8V{÷Ê¢ó˜ÿÕµ,€é‰‘&óxŸ)ó8VÜïäk;g¼7Üç‹/é	2Q‚£$&­Ä€C¹ìa+Éq_{/­ø°|ùğ«?ÿ–&l•øö+–ğ2o»‘9ªëm›ác×b’­Èª¹±ìÃĞlÒğZ0ÓÕ<³¢PÊÄï¦p]:a¤–×§rˆ²Ø¼qŞ¡¿BÀªxªñcñæyH­ÎuooX°®°±9{Œ3fÍ¡Œ [{rx¹Ã¬<ŒÙ=UŠ“)í³	|<±êÜ?Á  F+’:F#“doÏ;=\C{©ú‚*U ÀÀq{;óğ©	Ø˜„<ˆ“ñg¡B4¡ÛŒ™q¹èNÄUj7T°´¢L
+âaÆ1V:™³œÅlÄ p¬¥p—AŞwãGÃGìãG:ÿ­=iCÎØo5ÒÖdÆe`ØÅø|„iÌd@®ã<6wş 1óŒæAz	÷}€9x	ºôÏjöÍ’ùÄD HüŒˆ”J¡‰ˆµF)7&¶ë×Ex´Am=iÇ˜Xğ7 '_ RğHñ^È±İyZ>ÿ¸É  cF;Ô”LUVFğÖ=^ÆäIO­òŒlKcØÑ)„÷Ù’Æ àqÌ]™à‡-s¼¼İ§!¹fcÑF¬t|Á*
+0€³¾Ã@-#RĞîTÑ3¼EÛ#öÚ+¨]ñ‹=x‹ÌŸ\&¶«p)ê\~=éqM”¶qøÆIq&Ÿ‹Z£á5êcŞIa>ıjsfañ4U¡¤^„E¸yø`#u V8$Ø7ç³Î:÷pÒzöIÇ|dw·¯3£÷ÌÌ;ö¼¿M &öÇC¸òÏŞ´ä9KR9ò}ªL©Í4¦‚zØ[ó±”Ù‡ˆ†¥p$ÚgiØ gÃX£Ãº7ÃXâ¹¤¹Æ“½†İîJ {M oÆK{t16’°-§+ Õ¹(ËÚáÛÚi c-€»~{»½Å²Ûv\ñ	÷ùØedÃ}s÷l1ª°C™–;…¿<K×(Z€rÅv±e èÜ^MrRÆÑ9jŒ!Ra"± mF²È¿QÀµâ|W=È $Yî4¼³§“)ŠÍãğŠ'L)Ä}Í­‰ë|D{åÚŞ"Ö:ö¦°¤­o²²‘ÖMÆÌØ¢eø¡T)ux>Ï_CY‚ø±-|î‘U¡š¨O¥oÕg`(ó™bÜŸ™•”cOmX	ªt,¤İíÆŸFGĞRsÔ³Rg¦¹­ú€²rœ‘˜|löí3gûT"pBò1*éKoYÆˆ8´R¿]ÀTq)êœ
+®’iÓ	ÌdØ åtö¹%Éşû'@FGXÌNq¨Êp>Sc,3RNÚ·ç*l
+'w8-úDêêiÙíâîH!oÈ~s†cÚÓı1}\êJRèu—5æ²®=ácI}b8]Å((—Ú„ÆK¾Efa@Ê2Ÿú8TL«96_a–Íé˜3
+}Û[ÛÜZÛÜÅ´YÄ{u‚ÂyJ-öœ+9µ}ôœZ#š(ë¼ÚÙFüõcúkûÙöK{¶½µû½‰B*åÆ÷ÛSÂX|hñ©*r\~ì.0"õÆ5’’éØõhÃ|ŸŒÍ¿rtmğZŞÀ+†VÕÑÆÈ1»'ÏèÓËÓóB×‡áRƒ·šX›—b{],\ªPÓ_ÇØTÀŒBu:«‘ÜÂb1æ™¸0çß¶cç8”}¯§°àÛ÷53Æj'0c"N"ÊÍ|CÏhıséíÂ«X³Œ#5Wñş˜&]Ép0ókÌ˜wãºYÑj»Ú·šsİŠÒ+ŒBÌ”}'1Ú\û,À“¨†JÄAÙ4ğ%X¢Àè Å ×C›G%­rĞ¢[²{qt“Zß‚á•‡ğ
+Ş–¨¦ä†y‚ÊÚÁ^Ù‰‹¡ôU›ŒùãQ\‡+p^Xj6¸$Ğş	UÎí58Åä|Á§%ÇÄšÌi~*ˆ0ç^«¼Ëú£ã2i*rø³İvR`Íì&)XnvêåT<ğË1b  Ôƒ ñ¤í¾ã4)uäŠñ h|„âö0ôşÊK«Ù2‰œ‘ªc¨PvuÉeBEDÆ>Zh–„CãŸ_cÌğÅõR»²*\ÕÆbNãô%²/s]4O	_ïÑÏo§êbuãúFSñH¶6hPc$ƒˆ /ˆ`KÁª¨Iş†+†¯"×M£Xšub|-M¡¹s/5».¦çİ ë¬õ¯“,5ä3“ZKËĞ“îbëÃ{ª‘àõTDa‰½YS|*æ£ª¢ø`H¾qk"­…ò!›<àR&S •×ÏÈ%y¼[y²…ä%›Ï¢BH²ìÂnB¹,K…3‰}‡?¤Îšìp°.X!B$¶h{À!ÑMé¤8KÇ[0éÜé0¼1éû²5‰Ê‚¹ÒÄ¹d€BoH°¼,k«ä_]ÛQ¦ùe¥37ø·Yß¯¾X]Ù]i·§SKwëÛ+Ï^@sìè„î)İí­ìînw|Q9‰¦O7·3{™á`š¾]yşã
+2fÍü¾Ó‰6}½úêåó§+»m÷¼Å$×ö^‚V<_k£p`7®%N0±nLÒy6åi5Fgk\è6ñFVìuNë;8ÇÍ5UÔ5`ñzÿx4~[X/&¨®‘*”Ø¥N¶ÆG9ü–†,78Èó7K´¥"ëVÛ‹µİRj‚Yv5Ê|JşYpÏ@/j¼SL£àÊÓE2ç)UÅ“ï
+1²²VÇxÔx¾x¥Ğ:Æ‹×ßòíH~¤[|Š9H‹l– `jf®°mÍa¶c"AÊsVJÿ–Ğ¿ÉÄ ò‡Úµ;³¼d¬Dº†ƒdÙ?âµ¥g.†Ä@!S¾Úñ2¨£ÇmNK#B&>âLŞ|]pBéšü¼Ñëòf¹ÙEà=ÛhB¹Ù‹±gõCğ¶>PvpĞ©ğ„óİ¾ZÙù~}gPp¡'»XB ÍÕ¢Æ÷Ø/;ı[…\ëå(ØÃDú­ò;yØ²T+k~ãŞĞ€Â=ÙÁÿNØ½Ï;³3‹WH®ubVCÊCF¸n=^õb…-€3ƒˆ5o'L•?¡3 ,¥ÒRò¶…E¥s++}Ëüy8Âòñ`rtÄíì0?$YÉV†K%X‚-–=¨âDeL;ê^UAHÔ Çá¡=+ú¶=ô©Œ ^¨ÈÖ1ÑUÍ©Ğû–'•tD1+Å²œ[åß>ùÎÏ·Ö×wÖvßç/ÄCÉû±:Ryò6ì«-O[,yN
+Ñlªªc`Ä|‹ìnp€„’hy+›¬èN4	a.5î\Rb`Á»)Ö5zæ£¼ªÖ8OË×ºø¼\Xk­¯•Ò³ºü`9Ğ9v%”Â5 ÍÃŸÇGG“Ô0'uGK‹}¶öÄeÏ£UÆNÙ>“k‹JD””„ãÖáá€§$Ívvé½‡¿‘/@à­¬“O¶òÿ™Šíª6}¶Ò×1TZ¤§¦a‹†:4Ã€kÂA®µW·0ŒÃlæ>×ÌÅOMÎêy3HÙñÿ»_?º#‚‚x›!.Ø@‹Šš-(À¤9¥VD$Wh0(/H+5®îXp·ğ¨”]ÉWÓõ,•³¤q¬ Õ8˜@>§CÊ|õC§ŠEÎ%òé'öe5…²ÄEætVj) œAãÌ:Ü3zKãÁ	eCÿ]Õ×õß=&ï*<Ìô3°ıÈ††ë½v2RºÛ¤.;¨¨˜çª+ş­ßÁÇÑ9FõfŒ•ìLáYØ>"=%]®NO†Ìg~6\B1Ps×ñ‘Ä1+”¨á!Îs¡[*UuY—/ ?d‘¬¥sï¤G‰‚ÊˆÂÿÎÑ«•º«h%=öÉ]\Õ†ë¼.9^d‘¢[	3”bô4¥Ñ_YÁºÓ´rVú›ã†ˆÒ¿zbXGkíf=B´—0òª0ØÄYğ› ,ÏHºú*3çúû²:’ä—µNRğªòeÇÒ³À‰¦Y<&Û Wë7ïØig	:!¿.¦‘GÓ!‰ÿ˜qáœ^–óÅ.!	†­æpÒCÂ§OMÃm1 ç¶Í>àãÂT.;õ-­d!À±”Å¯âm¦%à‹–y,Ñ©µn>—²Ş˜ŠÀdõ„û€ú«È\ï’¶B¢ÍEo’î‚7éo{ådø&ımÉA¦¹¦z%ÇzKµkØ]úaP£ê¡Æßz…cğ"şäsëµÇ­­¾‚Œr„e¤ÊÜµiIS?S¶X*­@rá*Ã®°áf+‰Æ‡8db»Œ	ş0»õT2è:Âmïp\.:põwC „ËĞğ62œæÁZG¹\&å{xa p?ÍSoKİ3 eàŠS.u9NÇ¾•fü’¯o3áå½³§Ó¥Ég<\ ‘¾ĞØnMÙöKÒ¼bœÒ¢¹P™Œ½Q—Ï†¶Ûæ±à¼úÚEÚMçGÚ!ÁÃiÒ!·ç|İP0‡Ø³†¼P´-vf|†xhğí‚…¸Ëè<ÉäRGWs{¥¢8…”‚B*^@Ë3^f.7-˜6Y§xZ sı r?Uòâ®§n>(&Î/:ÃfA¨Q`%­Qñ,Ög¡}jÉFNëqşÌÔëŒ\Ç¥Êã¶½ÕíÁîO/UB 
+ñå	^?Ïæ8W¯ıÆ]ëÛ_¹4ó‰¡k™¬[a}(Îê®¤ÚB…È#/VB“0¼K¥H²1·©„ø'iv/€¨ò\@2qŞÑW)í0b¦§¼TÅÌm;§nrÙO8E‹Øğ„ÉL$ƒ]XŠšû–¦ªw¡¥"Ê8¿ºçÜ¶Şy¬¶Ôoİ¤tn£˜}êlúàè/H4‹|>c…íÛBÃ4WÊj™ß‘‚™ˆ kşË0w¢ùkëK~Å?Z«-*‹3ãü©'áåšA†îOLÎŸµƒF™’]7—¤Kfhç–¢ëvk¸7UN(xÏ©BK÷Í|w¡æ’Ä<Ö|ù :Æ>‚³SøYqcÄş?w(t¡†‚6sD]“bÚl›ÜxÒùuƒR™¢ÁLKÑ¢Ş¡$Êş1låÅÕÌ‹•gOã[¾ÿ®ÿª÷¨ş[¼G_õ{Üã}>ªDşQ¿¶B{‹¿ã¥•,{şaıùÊ³¾Î÷¸÷ã§{x¨ò?Ù~C.Òu—VtAD^‰è±²î1¿»Ûr38mÕ¤aëÃû£é@ÿĞıáÿß—zDßI÷„„éöhB¥u°å¼Ì=˜>Kóğ¬êÛ%½BAktl:oœeû©Œ;‡+%wi¼´Šï§v968€	a­úôbú®ß·«¥;½xûEI~  Ä@Ï	»nÈ~ú­l6ñõt F°mÙLwªÁX]€pàF¥’ÁåhxrhÚ{ıå¬Àï)¦	ONåŒ{cA9€s”‘Øñ¾6´ğÙ{à8Ÿ|ğwèËrŸ¨ïpRÄ‚³’{üÃK”5ÜÏ‡}Åèm¾\8rY¨³™§}7}«†¹è Wšú¯ÿnbW
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/87/6539a98a003452785cbc955edb5e13718df89f squashfs-tools-patched/.git/objects/87/6539a98a003452785cbc955edb5e13718df89f
--- squashfs-tools/.git/objects/87/6539a98a003452785cbc955edb5e13718df89f	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/87/6539a98a003452785cbc955edb5e13718df89f	2022-01-01 15:09:15.617172589 +0800
@@ -0,0 +1 @@
+xTMÚ0í9¿ÂZ.`­µ[•Jœ 4%Rw‹š]Uê™ÄVÁA³*©øï;şÂNÒ½ô–¼çÍ{ãİ¡Ú¡÷³Ï÷ï¦ÍÚTÒãİáiXÉZ¢ívök›>}yØ®£ ŒÓ‰<?4E7³öÊ}U¤«»ıM_SRPÑG—MY4’çU·ÕR4¹DÛ8®à@ÊË*ú!ôœryÿ=6Ç”gRPr¬çø{#<v} ÷¡²ã¬]%5·¢¨NTHF¡ÒÅ_7¢—Š(k¯¤œÉ±Ï@8W½MæƒÄDP:L¼Eºà—NOÆÀ§	Ô2_2^l!ñ”§ ÆŸ€3¶Ğ%v'şU-©ĞlX†¨©é	†´<êÇíJ›d÷‡°ûêÉ°!ùo§òáWJ$ì@3ÖR„Ÿ¹Á·.Å¸DŠÄ+í¶"`}ÕĞ¶ŠsÆ%6´½˜æß(i¾.õh@ßNÖšàW*}cc[-8¡Út¹	èåÆ‘TàY3€ş©[gbf´|p»¶+WƒBŞÏı:ÿÕoÛí–7^ˆ|Ï^¨Òà‰©îëÓG½ôƒ5TIêQĞšb¥]ÿø7RËŸ‚I]LïÙUİL!7Uh’…”‚í	r+ƒÀKÚAy"[($ßğ#9B~Õ"£´¶	Qt`Mj#‚:iSWLĞ\Vâ`.™úÕÄ”¦A}ƒAUKëÓAÔ‘À¬hG˜Q!úQq1°–Íy‡O‚ùŠH²#5ímóÛËÕY-=½‰0Ò:èÒğRñ/€Y³ÿns,H6ÍrAXñìâLãøYô¨™±ô@„‹ÌÅ¾Ë½ yt{ :ñæ»«ŸİhDyÁÊè~H8
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/89/df9e4385b7b8d8cf8961870b34b5c9376cee28 squashfs-tools-patched/.git/objects/89/df9e4385b7b8d8cf8961870b34b5c9376cee28
--- squashfs-tools/.git/objects/89/df9e4385b7b8d8cf8961870b34b5c9376cee28	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/89/df9e4385b7b8d8cf8961870b34b5c9376cee28	2022-01-01 15:09:15.665172591 +0800
@@ -0,0 +1,14 @@
+x­ZksÚHİ¯ğ+:ìÚğk’™‰cï’'Ô8ãI…%PT‰‘Dv&ÿ}Ï¹İ-Æ[³[ãraÔê¾}ß}Ïm§ñPıøôøÙ_÷Ëj_½J´—iå©ô×…—N‚TáT§Ë4Ó³¦R½I˜*üzj'Ó¥Å³y¢ÓTû
++}GÓ%é¬­Â£PçË‹2UÕÔÉÑÑIŸ§òù|>•Ïgòù½|ş Ÿ?òóøH>Oê$†GYxüŸn&átÎÕU¼Ot¢^ÌÍÀ?œÍ87Ÿ/,+"Å<‰Ç‰7£4A¢µJã »÷}¦–ñB¼ùaš%áp„™ò"ÿ0N¸á,öÃ`É±EäcÃl¢U¦“Yªâ@Ş\ß©7:Ò‰7U7‹á4©«p¤£Ts¹—ª9Ó	Ô6\ÊŠKòpkyP—1{YGgJ‡ Ÿ¨/:Iñ¬ŒâDU½Œ¬&*sbü-ÕÖËç6‘w%–¯ÂH¶ŸÄsˆ0Iuuª¡V‹T‹©(:P?wzoßßõTëúƒú¹Õí¶®{Î09›Äx«¿hC*œÍ§!ƒ2/Ê–Ğ	…~×î¾z‹%­—«Nïƒ‚—ŞuûöV]¾ïª–ºiu{WwW­®º¹ëŞ¼¿mÃán¡ˆOëT 6‹­|yá4u‚€%Sp7õÕÄû¢aÑ‘¿€7;'g"üã”ÅZÓ8‹˜˜o±s¦Â@EqVW÷IÉb¡U°#—¯LYWOT=õhu3õFZ5Ôí‚kOOáÜ/ã4‹£ºz×RG'ÇÇÇãÓ#DÁİmË‰“ÆIÖèa¹üW_a¤U¯{×VÇùãeëê¶­òçw­_WkLyvúÃwXF£éÂ×êÅ"‚sûÍÉÅÚÂxch™fË¹N§™—GƒQ”M‹C:I¢’~˜èhc%ã,—‚›i8,È‡V\W\”0YY{1ûì^ÇE…™à2NŠ“ÄÌÈlCO^”Ã(S³Ï!ÒD:H³%lx®Çgå2X_Œ2ä$„Q«ßÊ%_d¥R)ÍøzV.…QìğUø~„1¼g‰M2¥ıHÍÎÊß¶m±Ÿï6@É>>{úôôÙ§ÕLGw E'KµŸ?gcDÈ`i>ÂvvèK"‚éØ¦òªS$$Œá=ûò§®,Ó°(wRûöKãq4HÃëZNu4ñ0ãe“È›¨ÑÜæjÌ/—…Ï÷Ö·-©ÿnZ­õ[ÂnÌi!Ò÷+r¢ì”Û@œ«Ó“ïŸı c<œ	kÏ¼é4U)R8NŠ{ÔÀ{)ªÛÖŸ«ë»««Z¹Tz×~7hw»ï»UŠºe³Æt‚ñy¶•›Æ3òíÅ°î	‹e$ƒ5™ƒ—Aå4ÙXg¹ŠªÆ\´?Í•[›q¯ö‡‹`‹æIc‚ÂÛ`Bã WQ»êèk€ğµéçj?¥Â«)Vm86i}:S)~ùÒÈMBÉU<š Sç«ío5µ»«ì[î¾öµ#´Têu[¯ÚÕJ¢³E!ùäºT;¾ªî¤µ~TÌ§;x5~œ:héRÉ¬^ŸÅáoå?H='-µL²–¨{i¬ã~ëõëAûº×ıP¸Iª×+¨¿¹©}ÌØ¦~.¤:¡á­>Û¤İA™âÇ
+«
+Ì5‹Ğşd€ù/#Öpoğ`ß8!À€ûjßX7Ï90Şl¼‚T]Ò]§Ÿpõ7qh¦™Å ±ÍTô]ó”¢šÁÏß›§'ü$i…Úë*‚‰œ
+”lı©°áóÜ®j'­çÂÁÃÄ¹#Nd›;@Wå»šºPÇtfŒfsS|ZÍh "T•ÃıŠ˜æˆ±!,oNú½ìõöş,V=`Åÿ\|Gv<ÂØãpOış;yŒËà¯yˆX:1,â5Cgs†L9Í§l¶çêØ.\uÊ$Ú¨«]¨_5){i£“óœ‘¸2
+#ÜÅî¦1˜Úè¨°‹|¥›VH¬²3n3U]Uá5çÉX*É¡*¥"?òWL8dä±°å;ï,åğˆT,Ù0„ÁPFüƒbS½@n¤âûÁQE1A“]xk¼~eAu×I3ì¤‡;)³šP2¾~‚cÒÙd}P•å¬mD/[H7rVUE ÆFèPpv¸´Ğ0û­ö;q¢­ª¸©IÎ0ò“ªÔô©öõ{¤<ºÕúPïu§[&7Œ^ÅQFÍí‹ÿ«ò#up€yÔ:6…¶¡n†ÜF­G…pø¡ë=]	ÛVQ G×ë7ÏÕ;S/Â»X/21¥èQ¦ı'Êáiãléb>Ç¨–p0ÁKµSª%É 3¢Uu»Aÿ	ÀT¾—”9be,%Œ†ØÂBLo˜ÆS‚]7^ZØcÌj×!¾kØï&Úk"à¿öšüRÍ¼ÏÄ1ğc?J4ğ( Ÿˆ»ùùu­®bBÚû0\] ÏæBš.fPQµ°OŒ¾N*@Ûb7ãÉ–:ê%(µF²›ºiX,lĞ¯¬).Ó0?šé¯é¤_©÷#îšk¯°ÒğÒ¯Ğwûiƒ8N).â!Q“€cdi“-ú‘3æ†o)À›¸lVµ¹9ïˆÉÛy©Äg1uÈ+&;8C·fÃp¼ˆéJ.'ÊNÚ¯­°7OÅ­ˆ£±ĞˆĞÑ¡>˜xŒ1(€Wz&Ûè9¨Ük˜Dšfe~ºÙ„ÀK	65’I~~^.¸äà¶×êöª•W^XM3 JB¦È02˜ÍX
+ÕŠ‹'€·¡7Dj¨GùD£dr-R:5-tŸÕ‹)%mm"ù‚Ï·58ãÂËšâ ¢èAû—¸Wª3àÑX^¡«VBà-Âƒ#´ƒ ›–±KdÑxBlˆ¬è¹¹‘{½¯€ÑEÊ4d	IXã„b«EH°ó2°eÃ°‰Ì±Ç®‰kŞ!jÄT'ÍV5ÑØ†ÕP£Âª†ZìûI“‹Í½ÀËÀ©©.¹ˆM!t­‰¡7ú¾-áÃKrº”Êğ+Ü±™–sÒHNĞ±–º‡–„F µ/4ƒ$Ñ¯pÀ„²p¦›œt˜{KÁç	\+¥İfñªÃ00‘j°šç©Õ_±#´Y‡‘\	‹äè‡+†tL¤«ß0^€O2‰dĞ¨®*@Ä…9åÏH‹äó/†<‡,Ú‘£Õ’töÂ¬]»²q"Ã×)DQÕÍ7IgËy¹:‘wRtğF¢	SèmjàµÛAçò]Ï$’ÒˆáÎ‘nû
+>ü<DævK’JE88¶p PB(×@gPÂ?3®vÅ9ov}ÔÆ¹¼ø²AWö’4´FEÁ·ó²Œ5éàêeIeàãÈà²sÕVû¾¥&›¢57€ŒN>æ-¸u({¸¯báÜ_¥^€^Ê¡]Äğ—nıå/ÛçfuµÏUØŸì¢‹èœ²ÎrĞÕÀ‡ÛhõFy†¢0©¬Ãºß z{r0C1aÄh1ãP'’1U…$N@—\ñ ¨L“¹²Ut"ùÃqÆ¸6p×ÎÒ=:õ¨á.i•r€¿5İÕÑµıK(¯®¿¦PnüIF), Va?b".–ØbÈ›ó–oxÿ‘ãƒ´öúêÒ*Á2ÂBÇè£'ccš\WdOŞI?x"ô(rè•*›
+ª2¼@rŞñİ¼áõ€‘+}9A§
+ˆ1e6L*Å)ØÃ7œ%]=ƒ	ãré€Ä‹³…İhdiıI)E†Ô9õPÜP"³Îvú¹%û%"V-T@NGûÌâ’N”FŒG¥ab©¨ÎÀ¤.o?ãJFî$¬–`kÈ=gã›>om¦2T76å¼XU9&$Ã5ÓŒ)˜oà[¤,$`dY'Àó¯†§BrsJ»å…¯	V÷ãh8ÈliŠ·A•7(° ’ólÑ­—ñB³aGêsDRS_Š ©L¦\le1é•ë!}¦…%0ì‹#›[O,ˆÕï;u¸İC-kÂÙ‹EÖ’œ@´‘ÉÊÁ¸1{	Ü‘wæUÁjFbv"*ÜWdË:ÏâÈ„äõ	ì‹K„ ‹Y»fe¨ÛS<×S¸âDÚ*pOÂ
+…&ÜXÁ¤+İAò‚Î>Ú¦‚ïqãÒã‘ê2w©c\åUë×9@8ñõ(DKE‹jªœÛ
+(T¾XËì’§Ì¡I-ìÇƒÁ·ÖiÌ6•‡İÂ]·_£<	¤~N°Ò 44aù6nÒŞ´W¦·›‡‹"®mK£nÁ‘j¿¿"èšy8º³’”ÈóÕíFºÆé%>Œk#??lJ*U`¸+0¹½^ÜÁ$¸R…)	;mä.êÀv&}é).:á¢’b¸Ÿà½œOf#ô&Ëˆ®¿à²ëfZÍy.?¹ùl°í2‚µÄªÈ*2Lu­Ù`ÍaºT¥ª3)0¹ óÁ¹3øŞ5•íÉùP÷ëÊe‡|EÁ¸Cøˆ;Sœ<-Ùìûç²e³¨qÑí­o?4Vy8K`=ÆêZˆŠËo?ØØücY9OP6qYç}Tú|kVG’Pà¼ª¶ÒçúÜğÃÿWn£…öT1±¬WH¶º£VÍWiŒ‰+CP!unĞ«dQÏ¶q„JWˆ¨°¬'XUtíÙ÷À‡ºƒÉ‡’nsà‡{£iœ¢„òÉo•Í(·Í±UXŸÈ¡TŸé ‡Ü@îş¶b§U+‚GÂg>ƒ1Ô¾x;_[ j¯§`˜e›¿À¿	Œ€leS‡ØôäeæSv</Lç³Ñ Úyªš Z]˜®ˆªÚlhSØ¹ù»Ÿ\#xÇît¢”à2Í“f¹}³pöÒ2–-‘ƒ5Çí?ïZ·o/®ÿÕºê¼¼¼úÉÆBiíötW ¸3Ã
+)œE˜ÄYê\_¾¯J‡IzÔ‹hílxñ¨ØÆÿŒ Â—–Åwr”µÚ¥fSáZ_ZRGi5%—	h…×5ÜÄ®*2¨ş®*¯ïn®:¯Z½vE=WÓÃá˜K•³
+BKhÇÏ–Y¼Ë‡½s%EznØGÑ+¹YÖş/Zq:Á=üô'ëElDÜøË%}$
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/8a/000e4e1ebd115cb18aab0d4a60c66e71da88c9 squashfs-tools-patched/.git/objects/8a/000e4e1ebd115cb18aab0d4a60c66e71da88c9
--- squashfs-tools/.git/objects/8a/000e4e1ebd115cb18aab0d4a60c66e71da88c9	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/8a/000e4e1ebd115cb18aab0d4a60c66e71da88c9	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1,7 @@
+xíXmoÚH¾ÏüŠi#µ&¥$$m?§±BmdÌñ9xI¬ÂÙK¹\”ÿ~3»¶1pí]uºC‰Àû6oÏ>3ãÛItOkµ_à*œ°ˆ™?Mª£Ù¬T:ùh2¼î‰ 9ş½zÿšÇ<`c,ûô$]s>q1©Ş_d†æ<LDcqÌ#9Äx³R²
+¨Dø"AÈ'!gpíš½~ÇƒVÄ¿±X\FÑÄ‹ô q‹O³d>åÒc	 í‰™˜Ç\Â¯Ğ:7u0‡WM«s†KĞ’Œ!°e½Q¯f¢ã'ÂŒã(6Êe¹—M†g<+CùT*I[O¬×ãF§Ûòzct¿íO™Ò_L««rÙjú¬„§åu_Å¤o[-§mî6ØWØ²A•z^û‹é];mëKÖr™ß¢0€ÃÀ~ú§'„°ÕÃá,F,IXĞÃaenŞ t­ŞŠxœt³Èı™pCC·J¢»~,%XI,l–ÁÇFNxÕ »ßé”ñd€¼zx|áÒ@Çg#5işh¨àÏ=Ó		Y2(0ÉšªÍ4Ôl™¾´m`È¥x_SiUSàï©†¡"QÆc3–Óm:+Iûä=V ÌPÃpĞ2×À‚4’¿ ´‚—]`¹tœv_½NéRx©QkŸø€˜Zv·ï¯›v»c–+9údÑd´Û†Ãò›$*
+@äŸ=½[8J±ŠâU³Ó3áÍÈ³4`º®ã/]çÆ´‡]«kæâ­ô,R	üR†„Œ'QÛş†¬£•ì"òã#ş“`470+Ú¯ø>ÑúÅ=H9àÉvCfi³e{®âàp¼rÒ?u}™5Øñé%„Øcì«øéDãqÂÄŠœqâğ.äka\vÈÙ¢%¡#®¸•.†‹œæãì}šˆŞßš«}Õ·[åØêfæ:V‹ ÈÙ©
+ÔB•ª/•N¨P³Û—”šÑ{P³3ŠN×¤ÿ%2EÕò´¸Eá}h1«i>)dg )ñÓ‡”˜ÇÉæé8‰[Ÿ‡’Åeù²Ë#²& 6`üNÜjZ‰\:ÚúÁ)h9sA»U•·¬Irƒõzã+X¡,©(ŒŒäls²ğ’b¥¢÷.k•
+ä–¿¼rÙªR®xùA*í¬oÖ4Ä!úfñDÀ÷×9úJbDwê%U”ÿ)s”¯U.$ŠŸMşù*x%’‰~
+ë¯w5ÿ“>U»ká,µÿ-¤_@‡b}”N9`s¤öhÇŒ,Tqh¼’9@Âk©+«c[}×5m)wµ¸œ«Òúc²_¦“¥>$© ş„F±Ã6[ÖròÖg©:©ô¬&'2	ë¤¦÷«†ry¾«N5ÖıÂcÍßßËÙ{ôX£“ÖZrå6Ï4(Û7UŒAR\À1EñÿåKŒù4qï„<ˆ	Ù,áoLÂ¯nÃ;ğ§Ñœ‹˜¬B~"|ÍEuuJ†¦¡€YS­™ÀíœÜ\ªEZ_ªH<6a´œŸCícùLõFÄÀ«éÙâ+¼aÏšî¢ŸdĞ²ş¯×e80ÅÌé{›z°lFÊTàe˜RŞoiáÕ±dY6Ÿ—ıxù öz”à]1AKD?×íŞ&¼Û¢ËºhWÍGÍS¦QÃÕ™×
+™WäêbÓE@`Fí_ÛuiÏ,;Ú¤MØŸÔrdË
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/8b/c6add93286974bd7867737c8237970ffe55b75 squashfs-tools-patched/.git/objects/8b/c6add93286974bd7867737c8237970ffe55b75
--- squashfs-tools/.git/objects/8b/c6add93286974bd7867737c8237970ffe55b75	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/8b/c6add93286974bd7867737c8237970ffe55b75	2022-01-01 15:09:15.605172588 +0800
@@ -0,0 +1,2 @@
+xKÊÉOR01dpğ
+	æRPğ©ÊMtÎÏ-(J-.†rCó’a\ wB¥
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/8c/663e6d0460612a26ea59fc9b68e3d46393eba9 squashfs-tools-patched/.git/objects/8c/663e6d0460612a26ea59fc9b68e3d46393eba9
--- squashfs-tools/.git/objects/8c/663e6d0460612a26ea59fc9b68e3d46393eba9	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/8c/663e6d0460612a26ea59fc9b68e3d46393eba9	2022-01-01 15:09:15.649172590 +0800
@@ -0,0 +1,7 @@
+xåX[oÛ6Şkõ+Nl\§NÓöeNÔŠÚuìBqŸºBmª%"K­,É2ï·ïğ"‹’HÇ™;Ãô‹‡<÷ó}T&q:W/_½øéˆFÉŒD½şxì{;ºôüàu„«4!MuD“i¼œ8|ÑÍİtF²g_ï^’hÁÖ¬N§ç»W0Og4¢Ó0§i‹<ÌrÜqËïF×ã`<‹|FÓªN\Šé¤º6ã8âXG$AÖF«ûÆ…x4Øì®­Ëh’G\³Zì´oxõz0¹ömNœ†‘à½ç½A X:‹i²¼íÜ,!ñ³¯¥-)Yn4E‹8Ä q]º!şç3Y¬—îİ?Ûoß|Ş ›0¤QŒh#Œ2BX„+ù£NW0Ì-«¤éA¸Ø	cTyI¦¬,+¿ûFX}y¶œæù½ğ±?¿8ñÌƒárJdEâEÅL¥T­yp…z™`]×Õe¾üYsÁvàxpÅY§k«?ô‡¬R:ƒªÏı„ævM	´&•¸Ú…Ó¡ê­ƒŞ²€ °“€2çª/ªÂ9TT˜Îˆ¨™>|Îû·IŠ#Ëú;I#Uè@ìçpvö€#,kÊÎ£ètDÚ‡ÂF¨IÛùÏ³ß’ÃöşnĞìƒfæD° Ö–‡Â%/ËÒŒyÄq Á%ùs2O³;ˆPPÕs€b°\AFòe–ˆÈ×|…‹‡lŠY~Ş
+g2•2aÑ§OY½ÙÓÛ4(ï_ªYÉ…ãŸègæM÷ÉÎÇóåÌØıkò}I’œ†q?¹Î3Î¡E“ '¶ëmßlM×“/ÅB+T_Ë•¶CîZÑÿ–GÌC*dü$kQU‹‡¿‹¼{şë¶²õêN—Û«,Ùa±„
+šÉSG¬åŞ8Q^E9îeQ|7xë‘ÎìTp•®Y´5úeq”L|nƒò&ô®¹^}&6q‹›ŠÜ”¹§Zãİ•™X[ÛpXà3GcQ4[°ÈËËN›¨lØÇr)ë+:½
+^Ì3:ëuJ”võRÛùŠi±Or¯%¨›öo÷Ş&@ĞÅYÊ‰mpZ™6qÁ¾şÔn˜o>+úS ;M…whí„ıfİêl•P k‰õ¾6"‹; şãàèo>"òñXĞëk²‚
+Ÿt…ä°Úz%¾ÃÁ9^Å€ª÷_›<qÏĞËLØ„omìF„ÁyŞì¤Zk£œm*Şj´ÇO¤z+Ù™íI\5>pq§y˜õ§MiCÒTl/N¼¾›OÒ³-û¤à¿ƒ+UşÃ‹Š¹•Ò—Z\aîyÇl8ó´FšfÍ²È
+]VÉ³]@6•Yûá‹wé†Å’]…U1ÛÓÌ–;’¥ÅrXáJ$²JÚkdYû–Ñ6´$KdY­ØÄ–ì#Èp`]òo!í¹-Pe¹‡˜Rù@Êtè¸g*x,8óÇQfİ«G3&Käß¥K“q3[–™ø!dÙäJÁ
+SÖ(DÌúNŞşEeTQç˜â»^N¢¶›÷âc¿ÿ¦Ş˜ÊGÙ~Söï§ÿ¿ÿ:ûÑeĞğ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/8c/9bf9576305f216a76779ece7e1fe07fc43beed squashfs-tools-patched/.git/objects/8c/9bf9576305f216a76779ece7e1fe07fc43beed
--- squashfs-tools/.git/objects/8c/9bf9576305f216a76779ece7e1fe07fc43beed	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/8c/9bf9576305f216a76779ece7e1fe07fc43beed	2022-01-01 15:09:15.657172590 +0800
@@ -0,0 +1,21 @@
+xíZisÇÍWğWŒ™’2 HPQRâåÀŠd±B‘’K…Z,À÷@v„`[ÿ=ïÍµ`A*qœ©”c‡Ø™ééîé~}Ìôã¬/:û{Ïşø›İí±-^f“yÆ¥h†[b¯ó¬Åÿşc—ã(£‰8Ë¦£±ÌÅÑDøsñiPŒ‡E;ËGíéİ	&sşÍ8*Ä$ÏFyü9Ì¥E6,gA.Å<›Š0HE.QQæQZJ•"H»YNI6ˆ†s~›¦lX¥(e"ªßŸßŠïe*ó —Ó~…â,
+eZH.°;?c9ı¹Zñš<\Äë„ƒ2ÊÒC!#ÏÅ½Ìüû-’ÈrÑJ²š‹lÂ‰[ào.â |Ø¹mÌääey+±"JÕöãlÆ 	¡fP§èK1-äp«ı ñîôæÍÅíèïºWWİó›‡˜\3ŒÊ{©IEÉ$ ”™i9‡NÈÄÛWW/ß`I÷»Ó³Ó›”àõéÍù«ëkñúâJtÅe÷êæôåíY÷J\Ş^]^\¿jq­@|X¯S1±$Ë¥È2ˆâÂ
+ş'Y€»x ÆÁ½Ä‰†2ºoaO_yZq–”˜à¤2œCEš•-1Ë#H™)E.œ#Ù®²%¿7ê‘â2B)vÄõ”kŸ=Ûk‰ï²¢ÌÒ–xÛ{ûNg§ólïO-q{İµâÄ?f½YL&2o‡ Mò×ÓÉ$ËK¥‚³¿_@®d’ËB™Ê¸,'»»³Ù¬õe>&\˜%»8ì´€é„r4Afwcã·QÆÓGE9ˆ²öødáS¥£åoƒ8ê/~5R³tX;ĞùÌÏáMë¡=8éxÓğe]°f9l%Ü$ğÓiX
+®
+âQ†'üõÃ'q,~Úhü$6ñ«ó¹×Ùl	è©ó¾×é½}õ¶÷òâíåŒ°ÅÙïÙÄ—–¿®×ñ—vÖ­ÆÀZûŞŞı5Ûc`-ç>çë<_CàÅ‹n=ş®]ÎïÆÄŒüç·gg-ûäâ‹Øør¸±±»WÓ¸¤2Œ®R?ğra$DÄ´5sfQ
+Lu‡u,®ÿvÛ½~óúº§Ï¬úS­V€u=Mªn‰:ĞŞ_^½îŞİhNc¹(&2Œ†Ä%¨c‰Ó•İ.;‚Ìô7…¥Ãis<Â +×X|€Ö€0ƒGc“;kéÊs‰œ"hï¼wLÈ4	ëó‹ûå²œæiq N'Ç{¢™Nx6,"ò„ˆä#Íl	pYLÃÀE;Âã•Ş(] ˆ³QrĞ0«‰û5ıiŒ#ÓËD?`(áB!J	ÂsÑ”íQßïƒ8Pà ‘ˆO[˜‡ÿ‰ó¬”TFYXY”ÄÔB£‘-Ám™,½¤1	Š»‡wJ( lÒ…a{
+ŠOL@P7ºØ"NLsI5ãL¥BÁ4™ôÌ	6·„ã©:e^qx#YzZ$Ç$†Ñ°ôóŒLŒ´!†Q,‹yQÊ„›/xáËîƒ\lã(ïøÔ¢Fx¬áÖÀŒ?"˜d#6|a2iªy{˜¸¹óŞùÔæ–8>{[@Î%q$öõ‡ÆpP/I9L¥Øş@xëE!€sGñcº¹ub_±öÈ-:q«Ft@ÍËÁ>É|¨¨¥÷`GŸÚ)Ìáõ÷¿7Œ.‰Ù˜`õ3Ó²Ñp»‚"tVÚiœ?¾¸m•Şw‹U,ÉòEÈ~°Äª9kÆpÏ9ÿæÉ¬Ğq'´©$İô&hlsª_wØŞ
+Í@CÍ¤NÈ;âäX¤âèX¼p=¸³\ÅÎ Ì"mOÊt ¡åYG ÿóÏL7€÷D¼xÄRk˜×X‡ùRxC5?UĞÆ{P}„o‹Æ×z-{lVvdSh7KñïğÀhö!À)¯lñ±|R`é¢OàD,ÛàR<¾‚!ë„2
+0÷%’z¨
+)O<ˆˆD³‚’Ö”RŒ/D
+D+±g\„q‚$‚Áø­Š™DÒ$ò3âs©ÉB#wi6K€ÔD)+Ë(Q€M*§ÜH3¼[2©œ?Aô!]Gkš–"£ÓIÂ2É@®1‚¡QH4}$T"ëÕ;ï½…Úgl@«ÖbÏ‹Á¨§”ÎX~ÙˆÛ`p+Àb‚×E†uŞdèÇYx×+¢¥
+HPë
+A>à1i¤ËÒx.’àÊ/XŠ28©.ßªÈï»Ë^ùÍ±ØéT!Ååoø¾šÀıËşË3³è£+[2Ööñ¤¨˜¤Õ+Üc4pg¯ãÇÃaÊSE=$ÔÙEŠvÂi`Øõ²Òô>+XØhx[¸DrI—pR_ö’xğ‚ õ¸ó¢…På—Ê1‘È(§Ğ®ë»ç‘HK¿&aY³¹4ÊjÓ>¨rt•8F’ıälñœœç!7BıªLw‹˜ÂÁz¿	à)0sà’Éœ<•:˜Ò…29ÒÁ<8¼a Éúƒ§„^¦KÿwĞìFøB&ÿÒœ9¼ÏÀnÃzIâ¢ê4mÛ9äjmJ	˜á¡l°13{:tUU¨pêUcWJ9±¿B£Yíü…úˆêIÕêA–şi+N5Gª&‚Ñ‡©°¡hÑTÀKì…¨¾‘ç*ì)…Çr„h±Ó‘È”:pì£™_›¾ÜV3Î}™²Öˆùô)=İÒ:Uİì!±‰…,a©o’QÇĞö¶­Ü~YÍ¨Ù²š¹†Ùo±åêº¤¸ØÜ	wz~ı®{©y½¸¼¹n>u»U6ÊÆÒ²aÓ´U+Ä‰@Œe¯³U0kÖ¹:	úJp458èš w
+kLsD¤·ˆÛ¢‡.~”sÖ•iÆ•ói4°ÚX„N`¸X@"Î»-R ìËá¡ †f\‰¦ÊÆ©½zRC
+Ô \¢©Î…Ê@fpe¹±0FiA@a#ÕĞE’ÒÒ›ke ’Ò)`àZÈr8¾÷Y}«ÏŠË¢òÕ¾õ"LWù•İë¸Ü²#*6­^ÎQJ·tv¾Uª7ü;åAÙQÌ=L;Cù2Êet+ÑÁµì‚„; =ìR˜ ˜1…CÈŒJ­,k#¶Md`¤Nuì[3222¨Ö1ù@OÄ"TK}:õzæIÎâ|!‡& gè“ïäÑ` `{(¸Ø¤y+s2ù¹ÌİÓN9f	®èi<šš™å®x_:|ô§0]Úõ‚„ë\RÍ::lW£åÁeDV—NéªªßEŞhµlrk¦n•°Ã—ê±d³Ç
++´hZ½`Êe¦° ˜©ô,Ì¤IàMìĞBT¦•Öh D7¡š­j~2¹¦îÈ^¥„-bøBõŒ:İ){/Çı!÷Ù³a£0ËÑ×*SX‚â£€í‡ã
+nwN\Pél —ÚAÊVû]ãõCûë‡cˆÇí˜Ş9Y=-¤Ü¦¹³Z"U9P]9o™©³Õ´¬·¹S[_è7ı\w“5º@†ü5Ìë¢Rj;T&S'äc] v=¢Î;øm§t«ãÔÃJ½îNÆ™³ho7?ö”;Ö­ãÊĞ=Ë%zT~k:`¯;U‚â¶,°¦7ù´å°Š#¸8ÍÅåf‘¾Ñvã¶cÛ„%Œ‚@•@GÅ$æT#€§hş‡°ñÿ0„+-œhKv~™FéæÇ²²2¯åäù„÷jpëu|ı¯@Å/ÓPµÚºÓB]Ã=¸&ÇÃ8©úV×ÿuøÑĞqıÑ_X¾4mf®ôC¢70¸ƒBà6©´Õt†t¬/‘Tù:n~ë<¸ıU9$y-Uˆ?–+ÚKÀ\ôÛÆ':1¬šzú7 …FŸêñéX n«ğ§Äû.ÅÿàÍ—cõ-Aå˜ tÉB•3¢€\Y»E£aN©)¡ğf\“ké	;'³,¿+&|¹àhC¿õ¦ÒZŸêÂ¢ÚØA7¬ïœè\·"|µ÷¶û¾÷êıe÷üúôâ¼Yég‘}·Y‘Ã‹x>ò1’z<A^÷¾šâ¾QÈ¼Ûk¢µ$s’PRÇ´,ğ<Dÿ]äaK¸ÌmËå¿·Uàuw|H¡Jn2å(w¢~ÙÊŠFªïkº˜µr¸Ö08<é À¯¥sü+5}{Ş¶`Qm5¤ò5¤lv†³cJ`Yà xl¯z]¶%ø.š]x´¢.¤YxÙíy-1Îfx# —DA‘J]‡*yçmj2ù•5&)º+ûÆ1î7Ù,ä5¯*ïqÓÈ®Zh,K™/ºç¼¨e¹—¾¶œ ¿é^²G{ D»\-Pc¡HNu/ËS§Áú“eç0Îf²&^Ñt#¿­V¿ckŒİ/\KáåÏšØô”¤Sd”=™¸ú˜–“©:Ã|\ã¥OÏMA¨å2å«7ÖSA2à*át®öÕ÷á
+›L}ò\h•âê^ßO[Ş¹B÷ü©
+ÅÒÉÂƒ_úÑ-Œ5¡+Î\.2œƒYË±”ZB™×Sg¹ú=	¬0Í%»áu ›Jƒ"7ËÆ„¥‰LÂÉ¼©ÍÚäòŞ4Ms*–lë"ì‘·œ)²Ë¡_‹„ú1‚Ö˜&›ƒÅè™ÚÒ.·‚Õ>k°ÏF YÌ´Yï
+BØÖ€Æ~˜ 7hñ0:`nŒ.Ö1í†‹G4À½w¯†8)’¢®,±%j
+î`–E_ç,‰luK™ıûMn)ùŸÁH6ÂEär%UøXŠ…g«O	j–|,ß)‹ö&îV±×êŠµ%ÿyRxù®yv oğp¡®-¾›f©HmmŠ±É‡keµG4÷QG+Ÿì3ŠZÙk¦{ÌÑn‹!]²=l1·\ne '_èøĞ{j·¼àu™º' ~WêïÇª¬7ºíl¿TË<‰«;30Ñå½4ğØÎşüù³ç­/¢ ÖK·*‹V/X5²Ú¨Â7nŞÖ`_=$ò£K•„ÏÆQ8&°'%°¾Ä¢ˆov7èµNû~½›0ï½ş¼”€ü©¢9üm½jÂ éBï'JDí¡œÃ<b"ª€Ë—@Ö0¬Uï²İ±0Nnw"ıŠ(ÌİÓN¯ùá¥Ÿwšl€‡€å#K;¬O?•Ë&à¨Í¬®dºŒoOúaœÙŸª ÑV8l»Sz¡ùå¨Kq³ÒŒªOœâßØ™)ş'NYêßšYK_­Åæ…%·ø•Ğ™aõ7?âQçFöÕ)Z~çƒ'Œğo´Ûl„ãQ/bÍ±èğÁå?ï˜‰=
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/8d/17e0dcf80a7e2d0ab21e3999c80d9948643b66 squashfs-tools-patched/.git/objects/8d/17e0dcf80a7e2d0ab21e3999c80d9948643b66
--- squashfs-tools/.git/objects/8d/17e0dcf80a7e2d0ab21e3999c80d9948643b66	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/8d/17e0dcf80a7e2d0ab21e3999c80d9948643b66	2022-01-01 15:09:15.593172588 +0800
@@ -0,0 +1,2 @@
+xRMOÂ@õ¼¿b‚—¶´P"ÒD0&ÜH0ñHÚí6–İ¦l1`øïî' Ñh/·;3ïÍ›ÍJÁènxÓ`xœ6E¿ƒ!Š`z$,Húq<Šzqàæk^Ã"İ—|/Ñ¢ÉJŠ!çÛ”2ºİR†Ë&'ğ°5eëÎ&¹œµ4EgÓBhÏiO&9V3Îdrƒ…73'T>ú@ U”ä©HañØÀ=’+XñA§¯-—„¼½ğ)YÿÔòºˆ2ád¼ÖT«ü°f¼²¦A±¯„ş…0_Ë’cRõ3ŠiÖ˜(ñ:ŠT$9}9
+\FŞ—f“ m}£&Ëª¦7Ø%·'àÂ.ÌõÈÓ[|-'J´8OƒĞÕø¦@©4EÒY¥K}5MÍŒÓÚz­şLg*·d‹«ƒ.İzt 4)–ş¹&Ä±Û=Ú‹äâÜx')Ávv—mëZgçu¹³jröÊêîÑ·G \Ô/ûC®ÓóŸ'ø	¦søu
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/8d/25f0d5cf8fbe727c371edfa456bf1b193038b9 squashfs-tools-patched/.git/objects/8d/25f0d5cf8fbe727c371edfa456bf1b193038b9
--- squashfs-tools/.git/objects/8d/25f0d5cf8fbe727c371edfa456bf1b193038b9	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/8d/25f0d5cf8fbe727c371edfa456bf1b193038b9	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1,3 @@
+xmK‚@…[Ï¯¸ØÆXd«¢Ee‘DL­Eg®8 £Œcô ÿŞ˜-ïwÎ¹çDië[ƒ,T(Y²Ì8*‡å9!m!YZr‹j>/Nb5XÓnBŞnuÜì=w€åG•gTÕdâK¡í¹€ *ãÕ!+`Ã©!´Œj½:êRI Á~;%ïÇ}ò¥vG?k‘š&{qÕ]ê°µ
+qÃºúr•1,
+äÔ(f„é§ëÜ+PmiLíÍà+Ö˜úÃä	m—
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/8d/556fdc401a6bb82d9c1d80a63a2a76a0a66c3d squashfs-tools-patched/.git/objects/8d/556fdc401a6bb82d9c1d80a63a2a76a0a66c3d
--- squashfs-tools/.git/objects/8d/556fdc401a6bb82d9c1d80a63a2a76a0a66c3d	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/8d/556fdc401a6bb82d9c1d80a63a2a76a0a66c3d	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1,4 @@
+x­WmoÚH¾Ïş£äÃaDHBšëI›Öjx$½/•±—°ŠYS{’;õ¿wv×kv(•Î ï>;3;óÌó0šCëªÓùãâÜ^ø|i§tÁ²€ÙÌílg2ûdœâ;e¤¸„0æ‡i@àÄò˜x«óå‰a ¤“fëòÆê_ßµ­ŞåYó¦Ó=³ğmËÚlÄËI.Sép‡Î¤ßí95Ú€	_Ûé»CgöñÑµk®kÏàôpï«am´‚X¡C|5âÛ²JŸm½²Ñ?Ì¼CY	SŸ}ëtRÜGöÌ¢ïÌ0öíB­Ö1I’q=‰o—-")°mÿ Ó{à<|Ùµ)áÓH Ìš±„Ã£Ëøuê”Mé¿¤»«QÊÅ²	ãÇ‰sgü¸; _J*¾ÚW,¶Ìš;%ßRÂ8õB—©ØH½2J´T<Ğ•Ë=¨;2Ü®ÚúÊÍì¹†*‡A}¹ïø»6Åe/;¿qYáeyD³{,
+ICßRD§Õ–®´Çò“ÕÚzj+dOGæ\ĞVGîğ|¯’\Õ¾bŞŠ$kÏ'0”L@:®][2 ıà8ø‰ñ”x¶©Ld^ü*ïeÊXÊ-Ï		d©Ílqc!È~£dÊ=N>P¨³m}öò^Ä8Ùp±™áq†éªï%üÃ+'™€+-`àqÙ§Xk´6½$ÑÈkLeu‰nøÅ”/WÊ†›\Drú°Äê¨ŞqX0ğâg«õ[aVı8W˜µ¹CIÌ)ÁÈb]±öyWÆéOFc×–aÃìCì~éNÜîğAA´’-1D,Õj1;.êo£²1ÒèË
+£mâ‹_Ğq¸RL¨_ö[I´LÙfó+šÚ{‚#P<î5dµÄ|L­‰ÿ ;HUôZû&T!wJfœ…j˜|ñv,>®«:ÙÇAUì‘F¥&ñÚ¬éVñâ…éq-eMÓ¹*yZc«DÜ}T®)Ñg•ãE›:^72PßZP¯UE=Øq´^Üö&íåb/x	Ñ`³¦A{$•ÇQZUEÅ±cV¾Zˆ¿ÖYaX?Ş2}—<R%’|*@:C41¨œ!´QG;"×WâbÑ]U
+£ßOú4äXÑeŸÙO>—Q¾õSÁ›3Iú–uÜ¬ı¢ à¤©°Æ2#!ebÅG]@Mïüõ^U”wúäÒ{!b{Á¢K‚\Â\t«òñ¿«N³ˆ$xì•/){:W§E@90B‚<‚Ï|WğHçìyùÏ¢÷áäS£üÏQ~üºF´Bxº/&æùC£„ok¾ˆK§T0şŸÉ«¦Ù/]¿3éŠ˜~!>â#ÏWóUÚ‰vˆà{ÂĞÛ’¡½}Øÿ¢³7é	uİ·Õ!BUKlJ~ìSï¢ò„\3ûş4$Fav¾Œ˜Ã›kgsÕ‡¾ìgÖk³7‡É¦½éÊ¢Ç±¼8é›$~L×b"Dv©è”°€.ŒŸ_åO·
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/8e/4c4d3a9ef5c4c6f581788bf0eb08d5bf1e8152 squashfs-tools-patched/.git/objects/8e/4c4d3a9ef5c4c6f581788bf0eb08d5bf1e8152
--- squashfs-tools/.git/objects/8e/4c4d3a9ef5c4c6f581788bf0eb08d5bf1e8152	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/8e/4c4d3a9ef5c4c6f581788bf0eb08d5bf1e8152	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1,4 @@
+xµUKoÚ@îÙ¿b”^Ö¸„¨=ğ’zÉ(JÒSUÆ^ÈÂâEö:!ş{göí„F=´ìÎã›of>Ï¥šC¿÷íüS·SµÙ¼,»·I¾äS•ñ¢ñóRèÓt»‚Ï"Oe•q8¹ÓÙÅâåôñ¤yX;“İåÉ†—Û$åpíSÀ®yZ»àyğã*×ç}˜Ş"å÷É\òr0¸)ÔÜ”?×w†àä½Ò‰„ÉÖ×Õf¦ø-ÏªTäK4(†A©-ÒV Xşj„A;KóaW¹Ğ,Â>”ÈZ±{ì€Tå¥‘k† Àk¡5ñQÀáÃ,TÁ(ˆ@oç\BgC<™Œ¡‡ßq¢!åpTa¡…F3IÉO¯	|°åyvÔÒY! `.ì
+Mè!¬`è‰?¢ˆÒÓ§Ñ’Õš2AéjÃòİ£Xh*9„œy2ÆF«ğl¬'°®ÅÀÄn t;ôèB)6[=€y’A©d¥…Êñ¸t•†C¢§Õ?OèX÷å6ŠT,E15R×:]|‚d'!S.¬¿W›Íë¬’z†Óƒö [{‡ø§O!>ôê‘–º*ÑÍ]™÷1¶TKfX?4<®/¤lü%	&ÊåÑ6ˆ±E2/™Ì	hÜ¬D„!qDFm6Cè4x|×¤‹¿ly!6<G™ø¥TÏøtó1@Fÿaa;ç›hD`úšâPšuÃWBç¯İH®­…™	³µ²nìeAjŒvªøÍBÏ…ª
+5ƒäÁø½İaTÚ_—±±Ã5€Í0AñWë«)áÅ¢Â¬gÂ x~’3{;g„éü,ôÒá{×ÑˆöÓ€§x¾¤(òg{sgŸşY;ˆd[n¬—ÍÓÒÁ˜ŞzL“²£rewíwm×kîQÌb®Z-Ÿî}µè‘Gµv jß|ıĞ½}¾U"vêøÃÉæz~Iï#zxH¡Ñ½zäˆ
+J†âºß¿¼W±
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/8f/7bff21729a62c5d9f8527f1f1635d8e8cca759 squashfs-tools-patched/.git/objects/8f/7bff21729a62c5d9f8527f1f1635d8e8cca759
--- squashfs-tools/.git/objects/8f/7bff21729a62c5d9f8527f1f1635d8e8cca759	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/8f/7bff21729a62c5d9f8527f1f1635d8e8cca759	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,14 @@
+xíıOÇòıÌ_±i%tÆ±	¡$bLê–¯bòŞ«"dÙçs¸Æœéİ9%%éßŞ™İÙóÌk"Uz­ª`ïÎÌÎ÷ÌÎz8™U£Ş|¾õ¯gÏÔms«¿QonVV¾“p2Eê›^>ÚßÖ®¾kKb­V{Fÿ·§××ÓäÙşd2m%Ëyªpšd¹Š“\½5£´ÿ©]ÕP­–j|·³²'“8‰Ôp:¨nöC¯>æğ½^Uô¡QY¹[Q*òYš¨`XW»»ª~[?T««ğµ¡VáÛa½BËÍzegå3ò8NFÑXuş{q¾ß¾èŸıl¹Ò‡™ƒ/¢,on÷ğ0stá@MX}ú¤†tÄá!¡©´_µØè£n:I8Eéöv;@‹¨Äc<é_â¤—ÃúuÍì’¶*Í
+7L²hV+L&%Xõ{±~™]ß<+$ï"#‚Çã½§õ‡Ú¨Z/(	J)»ªH¡O+ÇñH»F ¼ ”ˆÀ(ªE Ã’BæUò äé´F.QşskÆÛÛÀÄaE|ñûóNïÍÑ…šCÛŞ>œÌ²+ƒ}Ş=9ı1v4»Z
+³+ìU²+ì"wûæõÎÁ š°¸†,ŒP Š²7İ$¾¡ŞDãÁl’Å×q¡hWÛØĞ•{¤mƒóGƒIĞíE¿Î¢$“®qZõô)ûoVÕVS&²ñÌ­MÚ‡È¶»†—dvÍ4ì– :ËI 0åÏĞI¥O@€ò#,‹Ú…|t“FYv–Nßáßn2ª§7æ›MÉ z‚y	âI\İô¢´Óïü{ÿ¨{°ştj¢•£¾ zúæâôğ¸s|zş³†ÕI#9ºØ	2ßLdãŞ¨”œè[†Œœ¼9:¢0lÌÆÛú¥¿GQ|i2@­‡ªH
+:âÙì·v}ŸáTªÈ'F-8RÂ’]ë)@T':8–?Ò¹€ ã§ÛÎòÀŸv{	×Mâœ‚¡/â«»a°œÀñWŠ½a°œÀö¢´ÿ¹Á÷ …ñ4E‹A1ÍÔwàOKm¼Ø‚kk¤ñ>ÖÌYÖiš4ü6¾¬9|Ş}ÉIznjçü^ã:=&Ñ ‹RÈ ô!È¯â3‚Ríã-gyÚ²Qól3’ÑqöÔ»Â
+º¹y}ï§Y”~„|¥ãAİîA!Åª
+>LãÄ}eµH[»€v0Î"ÓßÎ¦™Vkb$Ñ‹P›f²$º‹€dğAĞĞJÆbv¡[¸•´€²İìåƒ4Gš‹ :ÉHùÛU<‰Œ´,éÉÈ)(„|P¯LN)ƒqHX
+€EõTëĞûèâ‹¯)®Ö †iÙ¡GÓõ…ÿa!Ò¢ğ*5„Få=ÃPmsV†1â
+ç.ä¡ª™®ªU38¼b¹Ãã‹»¶• =V<Xµ¶ëmåÂNÁŠ±e2J‚jdÈ ´ÔŠJ²RĞ*‡WØ$)¨ªF:¦a×îkK­§$ug`ãŸĞZrÛôÖR°ÉÚÏœÿIã<ÒíêĞª’liÔNÓ¥p@-¦…Ë¥‹`Õë/ªĞƒ±ñ•Š #Õ~Â´_–Ñ¶Ié1©ÛgnªjhÚZ²¼a[$µ%h31Ğæe w°Í£é½hWgpxHœ¬ÿLLeÜb]½ L
+X‡ETƒúN£SÎı¶•µ®Ì²è“C¬ïõÛN¯<üå%~y²X‰wÆI…xkk¬±c3¢U•îêò8Áöš¬ÀÊÓ‚$Ñmn’¨éØ¯B*Ø´şjÒN–†`ËF@Ë“©àúRõi¤Œ<ÔW}iÜZ
+:"4=ø2Ê¦oYc—B`= "SHs/*° ²± 3 ‘¼‹¤•‘£E÷}ĞÑ~ˆÒœ«XüüNNæ	Ô¥p–¦ĞS¹1Â²ÈÄ"zµ—Bç*×¡lØT˜Ayy¿W¡ 1Û¨'¾H@oWPUQõ½×…–Áq¡k-TËÖBÁ5%3&½«zıÓ›>£Ğ¤²p¶Jïº5Xr.Œ6 8('¹>şk¿X Í¿Œ%ì‡‚ş³)SJp¸ÔëàåÂ-vú'§İã3ÓÑò ¤æ´Z35Ä| `Mè@wE% Fj)4·7ëªQ.|Q<IsI%ÁœªN©ŸÃÇİfM)9b`cb/IÒü:Kaa„êHm™«çChO}€Uªe¬[[Zãõ­;w°:ß[t’?t¶Ç¶Ô‰‰"D™`ºH:Cğïó ”ë´P¿N|­4 ±WæPTÌ-'"	-ÔËÆå¿NOåV+wè(eÔ{b;èûµ…nb`ÙAœÆp“›–¿Ø5„äVR¦ı?5Ds…§.İù ‹çZÈg¦IA³/PƒÓtˆâÂìZ=»«P€íía¡ZX©NVK"5‰#ÁÙMãjµã‰+nøË‹»Òœ¸Ë Å}§\\ÑÎqïÁŠgˆsêXàÏkƒ5§eïq×#²xÍÙF˜TFÿrW
+¾&fíNli&Q­p]Õ³G¿¥cÕÓ½šaÖ÷`¦tO&SœT«L»JEÒ0¤©›şš&Izeî:bîœ¹í…aÓ%ÔşjÙ†eÊ® TŒKŸqÀÜ»88î\|z íJÙ¨‡Lÿ?ƒã<ıŠ!CšæÇNÏyP’UM…ƒrÈÌãs7ô¬*üµ0«zƒç*7´ië£3†ƒ<¼ÂŠ·“6Œ¨_i‡ìÜ†ÑxN¢V£ŠºãW’¨ÖIÓiŠœíèş”°kµš êõucŠ `æo£dË	¢çˆğ¸şy&Ø,}&€—J¬¸Æ%ÊŸ	ôu¿»Ìc`§ï½P%"kµ|J,>Ó-ÀÅEbcáòy/=[¶+ÜûH¸àtëôò‡_¾ÒÜôİ›}8L¿5”ñS€'o Ïü`Ê®áó„ğœb€/Ø«‚K±ê1%ÖíyöÑ N|Ä«ƒ±ë‚W¶º8æŠP‹{pîÃÏz$j¯âÛA/ÙÁ¿?#§ôkê,Ô	z_<á'p™á$Z^…Í¥ŠË-–F§G˜`œÉq½»uß[¼ñZÓ¦éúµr±xxàïr‡¢Õdú–~K`Nã$pÃS“~¼9§Êu¼<=¦ğÑF2@ù JTîÆˆÔGÑË§~âÂ¾bÁÍ„œ
+¯·vnÍÉÎrY£[›}ı¾W-¾¥Íğ’ıw9²šw¹hI£"&„:'
+”wY™¦³ÓE²şÉ‹›ë38¿ˆYO<ùÄyÿluo«7 F*Km3¬­!Šô˜–l†˜_â„O`àÂ­¯~Dó«ÀÄÉİéjÔzgÕKñ\´—Èô_É^ñ„eìõå(ÚëËP´—‰=3ûÇ8€7VZD¯
+8zƒg¦'`]²ÓW‚T0wãeÀåbx9Öá‹IMkÆ>,—_ ğıu“¶ÈáÅxAÒ¥ë¾;¤I¾t³øç‰¿À²míwH¥oú×6pËÄ¾åïp‹ü~€Cä
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/91/ad34c2c4b749ca761cabb0eb0df74308c5ab11 squashfs-tools-patched/.git/objects/91/ad34c2c4b749ca761cabb0eb0df74308c5ab11
--- squashfs-tools/.git/objects/91/ad34c2c4b749ca761cabb0eb0df74308c5ab11	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/91/ad34c2c4b749ca761cabb0eb0df74308c5ab11	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1,4 @@
+xuÌ±
+Â0…açûº´–â$1ĞÁ¦PAÇP›[H“’+ˆïn¬³óÎw7îÅ¾Øä927Îæ‚–²µÊß ‰î­¢¥duUÕB
+~+âtæ,!‰I[úS¡3í<#‹"v4í,¾Ş€‡Ó
+¿öJW&¯¼);E‰¬Ò=¸‰|œGE†¥ëk;eï–4‹Ğo‰ğ”Ğ>ï
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/91/fbf087f2060eebcc126ad4a52bc858af44d738 squashfs-tools-patched/.git/objects/91/fbf087f2060eebcc126ad4a52bc858af44d738
--- squashfs-tools/.git/objects/91/fbf087f2060eebcc126ad4a52bc858af44d738	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/91/fbf087f2060eebcc126ad4a52bc858af44d738	2022-01-01 15:09:15.661172591 +0800
@@ -0,0 +1,35 @@
+xí\{sÇ‘¿ÁO1fŠ2@ñ%É¹Kô`Q Äˆ¯ÈØ:ÛA-±'‹Û$ñbßg¿_wÏ{);I¥**‡!wgzzú==İ{5É¯ÔãßışÉ“Ûİ\S›ª›&C•¨òI9•j”MÒò¶œ§7;J]Œ³Rá¿D³ëñäVò›Y‘–e:TMÌ§“[‚âÍÂŸôä Ÿİ˜4WÍAK=ŞÛ{¼E?ŸğÏoøçoùç¿óÏÿàŸ¿ãŸ¿§Ÿö¶~á‰xâ£oèÙù8›L²™:Î×ã´PÏgòàf;yq½³x¿¯Qá]ÌŠüºHnh7£"MU™æ“"}¦nó…$Slh˜•ó"»ZÌS•ÍU2îæ-x“³Ñ-=[L‡Xp>NÕ<-nJ•ø×§—êu:M‹d¢ÎW“l ³A:-Sš”jFË1ÈvuË3	‡ÆAæ œÌ³|úL¥ÀêCZ”ø[=f2ä…j&sBµPùŒ¶€ß­š$ÀÃŒİY²_·­¡Ê¦¼ü8Ÿac€Ä¦>‚œê*U‹2-&¼h ¾=ºxsvy¡Ú§ïÔ·ín·}zñîÏÇ9Ş¦R•İÌ&6bÉt~šĞ¦O:İƒ7˜Ò~yt|tñNa‡G§^OuU[·»G—Çí®:¿ìŸõ:¸¨‚í€å4U# »É‹TÓy’MJ³ñwàd	ì&C5N>¤àè Í> ·‚;#ÌxóË!3·&ùôš·‰Á-8ÏT6RÓ|¾¥>d3¬€4İ±rKıö÷ê"yRu>I©ÚV½Í}òdoK½ÌËy>İR'mµ÷øÑ£GÛìA.{m³Ò°ş¨Ü îîÚÚo†é(›¦ê¢{ÙQìŸ‡íã^Gí­ı&›&‹aª—óa–ïŒ÷ıG·åîüv––ÕÇå<™‡OGƒé|>J‹bƒ„ªL¯Ãa0»77É4|:Én²y´ò0+Ò)¯,GĞª‘šdÓÅ'»­~ÿå»‹Nÿ¬ûªÓUîWÿıÑë~çôÕQûT½´¿zï!vÇ3$økí7éºéH–N‡™F›~Ú>9'ÙmÉ=\7¦†ø3^¯{Q~Lfá+c<ó"|ş)™Ï£G w<êæ½Y“f¯eÓ9›àşÕ$¼oÒŸ£á–báåàkiu6§é'< ‘é§Y:˜§Ã­µ†ş÷!Ï†j“aµÖşºÖXLËìz
+Õ>s5è_İÎÓgkY¶Üò<~
+£0Ixa«?¸_ŸªŞ^¶{o{ı“ÎEûUû¢İïıWs×»ÚñêªÌş7%yoÀÏ šV^¿lÒõÆàZ-Â`Ôäñ/Ô^›*Òù¢˜ª½gkk»òÑiïÛöy¿÷æ¬{ÑkêÉ[êÍ7¼Á_8\ÎNÎ»0YWM·”üV?Œ7åÆÒŞÖ°
+ğŞö´‘‚9!»;IŠkö*É”“{YL=Œ˜$M2zÉ§š7WZÃ0•\‰£¥ÑQûJXÓ¤skµÔ_A¾Á8)ÔÕb4J‹ïe»?‚FÌ|–L"ëjş¨‡ğ\Zl¶4(¢sÌ¨€S¤Á&/úŒ# ‘´€vÀmÈæ Œa´Öö#Ú˜òşíîªƒ?½yª^¥f9ò¶<ñù–¬œM’[ÙŠğÉ)-³»ÛévÏºÍõÒc…Áa(yG-Şş0]g-ÛİeÛŞŸ&7é–Œa$=
+4?¯5~æõ˜+5 ¢0Ñ%Ú4kB ^ 
+GÁŒŸÁFpŸì	È5+ÇÿÌX+É(#h[ä§j0NïÙ6»ÒaªËJˆÀ&a…\jl °²[ImÚÇØEÔWdÊPhl¾­šãı³5lÆÿÓ3ö½&Ù˜–úa­Ñ$ûUÂ7‹¢?›øu3›‚Gıyr5I[ê¹’Ñ­ ÌÑéÙ«Æ¿·”Nj™šˆƒ¹’·˜M&²D@Ù÷ÀßÅ>Ãñ@Rœ½.ò|®ah“ÇÆ×=ÍG£2cÆÀø‡~¹˜¥…8µY¾œ@aSo;BP#ÀH‹µÆ&¼±¬Dµág°éÓÈ{I˜lzŠZzn#@´
+œ‘/*}:>`vmŒ xa0Ï‹[q`›4£?@Ø¬=Úfy{£ÿ†LvÃôC0€öèOe£<xPBƒ,ˆ•l¨¥$pB!-OP'Z–ÄlKCĞ$øŸpSv}f©ğæŒ…ãáİÈıÉÌ˜­WI™jÎ)zB¶ø¢Û>è4×c©{ªUyïÓÆdò	Fg:Tæwy¢ïë° ëò–l–q³$•*C©ñŠo{¡.N/ú'íï°ï8”¥PD!Ğ-€×{#Ï^@¯,ó3±|7|ä4æÖVVœáò)ÎS„¦átÜmHLnêÌàM6˜¬"3b[³æ¹‹	‚øEcìk	˜<'°ÇMÿ±p–q|èE!4ZÖö'*êôòø˜,`£qÒ9é‹â®K™Oä":ødŠ(A›„‡:ô"¬Ì”-’Ê ¡‡Bãm†¼×9NFƒ¼(3˜(ˆtc×ô?AÄwDg1xüGaÅ<“¤œ«éÈch¬õy•¹¨ØRcÇvØóàìª#)DQ6ÌHJ^âäL;ÍI=?¦tàÿÇù2u#9Ødr5q¾¾Êq†¤³&!*ó¯ÒAB“ a˜„÷Óü#Í^ì>„è°OÙD¦&#:ªk:rYÒXGàçH?áú˜ ø³~G,1•Ù•ëXó[³':£ò9xDé&qD]OY€8;iÒIQ"mGèà9³˜GdvpvG³9Ã'%Ñæ*Et`×`.QDœ·râb€Õtf…öoİF&Àuº¸¹•fˆĞ%—‘WB~Ú·Ã›Ô‰cîÄ	©‘IJM§‹Èˆ³Àbßéõ±<"Gí«„ğXœ9à+öO4n×ÿ[úœgı¤`~2Ñ­]¿ñ“¼õ_*AJ¿Z
+¶‹í‡ğ/ Èÿã¿*kxv]ÈÕ`nĞhˆ<ì›Æ*s9«ÌWX·Ñ j»xËÆ2äØıx¦ÕZ)&]Ê[²©£‚4Dq«à­cIËnKEÃEäU~EÎ…6ÂŒ(M4?CNã“—B…ÕÀñ€ãåd2€œÌaš- y>GêĞx<)bûEÉX:”Ñùe0ŒË¦6›&¥ÇF
+rš7É†ùYÂ_L!mİY¾€:r$´å‚
+ôj”Ã‘}$'20X#ŒüH¦p>t„![”.%³ÈïT2 Kp›kË#§IšğÙÎ:$¾ãsÿò¡(ˆ@‘ï
+¼¨Æ¡PÎŠa¼5§œxuÔíKpÿ¦ÓF©Yçâpš´Òµ½_i]–`ï1a;Ú<"ÅFşÚ.E«\¼;ïDZŞù±œ¯
+¿î°‰3ÆbtĞıhzƒV­wlä$…)˜ÔÏÙjÕèÑÄ®Ñ—ğ’õˆ²3ÖL{y~æcÕ7"23BŸ§3©·OjÂ…ãü¿ÄıË‰Fc#ªÉ@üÔRŸ”²ÒQIeUŸrÎû‹lØ4‘ÿ÷–8ÛûÌ ¼ü‘0¤×+GÒ[Ê‰.‘´Ç%Dr}ÛCNšœr;³)9L]>ã˜Ç/H)¨¤óÜö¾™L\haŸ¨Ôf‹0„„\<D“kÄ:öx½ò\ş3eÍÏƒçP5VÃgúÈóğ¡òqL¾Sò¶×´æš¨ÙkâşıÄ3¬±:¿l÷:¡>k„¡Â´"Óy¨Œ$?,¢¿x…?J6ËËŒn[ätAÇ#£HšèõÉäv÷Ğ‡f[KS8á6‘ö
+^iD¬FÆø½¬F‰ÄÓ`ÜŒK2Ûwéğ9q2IOùe%w€ &àĞbÔàó-Éäbu.˜ñ[—¸ĞÇ:c¤é$ÜÏÂ’mîã^lÎ‡ÔeBc%¦é3BS*ÆbÓí¼^&5,Â†Û5ì5¿Ø1
+˜û£Ó?·^õ»í×ê´ãÆzjfPÊ‚Mğ†%f÷Æ˜:ü'å¼ï·rK8âî0¹üÃ
+x$» İßgŒüµ'ùu~õG	qŠ¯"à+Î¢–’Ñ¤@vAŸÜõö%ejh`hf¤M3DDE,‹·ia Œ_.(Â’Np‘ÙŞÕK1€™?ÓÙÚèìNÔ26GcmÄĞáehßWéÛ¬iÁšÑeÓ!Å	 x$ ŒgÓK¡µÔÃ‡¢‚ä2ìw×ÈÚÈ~ñ;ì:Ë§Ó_ğ‡§»,á[şËã³ƒ·2Ûñ¨ò}&îed„×xCÿØhÓƒ*Ò}.tˆ:%MSoQ°¨˜<¢,x£‘ÅiJvŠ²ŒRi™esÆv¼á¸lx`'éÍÈ8¤sµìöÅ~j„hmOVJoá
+)„÷ôÛÏüÆı˜ìÙ
+ã>‰í¨l“áRöÒÙ9oOüöojİ+h}¹Ö†ZÃô¢O0_şeß÷µç×Ìç/µï¸BBØ‰“¦I‚h£^±÷“	,¾–rw;†Ø"R7ò/s?/4¹şeîa ş©Íı¯jê{ïNNßŠµ¯:‚àu}¤3”Ü¼¯ö	ÕáxİÔ_ËfÌï`¶›îÖÏ…0H¶ê ‚mJŸOk~NæØ¬À‰¡Ş¬”b‹Ì%¤&‚Ğ?§ÕÅ˜Ÿ;ÔÅ¾ëB@¬ï‹Ûo¯zÀppÙ¦4ÃşöhbDA»T$Ö$®–KmúEç¦\Öì³gÇxê—	*1Ÿ¶•,¢‹/ì²Î‡ÙG~º
+a6W“\-¹0 ·¢zÍı„M¾ÏçÔ¯¨ĞöBL-gñí²g²Ì¶³¹Æ%,«äÆšÎì³Ü«@ù2öUYWÍLşóò®J¤ÚãœeñN&…r²Ó&°^ p‹K„Ÿ10”ÖbáµÜº@ÒV'òjO`,éuŠõªó;ô>`4´6xÈ]a³ùèKícQÕY•í1İè˜UêšŠd/ß¾êüÙ8éøíÁT·Ú·Æ^×fM©šEü™Ÿ›ÿ±«ymÄ]eÌ}¬C¼~`â¯Ş÷ñ=6>ùGï¼Š@°õˆá‡G‡g†İ+šÍ¿C])Ó=8ZA`Õ¶ï¼/4füƒ7VÅ`ÕÎzHRu.şî,sÅf3–İcgU’Iôñ[^o^¾hkU¦©:’Ådş”¬´®À½œRõÍTe¹•Ùà—¸î+sQSwıxñ>¤—nzgèq˜šë\4~B2˜®ˆ(Ş’©-TøÊú%×|¢b+¬x\UC×ÀRÏ¨½Ä6ô&b\ŸzĞÍ%]@¡Õ…Kö±'Ì¹ØËÜLM¦9ïéßİyhp¯ˆ”ÊjooªéPå´IµIR;jËUã˜ ¦²Tª Kt&Rn ¸õH[˜ªF`åW”[OTjı¨ú}j„àş«~_5›É„[èsy7€Ö»hw/âÛP{ëè!Ş¢¼,%‰08äR­Î‡{’8Öl9àú0ôÛPóYC1ÎL¡óMm”V®ôöĞğõÛ‚Úˆœ¤P”÷—_üDâI¸ˆJ%yÿ†j[ñ²Óf}\UIÃåy§+ùu¾fa'’	/û7É5:ĞüTúIûõÑ½šÇùgc×§EØ hbœ£ş›=u•]o#Ë‡N+L	ÔğÅ3ÔCgş¤C
+ûÄ8./f34’hõğÈÅõ´úË)ÿKHO…”ljÈ+x`kÜOÚBûÚu‚0­k:ïJSØä(ûßàwÈš÷ÓOúºLB8W )Ã2—!Öğˆ =Wßø9´Hähì‰éÆpfÉIÛa‰j&ı0EİYF,œÀLÓ“¨:ÓrMçT‡Ê|ŠEî¤Ä\âYßxë³IËH@¦è‘jÌ—:$ÊØ¾÷'½e]Ñ †çuá]¡ÚÓ”v%º]ÒKM‹7lDÉDûÈl7Òn‹eHİI‚ŒÉ%«ÎÉ)ªˆ¢‡¸w›äùûÅ‡3i³EjP„æ¦iÃõ=ÚŞ·Ì	X… (@+a²À88ÔÀ!
+Ê$Y÷ÔÆ[^ê>TŸ…BY˜ÆdZ¤!Œ¦îò©±mºÆÛZÙ\G™ùújÓ§kZµÿÕwÎ¦¸²¼áÖYÜ^å7È1”ï]‘Ï3;†•è{ËF0ÒDK½ÀziRk3Jr¤–m–”(ú¥B?ªg6ü ¿Ğtá?Ñ Ü¢RYx¨ +Ò¯©ô®f¼[
+íÜ
+¼&¸‚Pm¹Tôƒ[½*ÔİAÓ{Xâ¢ú–k~
+àÂóN¯B7Cn)–1„ a<Ğ¿9äéÈ£µgš
+¨³FQt±]dÃa:m¹=X
+õqT$ƒyß@&Û4)s*¶æH}!VC‰-¯ƒªA.££”zhÛ±`Sœ³ôî±®hà$öÊ‘:ù¬JScút;İ?;Ç-º¨Óh’\—-Q¨p Äî]¥Ş”;hZ[\„ÏÅğRÊÈN—â=ÛFÖ$IKXGp-BC>ñ›Æ~º-Å±àœÍ·aäì :ËƒØÃp¼õcéÖ:¡oŸk3Àq ä´ÑÑÑ’4ÔÙhÇ±ßtÂ-ÕƒrÆì˜›©!a¸'+AØ ’1úïÎÑáÙ~yÜ	x~Ôut˜!
+á‚ğu¾r±ˆYù‡¹ÙÉ‹­„zLCgøÜø#º½”¶ÁÒ¤Ä:>b—§^§yBi$SAŒÈíxEP¤;C§ÛÊîëaêr…{âO5N'*Kñjù¾£àşk|×¾¸èŞuxÚšÓ‰,[ Y¼ èlùf(ü©ãH{ò1¹-·!Û¦íüia”v5U)hÛ~×[±$/ÇëFB°À—(5T,ÒXcÓbjåÿÕåùñÑA›«.¥6†m±fè€9ø.¾…k¨´„ËHä… œ5İØy<RoÅ\6ùş£¥—ÒˆN}Öº]õhï1&òâÑü
+Zµ«šò>@~ájW§3/©%–«tn¥,.$ï©íqİã¼–p£(Ëæ!8%3L’gKg£áÓ_IÃM)s¡H¢B+êè#ºéMUT@Ø»£Z0 ¨l²vX˜)‹^‚Œn—”·•É†¼µˆèıÔ© ÒÑ2ÛózLª#*@øë ú*lêÆ +l|€·Ùò ÈYøGI$|t*ˆzù$c/‘u
+E‚§OáØ`“0œP¡VIjUÉY¹[S)M3egô;é`<u“ºFúçìı!SÒÒ\—=ÑÅkşbDs¶(ÇŞ|n¦i5eC€c¶ÄâIõqÒ®‹+ùãU€†w»;}ı¬¡_Óµ@“dU\ÑXxÚ>éô;§tô#d{Ej©†ˆb\ÌâTfZ¼ívì¢(±×Q°øI“¹eY$p„õ^Ÿ°©Ã’@ò•- EÅv˜¹B7±E·’WK.¹ë=#HÔløL!Ğ’›¬ZF°¬#’-{•^X¼Aâö÷±S‰æÿ5-ÂQT‚L:ƒˆ¹²«’:¤‰XÈ$+:Ay¶_ ÑİŸnÖE¡³×"Á5ÙK|*Ÿ±†×È®VÇ§ÆÓ‘‰•Ä6Rrâã#éº Ï°ğ(lSğ†Imy?®Ù8M bK;såŠWÔÃƒ‰åÜ	1Èõÿ®9qpÙÎ—é¡“~j!’mæc	á+nNÒf\|(À‘·îZn–‰NH•î+—çV$€4f[ÆÚ/İÛ¡	•áùÒŞ5¶`Œ( èßÇ;¬d@ˆ&ÆW„¢Kg;_éÆüUí#Ô9âÍĞ»g_®±²¨0=e«®Fœ”E;ìèímQ: Nï¾«è%á/¼‹c(«5nÒ›Áì–¡˜Ï˜ĞDßÆˆ$ElO"Õ¤ky-š “©£
+¿š×?‚ì_ÿ°÷5ZJmr7¤‚v]ôLSûæ®tZ]Úøô´ÒªÃ³4æÁ±_Š#
+µ½o¼¦`H9:A¾ÎÙùä` VOŞò„«˜µ±{İÍÈu¡îaæ–WMC‰îä…AÒ¡eyR”() £PBj>Hµ0UÇ6€­pBXË|í%”ˆ(Ò¡8Dî™LÀe£œ8à$ŸA‰9ìåWd Îö¬<zn¸İÀœ]í|)Oû^O¦ï2B»’4¬qàí YïÎ{0èk0ÈŠp€ê@Ø™¦:Ğ Áà¹·K]dkØŒJÿ³WrâÔàkh ¿V#ÜÒøSèEE:‚…Îá„7^‘W@ÎE¢ h\ƒñ «rQìÌFYqB‡Pw£epïA€§F—É¶Æm‰^SŠæ W»D1N‘d9c{C×/z,¾N-ıï)¾O¿[âVgUğÚ±Èà+g×øÊSÅKóZèm1™Bƒ1©Ñt
+&ÁqKYIw;°Ş\‚%ÇMÆ±Ã±Ü‘Xd5õœL”o¡àC;‚£A2FÁá'o™5I³ŸÏ%0?·¦¶¿ñÒÂ¦‹·îİ²šUQ2fF‡Ò&Åi¹«oH¹]ÊØœ‘­.WDÊ×O®´jã4ŸCYHN`Bğõ¯e£t5¡Òª;G‡«×;ÌıN:ËŸÄ2˜‰u$ñ}×		¦înÁŞØzÚó³>ÉlÚ¬ÕÖ–ÃUoMZ,0)’Ø4àn”Ì³¢vâÑ)jø¨ıWQ~ÅYfQÁµ ’!HKj›©!ÒSâ‰™LCˆYŞS‹	èº§&^úÄƒ wC*"­±ãt‡íy8B×`¦¶xárpPï*ƒ¾Ğ?„kIR„¶b$äÌÆÒŒ“åşÃLÿE^$¢ŠïL¨¡¸Î“„ûƒäD|áú§ô/uqîkXƒâ®wÓò¼Á@óô.¾‡ĞÊÈ9É×|&Ä.á®È€«GD;¢U¾°Vºc„îá£bâR¬`Œ ·¾ë«¸¨¿62¶ÑÖj«vgV¨å÷ Í»A[â|l»İX³EÎ~2ô~ÎÅœzåle>
+èÃ³E?¬ÄÕÇggo/Ï{ÃĞVy3‡‰q“œÿˆ;3ãÙ<;í#¬óÅ~ñ“é7Fñ2å"^¥ ³ãş–µ…Ôõwş‚şwÜ¢,×êßRcĞ}"Õ‘÷BºÆĞ¥(¿Ì|W©v~|vúºO?îr0ŞİÛ~ñqÀgèßùPP#8(&kr¿óA•…«­5ÛÌu{^¨Úïa¡™ó¡9´öB±ê‰Åa@›o|ÙÑ¡šËLsls=)¬cÎÖÅ¶×Y'‰Zí‰Y_pæS¾Lò*Ÿ]äÉÚ[†Ja™xóÍhÇòø°}®ys“¾e×$øŠ—}4°‰2ñ¼‚{áO³QáT›+„p`p}“6[önà¥²$†}£*şĞ¬[Â»Ë "Œ$Cå\-Y:`í¾+/ÿ¬…°üK°ş÷Ó+ßÖ¨Ğ"ÁXÇ[	FXT ¹Ëo:õÓÍ›á“ÕSı¹`@ûE—s˜Ïã$Í¸cŒ`…C„Vv`î›èTZºØ“>î;¥bA€–Êƒ"JîÆÒg5ÍÈtÍh_ùÃœúÎŒ­°g$ø»ĞÇoõÉÖÍ"g7Ié^iQ/`Ò"Hg‡‡½ÎÅ½€±=åÅ¨L)¤¿¹GeÂÄmšô¨â]I"
+¡ãª¹Óîá«Ü_PÓö°³CEWØ)4hÔ¤¯Wñ¹ş>?ú-©¨Ç>ùFÇ~4£kñRm‡iñAás`„ï~€äª¾\
+Îål;CLGuæ¹Ê…û“H.îé8ra¬~OúSıh¦¸ÜQñFÌÿ[;Şxà	ËB—nûƒ/Jš¯lC:]‰š»»×_¸Ñ–Ô3¢Î~K²ózˆë:¦îÛÙ6!¦‰Æ$¡ÜbEÂŞfŞ%$2Ş•2~½}àŒaÉt£ÈKÁ9ĞEVM°ÌúNÙ|ŒhÕ³ˆ¾iÓ‘QÅsMØ…¬çşı_ÙçWDwk¼ÑâCãÖsİÓmõ$"«è»$ÿE<É÷"ÁRşšäfÀÛPj>Ï¸Š<ü®TàÁ÷'O»7xV…05…Ö“=«ÙÈm7Ç|‘ xt³ßÚvBÖÁ»aDÍõå;dJiRİ…%©%YmÀ®n¡JäZ¨É­¶o›Äñn›B‚QH¾öòô˜ç˜u£á.Ï~Ûµİòçpºê·\ˆ‰A×ıèØ,kÍĞªR–	9òš¯»%|/@·®L–
+…ijkƒèf³ûŞ&¦Ñrâp¾=ÂÀeêï‰tÑƒÕÈgçşZ$tG“Z¹3Ë¾ø#·kïH´’Šº²ÁNg	ø€_KZâ‰Ş*TH,iúu{òL¨Dğ½ÇVçİÖ¬şú—«“)ß¨E¥RJÛƒ–ùú+öÃñŸç€Ğ­^ÖÉGGÆ:rÈuÙ$o[ÑC­8Äme­º¥–­¤B^öçµÿ±†ë¿
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/92/6025544b73b83df2a55cbceb4c6eefbdf93b96 squashfs-tools-patched/.git/objects/92/6025544b73b83df2a55cbceb4c6eefbdf93b96
--- squashfs-tools/.git/objects/92/6025544b73b83df2a55cbceb4c6eefbdf93b96	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/92/6025544b73b83df2a55cbceb4c6eefbdf93b96	2022-01-01 15:09:15.669172591 +0800
@@ -0,0 +1,7 @@
+xíWYoÛFî+õ+&öC%CñY§‡Û¢t"ÇBI©Æ.
++r)nMqÙİ¥b5ÈïÌ’¢îèsƒĞóÍ7÷z’Ê	\½º¼şêXÄYÄcxp}Ü7q!2^¯ÏNp¯g†ıWÁtkˆEÊõB>;ğ¡ÿ$bš¤å,W\kJF ³tA8kR¸´È2_(2Ğ[py~qŞ¦ï¥ı^Ùï7to˜ˆ49ôd1M¸‚órã—%£S©¦§ÅÓÏ®¥”+9UlFÔbÅ9h›LñXÈB–!»Hh£Ä¤@ó„–EgR‘Â™ŒD¼ ½¤À$W32¶‹·ı1¼åW,…a1IE=òLsgrÚÔ	ú`²°wÄÁ«8ÀD`f„Ìn€„W0çJã.Û!4™!ª
+dN[Èo)†¢¾{zÀŞ•YˆÌªOd&$‰F}DwÂ„C¡y\¤Vú >tıûÁØ·ÿÜÑÈíû7xÙ$Oùœ—Pb–§Cg*–™ú„¿ïŒ^ß£ˆ{ÛíuıG²à®ë÷;wƒ¸0tG~÷õ¸ç`8^³ÇC¯ ùpØ§#ØL*7L¤ziø#FR#»4‚„Í9F4äbÜfaNÌ¬ñ‡‘I/Ke6µfâeÌ–*qn@ÄIÓ†J`‚i±6âHâ«P¶áú{ğ9º‡Ã0e!‡—à${u…™}+µ‘YŞ»p~yqqñòâêüÛ6Œ=wiÎ33F&ˆzÖØ*ÆßÜŞ¸=Çñ~»Şı”e[ŸlIG»îCğŞõŞm‹¬Ôxİß;s7­‡èÓj4Î°<Ø³˜3 Sò±ås–!f:
+m™e"K±©DdÔfƒéö{İ~>€sqù…¶•ÆÔ”›+Ud2â_ëJQÆfü‡RÖ˜Á,êÆ˜ÖşriÈ6Å+Û%·ä¥‹0Ä6…ù‚M‹2-±L	¨ÈŒH©VfœÂÃ(ií˜á»£·ŸÌp^]__½Z¹´[Å¨ÉZÓdğâ'¨ƒ×ícàºoÊ ¢[±¡)Ùd|j8aÂ”ã8'dñÍj‰E›ÕÈŞ Hà…r1¯Vs)"’¶®ªOÍ"§«uHGÊ4XŞ)2-¦-,+…Èó0áá“.f(²C¡3şlnŸoj¢"Oû=÷m¦Xój>vKo.`¥¯B$7l+Ã9‹çuO•;5Zi,ÑCQ®(“Lmã6<(U7q¯;dá¤…b8"WÒ‡ƒ‘¿‰eöÁ,S ‹œ«`’ÊğÉ®Ñ á¸”¥P­Ÿ×Ñ)›Ïò2ª ¬€Æwà°Á†¹{Z˜<Q†c²0\cµHÃÒR °[›Êl,›”—pÒÆ*©²ÁVÜyÍ¸ VràLzÚğô¿¹hO@°+TlÈÖµ›ÖA4ø+‰=pK‰câÜÖçqˆ Ôª<Y-ÄQ%û¹ëÛô©Õø„e7é÷ËŸKÿŠ(0l’ò U(³·ÜöŞµ(8WhÊ|w¨6=ĞLÀV¶ö~z.®ñI†'¡ s„©–cÍbíâ+ÂN²å“›W½İşÈ0P£¸)°Îñ÷g°ö×{;-
+Éa‰7¨Ä·]´æf™Ã‘PÇl ?TJv íàÚy(í¿v€İn È®öÚv±¾¹[93	µâÍb(+‹œ°«ò‹åñ–meÙºİh ¶<âÛ:¹ùÏõ4ì{=Jºcáëş@kßè÷o:wî¸ç×Ï–şàa0ôÏÕ[Ë8‚&
+V¤¦u´:µÿX!œ£Zê2ËĞ
+ê€ä¢êbiÁC$}Ø9—Íb/Û5ÖWÿ *,¯.
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/93/26372a140c5548ae78925e400ab2b633adb387 squashfs-tools-patched/.git/objects/93/26372a140c5548ae78925e400ab2b633adb387
--- squashfs-tools/.git/objects/93/26372a140c5548ae78925e400ab2b633adb387	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/93/26372a140c5548ae78925e400ab2b633adb387	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1,6 @@
+xÅU]oÚ0İs~…U^’
+ÁÕRí…tXƒ50´§(³Z6Ã¦¨­ºß¾k;!	j·=LB"¹¾Ÿçã,3¾D½÷ı«wİ.º¡‰ä$Ñ¹³¬]³”¬Qßà±ÍnıÁ$ŠGVŒ”‘†]hÿú=xc«lŸtÑétá· ,åÑUUpØ¹»°Z$¤áçñÍ†³®WYJ×ª£JJlZÕ‰ªv(•§˜<Âƒ:·VY"ò0+Gt‘…Ğv¿Ìè
+aÌL²vÅf,Ÿ‰Œè©x“Ç9»güÀğfk=[&‡‘õù
+ò‘]7Puá‡®›w¡Ñ¾VQğö^óÓ  ú¶ƒ_ ËİÉ}’¡Ÿµ!Í)/9ÏP¸%ÌO½ì­¡£ ÙG÷PÛœÄ¬~`/ú§Í$ï®e bò-_‚pÄx2íÙ%Ê(ß]®cw4NüÙ(Ú·$IûÓ]¦‰LÚh™ì÷P‹(^.·;¾"BTíGOQ¦ˆ¹wlˆúx…øz-ˆ<Æ	8
+wô;eÆ—Œ¦\PI9ƒDµfŠmÕƒòUM€Óø¢	/<¿ Z$Ó³\‹È=a’&ÙoXw\ ÏÑ ı#qÀâ‚}+¦Ù8ø:ãal"bx™ûk˜a[Í`@ŸšT¦£„¥  Œq0ÏòÎ5‚‰Owª *‰×ìE3³ÜÊ_.
+¤Êuîå!ÃICÉç1}£`órGàÏ*¶é˜‹¢©Öz!^­N.^Iúlí®ôé ;$â$[¦­‰ölÚ#uMÖ•üÁÆG˜O¤»ØQI{Å™†eÿEÁÕÛ$2xq€ÔóûâU×VUû\”>ñ¦DÇ†zjn”òù7p+*ÊÕô`a|A
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/96/26b03e124627ac5a9a4179528dccf4006d5bd2 squashfs-tools-patched/.git/objects/96/26b03e124627ac5a9a4179528dccf4006d5bd2
--- squashfs-tools/.git/objects/96/26b03e124627ac5a9a4179528dccf4006d5bd2	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/96/26b03e124627ac5a9a4179528dccf4006d5bd2	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1,4 @@
+xíXmoê6Şg~Åi¶íÕi¡£½hL‚$0ty¡ëZMŠLb ·!œ¤¥ıõ;v	…B›MÚ>\©UOlŸç<>>~lwê±)üR«\ÿğ#ô]›³Í"Ğé#õX@9˜Qì¸Fœ}£vm×£ğ3È’6”«í±ÈœÂğÉ§¼ñëåo¥ƒHŠÃHDhÅ®çHÄÏĞf|I"øƒòĞe>ÔÊççóéèC'`èİ	~–°qÒw&w#”[×¯Vàtu];ù!CnÍ ğ\›Dˆ¢Àùêüâ¼Z*iíNãê¹&:ÆóÒIß0ÍfÇ€ÉÂ|Gâ¹,Éá\Ë0a0•D#1,Hó‡®?‡A¿ùÕøœ!Å!…hAÁXŒGĞOAÀfË%ñ¿<ö3‡Ì’P Î ³ZÆèJ9ëË¬;ƒM|j»³g¤k3æÎcÌ¨ÈÛÓ‚ú"‚¿a—ùNŸÁÁ9É.ArIpµSè(Ö,=×ÇyãŠ ]‘eàÑz’Y;„”¨‰í4+™GfXºS\-{Á\›†0Ã`Û3!|Ø|€1õ(	©§Süãˆy­‰³ŒEJ–DQ Q•-:wıõ6ÁïÑx8‚¦ç±§åXœ¸H:¨ïPßvqÆ¢¼åÓ¶-±»Ä–EÉ7÷˜M¼‰¢]¶W¦+Z›ZƒÛÒ,tÛ ÊO§˜ü3Q?›X'H”ÁZMÓ€›Zı¶–QØ´Ê,X=wÊ	ß")Gã(ˆ#Kw9(ä<p×(_RÇÅí}`Ø„ğ9Mq6óİ!%ŞäsˆÊqİ¹Ï8µ’]*¦›¥â5·¦®ƒœ<¦TŸylÎ@½­‚ÚùÔaTk®;¨Vit£uÓIlKÌaÏH¿ú-ÍDóıÚ:¨6®‰@ßîcÇ+ğ<b.Ğ~ğv3Ü ùcÍ€ê¡"^^|Õ%ÅMY¼Ùİ2µj¥1m¡ˆ²äÚTv®Ó’"m·õºƒ¯è’òğÚ9é‚Ê}êU+e×”§æÜqSëÉõÃ€1O@‘r¼yÚCœG¬‡…ê­qğ$H‡ Eâ(ıˆc×‘(Ì™ÚëhÚAúñ¿"³)·0†ÏaD—uÔHyÊ©(Ş”éz·z]Kÿ=ŸG÷½ù•ÅQ}-qêÕ‹N¥ØâæeATq~¹Æ¬›7­É¸©M M½8ÓºÏ|Z*=Ó8$ÍÉST˜/0z&èy5Lqóİ»‚¸gĞká“èïå—·icğïò2åû.
+³óZ˜­wsçşq¾½Ä »AòÈGOË¼·š½ŞPKÓƒC´†Vw0±j—V3wPäùì—ò”Aª;R¾îş.åâˆùOÎ•CÒãˆ×l):%‰Zi}×÷änpìğşp’¥ÌK-Üù­Ü£’tòìŸ(¥øN®ìûîÛ{ú6š›¼:œÅ(¾ñ¥º9t:#±YøÎÆ»tòHLs›Êçr©doÆšÑ(—ÿÂŸ«—V<+‹û¤ïËü¸õ³$ß¶ÏwQĞWÃWHÑ¸Â·h\ñ_ˆÂ¥sÑÈfÄ)YŒİ²¿Uş‰k1Ò-N
+&=¯k	÷^–DÜ›Š•ÇÚ»ØŒ'¨œás[Dî=,ù7•x¼à¿ñü0wôÄŒ1§@ig®E¢«ˆ;úøZaØµo‘¸¿SâP^(lêZ$j×/İ
+EÃg[±xÂ±HÄ>qßš¡(şôøJ‹ôßº¥¿¹µ¬ˆ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/97/7384042730d11c6271abbe480d9ca733f25340 squashfs-tools-patched/.git/objects/97/7384042730d11c6271abbe480d9ca733f25340
--- squashfs-tools/.git/objects/97/7384042730d11c6271abbe480d9ca733f25340	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/97/7384042730d11c6271abbe480d9ca733f25340	2022-01-01 15:09:15.609172588 +0800
@@ -0,0 +1,3 @@
+xSMoÚ@íÙ¿â)•¢µã4(uåÚ‡|´Ê­‡¦—ŠDØ^Ò¥–AÆX!Qş{gv7`CIÊì™yófoÒb"ŸßyøôxQe2xgó^•Y±Ê%Lô÷År9U¥Ä*û>/Öè=\]‡á ßsœ›ë²ôqGÉ“´¿úGãÈqš¹Êq]ªú%!\çÉ,@Eô<W
+1z¾€ ôprâRk7ÕÕh Ê3[øÌÀg#Ì˜³j
+Qá]Í1îCÁ$áèíf#ÓÅRrY$1SĞZR©SÅágçÙ.K‹ò¾ÂnèeUæâ	üË3>|µŸˆ0¶† ßd}©îårWÉzU•~Û…cËx³È'µ<_×²Íëƒ#Häv‚ÖøBpŞzFV"Ó—~eqB7joe8xä`Ôe114†‡¶iCkû0<õ¦EcH±úû¬ä9ËÊ†ĞŞØuÓpã¥7¹EÊuM0îO0¾9²ãæW`jvK““we„íN‘ÍËe}h¹`âc©å]­:×Öù¿æ¶¥ıá-øÚ—ûp•3Ò óxzêcñrbÜôj\6”·Ğ²ÿ,w´.l´µ¶ş¿˜Ùª Û+øÿ¥ì>$ª>»cz×"RÀªÅ![itÚŞUmOÏbé’ÙM”ú)+5]w3×gê[_•İrê´»_kÄ1LSí»¿`¬–	
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/98/4fddc1ab6dcdba5e94566e6c79e7fc6554fd78 squashfs-tools-patched/.git/objects/98/4fddc1ab6dcdba5e94566e6c79e7fc6554fd78
--- squashfs-tools/.git/objects/98/4fddc1ab6dcdba5e94566e6c79e7fc6554fd78	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/98/4fddc1ab6dcdba5e94566e6c79e7fc6554fd78	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1,5 @@
+xÕXIoÛFîÕü¯	`’Û)Z’ Q–êà8HÔ\C ©QLG"rd×œßŞ·Ì3¤,§Ams¨8óöm¾ç‹E~¿şöû/?À(_.óìà“Jt^<½‚Çé<›©9L§£Ó““ÓwÓO¯G“ÓÓ?‚ÇxœfjË2eÉb=Sğè•š—O/A²ˆËF/ãR}PI^ÌDE°	 ®ót'ùµkµ,Ã4Ó0S¥£â¿z@Ÿe‘ğW4VE®Ñ:5ë{t5MâUœ¤úv€’ø LÿVƒ`¥v¦)É¤;:"=|dCóA•ª¸V§™zŸ—©Nó,D=Æ¬q†—ïÈ66-%³j‚‰µôE6åE¶½[;”âÀ~¶^FäY©Q2ÀÒ9 8]ÀKxS²0â¡|ÀôIpÁj}±H“>²·¢ß¬kQÑUpÂÃ¨'2åG¥şIñ+nØÜahÒB¯ã|mkcç)ÔÌfÜB—
+¥×E&jĞä`ï"Ï0._/Wú6lÑ…ì0‡p19gÌdƒC©›‘É.ê¬LbºWj¡4fpŒ$ÎÉ!15UÕh¡âÂI§p½)r'Cu.åöeœ|!–»A`ÒW‹X+8–<·•ìVq$9íÌ`};ysyÂ¨ß,å1Ÿ‡“(Ú vÌ´ÇÁåãŸÁşµIö.a˜›¾LKÍõ óâ‰İ‡|¥Šû}Ş£-ÙpE9á›îPDwQ6Gò®iw­ û°Ê'EL}*õE °uaj®ËT¬`RÈu8€ùu»s¼˜ÍÂë³ôÜ°˜ZeÛIF…TÕ¨ˆOœ¾o> „HÛ‰dÄDg\Îçh±‹ÑnGt»F—¯Ì·|›j›“ÇN¦Z®~W-% Gù¤o•~Ÿ£[
+[@†Oİ¥áÄZN½Ç¶)úÖf3ó¸<¥\&u‚ÏÎkÚ½h‰ÙÜ÷÷
+¨FŠh‡µ² [:Óms­Kh˜ Ôf‰i›µ÷*Ñ2šñsd=¡±Ã¡D†g»ŸcÏññ&^Iôd”]Õ8šCXYÒÔ²wä“\µI®"$!aR‹•î¼Ğ¬{¡æZÔéçKÍ& RáÓŠïŸá£DTØcÏloI¥äÙ2]D ƒĞP§!Ğh‘È!61½ˆ8Îí1723{L–ø^»!‰‘µ€íévI:fpŒ¤{JQÓ[§dmzÆ	ŸÍñEXKéÇaÏ¼‹X\’İ{",Á;I¾\Å…ŠÌtz¶ñKèà.?0–ùô_Lñ$Ü÷rÔ÷›sÔq+éğGä‹"ÆA´‚MArVıüm%½Zíğ=y¡œl@2ãD[+“İ	Ò¸])ÚŞÛ|ŒığFãL\z+Ù:+ÓÏ™š Fú?d d†„/ñß(9¹Œâ¸Õj7‡Ô(’š§ÇRïÀR§W›…°ÆR¿¤\†Ğ`¥¯#ÿ“`á
+·¡mË‚êØ!Y'÷_-O^ıVg·èUk ˜—¨ÆS®JQİ\±µÖY¹÷mD-V‰Y®·\á;¡WõÖº3ƒŞµšOoGà€_`ı¾ÇKhI¶Š‡ÑÅ¿–gñÃ· K+.îà¨QÃ6"3|78©@nq‹u¨Ò,b\Å`Â+¢	+·yÅn•ÛX±a–zĞmVOV±{Ï£YËÍsï.*pû–×`Ëª€;£‡/f¼Y£Õ0eY°qM"¨V‰¦w•ÅjÂØÔwoß>òû²iH}W®l1Ñ,Bî>Ã?@$Gû³Œ4í¼~GÍ4IÅíj[{rD®1ãŒ^)õ€Qd:½ÚˆÍà 3Çîæ2](Ğ÷óĞ %N¤Hü_âV³,Z;«BÂOñbM› õÎ-ë¿%my-úcØBN`9ôjQ*6À¯ñ¯	ŠHŠá=aÅ†™ä[£Š<æû_ÅSLfwë@Õ‘ ‹‹BÅ_l¬%4²3Ğ|A„÷#cnÆ!âgT`šÛÔ¼¬æİˆN[ê­ÙÏæ–BG`áa“~Ÿq^}ŠúRÇ:M¸õGOå…£Ù¥.FiŒë…gTüÌTßÓ'·F`ØÁv¦@§ÅGŞ:}Éìn®-[½iÛ3§£¿‹=VÙ;0ø2 Óü
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/98/7a45b16083d35a0c2c68baadf3ed07f2fbb553 squashfs-tools-patched/.git/objects/98/7a45b16083d35a0c2c68baadf3ed07f2fbb553
--- squashfs-tools/.git/objects/98/7a45b16083d35a0c2c68baadf3ed07f2fbb553	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/98/7a45b16083d35a0c2c68baadf3ed07f2fbb553	2022-01-01 15:09:15.661172591 +0800
@@ -0,0 +1,8 @@
+xİXûoÛÈî¯Ò_1qá˜rhY²“ë|ª8r"@±IFš»ÄšZŠÛ£¸<>äS/şßûÍò!R²‹öĞâĞÚÜyì<¿ú.Ğwôê›o^şéø°M‡tK‘J”üœ‰Ä÷òT “u’Êe—hæ«„ğ_¯~°&W/£X&‰œ$ç¤Ã`ÍzjRx5šu´!”’åvè¤×?±ùyj/™ãÆWA "ëláË˜¾òƒ¿–¶tu¼èf?½.4c¢X/b±d£¼XJJ´—Ş‹XÑZgäŠvÍU’Æê.ƒc*%ÎuÌ.õ\yk>ËÂ9.L}I©Œ—	iÏ¼¼»º¥w2”±è&»”KcåÊ0‘,.Šø0ñáıİÚH\²ÓÂºÔP,R¥Ã3’
+êcZÉ8Á;Ø¬BÇd‰”MIGÌØ}k
+„Š·û„¿·æ¤Bs½¯#¸àC%œºG8éNR–H/Ì}ˆ}ÍŞ_ßÎhpõ‰>&“ÁÕìÓ˜S_ƒ*W2W¥–Q à‚‹0]#&lñ‡áäâ=DoFãÑì{p9š]§Sº¼Ğ€n“Ùèâv<˜ĞÍíäæz:DİL¸Ï
+)yP¶Ô±¤¹L…
+’ÒñOÈdë‚9ùb%‘QWªl¨¿ˆ-3Î?­™ïÆM0£ZŠÂ9#åQ¨S›îc…IµÑÕÈ#‹oRiÓ«ïh&I7p%Ñ4cÙÓÓMot’êĞ¦êôûı£şiï/6İN¥;æfôÌˆ».t·ÛV¡ds‰šO}n¤®ÿºvˆş;VÚMƒæq¢°·YÕ"[|,ª¥lJCTéæÑR¤~óLM×°FÆq¸%¶@İ1ÛÆê=ğé¸ëïál.=JºŒ§CêUï³Éíúíö1 #È/M“Ô"D¨ò(èÒ„d(î¤e‚ŒqàT˜–N)ä ®tßu¶«››¼d%f…b€[¤c+ î3—Ú™äà,¿y£–ouÊ`yN½3c‰›ÅNÖ ›d‚Øƒo¾C+¤t-Ã¦¹wÒÊ@'¯†³Š´ˆıRg00áfö~2¼u>ÜÎ†sFW£Ùh0ı0œ@o;À®•VsJÔâÕæ;>€0±ÕiÿÚn 3—!#LÔ?dù²-åY¦ô¬¾M³ÑõÅ»£«é6=/x;t~NGıA‹aNDš®­éì-@Æ¹‡W×h­ádr=±ö6JÈ(&½.ç6ºŞY*´)ºğÛí±TkÏÍô9Üëœá¤x…Ïß"î­’ğ¸~^XÖ½O0ŸµvC ‚xÙŒ@•L«øíÁ©}z™Ë›Ø!n2Ëc·“ö/j2s¹%Ã•ãb0¤&ğ;ÂGç9µ¦¢,W®l‡óc5u<Qa/šê5PWh\4ØËP¸9ZŠ_l¶ØTin³¶É£ä`ü¥?~A2~¥ƒ¯6óãˆŸ?Ğ2ÄâĞƒ.Z¨4±y!Û>Ö‰·$„¢úQ‚¦H™Gı¢ş ÌEÖã*ŠešÅ!6*ÁëZÇpeÑïY t:„ôA)ßr÷N˜ÆÄÜ­Âsà¼U–×‘±ŠYší3†‚»ÉôÏõÆVº^³\‡¾~İÖIßÃ•¦/h2ã³é$x™ ¨³ÛJ°ÜÏ@È[®Û&eØÇVJg	,Í#Ø¼ŞF¼‡ ³–™ëçCëÒÏÒÌÃÆÀCHˆ]-ˆ/$?[p[!&k¾ĞusM—W^îS¿×ëĞ3¤‡?§2xgïÁ\e¬Åv¼ÕáÖ-¶FÒß³¹Ö%22'‘
+±om.*"ÿ¥c[ZËcÎL^ÀZ¾Å¨%ÏÚûÿÈÈÑnİcŸ”di?:bEQ–º(gëàüÀğ”ïõòÎÿ²Ñaµ°¥‚
+Å½_hÿ0æÇæ¹g×ŠĞ.-mrÄ`{i7íŸB|¢e9ÚyE2§çYâ[˜¾XİpÀ@g€*Ÿ”`U9bÜ@Š0‹œˆå-#sØ¡’šO™,´û¾‚snLÌç’“32›õê´˜ŞKLØymÇÄÆµÔ˜OÍLÄ¡@!øşÄ`n•>TêÈê×cSó†I9ïˆşnÁ)
+7ŸxÛòÖÄeRäàIG™VNšÉÁÛŠŒÒ@ù’ßÁeÜ¢r‡x¬j]5B‘ãÚå·”#S¹JpE	J¸(öŒ>jHa-„À²Àír;¬ìC¾æE«a§®¯]¼œ'‘t¿€d|kÏ>²ñ¾*nã²bESL‰Wø"­~Ûÿ˜û[;+>j¬éˆ—Ï‹÷X¶–XÎà†i0|0<õ-,˜œeğº*uÃLvÓ•“ òf‰‚%‚N^õğ75´ UM:ş…¢:Ë¶.4i®ÎÂÆk[ü˜[İaÓÕíxl¬oVGóÂ]şJ±±Ú^L@ÀaŞhØ´€Áğ,¡N)#ëyS©JĞ˜À»‡‘áå‚[Ò|rGW³‰ÍoğRìú•âbÉç½¢ì,ü¥›¯õ<‰ÿ­™Â<Ú•»ğ7õš¶åƒñ±‰÷°ÁhÛüš1×\ó‡¶šÜû<Ûv$ş Ä²\”@5ßË2¬›Ïl‹—:ô–ØŞ»İ®¹j%ÌvN"âÒ/]¨ÆÅÿéÑ"ÿI–¼z±ÇÀ›öÊš€qj‰È&øÆm¾Úæ6>‹ÈĞ„#Ã9¸M­îx¼Íõ(ªĞÓÿ×Al/Äé±ØL¿%dÿĞ±L†
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/98/cdbe949495dd4cb3fc6be81e680693f8f354d2 squashfs-tools-patched/.git/objects/98/cdbe949495dd4cb3fc6be81e680693f8f354d2
--- squashfs-tools/.git/objects/98/cdbe949495dd4cb3fc6be81e680693f8f354d2	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/98/cdbe949495dd4cb3fc6be81e680693f8f354d2	2022-01-01 15:09:15.601172588 +0800
@@ -0,0 +1,13 @@
+xÕYkoÛÈígıŠ›äÃÊ®ä‡œº»N·€cÉˆØV%»É¢+PÔÈâš"YiG	òß{îrôpÚ¦E‹ˆ>æÎ}œ{îf§S:ıã/w¸Oï>-ƒ®
+ÔnÓ»Wç„«t¦òFçèèûöñQûè%Qÿ.Íi<Äé®å4Bš¥Ë Jhÿ°ÑxÍ“™šÓdÂ6º½‹É›ÆÜˆµv/&a\Î=¯2¥Ï¸Q½ËË'ƒáÍë“Æ#±èn…AB°«@+*Št¦ÔŒÒ„tºTt1¸Õ­MË‚–j™æ+*up§hÿ/l°ggYN5=FqLS…8¬ –b²q•å9UE%Æ°C·ı¤8é4^¨X«'Ÿâq2‹æ‰¶]ı˜”ÃL¦ò"RUp?Æ›CçÁ`4õ?ôèFü±wºÈË° ‰s(ÓÏHA™èè.ATqØ¢8kQ6}…ÛÆYšEá(ú¤^5¾˜¬°ú•8ÇI’Ë‰Aµi&Ğ”U~6†ª(óDŸÁäèÃäæ­ù»7Ş'·×£ÛÁàf8îu±ø6Ñe–¥y_<œßÑoî×¬¡}ø¦‰.èõª@MfA´êĞ4BØƒ×—¶#=VzOyc>mØûËmØëNú×ƒÛñäêügú‘’r9U9¥sÊÕßÊ(dd Ô>hAÒcšÃ'ÆÉ§ërIÓ¨ĞX§wf³óëñ1ÒÉñıJÎı:§ô':>yişù#Ÿ½Ú.ñ‡:G›µ–úzYâ¬rmİ­)òÆ ç{6oQÈ~*§åÜÃC$wŠs=&PR$vÌ ¤b¥º~]În*$a§Pi­föU°p¡Âû®C™G©‡¿³Êô//ÿÊw*ÈæŠ‰åJøn”” É/ãR/üı$*F\]Ïj7p¡Wæ
+µÌ<Ç%%öŞ/OÀ şØÎ@ aŸ,ƒL.”ÜwÍl>~·ÿŒt ¨ª\IÌõ—Fã!fk'ì¸A9Œ£Va r¼P¹¢ ŠÇ”¸½5ƒ=ä&WÁRÚx;Ú£‘Ü …³Ğ2Èï`ôå.)˜Í4ÓĞ=µà-RÔx™åR1âş ©I^âÌĞû´¤e	Àß'é#©è¦L6ìL3Oã¤Ëpa½>˜;ºR(‘ X2Ù¿îŞLÎ¯ß·’€‰é!Œ YQ–rõÑ±dúÕ¾Ş»îâm~}§á½qDn£_±œ‡‡€Å_¨Çu»ÓWqÎ÷ÆMZ3#H¢ä%^Q4+Â~|% ¬Q”²`:ˆ£eTĞ³gÏp¯NR‰ááÇg[ô¸P	­GI¡™2e+Dg­¡ç˜º°¦*×È¸¡ @= ~B)"Ë…{´X”ÊlnŠ„ˆ[} 	ë´B ®´¸*LFeB“À½ØZ„ørCô†åe¶Èªuú!ˆKÅ )] _«‘`<Lá®1hÂÄ™Ä	îY<Ò…-„ªKu£ş±NMî-r‰GQ+³{ S°7ñd`ªPwyT¬(˜n^bÀ× ŒÒ„ç~€ö&(Â ’½Òsf¦R?§‡ ñìmŞ•ª™pš6Ş=4¸ß	ÌÈÚ¼.50o½b-Ÿì²¬ó‰dÃ®—Ôì	³ë/X£ˆ®êWNX˜fhXÛXKÀMè|­;Gãóñíhr}3Œ½‹şe¿,¯ÿîCa¡.¬UCfñÁºP´Ÿí]kÌ´0FîOıñLÜá[Ï"Œ¦£G4cÕÎ,Wóç ³ëY3®ÛLR—
+ĞÄ¶¡^¯;š\İ{F¬ƒ!î`é7°ûC„0¡09ÖZl™¼:ÿº7qŞIÔ7"5†o…Á¸›aBÄÕ4˜F1ÃW öT& Áªƒ=zãQXZ'Ôfn°iˆ52(Y]k]–Ås ¸@o Ñ.`SOAßª|`ÌïĞQõÔ:¡X=@3p'š%uÇAğ64yeÑ´#Zóô·ù rƒÄ;¶¶ÆQ‚V1ƒ›gvE.Åzï–œfiòNÑÇ*R@+O—Ğ7¼'8˜½¸ËÓ23êN8J¤Óß`ÙtÇötH øÀ?p.Yd2˜“Æ®PëD8qîVÒà2WªÊÉæ{¢l +İ}~Yîñ
+—nFëu*.Ò
+Yçß²ñ2HJx¿:`—€ÂfjÀñc°$UÖÁÎÎÊ¾Ğ¹™;ÏW½+Ó–øİ¦+sD³d
+…À*şµÃìÕç‰®
+'Î%É/·ÖèäL{g
+¹6„Û}#´/B¦­É¸*ıëÆ·WíöË[%ÀÙvë›½Ú6½Ã)Ğ™w*Ú…Xÿ9ÓVø(‹Š
+^„ZA±&J¸ĞŠÄ:fÁC€YFt˜f+VÜ~Œ9’X-Gx#oÔGğG‚Ñi* å½…|qúº7ÊWN<(v5³5Lò¸cõÆ§y_EFLŒÆ½ÁÈö¢C¯QóÍ=v	ÓÊ|© äîsM–€8<Ú9e—|6+ëµ"ñíC‚ú‹ XšPS|Êä©±¦KªW+Kµ-Ä‡‰:NQ"ç
+»É.I.s™8;CNÁ‡3*3<wÚpäÎhÎÓ/æö/3c›Øj»»¼Šÿ€ö%‚—µ“,sÁ¼’Z–©Ğ(.ì­×ÒQĞSî
+ÄD†í½èŠ;Õhp£XŞsuûÅ7êù&xÇÊ^õ…<45(Ëä‚~ãó{ÕÈtÌŸO)mwªà®QD¡:Àæ/*d%±…«±ş¤â²àG\Ø!Œv=Ş;;^ùŠ|ÁÛKwÏÇçœVá†ÂBÕ÷$Í~M20vU”<\BùØ i—#4dıÑŠ¸e¿HìuÜÚ:»ÕÅ·Ï¬øÙgj-õD[£Î#Cÿ~ñ¦Oq4mÇÑ½§+Á#…ce
+¯?ø$æQ&‚Š#Jğ{Èµ9‹I‹š9i<õ‡Ë•#:nñÍ=à7lqÉ³ù¸k»ŸmáÃ”Ã…E“~•8]'Šu6ÿ½VÚwÇ¤ÍÖØÑJö )ŞÍ×ÿ™Njz›=‰=$¯b#Áı<†Í+ˆYŸÿ[8ÜÖ·;Æ®­2¸íÿ¿8ÿ¢ûfó(N”ëN²z–ÍÇçŞÍ%sËÓæó”Œ=bšCR,ˆé´‰r £ù<ÿ#Nò÷y—•0ú†5ÚxóãYM¦qü¨%áíP¡ö¿EşsnpŒ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/98/db62c4f92b260e2d5579dfc35a88fcffc41147 squashfs-tools-patched/.git/objects/98/db62c4f92b260e2d5579dfc35a88fcffc41147
--- squashfs-tools/.git/objects/98/db62c4f92b260e2d5579dfc35a88fcffc41147	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/98/db62c4f92b260e2d5579dfc35a88fcffc41147	2022-01-01 15:09:15.665172591 +0800
@@ -0,0 +1,3 @@
+xSmkÛ0Ş×ùWôKÜ4/K·â1æ•¾Ò$Ø%”û‹9R&ÉéÌØßIuÒ®£°/‡îtwÏóœN«R® ×ïßñ\d˜C<’åxGäpïy§mÚÿ¨˜.rMgë^Èm­øº0ĞJ¡ßíö}kÎ~pvèì™³ıäì¹µ½®³ÛkVğ²ä[Ëj] ‚ÏÛ§ÀWİ`v¤Zwªï_ì¤à¶J®Û s…Zææ‘) –¤L€ÂŒk£øª2Ü Ù©Tp#3×6V‘r¦@0¨6dîœëÉ®Q b%ÌªUÉSó…F[Îİu¬jWqe9Ä¸’Ô˜.E È©½‚*M>ô}ÛB*h1c©*[›xLüj(ñØçvŞĞû,+.|!·$¡ –$ê‘Æ	+„Jc^•f w£äf:O œ,à.Œ¢p’,J6…¤[ÜáS+¾Ù–œ„Ñ0¦¦™XÆ·—ÑÅ•„ßFãQ²°
+®FÉä2ájA³0JFóqÁlÍ¦ñe ¦©|Ûàí™BNÍ6R!dh/õ^ø‚^R»2ƒ‚í^4E¾#nRÚ¿ÿ|­RŠµ“IL' ƒÆ‡GÅiAŒtƒüë-íç§ôax	Òxf%KN ®lí`@ÛüMj#…·!tû½^ï¤7èÒÚÏãp/GKe:5=õ<ZÌ*5´Å\|½DaT¿¼÷ÍEÆ•A›Á!ú*½-ğ§	¼ßçÑ• u04%–--Ö2ç%¶Ò‚)hûöÊ‡'çşá8ØWì$Ïèó4ÙzI¿dé&ÒzÁ„‹\BûUÑÚ}ƒfÙPã¨ÿ-tà­şA6´°/Ú6ˆ‡Ìf*íƒlúsæşl8œ=Ş
+úÆŞB‰
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/99/41b6f7f86d23766db80d6a582bf7e02686b640 squashfs-tools-patched/.git/objects/99/41b6f7f86d23766db80d6a582bf7e02686b640
--- squashfs-tools/.git/objects/99/41b6f7f86d23766db80d6a582bf7e02686b640	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/99/41b6f7f86d23766db80d6a582bf7e02686b640	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1,2 @@
+xmRQOÂ0ö¹¿âoÄÁ Fˆ>Í9Å¡&CºõêÚ’®#‚ñ¿Ûm7b²dı¾»ï¾ŞõâTÅ0ºgƒŒS¤ucT0##×8C×q/à
+foJCHw©ÚYæqÊ`JP.¡7 ¤Ë×’áV«ñójx·ÁıjJº–âOX›,“4g~`¿å~‹YÓ±e~ãCÄß$5¹Æˆ.	~Ônö¡~i‚"÷õºUgNß•~Dq%Ám…"Cµ©Ú-MÜÏ‘M@™f,°òE p+;·g€š¨tmÎÓÉ†ï0Ôj‹ÚpÌNÂŒqc¯AÓÈh¤"›Éµ*RJ‡¹åüOñ˜Y'‡4ùh©äö”Šòø¤^­.º=úú÷~q®cw*µÛĞd|e‰¬2h)¹øeËvšš@lÍ¾r?•\ÑÍ‘ñ¤áMÕ‚Š¿ ¿ääµĞ¼…¸ôŒÑ<ÎM5òr¾¥iÖdb{aOW7]nB¨Ê÷*Å·¹{ò]¬JÆ×ä6‰üê
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/99/61b30e939f8dd7c1ed5ab25406003e8228fed4 squashfs-tools-patched/.git/objects/99/61b30e939f8dd7c1ed5ab25406003e8228fed4
--- squashfs-tools/.git/objects/99/61b30e939f8dd7c1ed5ab25406003e8228fed4	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/99/61b30e939f8dd7c1ed5ab25406003e8228fed4	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1,7 @@
+x••]kÛ0†wÛó+t‘‹˜â„n»
+ìÂñÖâ‘àâ~RÃqœ`¥âº-Û¯ß‘%Y’?2B,Ÿ÷ÕsŒt´£|G>_\|ıtÄWä¡Åş-S|,R1t<?'~ü…ø)¥$J+H¶ø¬Jâ ¼ÜW7øêg„øY,–ò¯
+áò´A&o†›§mğ=Ïø>¯¬ÈæF"öP°=o-ñkíD’”óPPÖE­\[¿-§8ï—Íoê*OË5! ”gjşzëW^–)Ûo
+–_§ÕK“P9$ê®.¨Æa¤`G#ãKÈÙ[^é”†[1¹Ï³šË… À%^‘Ù\TÃP+éÁÙl$©´¥@.ïJ.söü,¬X?²>‘À)ÀJLDš?]—aÄ˜³!¶t‰:ü¢íD¢Ù 
+ˆØÆNĞº6DY[Ç°Lğ4ÌõAgÛ5<[š¡Ø•£dc˜f7x\ö7#gËVxÁ:
+¦Q&@]38' Ãµµ	ä®œÃÚaÛÚv×êØkªY4)œByÁ´>²Õ¦Q;ˆºwšĞ@†ibªÁyĞ4¸,Ø÷&r•¶dÇÆöØçqÕõ‹­×´Ú>X)Ó¨–Y!Û†=FÖ†$°ç¨<êË"åä03@_*}¸R¦q-3d4OÙ
+ÎüÙ<ÙŠ{¥¹¤Ìô9¡hÉ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/99/94297ccc01d67a89fd3c7687f354553dc56a85 squashfs-tools-patched/.git/objects/99/94297ccc01d67a89fd3c7687f354553dc56a85
--- squashfs-tools/.git/objects/99/94297ccc01d67a89fd3c7687f354553dc56a85	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/99/94297ccc01d67a89fd3c7687f354553dc56a85	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1,4 @@
+xUñKÛPŞÏï¯¸U„Ôª­cˆ¤:p±*lÃ2a8	iriK“ğò:eRÿöİ½—4©­"+”Gï½ûî¾ûî®ã$ÃÁáÑ‡wİ.|ÃûË Tûa[2“y„Ğéè4~ØŸ¶Dm<.t”ÈñşôSÃØj€ğk‚İŠ0–)ÂÙàó8^]ÿô¿N¿°[œÒí¦«?™Œ`‡sˆù…?yşÍàZø~a˜Ğ¦‘ŒE–£
+t¦ Å{§Ñ×ÀG[<
+ 
+or8×½Ä ?M’,t\÷õw•…XluÚ»ĞÛµ}rlzÍãbPùNÆàŞ	ôÚô@OUv1<„˜k™¥N›*Ôs•BŞ!âÛéD˜ F§Ì£mƒ8%«YØ`Öò<Wˆ/ÑÌMz;]ó8æ‡l¡$·0)\“Y 2•Ú/pâÎmfi¡É¦á÷ç“•™ÊzĞ3Ÿ¾(t eX–.¸­İ-ïØY’ää×ë‹Ê…Íé|f¤)ì•%•Ü¯Ë¼ôítVÅ«]n–´Ìë>]©8¤5e¦™$ã.è[¿<n”Á:·ç|HwA|mbÀ›º'W<vZ¦*°}Ùö$àí£èWÚÚ­KÖhÜ•“ (Àóhòù8‘¡KyµQ•nL“CÌISv:š´ú ;Ûä ÄŒY‘l¶OÿÄ%4`ï—#Äuªx!0ñ=ÄÍZ<›3ëÏÇ²Æëò¼lbj¤j\fFÃoâmF†›ÊL×Æ²³µìÈ½=®W¥%»Áö3õªÑ3ûLP²¬Çg¥2uã•[Íş‹»†6])=µêBğ6*—ùµFåºk¦j›t—Á®’èÆ;Ÿ§!ï0Òšf_û´Xı©ı_pê¬LÒk®û´f«Ã¼·× S¡ÿ Òó
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/9a/44c59ac0c9f7506fc67417ed26a77b6f5d86d6 squashfs-tools-patched/.git/objects/9a/44c59ac0c9f7506fc67417ed26a77b6f5d86d6
--- squashfs-tools/.git/objects/9a/44c59ac0c9f7506fc67417ed26a77b6f5d86d6	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/9a/44c59ac0c9f7506fc67417ed26a77b6f5d86d6	2022-01-01 15:09:15.593172588 +0800
@@ -0,0 +1,11 @@
+xíXmoÛF¾ÏúSˆ²äÈN‘;8±²Ì8DdÉ åª½/%--ÂW%);Nšÿ~3³»|Ñ‹ã^q¸~¨ KæîÎË>óìÌ,§±œÂÛn·û·×-øÇ—Q,fĞé ıÎ¨qÒíş³s|Ü99Spîd
+7ÁC,ğéf=£Ìå2ˆh½n4ş%³x=p U-h0Læ"„[Ïö'Îğr4ñüÎÀ®,/Ò4‘G‹sÉ<
+Yj·ĞëV \ÌÙÅ ™Ã$rÁOá:™å‘L2@&Q2—,‚·W§$è„ğ$×,¸…·?^_ĞÓR¦š«TNƒiüË(ñÃ Š×©ğ³è‹€3µ²oN>]À![¤2Låòu.a(òG™ŞCˆĞµ!Ê!ù:E_l×¹şpä{¿xcûÚwmotëöm¤›N’­Ã0šE"É!{Êr±DÉL®Ó™È@|²PûL.W±Èäó¿®®œC&Ò‡h&¬#Òuc<Çİgr)àA¤Â2,Ğ@qÜd€´ÏX,3xŒòHš ÚfÆ@…ˆÇ›@`šËàiŠ"q&Fßâ¨2ØCô—"Ë‚;³ \v``˜É$x2ˆe–4˜%Ø(pß_¬“{-^Ÿ¡yïßÃÉ‰UràAFs&¢ßÇæéz–7û“Z+«ñ÷ŒìÚÉ€Uç|ì@Ÿ3ü©7p.ı½áåÀöñáÖ~GÒ"ÎşâZŠ®Şj†yø­ÑÈò GšO\Œ‘Ì­DRñ£¡Aï`¶Rh%Á’‚¡|$V^Ë¹ø=öS(.÷š¬ŠÂŠŸBü®ì¡í:}â:cÏ¡yvíŞe[¯§æ{{®lÃaŞ—™¬*ëãôØö{ƒIï•nì¡oÿìxcgxeX[o<v‹[\<¹×½ÒiXŠèxr
+ÈØ¹…îwÉe‘‚,·ÓT¦MV±‰PÎ
+ÏªÇÓÃÔqN6­sÑv×âÄR'ÒI^J¾šİ•«6(·ºÖ;øÖ`…£u^.(IºMç5³F¥’õõñÜˆ
+Û¾G¦(|I0f_™)´ü¶ñ‘ÏJB‹sROw;d/;bßĞ	®v.¤£†Q¢³FV´+xf0ïág¼i}(9Æ $KÓ]ö½p‡)Ä»±²ÎG¹XŞ}×Àc]gª%„ÛÀy§5ò Í	ÑÏ¡E‰QaOÿáˆL£»(	bÊ_è3/ /ÈÏúÑ‘İÓH¢}|Ü—¸pŠu¡N\X^ñK!t9¹—0[§ÚfİÎy=¡Ò	¨gØSh²«êNiÆ‚€%'Ãª¢m\ŒFSrKŠ´Aa¤=jÃ«BC%9àITÙT¸ZÍæÅÖ±–Åã‡T‡”Yéª{Ğ9+ç•¯
+Ã­q¦2Rá¼e«pV`Šù÷ìqDÔM”ñĞã\=–ºŒà¸‰]ˆŠæM…Ïq»Æ–¶)7¬ˆ|ÑBgµe›œ)l†˜Ô0mVÖSÙ*A5j«Rõ¿'8 ¹´§6W`úsQœñ¢´ûÇ÷p¼º‹òÿ›â÷5†;IşöGleÖÛûBóúX=_:qgƒ{eûÎpl_Ù.<ñZ*9.åƒ¸ùBÎiŒ'òñ&HsÊm*³’Ùrúct·0óƒÑğ
+3ß-»gÑ:8?§Vš¿±êãı‹šëY	L<"µ¢ÛğÎ¯2Á;	6Ğ vì³…ÉLe	eaïß¾gÛŸğk|Š7ã5:ÉmÜ…}åß•‰”I#Õ¿uwIá°kÇûåìáå.9®É`¯¬ãüÔäOu52íùMÏí]ÛcÛ%)oÂì	î²n$6Ø‚S jñ±fS´L@°©gvˆ"ëÖD¸
+|ş ?%¤Ü&¨¶dWDÙ[w%x¿ãİlÔİœĞn8êÈ¼ò!G­º‹tûysbÁoõ­ûj‚PÙ­¤mğ¿äˆ¡N-j5^m3„epx¿Ì6;Xæ{ì86<P3:ìºîµ¡ËäÒVx5Òa.âØTË¶ÆÛU6)Ğ"¹ËµÄ¢Ïc+æ©ç“	—?•7¨]$ÒVÊÌx ÑUjçªç•‘)¨J,‚­Ê’*½
+¤?ÎRµAJjE¾*2,=äÆ]ªóS•ı²¢å:lê·b¡ÉJsõÀvÛ`èÁhÈw*Ùå´o8ü½ˆ70çvŠ_î=ñ«“x96oËê½¶Ğï<W¿¨,õ©7Öíí
+o‡ª¿š®Ã]÷‡>‡¼b§µ"¬·‡­Õª‚.I);¯ŠPX°8}aÇi|ô	/Çø«R+İşù¾Ã>m˜öÕë†ŸÆøºûÄÙâÚËh‹èçÆöˆõï ó¥Hšu¿F#‰®–cu ›/@.Mû!Üd€±äs¢‚NáçôşLÂ@á—¸Î³‘2öÌtuUBcÛ_ØhŞ]3µ7´f+_©³#2­c_, ±}Ç—!Ï!J'x…¦mK}uY)QÜ{U!i•~ÈBCÉÊ fc¨l” ªûçÛj² uL};@-æê¨²-Z±Dí’tÿÎî
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/9a/d32c0762a91b13c83bd3b262626a0ac4b9a783 squashfs-tools-patched/.git/objects/9a/d32c0762a91b13c83bd3b262626a0ac4b9a783
--- squashfs-tools/.git/objects/9a/d32c0762a91b13c83bd3b262626a0ac4b9a783	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/9a/d32c0762a91b13c83bd3b262626a0ac4b9a783	2022-01-01 15:09:15.661172591 +0800
@@ -0,0 +1,2 @@
+xTQoÚ0Şëø'õPJ¡´Û*¦iY-¥(U<!“\ˆÕÄÎl‡.ÿ~geÀºíåğÙwß}ßİ…e&—Ğ¹ê\½;ã‰ˆ1 ï_ÂÅ}íŒ\.ğ·›‹fšş(™NMgëŞÊ¢R|•¨G¸l·/=k»Î^9{íìg?:ûÉÙk;mg»k’ò,ãŒd¹JQÁçbsñUok¶¤ZµÊç/ÛÚÓ”k(”\)–…Z&æ…)ìA%Kˆ˜ …1×Fñei¸&â©lÁ\Æ<©ì]Iê˜Á Ê5ÈÄ9wãÜ¡@Å2˜”ËŒG0â
+6Qu{©SŒaY¹Œån9À@03\Š 'xkTš|¸ô,„TPgÆRU Ø ~dŒxìb[oèİËŠW>•IH	’D½P;a‰PjLÊÌÕ£ÀÓpzÿ8›‚?Ã“şx:ïQ°I%½â7P</2NÂ¨™Š	SQO,ã‡~p{O)ş·áh8[ƒátÜC<àÃÄ¦ÃÛÙÈ`2&a¿RWH¾x»§X.BŒ†ñLï„Ïi’šØe1¤l4Ñùš¸1ˆhÿşsZ™+'“˜ì§<!/ŠÓ‚éy0GK{?J®o`ŠÔ„IÆ"„sK›ÛíÒ6“ÚHáÁƒíËN§sŞé¶iíg¡¿“£Å‹D·ÒÍ\/jø“¦-€–´ŒIÊ…ZS3š.T—ª:Äq²û îi±ÌdôM¯ö>Je5z;H§Ù™MQ¡®´Á¼¾‰ôhqş»‰mzğ—C)4_	š	ú¢üÚ‘ü~âoaşôS;¼Ük<-{{Dã„ÖZòêE©ÓEÌiÏŒTÕ…QUãµe¯İçBÆ¸m!qjxµãù$Š­rJß@@“fÓMëıÕ~Ñ}É×
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/9b/9c1a33a2ae75274a36ea8381eb6b57ebc579b0 squashfs-tools-patched/.git/objects/9b/9c1a33a2ae75274a36ea8381eb6b57ebc579b0
--- squashfs-tools/.git/objects/9b/9c1a33a2ae75274a36ea8381eb6b57ebc579b0	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/9b/9c1a33a2ae75274a36ea8381eb6b57ebc579b0	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1 @@
+xuO±‚0tå}ÅèPq‘ÄA M	M4.J5&UŒ2ùõ¾ÅÉ¥}w½»w­tS¡?_Lvy–àõç^ÖJBt:ºJ‰ 6!§t¾îÈ/­Å*Ùäy6C~,µFşTuùhoÄÅXˆsº*(4ôg…[£”~PïvÚtc¬dS+  ë™`cœ×£FycEt‹¸ëÁ¬ÊP›ì¿5Áo¥C(k0BÙ›l¡Ş6 Æñ@jU>p¸ëå©éÓıÃöøïs^á
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/9c/e2c3467fd99edbc370283d29e557bac1a242f4 squashfs-tools-patched/.git/objects/9c/e2c3467fd99edbc370283d29e557bac1a242f4
--- squashfs-tools/.git/objects/9c/e2c3467fd99edbc370283d29e557bac1a242f4	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/9c/e2c3467fd99edbc370283d29e557bac1a242f4	2022-01-01 15:09:15.617172589 +0800
@@ -0,0 +1,2 @@
+xm’Qo¢@ÇïÕùÛ†—ˆ¼Ø’ôA,t¹³—Kƒ°¶´+k&ÆOßYuI’ıÏìoÿ;3ìZÈ5y~%Ù”<‘áqÂ3›8À]Î'AH˜RJøÉ?`OFW
+wA¼0Äİ`>‰Âv?ŒGÓZ!x’”X¥òM+#V(ækº°È]±N³ÁeÇíì¸ ñÕ¿‘7ş,yñæì4| P%£—geÁ–F_ÅÀg³$Vw’Æ;Iè¥TLc`š-äş¹7?Cg'€áëŠ«‰,¨R†Ç‘2³åúãšm6¼Òs~ÕğßÈœëPp¨«4«õä3Oó®[TêLTó­™¥E‡™ñú]æÑäÌÁm#ısc´m">nS­BH…ğp¸íŸ  <-=èY9Äù£íâlLõöÔL;¢jN§Œ(Öà‡]#*¾oÄ.{Gsƒ¡s±!¥¬	?ûšÜìl?ó¢:ID®Õ`iïW=Qè‰¢üÄèò¦äWíİÀ-¨hŒ”U;Õ¤9¦v=|õêQ¬e©Ä#¶íàçËíëŞ;ñël´òîÑs)|©ë,
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/9d/8dc7990cffeff3f53c4ab312b828efd5b0d673 squashfs-tools-patched/.git/objects/9d/8dc7990cffeff3f53c4ab312b828efd5b0d673
--- squashfs-tools/.git/objects/9d/8dc7990cffeff3f53c4ab312b828efd5b0d673	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/9d/8dc7990cffeff3f53c4ab312b828efd5b0d673	2022-01-01 15:09:15.633172589 +0800
@@ -0,0 +1,2 @@
+x]İ
+ƒ †wìUH× nÀ•Ã`VÌ¶Ó~…p0êşglíĞ‡÷ı×n|u8IÎ§8Æu;¥,Ò…FÙA*P“&e …îm¬üE(œ×”Ë@vEîCà•CÆÛ©×WãâïUâ{·$œŠšdôĞ÷—[ÅO ¦‚;åÕsï ”UN!…KÑÉM'‚A²üÉöã<H¸s‘€·Æ.pÛpp|Çş)6èÒF!ôòe
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/9f/1366cdb4cf52e9c8eff4f9a340ab7cb0759f3c squashfs-tools-patched/.git/objects/9f/1366cdb4cf52e9c8eff4f9a340ab7cb0759f3c
--- squashfs-tools/.git/objects/9f/1366cdb4cf52e9c8eff4f9a340ab7cb0759f3c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/9f/1366cdb4cf52e9c8eff4f9a340ab7cb0759f3c	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1,5 @@
+xTËnÛ0ìY_±ˆ/­¿Ò´.ê“uM v…:¹ô"È•IC¢œFEÿ½KR¢hÇ	
+°¸»îì¹ÍÄ†Ã7}F‘tßÛA·‹ß …w3|êİÁ-|ò r¢c&¸
+ÊmÆbHÄ>bü¾çuXÊšB~†äîË*\z0NObXÈã¬L(\õz}üªi™övW'ŸTA2/céıñ î	—ïo`]î	ßÈœFûb|ş^Ê³øÇ[XQ¹	™«Ò¢C‹nü³M5	Í	OÅØó‚%à„BÂ™|ëx7~^·È)=¯»²©&Y&bğ#õ‡_áD8Áıvè —:„NO‚ˆå—1N[Ô”ô`ì6ğ w`~Å¿ÏË¿ç•`u«qê-r«Ä%`,=ƒf\‚ı˜Íµ‡«M!?Wæº“Fj­ØBd(Y+—Y[­ÌÒ¥ºDlªºæ+•-7%˜[¬Zl"áçİ0[4ˆÓÉëÆ¬Îj¹Pæz8Å‰´Ş<A©ëÿ»ÍW<ôM<:3]²‡6ùZ¦Å‚eôíéşqK`e
+ª/4‚ÂwQş:R(V$Œ’jİ¦O’Â2*Ì¬T‘b®ŒkW.™]ÖûKè=º4ºãIê%r”ÇH«{6Ê¿4%¤c\ß˜[Ÿ¦CÈ¢°'Z~6¥:vcœcn
+mW_g·æì*´WÇÁp‚@S86Ÿä–êepŞ!Ì4Î\|y:”',õşßQàô
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/9f/4173e7e3329df2b2d19e8e998c319f75c6956b squashfs-tools-patched/.git/objects/9f/4173e7e3329df2b2d19e8e998c319f75c6956b
--- squashfs-tools/.git/objects/9f/4173e7e3329df2b2d19e8e998c319f75c6956b	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/9f/4173e7e3329df2b2d19e8e998c319f75c6956b	2022-01-01 15:09:15.601172588 +0800
@@ -0,0 +1,3 @@
+xÕTÛJÃ@õ9_q P%šlÒ¢V¤…
+…ªÕÒ4±‹i"½!^şİ½4Í¦õRó–33gÏÎ™~’õaÔÉÖŞ6ÚÏÍ`2ÜÂ4Ñ<í6ÏÒpJ³t‚8£İCÜgc:&±¬}Ó¶LËÅ!Zì`dsö×™õbšb{OÓ*4NQßo÷xe¿©UØ?M#õhyöÀy.} Û8:‚må £ë+AW	–Y¤Ó'‡×–€¢R€AÜ ØÀ‹Îe|í[|,˜)„¸Ä?;mŸaÈh]É,Â1ÂÙøÆòğ
+]¿j¥S‡üÄö¸ûF£¸Ïwdşn5@Â1F¬Î£yÃYÎÃ(l{åIŞQ$T¡’À„mÈ¨ä]™Y03På=yå‹`òĞÀ[™ªû'T¹ÊëÊYúÁu™ º"±ã	jÆw2ÔşîFR~ªÃãÃgcQµ¬+ÕsÖÕãs­¤Uc*m.ß[`ùN+¦×ê¬;K×¿ö–Áî¢<)ñ<ş˜ÖÓ9û|•mÚ‚YbÅ¾ÌĞÂ¾+-ìR­0ÌÅ¥¯¬‡\„¥cÕÉ³˜v¹¹9ß5¯Uı›¥ñ'*«c¡ÄÿÙ¿´ÍòW&¼¥kïıÂ=ã
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/9f/c08004f092f7f77858c3381456e72281302076 squashfs-tools-patched/.git/objects/9f/c08004f092f7f77858c3381456e72281302076
--- squashfs-tools/.git/objects/9f/c08004f092f7f77858c3381456e72281302076	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/9f/c08004f092f7f77858c3381456e72281302076	2022-01-01 15:09:15.649172590 +0800
@@ -0,0 +1,4 @@
+x¥SËnÂ0ì5şŠ\òà%*Uª"z E*êƒŠÇ¡'dl–ˆSÅ¦-Eü{½±+TNõ%ÉÎÌÎzì,6ù®»Wu©ØfËÔ´á¹h­käXÕhk&¦4ÓµÛĞß>A–s¹”Œ™+ ÚØï¹äÛ&óLdìmºÚ4X®´ñ]°†–_bn€)¥ÿÔ“=»¶JË•Øšó´¬:ßL§¤9ô <Á"ÀyX#şg‡ì&|—µÜË³[=	b$Vë$II`«Í¦}œc!Ì¶PŞÂÖîÇƒÉìq
+CåBÊ}lôÚ€ÙğyzÙ:±ı|Å@_Šœ	­Ç:úb\BX2á¤šëòàZ…È¨TR­ú;#tä¨ãõÎò\A\µ²;+…ıuØ~Ş£-/ç/ÙQ
+öæ,
+–UnúÌ Ğ¬zU;CRE}²“ùèÁÍfÓ­Û<:¤ÿ:TÆBƒË³ÃèÕÈ ×ƒ —·ë|vœÖÎÉñ ËëB*‚ø(Á´ğÆ é@êBÙŒ|İ.·
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/9f/cdeadbaf2d4df88518b329553ff360198b45a8 squashfs-tools-patched/.git/objects/9f/cdeadbaf2d4df88518b329553ff360198b45a8
--- squashfs-tools/.git/objects/9f/cdeadbaf2d4df88518b329553ff360198b45a8	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/9f/cdeadbaf2d4df88518b329553ff360198b45a8	2022-01-01 15:09:15.609172588 +0800
@@ -0,0 +1,5 @@
+x}‘ÁjÃ0†w­B‡Š3(¬…@M»–”Œ”±vqİtìJOyúÉìì°ìdışõÉ²tÖíçó—§÷ªÜáug$¬O'
+¿§S(ö9.¡:¼WXo‹ÕîHR(åÅ§Ô Ìßìå TáãqÓiëäJëVq\tÛ[s	ÂÈM=XF¾6^-(Q×œ¸è{-“ ô^†QlûM 8°7¶‡&QLí'(ZŸDg±qm'>Ë^ís+é˜Q™¡élø€
+Å¨&‰
+€¿–aš>÷ñ_Ä/“éà#Lp]onPLõcÅ¼í87ÒÀYõ×Ûà‡ï0#Tp	òKbŒå(|Pº–MÅÕÁîÄ­Ö¯
+~ 6ô¯Æ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/a0/e33444e485c5caa22921c257c039d45afbe5af squashfs-tools-patched/.git/objects/a0/e33444e485c5caa22921c257c039d45afbe5af
--- squashfs-tools/.git/objects/a0/e33444e485c5caa22921c257c039d45afbe5af	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/a0/e33444e485c5caa22921c257c039d45afbe5af	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,2 @@
+xKÊÉOR040eĞ×WpÖËàâRÎLËKIMSˆ
+Ä{p)9™y©p>PA^rNiJª‚’SQb^r†s~Jj‘^†—o¥sNbq±£†“3X³“‚A…‘‚©&ĞÜÔ¼”Ì4. ^ 
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/a5/d9ac0ef07fb47cdcd20035cff5c4dda1af9b31 squashfs-tools-patched/.git/objects/a5/d9ac0ef07fb47cdcd20035cff5c4dda1af9b31
--- squashfs-tools/.git/objects/a5/d9ac0ef07fb47cdcd20035cff5c4dda1af9b31	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/a5/d9ac0ef07fb47cdcd20035cff5c4dda1af9b31	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1,2 @@
+xÕS]KÃ0õ¹¿â:AÒnkİÄ§1AE°lZX->J×f,Ø%³IÕ)ûïŞ4ûêÊ|T„’“ÜsÎıÈ8cètºG¡Êi<‹Ë¤›Ìç–uÂx’)…F¨Ò«É‡;mì‚®ëáw#f3Á½û.ô…İ -Ÿ¼İ†ÑğF4NñCúZP®XœùÜ`àÈÒGŞKÁIc· ò¹:ï‚dŸt³qæ¹H¨”4¶­/€M€T`8îÃ™' Õû€xñ÷)Ë(ÑÄ›«šÖ’¶¡HzP®“É©D&c¹}©S#Æ±±zºnkÍŸ}Öœ6û°OcX´ª“ë…¢àØd½(ñf-h¥]æÚ>Ä9ò‚Á´9Å@ST€œª"ç>íj‰Zn;ÿ”3Eë­
+µßûDp©şã”)şÁìÁlWsñ«ã0ÆGÿr`¾+m^D
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/a8/23e57858a0b415a1dcc742f8a8e9713641af06 squashfs-tools-patched/.git/objects/a8/23e57858a0b415a1dcc742f8a8e9713641af06
--- squashfs-tools/.git/objects/a8/23e57858a0b415a1dcc742f8a8e9713641af06	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/a8/23e57858a0b415a1dcc742f8a8e9713641af06	2022-01-01 15:09:15.609172588 +0800
@@ -0,0 +1,3 @@
+xU]oÚ0İ³Å]û"XÛ´´IÈÉÔH)E$]Õ½X†¸ÅRpPâ UÓşûŒ¸‰Õ—{Ï¹÷æøÄ¬òbã/>¾¹ğ!İ”ŒfÕ»ŒF°­sÉ¥Îpñ9_•´|B“ËËÏ£ñx4™ÀWˆ‹tŸ{õkQ¯r¾†¬ØR.À¿@èœ?ˆŒ= !Ÿ~‘ôj&AB®Ğ¹ÊqÁÜ´‚‹u^gÎÒ§S{œ!$UthQÉ²^K Ø,‰ş €«Ù<ˆCØP‘ålŠşBSœªÉÍƒ&¸¦gh m0únèğæ·qìïh…•(’e-¼6²Ô·†;@`×­EÅËàğÔ³€ü¸c²S’Ş/Âéó”NÏâX—áú$i@‰£È ÄñÑÆ½¤í‡Ğİ’UÍéó8^#øFaÚ.
+^w}ÛüJÒRÎ²¬dU5ğöÏÀ!^ü¼‰ØÑ’n™då`Ú}G¹t;œ;‚±ÂZ„{&ä	èšrAk¬€gµ,”L6 ·~MEMó.Âê¯±Ãxe#óm­à¸È°"ë¡–åÒ¬ƒŒ^îöĞÜøºã¸êÃ%§y¢ŒGs–µÊºœ¦Ù¼-ÒÃ.¦éÛ¶èëf·é§ÿg—>ãØ&}„³‡‘3aÊE:<ZÖÇ÷ÀØğtƒÆƒàÙMÖ‚	ÛÒİ¦(Ù	ÚzçB²¹—vÊG»ë!c…^ßC¶ğwC¸„|?iÏ>ÂE-¤MoéohÒrÉ’åŒVl~¢Ÿ¨·'9ã>ç%Îlg©=_b‘Ğ³Èx¥‘ºqHâ4º™Æ¥²÷Zù›­%/„ÒT_kNšDê-ğ\°Y¡ıSp)ÒB2u`"§®
+öpJ$êš;0uàT_#ÆŒîõH!¢s&2ş€Ğ?îh‘á
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/a8/8828d58910ba54b479cdcf3b85b0b528b1181d squashfs-tools-patched/.git/objects/a8/8828d58910ba54b479cdcf3b85b0b528b1181d
--- squashfs-tools/.git/objects/a8/8828d58910ba54b479cdcf3b85b0b528b1181d	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/a8/8828d58910ba54b479cdcf3b85b0b528b1181d	2022-01-01 15:09:15.629172589 +0800
@@ -0,0 +1,2 @@
+xKÊÉOR02´dĞ×Wğp6ÑËàâRÎLËKIMSˆ
+Ä{p)9™y©p>—r)XŞÃ9ŞÏÑ×58ÀÑÙ®YPÁh Ğ<¨~Ç`xÇ  ÇÈx#l‚Æ «ó’sJSR”<œõ2”Pø¾‰™y 1¸õ(ÆA„™–š—’™ÆÅ Î2@Ê
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/a8/d3f4dc0a24a38c7069c19801b93dd15aed0d00 squashfs-tools-patched/.git/objects/a8/d3f4dc0a24a38c7069c19801b93dd15aed0d00
--- squashfs-tools/.git/objects/a8/d3f4dc0a24a38c7069c19801b93dd15aed0d00	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/a8/d3f4dc0a24a38c7069c19801b93dd15aed0d00	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,2 @@
+x}’_KAÅ{Oq(™²\×¥İ … ·(z
+	]ÇYØ]ËJ¿{÷ÎìŸBpAÜ¹û;wÎÜ3óu:G08ét0Îf6Y=?Ş=M®!ÎŒMÖ›…Æéß«S!^lÑáÈ·Ij?tVÈñW¡q¾˜³6J 7ßº^Øôó1ÍÛ0¶€¶Iº0ö]‰Š6Cz_¦¤AŒ`ƒDÅà>n#R±0KHŞîÕL“`hµªi»S´¨<	”ÿØíà´¬ÿ§½¹?®¥&Nè·®=çYB^ë–Rú“+ß›<SŒF#…İŠœÕ½>N…ê‡zSÅsä§üc#šbXÕËt:/ªÏ²	ÅËiBDĞñ|rt„ºU"½Îu}¨’åÍ.!IíÆ··|”ÚR)¥X*Ka¨(¿®Rn‚nl{÷ş¡!PÒì#öU®ñ-ğÏPTıİñYÄp÷T5›DÁŠ£48Ê¦:v-åqÀõ±^ƒ±aßfOæø—éb“Y˜¡Ø‹_(3ß
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/a9/afd2518b1c9f941699377cb08eda8512bba956 squashfs-tools-patched/.git/objects/a9/afd2518b1c9f941699377cb08eda8512bba956
--- squashfs-tools/.git/objects/a9/afd2518b1c9f941699377cb08eda8512bba956	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/a9/afd2518b1c9f941699377cb08eda8512bba956	2022-01-01 15:09:15.629172589 +0800
@@ -0,0 +1,3 @@
+xKÊÉOR04·`Ğ×Wğp6ÖËàâRÎLËKIMSˆ
+Ä{p)9™y©p>—r)XŞÃ9ŞÏÑ×58ÀÑÙ®YPÁh Ğ<¨~Ç`xÇ  ÇÈx#-yÉ9¥)©
+JÎzJ(|ßÄÌ<Ü&T©y)™i\\ :´4‹
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/a9/cb73204636bc8083735af684e0bab83cd33f85 squashfs-tools-patched/.git/objects/a9/cb73204636bc8083735af684e0bab83cd33f85
--- squashfs-tools/.git/objects/a9/cb73204636bc8083735af684e0bab83cd33f85	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/a9/cb73204636bc8083735af684e0bab83cd33f85	2022-01-01 15:09:15.629172589 +0800
@@ -0,0 +1,9 @@
+x…VoÛ6İßú‡(¤¹MÚlÀ†:gÙ*ÌMŠ8]°…@I§šˆLz"e'3ºÏ¾;’RäÄÍŒ°Éûñîİ»“òZçpøãáÏßÀôcª®¥*õzE{²R%VeÓYz]§ç¿^\go£=:•
+_‹*ê¶Dx¶¿@éÌ6(ûógQTÔÂ8½Ïm"€ÉEø>ËÛªÂf"€,µT°ü¬¥C)¬ Ÿt†·¨¬uª|
+a\ª1İH•ıá²¥6S¹vSW•AqÕè„„	B%c!g ë9*P¸†¼ÖÅöRª/°hÙ ¡Ô
+)~®u!ß™*¯…¹DQÌ±tØe±mZLÀr´`÷^0s½6´T%§ö˜)d¡¥d„ê¯ôT;’³´R«q´l´ÅÂbù†œœyOUÉe¾¿§n%ÛR²‰#—
+ø"Õ€WãLşC”³#cL'5Õ.(,p¡›;ÏÅÀhå\÷Ÿ§È-Ú†:åØ„¸A\r¾	Vº	ù‰Xu“¿®ÎLÏù.-HÕé w®·;âT¤š@ÄSñ‚¨›+Ö%lV›§b	n)›ğø¾RÛ–ÿÑÒÖiÍ‹Ğ	ÔË:¢˜]WZ–à	{§W8a…Æ	l¾²ä·Œ;l8Ààxè÷öòlöaz$ä2Dv×ìò[ƒ'¤½6¯eÁÂqœ¼é†‰§7~Åˆ€şİ²…M¾rmn’Ni",Æaj·¥ñ¢æîØÕöÈ—?||Ëàâ×GG¯J4vµ¥JÚxçîğí"k7èK¬‘êñmàêéÎçïhı@ù~l7Ô<Û64ë^Wc_Üp¦É)æ•>m	RÇ7#ÀÈ©2ê
+àŞ9/Â²¡pF£ãà½Ã+~qÇnó%îÆÛn/™~ÇP@^-DZ@ßåv®6~dë2¸ıxGù”èÔø(ğô@e@|ñ-Ö†×+‚á,»øƒ«ã{Ç>ñ˜ÒCé–Ä~ÍÓó
+oG¶sŞôŞ¡ O±¡U“ÙÄ±3¢eBŸ·´»ÜoªºægÌÅ
+’=x[ íÁlK|Œ'èĞ¼¶˜OQÁô¢-¥±BØ¸A6† :ÈÄñ®ÇIG%wÖ·6€Oz´Ô‰~×tæ*¡öwğ2ˆ£‹à5Óì4ä¾Ìï¶ä°‹?ïxşíòX’ç«1H8
+(?Š÷I~†ãc÷­‹&	S—Ÿº!G#7€}÷\P·%îÙ>o'+!k‘×ÈXwMĞ°fîxht˜ê²-ğÂ½	˜Ğ2ÓæŠš×Ü×~¡»ôöoğr×ÕÓ˜m*Œw´G/²Šş™W
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/ab/a89da4995a7f3303096193cbf607c90551f926 squashfs-tools-patched/.git/objects/ab/a89da4995a7f3303096193cbf607c90551f926
--- squashfs-tools/.git/objects/ab/a89da4995a7f3303096193cbf607c90551f926	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/ab/a89da4995a7f3303096193cbf607c90551f926	2022-01-01 15:09:40.213173601 +0800
@@ -0,0 +1,2 @@
+x+)JMU041a040031QpIM+ÖË`8ÀÜ›Ø¶†Ùoî'7¬m¸ÿ‹ï‡ªpËÌIõô×K.(`P°}á¬òøİÇ3ŒS$Ÿ7¾¼rúªª	F—3‡˜Î²?Æ{ê¢‹×Z5¨šà’Ç´
+ mÏ'ùôŸŠ6ÿ8éšnëµ«Z_¦GÎ ˆø;'
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/ac/391c715098563125a475c1bf44cafd9de45c36 squashfs-tools-patched/.git/objects/ac/391c715098563125a475c1bf44cafd9de45c36
--- squashfs-tools/.git/objects/ac/391c715098563125a475c1bf44cafd9de45c36	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/ac/391c715098563125a475c1bf44cafd9de45c36	2022-01-01 15:09:15.649172590 +0800
@@ -0,0 +1,4 @@
+xXkOãFíg~ÅÕ®ªZœ%ª+… Ûl—‡¶U÷šØ2ZÛãÇ¨úß{îØ&Á1•²V„ˆí™¹sÎ½7³HÏ¨wØëşôÛxzs5ù‹ôœìBÒ—oCšş¾ã5_;;DH“)P¯}Ğ¥ÚÕõı^§ëùÇx±y‹ú]¼ˆWé³¸t_nk*Kh)2RIå¡wjçûµã©8¿ãuımÏé852sa•.ÆM}/CX@èR¬CY<M%îëÔªX=ñ‚$£¹6T%w«¼ùŒ²¥²Á‚½¤,OSmlF÷"ÊeFyJVS·Pr’»MúO·#jõŸÆI;Øu†ÍÕƒî-¢±¥<ƒ1Ã(ÒÁş¹‘’æy”6S¨æsidb)–±6”jeírıT“š<½3".¶²KıâÕ=R––Ú|w±´12°Ñc±ƒGlà€Úı'A,lå˜B\Ë8–nqrß2Î¨5zÛ¾<»©2_8÷Jº»}j}MCae¸[$Ş¥Û?öºl\Vów¶À£©%}ú:>ÍöUb¥™‹ ÑG’GïßÓ‘¢`!’;–!O­‘"n/ªÓx*ÿÎP%¢qR<&R„.¯©Œ€\…Äw¯…±e´×—^å¶Zû§QVn.v·İj,ÇgÅ>„£vá8òü>^lv¿~×ÙäQ‰³/O±8•@>UO²lBrËé»_ŞNH$aùıêëÍíälxZ„/”s•ÈpÏí3CìZŒ!Ñ ¤—ÔîÖ|+¨íÃ¹Û:w®¸ä:±wÎlvöFf¶TI… Ü+ƒ…e s²¹¬Aê+¯‹X0çZş.isğk"Õ=höäĞën-’S>˜ûÏ`ewê'6Ë²èu¶–Åµë§t^óË?Ú6CãYB‡—Ó±7*J@GC­6®q´Äğ¥\’CÅ²'¢*‡\Ùšöƒ/è)R3/Rß%²[ª@…V	>rj¡7…íE…æ†gAÓ³^¥}MVpD²Fd7Bv#aî¤AMÆÃ}:avà³bçö÷¼ÎÖáçÈÉ§
+â?^xñg½–í¿`ğ€áË•é÷t2úL-X º±8”»õpNXDËµUˆù^¦›w_	;Ş/Ÿ¬İ›ãÌ²´²’×– G=r¯HËÁ’u“ë›+Ç\?ÖQJ­†”ï>‡Æ•”®¤[UÊé4
+
+#¡;h}(sÈÆB”§(ƒ•9ü„ˆ}¡W"@5Ëªú­s›)hˆàÄŠë'®nUõŞle^cM‹«ì;Ô¶ö…(ÿLs‘!í»U3qÁ¬÷qEºŒ«nÊI£|-XE¹i?£ª^‡˜#Ü‰±Y¤îè=(c5tNã®cÊzôœPédfÍšKw»\ñˆ2œ=¦_âéõp2‚«üÔÅê‚´xoª@5Wˆåš·Ü•I¯|şŸşÕoBbÍó¹²‚ß÷Úş‡$Wôc¢zgKí`˜¼³(Y‘‘ÛÉ,gÜx„ñe]ÆæµML>òº[×å©ÎM€s8¼ gù¢‰†~ìÑxèööh8¹p¼›EÏ*ˆpãq­Ñª]V	ªGn¢yŠ)SÅŞ8çº«„»t×Şeuïz5ç¸ë€w}¯»µ¨^hî"Ñô`6˜©HÙGr5ÇÅ¶ ]œ‚fÃˆ¦†F |omÄ›ÈÇ"æû¶%æ¨1 ’Û<8Ä@@ÁÇ™ê ôg.pä(|Ñ¸<â]²…^fË-~1½<Ówe˜(,‚,´ÁaÂ¥@4¤1ÚlBª©])üİº]á¸º’T"}¿b¡™/è"g†Ç.1‹Ši®p•-†ÎÌŠ´!5!ÍéÓhD˜v¿¨$Ø`CSÓ»^çØ ”†Òb®âé„À¤#§õ|‹'6ºK€ÖuÉ£}š°®—NóÜqòh+‰Ú|•¹%úçù?"zÏ¬ü~F¿Rç—õ§®µ%ÿáü|uûß:wš†ñ"<ÍÖæïîP®ŒºSµ&Î¥•I«áW‹¦_,°øË¿ø½Æäb1µe¬nÇµ±dÿ%Ö2{*]ø.eÊˆo ¶®Œvûs0,è£Õ‡°àTŞËH§l'ø¥Èp¹«Ü€s+hu"³«°óJ{à6—>³š=ë{ß÷S8µ¤@è\™Ì®×*÷’UY¸´íìœÜ>älçÎöğäO
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/ad/cc563af8ebcc3e330710009810bdbcf57e4489 squashfs-tools-patched/.git/objects/ad/cc563af8ebcc3e330710009810bdbcf57e4489
--- squashfs-tools/.git/objects/ad/cc563af8ebcc3e330710009810bdbcf57e4489	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/ad/cc563af8ebcc3e330710009810bdbcf57e4489	2022-01-01 15:09:15.609172588 +0800
@@ -0,0 +1,2 @@
+x…Qkƒ0…÷œ_q©/ˆe¶ÕAÇæ`ëëh÷°1‚&×±hZ¦¿~Wë@×>…œóİ“Ü“ê"…å}p3s!jâRø9¸3Æ•‰p}ğø-æ¯Ì¡»28”3B$ÂCe%ù~şØÎöâ$j6õ+?Ÿ0†ßKÛµ±ó vœŞÚ$©ÆÏ`~­Ø±PÖFÙ_}z»b'•”Ö˜ö£®(yıÌ´Ïj‡Õ_¢‹$»—‰Å§Úâ0ÂƒV#EÁ6ø.£'íxœÃ´âåäpq‡‹ğ…©,tui›ÄƒJ5ÈmwĞ
+0è#N´8hZ¹oåÚ¬2¨¦w,UV›”]¯\‹`©2ö˜¡¼Æ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/ae/6f9747dc5bf0c85ca60ac6c7b5f66ad0df533f squashfs-tools-patched/.git/objects/ae/6f9747dc5bf0c85ca60ac6c7b5f66ad0df533f
--- squashfs-tools/.git/objects/ae/6f9747dc5bf0c85ca60ac6c7b5f66ad0df533f	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/ae/6f9747dc5bf0c85ca60ac6c7b5f66ad0df533f	2022-01-01 15:09:15.653172590 +0800
@@ -0,0 +1,2 @@
+x­S]kÛ@ì³~ÅC9%U©²mZA+9í«P¬S{T>¥ò)Rÿ÷î}ù‹úP?³;»;;³w×´w®F¯¢–¯QÓÅ—¯ù|¹LY‘È>Î§‹Ù</>ÊÉ_‚!WM_qœ¥©\ôj©:^®7o»ú_Y¿¾mïo„Ú`ô~¦Ø÷²é9Øã1`a¨Ç{®ùmT×¯¦y)ğ_µï‚§ ø–f·—#`]˜T|š,¶Çeq@¿4ûœfs<´¢ÂaÏT
+Å¨.ùïK%Ê&•vœYZíèˆÎ»v!4A@H¡‰‡€(Yš &x÷|Ö£4³K†,†Y·¦c\ÅzâCØ³ÃIñëàwÌyYİ<*Îv«š‘ÛdNpÃÍ1_)íëÿQÎië•ælTÙè{Q}Öktºœ‰[±<Ô‰}Š4Gb•ƒuÕä|Ó7jï‹;/É’HÈPˆ(²†<9[\µ²¤€ÒRO’	†>¦‡±Ò D’àr‡pÉ‰/¦Á†nëY3ÿ—<jéEPä§c$jfYĞ»óïĞŸ‘çM-rÙ?Œ•Ô÷Op[y­!`¿§vX>~?+Ì)Æñ1¼‚«¾“~y£‹pY‰:ø.ık{
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/b3/3b367b9e2fd33e30dada4c7960584804a21a01 squashfs-tools-patched/.git/objects/b3/3b367b9e2fd33e30dada4c7960584804a21a01
--- squashfs-tools/.git/objects/b3/3b367b9e2fd33e30dada4c7960584804a21a01	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/b3/3b367b9e2fd33e30dada4c7960584804a21a01	2022-01-01 15:09:15.661172591 +0800
@@ -0,0 +1 @@
+x…SÛjÛ@í³¿â@^œâ8¾´”âRª„\md™à'³²FÖÒõ®º»rª~}g•¸¹€S‚=sæœ™ÙT™ıAoøáDæ:£óxv_-Q¼¾mpHjz=ÿØÂG\Z à~UÂ¹C.¹ÚyÚu¤ü	r[¨³+-9G83ƒÑª</²øØ0›²¶œäÑŞœbĞë:á?lşŸb^H¥d‰‰©¶Y|+?ZºÆn»ÕÏïOŒ˜Òš­» *·Dp&÷ÂÒµ©°šueÒy+ÓŠI¡³scCÁÉd^‡XÅm²ğÁ“İ9˜¼9ÜL—¸!MV(Ì«TÉ&rCÚQHeº‚İ§u“q4,4àÚ0±ğÒèH2½Å¬ã3@a,ÚÂ©¦ÀSÖWCñşa»Gü>ÛÊ uS¾0%[(˜’M=p;‘*Gy¥šzÜÜ“ÛÙ2A4]á>Šãhš¬Fö…á[ÚÓ#•Ü•J²1n¦Ú×Ü“ øî*¾¼å”èb<'«ààzœLy¹p=‹aÅÉør9‰bÌ—ñ|¶¸â½YpWØ~ 8ŞSäL¶3–‘R¹ƒñOÒ±:•¡{â‰nHîY›àı+ƒ²ÆüqæPW(£·Mó¶<-Î2‡6¾ƒ+yA¼i¸^Í1¤?²ƒÏ_‘·‡ŸÂUÈ{\çîà.BoĞï÷ÏúÃŞ—–‹è`§©Ìo&¶[0÷y«E¿yŞ{#Ã(7ëdÍ˜öéèÕ}Foî¥öÜ‡Jû7À—$k'ÿPû’´H½_Uºÿb¤–ş]GÏ÷ìlí<ïyPÅÊOHóklıÕ•“ß
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/b4/2ff927770c4668743ee2fbbb9fec69588b6eba squashfs-tools-patched/.git/objects/b4/2ff927770c4668743ee2fbbb9fec69588b6eba
--- squashfs-tools/.git/objects/b4/2ff927770c4668743ee2fbbb9fec69588b6eba	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/b4/2ff927770c4668743ee2fbbb9fec69588b6eba	2022-01-01 15:09:15.609172588 +0800
@@ -0,0 +1,8 @@
+x•VmoâFîg~Åô*QÛá%	•‰‰8¤²BäCm–ÆØœmª&ÿ½3;»ö:@¯½—vŞgyvƒu@çªsõCÛ_ßnE˜,D+§]«ıÅáz·ğ©¼|ÂÓåB,a>}šïó[o2pgãÉ†úğmã+Od Ö™0¤­Vÿ¹Éf›Š,kŸFı¹Ûşh/¢e­æDş’,¼[ø:w“í+\Ã;ş=ÿûö¸€}·¢B¾
+•Nõ.äRîr‘½ŒêİÏİ›Z-İ
+*)ËÓ]˜ÃÜ¥\¼Øõ×ëÀ¿z›mí½àU¡Ôè’túæÅÓ<şı‰Yô&æ9LñW·¶‡Cç˜Uç@Ş'Â_`8ë¯$Z€“+æ“8ËagÑŸ±X@øâ§à8Án¹iC:Cal™çapÂ Ûb“ØÅÈt›&!F,8e œôd0}Î FŠ2:<§/x†Ã ÙÓU7{T‡¥ª°MQÔ©cëüIL‘P¯D¶ÍHiÌìŠÉ£%X•CèÉTHİF9¥—ïÒ,l±=}ÌïúŞ,uXh^CÅƒv+ëº¦âÇŸ+®TÕ¥[Ù•=bK0hË~MÕBY<B÷.ZJœ-‹>ez¼î]²^ìRşnÈäõ®h¥š*X‹ê”…\6Râ7¯9F‹âF{å<I‰ÅÉ.WrV<¡ì 2üˆvÔéƒHƒ2é¯×	ò.Kü(f>zqŞ¹DwÔNe™Rí
+7®‹L“zñ2AxÒGİxn@³w¿Û<P—äNeğã5\Tæ@Ó¼Ï¼Ñƒ(AÁ0•Ş¿o%#cJÚ’Í(•ƒj9q”,“¬,’ß±6ø­°®¦ÜEáÙç¬j?Ã-änØ³èr ƒ¹Ÿ
+¦¼lğmç¯­ºL°ÙÓ<ˆ[ÂLh“ßwü_¶—²f/*¶LŒ“(¶ZwÛŸõçƒÉd<a»X“ÅªZ©Tvİe‡¿È`Å4¬4êô©‚/>AA&Şıø3n(ú}èã”ÜQ×®*hB„­)]Û’>t?Ês¸Føénük?¸“†eÏˆuÔƒ¦Šzˆ}éLW.»»b$­°»¥Ôë`ôVggX¬†…(¶ö9ú‚tKWˆ&’ïåO¾}éû‰IšNO¹$€’‹Ãª(n9JÅ€¤ªxWÒ'#?ş„á?Í#÷ÙoQ}qsÎe(Ïæ[ğ—V`Ú¦¬¥G~º¤ÓÜGîÌèg ŸGQşs~€M‚Ë_šWç ¹fêÙ°K‘-‘ƒè*2è\6ƒ)³-ûF‡xKìÖ9‡äLÔné“Pò À‰zÍâZäC½lEîé×ˆ‘$QşAKw«E—6:–ïÃşÉ’·3ßŠ4DfÕeŸZå	İkHêÍ^yÔòr±ÁO¶„º}¨áúH‹QşjİË[_Ål KßåÒ]> ×ˆåbÔ »¸•š=yOÉä95jÉÛGŞWÉ’h"¡Ê+A)°>˜gã»Ñ`„âc³D1¾¥ú·Œ
+Ó¥jdë6
+ó(‰ıô•l„áğ¥*ß" Å¥ÿ®z{DÕúğ€<ìMQŞñ\*ŒzÀHTg`ôÿ.Âì`á®2ÒJÿ#šÇ˜ÍJìáË!Êì”+ış"#Ş6gF«RæwéœØ2ÕO,‰a\ôœô5ùâûVî¶Í¬ˆW’A7¦±¤²¤?íæŠĞşI¨r‘±~\±âeşş@*]©àõ¸m‰Çê¨0Z=‰ê>—¯}•KT
+9iÃÍ§Š_øDş W¢âÌx=îkÿ ¥º‹—
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/b4/6550cecc180e843118c6c175d3e9165b12e302 squashfs-tools-patched/.git/objects/b4/6550cecc180e843118c6c175d3e9165b12e302
--- squashfs-tools/.git/objects/b4/6550cecc180e843118c6c175d3e9165b12e302	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/b4/6550cecc180e843118c6c175d3e9165b12e302	2022-01-01 15:09:15.669172591 +0800
@@ -0,0 +1,34 @@
+xí\ksÇrÍWğWL˜²R€$ÊøZï¥$Hf™"‚Œå8.ÔX[vq±€(ÆöÏ9İ=³³€R•JârAÄîLOO¿»§WÓâÊ|÷İ×ßüÍÃı·ï^,Òd™ºÄ•]%åd\ºq6MËÛr™Î8w1ÉJ‡ÿ7É®'Ó[7,fóEZ–éÈaæÈùô–p¢Yø*‹ùí“–®=Üs=ú®ÃÏ?ñóà‘|>–Ï¯9úí$›N³¹;)V×“táÎõÁ_<^ŠÅõƒÕûCƒ.ˆÍÅõ"™Áñ"M]YŒ—7É"}ân‹•&9peår‘]­°Élé’|ô°XpÁY1ÊÆ·|¶ÊGXp9Iİ2]ÌJWŒåËëÓK÷:ÍÓE2uoWWÓlèN²aš—)§'¥›óa9%®neÆ+âĞ7Ü«€“eVäO\šüÂ}H%¾»Ç‚(®,‰êÂsÜ~·n
+†„±¶ì·ÚÖÈe¹,?)æØÂ ±©Ó]¥nU¦ãÕTÖÜOÇ?œ]^¸£ÓŸİOGççG§??Áàå¤ÀÛôCª ²Ù|šac æ"É—· 	1~Ó;ñ¦=?>9¾ø™;xu|qÚë÷İ«³swäŞ_¿¸<9:wo/Ïßõ{¡>¨‚íÀvšº1€ÍŠEêFé2É¦¥ßøÏàd	ì¦#7I>¤àè0Í> ·²8'f²ùí¹n2-òkÙ&CZLp¸lìòbÙq7‹²,Vœ^±²ã¾ù“»HAÔ½&ÃÔu]Å¹_}™~^”Ë"ï¸7GîÑãƒƒƒîÁWş¾ã.ûG~;“årñ`¨wvşn”³<uç—=w¾¾::é÷Ü#¼Ïòát5JİÓU1=˜FÏğ +nË‡ËÛyZ®?.—É²şt<Ì—Óú£t±È GÙ"Í3©Qùu}*°™fWg@G7Ä+Ìw½NÆ@twÓ‹ò&™×_ÍŞûYõç?†‚]‹ú(a8ÌÖU"/vîÇ–L`¸er®‚/$´}8In_Şôİ3wzyròÄXåevC³|ét\™ıKê¹GOvd‰dHó°Ê#«©kÁ0$kKñá`È9 Q[‰È‹ÁÕí2-¹BÇ|îŠÙhmƒ`ãj¸– [À@Ût6Ú¼ïj»ÙHpÑİ–PÏÑd­‘«ÔÅ¢í@s–ÉÔÏk ÿmä,ï¦gÙ èç­´Œ$‡m§Fåô^Õ(O÷!™®`ãV°¯C:^X»tHÛIƒñE)³tûœ0¹¿|ûÍ7_}û«b»q	 øYğ&¹mÔ ÓŸ;Ü5‚†dJ[Ì\¤‡Câœ~„·ÊEòB¹Wv`Tß=ñ¯ÄöÊ‡p5<'İÆ£ğµ&‘tt`–‚¡›Ÿ¤Ó9åêEŞ_€_²Xºët9€ß—«Y[½Ã=t ¬¦Ô2p/ ÷¡ ©ÄMFi¹Ìrqím™vh0dì~57¼Çº(²á@‰UQ:¥6_¾T@H®Y’_OÓ€pqÁÄTÓtÌ<YNòd–¶M¶`Õ0ëHÒR­ÑdŞ)‹hËˆÏXü Éüèİ€‚2@„ò^÷Ö´3å
+|\M‹á{AÀDhƒØ“M"
+
+(ğ†´ØoĞÇ¦#:gááùÚ¯_¨-Şhs*Áê OX×äo˜W1ÿ$ÚŞÎo;-ÎË §%¯»‡ˆª¦¾…1ÆÒĞ¡¶Œå(z;7PÇ#ûõ½³ûÛg®{€àãşı=Ğ­:êûsL½WÛ@†´ZÙ˜èæÃÙ¼İD¢ãæİCÒ!:Ó4o‡'{{î<Æ@´®À§÷ öĞ¼Æ*zŠ™­cûl®êî‡µbrc›
+ÂÕòô2?e¸Ep9ˆØ,Òå
+†dFOv8 æàš´©©2Í ñ"ÊB
+º8Yn ¦T[)L-‰Õ æÿtÜşl”ó:‡``Ïöçxn"àÙşö®{§uƒ&m52@’S.et»Â’¾¾‘\d2‡>%ÇD:ªGî‘»wÏIFê]ô/ßÚ¨Vïüüì|Ğ¿@ŞŞ­Ö‘ÈúXGDÕ«¸]
+B«µ+Dd<Š^¥Ã¹‚û¢ÜíH2'ôÓà™„TmYyOĞlÙr½wÇXQşñu^0*ÜÕ×pª±ÑPKX¬² ZÃ¸a–Lad»~ëÑ)³$Œˆí›Ş›ì¯‘€&$zæª]FÔŒ`@ @K\éÈÊ”QI1RÄA%0–ï!?zİZ0’Ø‰]/Ò›?#=^Üºä:AOHš‹®aE)jµÒ)ú›<ÿÅ›_ÀcNl‚ƒa§"’>Áƒ§ñêÍš9ÓIªtâ&ü®wÌä}Ù*)_1suµU¡o h›X˜©Q5Î"(Õb¿xëû,¶ÿ÷j°[‘‚¹»/V]ÌèQ4Õ¬Vk	|º¦ãªíİËYjqœ
+'SÌ¬A½ş9ßíÈfë ‚;Q)Œd“$îY·+BK­dİê´Ä¦øSø<YqMQÖà+z”æØ.Ñ
+)°§Aƒ&Ç/áMã]hÇ‡Åi}šf­ë)¾B!Ì¬’§ƒFèÁ:Éƒi¨3Í†FÙjªÿ6,fN*à³Æ‘D,u™¸ÑºUæm›e«›¶Ø¶}˜´v!ÛÊ1nö<Ÿp=­Ï‘„5Q;¨DÃCyÒ`„9¡½™‹ó£½¶úS[j¬AÉ÷ÁŸB:f$¢ÂW!Ë®†î‹­CncÅ Õ,€hè¤Èd˜óH$|ác‹z‚-§´ã±yèÛPµøŞ‡-İnæCôzR·G¹«£ÄùÄ(š°¬hfï…D`@âoÚC¤n,â?•;ñ$«1 ÿYÜÂ¸ƒİwÃ>è„ŞİC%Óé‹;u%¤¿çŞ]\œşñèä²78;“°E°€'i¼ôÿ©
+0>°Åéo\+#†.ÑCSÅˆ"sÔ!ÛµÜh‘şUÕqUê¹Ï„,Hj#%g‘0W“ã¡T™¸Iœ´X÷-PxeFèëXZ{jT¶¤¦…¹0—ìö 6ÒX8.¹@¸úÿpyÔÿáUğ¦wqôòèâH(£ñ,èkÁ™P±«@µşµçŠ©h·7CpOŸ"¨ Ó[p¬Êâ«xõHDz]S–)ô»€lNöô­Ş cu ‹;±ç„/.J9åµ@¼ I¦Uï»ç'g/~œ½zÕï]ˆ¡¨Ê`-—a›w+¥Ÿ›˜{G¹wš¿ÿÅ=úøÅG³½ıRì¤Øƒ4Z£Â·Â
+ıŸŞú?œ_ôÛ÷t€§¿²¨¶§xÉéXªK€öâìÍÛsœAô^Šø´mE0&!ÌÒÙ¢Ü)Rı	fM …<±è¢æ¿Yr¹Hm`„f$’±¦_½¼\áäƒgDé—¥Ks‚9ÑNFO<šªÕEÓdÓ.Ù„×…»qÕkB©¢¡OáˆÕNøD5Ó1´ëœsT3¹Í–|$d˜ÆöÕÃZ}š6–é ĞÂÑ€¹Ku”¬^ubPFKîM,\«%¦XµÛÁüíÅöCìÃ·{î÷yt­=CÂ<u°€Ùâj{–xt7™jÄ/ÌcB¥UJÔÕùd«‡/Õ-EÚjXâ¾ÈS-L­q«n‚<`€GëÍsP_øtĞ…ÎÆ¦¶Œêù!¡ó‰^ù‰äNìjVª¡ pQ”R´Æ
+,è°üWï:C!*?¬•+•ØöXS@"7şË¨xD%Nµ…úÇÍ
+ÉWÁ=ğ_qlËÁşÁùÚ=ÌQ¯ô>Êéôî¡¬S²*£IÑ ÊÍ@ŠO–›¯'½vƒ•›”…2mhhÃ†¬`ã#Ha	•“7Wˆ˜úZ ±ˆ˜š0¥¥8I¨tíILş½z¶Vÿj¥5ºùà›,ÂkãY©¨@šó":æH?"ª,µ
+cÃãòbÀ}yêu˜ÜT-sCñ†¼|õèÑòÅoB±* _ÖFàØ òÇ§ˆ_$$ŒÆR¨0n]±àÚC$0_‰hæÉFHbE‘h==ºÛğhMt]®0#æ(ìÃ¦Ğ–|VŒÌğ¼ òò¬]ß¥„{Ò0à£QCˆò¡1dô+y…Ä®7Ù’fñÊšvËĞ_šp·*ú‡XÓ½¢kÆíõ‚N—$’]i»—kS˜¢<´¨ÇCÙZ¦¡òe *#6?]WƒKF8í-Ğ0áÏñáû,Y¼GçŠN„w[e¬ØÊ©ş•Ç,czÅ2¹t.â¹å=x&Ğ(é¶(ì$ïBåÕâùÉjJ§Œ¸Í—A^TÕ;ØÌ{„L<NiÈ ìUg-R°à
+Nî†¡•R•àeJˆhÇí÷µ|mòÆÖ°ƒ]ÂQn2Ÿ§ùˆ¤ù—8ådcPµ°Ğª%wöÆÈ#à™æŒnİ¼€/}wJ^äİæH©>ÃRzÎÉ!3d4–<‹ñª´ÛŒ´Fbµ™õ‰ÜÌÌ<„Ùœ“g#Ï™çÛxè"à5®´•é9*Ó¸7„H¾	_CÖšY¢!1w´¾ššápÙÌc®ÍÙŸZ´"É3üP“¦ro- d#q'îÑU [ó*…Á†é‰v=¦—È¶PX©WšPA†Ã9úºÈæ;ÂPÖÇÇq å½TAæ¥ğaI•¯é„Úƒ'tÔbO'5ŸØkÉ3I?Î¥Wwáhíõİptp2¡¬½œQn·ÂŠåDïÓtî–‹ƒ-^l¨l¡ªş)]Ä}8ë‡¼µœi­«@jş†„î‹²g;£DöÜ»»{0·»i0,[;;•¤ë‰¿n¿-½¥ê¢=ŒØØiV¥ôL’ùÏcª<¯ª5 $‹¥¡+­Bxo‘bCMT&00é‚jI1ÎæXøƒ8Ù7›é¾şW”‡|€ıÿE p¶‘@@âìó°r¤µ*ƒû3¦Ue—ú»ïc\äß]dqœKÂá¸µØÄæ ÿ-%UHÔ
+¢-ÙªfšØm¾%7ÍÊı$}§¾¬NU9yVUµaùB*gÔZÆ#ßS×}­öE@ÁÇ;û/T7Ôj™‘õÑx)]±h³-KXK	šd¬ƒ	h†É&ODÛ¨ÅTd6¤â§qÚñËvÓ¥d¿Á–£ŠldpAÔÚkAd Ã"Ã‡›×E×òI¯}O¡Èzfİ6õdU8ì‹cº+ àûñdh”‚9¶XÇÙ²RMÅÚŒ¤1ÉÒhÔ¬¹üü(*DDêÅè;Q0ÂŞCfùŞ,Á9xK>²‰¥òŠ3kfxlNbCğ¥9œ8SÉÄ4KU4® ¸f?6û¢ÙÔ‚u&w<ûîúüNàd#!CÃiÑ˜%B€4GÕWLL¬KĞ­òR×ŒX7âz”bG^¬Z¬òé é*Ùç[«µÑ7Ì$’ÇÆœÌ7 —	:‡®1¸p)4]6%“äÊ+l®
+È½„$[àÚÈ›ğ.t=õPXí¯cš€²ª ‘XD#Ty8öPR™DüX·cÙÎ–I.f¬¦K4ìÛTRK£«>\,İ=ö4]ªÏrF#Ë¿¼•ŸH™ #
+!Våè);Ö‘òÂ 0å×
+ÀE„İuÉ> ğzÃİ†Zoóœé©0-Š÷«¹%mØišK+6·@\ŒÀ]	Ï Ğ*ı¨;ÈP+ÙU´F:Á"„Åuêò•ä„D^¾Md²D*±Ëp+"Ù¢tÑ¶âf˜‚Ñ?±½ËñÖË˜V*æJÜ¡3ğv˜`ã¢SWnÆRÀşpqÃØ–ÇÙ0C§(—
+\	X¤sŞÜQ¸@NÿÒD]x\ Ñæß8Ç<¾SÆÓ#ÎQ™q[$ı8Dª|˜Ãede>d§ÌÏÁZ/=¢ ú­%âÇ§'Ç§½Á›£wlÓëh$mÄïÑZÚRIvğ*ôPšÙ^÷.‹Íå†ˆÎL®Ñ© -übá»vˆË9­d®k•éRjÒ¼œ Ô¤ÀĞşà!®%Éb¿ÆÙÓÃïL´Z-s`aHH–ÙJ©Âİ¢á$ÃÜ‰’ÛD<ÊQTqÃdBÖLÓ±H¯`1£|½«¢;,bs=X«ZO!=på 0·¬ïtcíŞ[yå¤XíÀÔ%fæÏ·=68j{uüéÿøÄ¡ÜAm32J&Ú2i«j¹Ã¦äHµLÅÌ oª¹À«¶¢Í!ÆbõOQ§áÓtNAÃc_)2‰“©±…Ü”=
+	 xOŸ
+lÏšĞİ¤_BòQÅÑkEH”"´Ğ¦Ùœ$Û«ªå!±>€Cfz¥“B·€|sËÕÄ°!5¹&e&wKiC784o¶š‰-HùhE§‡	»ªB[åk(uERöğ™3o@s{u·i#‚¬Ö7ŞD±î©µÊ‹T¨JD[î®pHåSã¥&'ûp’ÌD›%"Zõ¥Pñ¦‘ÂY‘ÊŞt1Š]ˆrÍ<Š´dÏä$˜áÀ¤ÂŞ”˜*y—
+Zœ¥b|·ª¬ùšŞ–.4SjZ~X¨FRÈÖB"”WÑñgl®
+€ª$•JBI‰0´6ƒpo¢N+aäGÖ$"í”†NEà+;í¼Da[€ô@+éã›±…ÚQÖ ÁjßÃ,ƒÚ¢ÉÃüáü¶µµÕğ³hÑŠ›Õ7¢cÆ"»ÿª|~0&±úy|4$rÚÜ0Œ¯Q9‡ÆVş…aÃôd@>I»Op#¶ò
+ô0‡•…Ò„MàòÚš^Õ¦«ù®Ş™¸Ïùï6ñ³wzqşs[O)O7°TQ
+ld€¾K±‚7^ŞY5Í«É<“#C‘ÿT½ÉóíÔêhoºŠ…y+¤MDXêú¨“³Ó×~ M¦©G$š–p}÷µÓ÷ÊD'(ÿ7ô˜fö\µ…
+Í*jõŠîû(Ç2>N¨ÿ&]v&!ï%!…íğY;Oe|Æ®™õ(>9w«ü¨×BNL5³Ñû ËÇ…Û—¿a:m`÷P`¬V{i~(ğîoÙPZ²m®ÄC‡R ŠÀ’9‡ûyî÷ßİqğ¶ß»|y†¢0B3ÌïˆãğW÷pQKŞCw$t`[X$•†@2¢KÜÿuœGA&wàÕöÓç°X`"/æW…“u>¿D!®é@Fæ«ANàÂaîev•[ËUlı¯RfS€¤G{ò—/&J ‘å]X®¡–’Ò¬TxÔÍT¬¬â-sH¦Và’Ç˜s¹J.7I±3(1¢úˆcJ5|?l¿Q€v2¤¼€×^P„´<X"¡bTİçïäéÀ‡V§2Ñ+MOS»ÔW>ŸV­¦¨äu øÀñÏäªV%Š¨œQ¬»0¸U^• yÌÂRàštÑË¶®¦â$C7>p{-gr€‘=gJ±o¹œ•f›FeØb ò‚“~¯Í8—•¨ù½°Œa £Ò~sŒ›¾sÔ°óTLÒÙb³9ŒUU‰İîT|P*P°‚ßúúz»×8±õ†#³\ÖÒîx#Â%xX5Ë•Z6.…]B@’¡Ÿàö(~2„q¿¤Ô•h±–ŒŒ›¿ê€Zµ¤¡CH¿±f«.aœÉ>n—]K!ÒK‰PŒ–#QÌÌÕëe±İç—¯QÉPÁá¯(Låf ’É¼½
+Úf
+Àø“è7$ÒB— &¦Ï§®²Ok¥æ£j\;ÉÅ<Täh t”m¿½!µ$=¾â5e¼½¢ŒânxÑŞûq<HÃùLè¸†‰»vÀ u æë{øÊJ;€‡iŞ¼†¬=‹tæXğP¤Ñ4®\&:RDD;wƒ²šì•¾°/Ü¬…ÂÏ³ÈÄÒ†FŠñ
+7H!=åàäV¸üÊ(•Â´ĞÂxÄv4«ÿZ€]MŒÙÌÀÔ†m=æ·@6)¿îà[c…Ì„Ûø)‚hU¥mD…¦€qGAS$o•ZRí÷”©´!Â¨¼‹G³.….¹CUˆ×¤Ğ«B{¸[ #‰ƒpÅâÂ¬É‡¬=4"m]\z§Q—_-ªNeœŠ™SãZÌ²*âq‰¾~
+‹\
+Œ©vn\úW3Ø¹]
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/b4/9cd76b294da4e71423fe13a1d28edd74cfc0f7 squashfs-tools-patched/.git/objects/b4/9cd76b294da4e71423fe13a1d28edd74cfc0f7
--- squashfs-tools/.git/objects/b4/9cd76b294da4e71423fe13a1d28edd74cfc0f7	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/b4/9cd76b294da4e71423fe13a1d28edd74cfc0f7	2022-01-01 15:09:15.601172588 +0800
@@ -0,0 +1,18 @@
+xİ\{S[G²¿ó)&ë*—R‚låÛ)À¨ f»¹7¬W%‰#s.z]éÈÁ&ùîûëîéy#dëî¥Œ9šGO¿§»gzÃIÏ´Z[­ÿü¯ÖÍéÇ£||sV|Ù7Í¦-†E^ÜÎ²îMvcÎºEÿÖĞŸÍÌ`23§?™îğİd†!£ùZksó›æÖfssÇ|kNĞl.ºï‡“÷øt±èó¾¹™ŒºùØ¬µ¶ö,÷‡‹›Ìüéôãqw~ûåíŸâF‹5¿ŸäX¼h÷;“ñ¼˜-úEí@ZÌú´¾ö°fÌ´ùêçîü ¸Àõ¥9êçÙ®tôç?vç'ã¼È»Ãücu÷á¸Èfq×S¬ù‹;êùğ}6.’î~wÜ.º³bé  É²›ÕC&Ó©ÒÎFİéíd–%KfYæú˜û”Ì‡ÃìÆõbì¯1[¿ÏŠóì¾ØNúw%ÎæSáã ˜4Ng£‹Ù¤ŸÍçÙOŸƒ÷[ÄéÖI¡D¸g^L¦?Buòñ»R_vŸq£°ú2›gE¤pQe‘P26¢mDrÒé?vóJğ¿@uÂ!ü€ïw‡í¬_ä“qç4ë¾Ï±şœ%Á$²ÚUèÕÆmlÛœœ:—Ù0ëÎ³-†\7¡å;ä%i“"ÌX…ƒ§	ºW³ìŠ·`­¯Èl´˜¦—pºe $*MÈÆÌIQĞL¶Úo ¡¤g=Û-3úp¾9U"Å+©ñ‰´òk¡°nkøL’5QóË/ä"½5f–‹Ù˜  /VB¡X@'ü¨ÿN¢E¶Z¾XRtÖI–µ>PêŸoóafjÇ66Ì/™êÓ<	OÔ™P¹Vcjˆ¬Õ0^§>¡ø_gK¼7Is¥0=öe]¬M½ÍY×¡¢tÂL´@Y»Ä8T¬?°%öi;†“¹Ø|ĞKŒ°ş2İt<©1¾†™KÜÇ’]f©$x<"Ÿf7'‡dâ1+»UµBÉ{ğeä)Uò>¢X¿´9ƒŠg7"ŠÌ\œ¿ù¡su|y¸÷ºv_7ÌFz‚>oÖ­ÙšöOÃËË7—vä.4o¾ÎØ´áüÕQÉJ­ÀÅ4Ìb<Ïßá“jgÿİi_½îìšuöT{773laõ+ëz½aäaÒûŸ†±~	nH¼’ÄVÊ,’¯ºÂóÍ»$¤ˆ°Tò$]õÂ¬Ãêvb±‹6§ÀöÅ„7<+K}Î'Edvá“°Æ#>BæIóµù-D³BJF DL£éZÃ8Şõ2>Õ b…l˜Íªô]Æ¤¨ªå{<Åô²ßY-j¨`¸^AœSLµd•ÿ‘*Ì½bÖ©ªİL+(
+¹¦0M†}²¶‹ş[@ÎÑ‹k–MF</…lA0Ë¯’ºúŠ»³â¬{ÿ·îğh2;ŸÌFÔ›Íû#ûãG¾><ê ¶=F3oÕÆİQËn˜.Gmuówõlí:Ğ<{fhh­OÉ†ÙÿPdÈ2œ˜NæÌ´^aıÙ‹ë£gİùkX¿¥¥İGè1ãÒ0[ôg}ÂæÁb¶ËéUm—ôÇ³ô›Mr_‹€¼ïDY{_ß5S“FGH€ˆ`27MCè]ó¸·»á@SÌ¯!£Cö)÷ê&l˜º[_[‹»ZƒÌázó­ùÅÔjBk}z½õÖ¼xa¾©ÃË*¿€€>î0Ÿñÿ®©GkÛ×ô­ù‡a`ÿ·¸yî@&PvKØõ¶±°şº^_¸×Ğá¡G€=G¶öÖŸWÿú7aí	ÙB¶“µ$J?†‚ˆ“;ZŒûğ=”òS*ÍÎ
+³>*dïóæ
+A=ÍW$=JĞÉ1Pi ¶uĞlÉo åTqSbª$Ğ"t4V¶$™,¨Kº(ŒâAñL~w–YnHèÈà.?ä‹J¡4¨.7*ÔJt}d%`{ØBît\›´úeCÎƒï¬Hlä¡“…Œ £sœûl‚|t4¨+A/´R†ØlVèqåK—Æ
+b+&¨äÓ)ºÒ^eÅD…xÃÿ^Lr*Ã\M³Š+“9QáiMauPñˆ*qBê%@:ù3ñ vM„¬i¾DN¬ä5®£Ç|^(£=a<¥ú“ÊÁÖ.¸`Â2ÁATE>¦Ü_Wuúæ.)B5ˆÊM¥p‰mğdp™ıï"G‘-–)EÒ£ñrn^™ZõîŞ4h'÷Ä²l£Š·D·­³™/zdCTà(hb™Û?û@ °%nEÊ£|³ègoÔœHY˜K§¸`d»¦c²&7ü8Èï³"„ğ½5`Dˆüƒã©ÑlDövëH”û‹æ×jeÇ´±A{–eß¹f1´`İ¬k»c«»[ i!ğÙ{Ö±¢ógˆ,ÏÁí÷/M«Ü}ŸıfØC²'ğ¯>YÆ¹æŞuÅÎËïHaÎ"†ˆ{ä%J¤bz+\…ô]`§ºF#c¨dr0ò^IˆôØ¨E¨`—îã²G,D‘""j2—âÂx]Çâ/½¾)òx–:€³wŸOÅõŸ8£²Òì_}a9Œ(wõåI¸ZØ*¾MÂñœ’†S|ÁkaO¶M<ÍG\,¡5ªYë´/ÁÑ4ö ÛÿD»ˆÖ…Á`ßzíÙÆÆ[’m;_ŒöŞwó!Pó£*&„yÎáhZ| v‰+ÛäZ¬fAgGgWïÏ:'ç§'ç‡öTe€rŠ‰{|6tşF£r´×¾âÈÚšÔ]}/¸Ï0›·§YÿÜÆ©f˜™f—Í°Š‡;{1k˜ƒÓ—@b}>7ØoYÜéèã~
+ØãÀDâİ”EÁ¤G€Ö;7páİ1<ŒQ÷ş4§yÉ¿a„¾!)Š›0gïk×Y%¨¤Hp{3ÖøÕN·Dç—VGcGtæ‰—s-N©¤HÊ’i1ÛÄ p³kİ`åPIëÀ‚9[Í!5³x@H´jx¢‰`;$…hîô-kƒ¹ÂCê”'ê
+bkâ‰[ç&]b•zš!WÁãñ% Z¼L§'‹ø¹¶°‰şw±ÈÆ!´8.ï8×Í)Ä´Ü.³»i1¢]Óâ£™ÔÍwq¡‹ÍM¤O,.Å&4ƒiË‚%Ø5®ñ"B%õBÄôıÙ\šóø\bì]£;'Cägİ²”^aøÆÆQ Ä5=n¦Ëg“ ìùAiª®@cº|¡!ƒ"yè,«PL¤‡éñ†¬qq™Âi ˆP®°d˜H<CÜ"€SÊ¿fB¨nM¡#XB8^¹s+éÔN(×]“v¿¸%”ß‹ß<™ØŠ–µ BDı‚,¡C¡H<Û ÚÉh*Zö“ Äk“ÃP€µBZÛ7ê0»®ÍŞ	$$8¥uiuú…£ÎÈúabÒ
+Àò ¨YS‘hL%5§,°,ï‰­½Ûğ ™NAüØ(æáR0&UkÒı
+Î–ÔlÒ!‡4ÖnX	„Qƒ-qò$.r>ËÆ7ùÀî~S-Ç>nWòz.{‘gƒ‹^°bìÒi/E#Ç§êalL„0v_õÙm5ùD‘Ùo—ÿ[Ì=ÇX*Î¹ EC"Ïòb¢å`Ñ´Ù×~­Ã22Cç`Î©NĞ)&LşÏŠŠQõŒIğƒ¼<?6tİ'í¢<Xa>EUTÙÒŒ4ñ•­/…nK±IT‡Š,óÖõÈ
+·ªĞ¨;p b™ÂA·³²U1úq”ÄB?*tõû<7r2ú*"ÆCÒ•Dh2,iÔ)Öİ²X-[)ÚRN{vÀ#È G“QPu–bA«¬‡`€¥y„‹Ìyaè¯_Üğg€ân]PZí
+!}m²ñ¦	› º~Ú§.$6æY>@µ™‹ü*M‹|áŒø‰@-‹J¬’óË×ƒR§~Ø1D=şŞŸ` s«Ş5Q¼¿E»(K¬a£;¯u¥|Es¡ú„>Æ#å )7yLÈabº4FÑ¾ åãYOÄÎCC&?_ÇñPEÁWÇ= Ói–gŒõkiº¢	EÊQ}Tº}£~åÆkE¦!ó(!‚”}xÓÄÂ9…óûó»¬=•üæF²w);y—pÂW½¦4wë%4–õs¡:Q€6i!á!àNœB.èÔpÅñƒÿ½ÈdïQC[‚í†q#Ä¸b©¸YÔµQTÌ«†Q3wêTr*‰¢Ùİ3l%+ñ~-ì¹`€.&åŞ¤E–&jé×É\Jwê4P‰àsÑıâ©¡‡çt"äEßáiWFÀ×İ''Eso@6İİ#µÑ³"¢ıêKîi=°¿KËİöœBÆ»#
+ıøcwÎø§^ "úğ/Š¿€4Ğè¢»µs)
+í%=J¥A8í`" ÀH¨¯¨ÀˆÀ
+‹£ğ`šK×áDLút»óµjŠµ+”I_„ÆU9’ëTÖ›‚İ.ş¦\¼ÇU)ÖOìŒvuÏ•¿O“‰=QP!X›Ö‘LÜ•\_&Ü/>ë¸QN©ãeõ‰]eeE„ÖYÛø·;dôDˆìÉU\‹N`§*ôFÇ¦œCŠ¿óeß¥‡<20ô#ÔÖ<¾8sP”=´ßXD>î~‡Õex!q6Ğxİ’¬ÌõZ‹›úÆ°r„¨úÕF‡Lå¯Ï²QUwÒş¸7„ê™u\‹ô/~l¾¢i5~wOÆ"Å¼z]w©¦ÂW.l‰só–QpÄ§	š’÷)ÄIšk/ğİK4€â.9+>Çã&2DnqgMÎ±Öı•øG.»¹Ã”SªÀ!ã¦	B:ºôç.õ…wúhYïVZöRß”îÌÄ]µ’ëÈ9].¿I×W-z/¿¿À·†˜Mİ×‹ÑèÃõæıÖ7RhÂ·ÉÕ+±ÿ’OhDøÏ»&‡õÀµa³ŸSY#°õœL+\»š²E	ø?h_÷Š5Yî{•¸àwõà°Ô)î²lŠ«n"¯}>íêóAêY=gíQ–¯²•PµíÅG€5ÑNæœââòÿDı´ƒ%µ8`Œ
+;ÂbË!w¯ôbïrïLa„f	B3ğ+Øà×åQf½n}L_-½–Æ†¹•Î`ç0˜É@ó1ö.²¸Õu,´|ŠôÙ!£Ìxõ8¬A€é!VdKtFôQ`T!IŠ—E™æGsY¢45=8UN~H°cµÔÁ5bV±B©%#¬‰/ª–&3Èò½×šúz}“˜ÛFôÙHÎ`a–ï®X2Ë`‰ßlD†éà„Î‹¡xÒ=aX'Ş²8 )‡™|kÄØİ²ÍGîæ+¼éQØg¼TÁyÀSìJö"eåÎøT«bå‘|ú£Ÿ´|Ãa”×+7Îª(>G#ô9{Òk3ŸrˆÓ<‹KxêKÑ3üè±ò>AjçĞ‹<&Ğ18áM
+ŠÖèV†íÚì8¹›H“é~"% ˜L'Lö~ÄDß,	ô-Ø8(CZ a“5åô–Ä“më±)Û9òAL2dY;LÀ Š±¼ï–S³¶Õ»ªğ©òÆêšÏá¤ä²)&ôÒ`0Áû„ôÚWµG€Ê[“„TÖ”Ûş…$¾&Ä.°'ˆ&ĞÁæ«26z Pi¹ÄjéúŞÌÂ,+ŠJ©6Ğ@T›\ÔÇ‘v±Kp“Åy“¹ØY)ÊCşfÅ>½é1ã]øe3M “P-C)ıˆ¯T‹W_¨¼çÎVƒR‚µ	Ğƒ¥8RÜ÷'•ó©HdPYR!ù[=ÊàùÎ…z	V1Şæñ"=œ<=•OÃd¯;t~©…GÃå3ª+K„h÷P‘øO^Fï…|xÕ9?ü¯«Îşé›ƒ:'GËÃ¿üõäòğµ+”U¶Ê¤Ùy×ËFúE4éİ÷HÕøüÆò»ÛfÌóeê¸Gµ§3!ÓI€ËHrªO]å%õ]c¶e)¿BÂÉk„#_ÈÍÚŞ~Ìï™Ôï”DãBÜ‡—ùşÕµ-9Ï£§%[ÜÁkx~ÇwG`´îQ¡¡@'	òÄ;‹t°ò#uáºĞñ^û¸E·~ğ™~ğĞ˜::¡Õ®=v|ô¶a˜‰Éd6 İâó\Ì¸®á<ç¡ƒNQ÷p C¶»Ş°ùV&=Xô<ÿøz€»ƒ—´µ8·q¤¸â>…¹VÚ®Ì¹LºÛ¿¿t‰yÛ©¤q$bİDö‡
+}[„^%nQÿ"~‡ªªÇİQ~¿}º8dØ`Y]°kŒ(OXóR­€Åƒp­€ôÃUZ™_õªF§eèû%s:!ß+é)zŒ8ïŸØ«:­D—ıR|A–EO¬Iµ“€ZHŠVªÎÛ>².n#MÍqûé<ÚÆ9E•!
+c³ˆ'­)ç$Ÿ¯-5À¯Ö‡õvç5ARÂæè-sç_e™;¹cÒ„ğ'0$ÂQMbû‰ö©ãwÂñ;Ç±=~{&Ü¯Éè—,øÿİèy³\é¥`ıxÌºí·tÿ¾OåßÇ[8ÇTíQ_pÎªŠÎ!¥ì`¿(n©äÙdÉR>Ñ£ZŞ:Äš¸ÔÄ¥ú‡ñbc¬"g§Â¿bËzâ¤„vÖÊ@É±â/MˆÙ[Ëü4}ƒ‡¦'çx?¿}Ø9ı©sñ¦Mñ)û}Üy ç$¥›êâ9ÂÔ	[”+pK6_áï=î’ÃJ¬Q9g-ğaXWù˜æ2÷Æm[ç¹œ¡SY¬·À`¢)ÜeÍ&µ‹ÆÙ¥sj±'Aå@ „OÛñJÙ„˜O&Ç¸q7I…~Î£Å*9#î“•ˆÏÿGÙä)Na¹DUuj­’ Y-×ó=SˆSkå4ŞGü"œîk<‚ş¨Æì¬œnù¥òº>q:ú*ÊNp„¾äç[SÜâ¢L¿œåàİw|›•(ßÏø,R¢wøó‚Ô(,äQ‰$­ªëp°±\Í¢c~¤húJRxİ†¿ĞÁu%8Jz¥Aµ8Ô¸V…Ê=ÖOLr÷AYŠ¸ëÒ²ßÓ!h“hC!dT3ıQõVÔşáä¢sŒï9¼l]8Ò[^Kp~+˜U×Mğ±åk"‰Ù“Òa0>)÷vÒ¥G¤EO»1GoŞ\^â-û„bçÆ¬Ob•À	[X©z?µ…#I½‹ÛlBÉôFrÅ‰Àf§}—OW8XLÏ1„¿!)¼ˆäaBAuİ´õ9+ÖÜ;xÖ>ˆmRmª®\p(é‡Òé(˜ÆfOÓÅuû³pİ×îlÙ# _f ‰p‚·M¾ÉllrüxŞûÄ,Z`® YVù¬hç³hw.¸$§vy–"áC”ê°üOşÕ£p§Ì0{dù·+ªlVYÔI°ñšõ÷<NlK›¯èx|âÙ€Ã:´WÕƒYöX¦S%¹²¦6UûPêß\qÖƒ,u-]—,q¼o_ß÷‹Tt.Y¦bd²ó¿¸†øé£É% íp2ÇNİ¿å°Á”ÄÛ5™ø~ÎãË÷Lë[~æà+ñ÷±ğ@™~´û8‰·hK>;‰º»¨©b&/mÇÑcâÉ	}úÑylÏd»HŒ0èVHÁ«Lêöã¤ºD>çQRı Ç!Eşq¢e3©@ºøbRÁ£¾ó­FYU‚"dCq÷òwÇ´MçD¸ÓC–­òté“"js"õ>@™|7ŸÎÙ®*¸O(DL©bñµÂø4”K²ì2º\ kÓĞ)=±
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/b6/37fd40075615837662becd3cd6d04fd100f230 squashfs-tools-patched/.git/objects/b6/37fd40075615837662becd3cd6d04fd100f230
--- squashfs-tools/.git/objects/b6/37fd40075615837662becd3cd6d04fd100f230	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/b6/37fd40075615837662becd3cd6d04fd100f230	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1 @@
+xKÊÉOR0µdĞ×W.IqL«ĞËàâRÎLËKIMSˆqqt‹ˆ÷àRò3óR‘…¸”SóR2Ó¸ ™ö¬
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/b7/217ed85f66199282dec2a22ba7c30e4c7484a7 squashfs-tools-patched/.git/objects/b7/217ed85f66199282dec2a22ba7c30e4c7484a7
--- squashfs-tools/.git/objects/b7/217ed85f66199282dec2a22ba7c30e4c7484a7	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/b7/217ed85f66199282dec2a22ba7c30e4c7484a7	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1 @@
+x]M‹Â0†=çWôÒ]Ew¡xØzÑƒ"‚à­ôcbÃ.“%_ˆÿİé‡­˜Ó¼ï<™¼“äO'0şšö†>„&¦4ßO?rğ‡B8JR†¢(Üş¬çîDá°¥ßÜŞ-ÉG-UK8R¡„(²ÂAÊ”ìæ‡W‹í…RtxšÇ¦ã›—/œc®é„ÆFKRÖı7xZÅÅoÊj£nUYš0ƒÏàÙ`áÖ‘<w0ñ¸ÑD|™êV!üä(%š>4 §æÑ­$}®¤ >âwI^ŠãÍ)Õ™¢ƒğöõ/< Ñdx4
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/b7/eb235548f64a956c760928d2e504cb541a3bb1 squashfs-tools-patched/.git/objects/b7/eb235548f64a956c760928d2e504cb541a3bb1
--- squashfs-tools/.git/objects/b7/eb235548f64a956c760928d2e504cb541a3bb1	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/b7/eb235548f64a956c760928d2e504cb541a3bb1	2022-01-01 15:09:15.593172588 +0800
@@ -0,0 +1,2 @@
+xKÊÉOR025aPNIMËÌKUğŒsŠ÷uôòR0áBöô
+›™¢‹;…zú¸( 	{úû)(™è™™*!Ë¸8†¸*(Xêé£H:ûDyº{„((Y)x¦ç)$–åä—)X)”&åd&+¤äç&fæ¡hºdW<\s<Øˆ_ ®PPy® Èµ‚Tr VBKd
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/b8/01dd1cae2c51e0eaf13266d6a621e4fa8ef912 squashfs-tools-patched/.git/objects/b8/01dd1cae2c51e0eaf13266d6a621e4fa8ef912
--- squashfs-tools/.git/objects/b8/01dd1cae2c51e0eaf13266d6a621e4fa8ef912	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/b8/01dd1cae2c51e0eaf13266d6a621e4fa8ef912	2022-01-01 15:09:15.605172588 +0800
@@ -0,0 +1,5 @@
+xTÛnÚ@í³¿bšH•†@šRK„J$˜Æm–MY½¤«:6ò5 ş½3»6ØiûÒ„w.gÎœ™İÇ(y„ş‡sãÍYn·Ï¾1˜° @§·÷wchÃ/c êÕõ¦<ÊY
+„,UÎ{=£Ó»èô>*ÖS’‚ío¢d£ØÅcÄ“gŸÇĞ:S”SQ289VøqR·w»gã(J‚.šÑh½Jı?lB$DÈV<f‚«1ğ\ëŞôæÓ©k.@í#yêÁ³¹í
+Ÿ¦œ6nÌñÄt„T
+~ÒCS”,÷sli“ğZîVPUåi­CÆ·ÌËÅŸ;XÃÖCHY^¤1Ü½Èh
+Ò†°o`¹ÛiÊØIBúa˜²,«aİ½ˆ¸ÊQƒ±J6ğä‰:X{¥MÇÊƒıPQ\‡eå€½Ï,_Æk?øé")5Hâ,‡«—œA+KÌBëğó–Å:,­8\@«8dhÊN(âŒ?Å,>Ä_*3à²FM[C ’Ä½÷LÇ™;5³—ÏœO	¡V ›è‘i…K¥rq¸¤a²R%#“·Û¸ÛZ… £ï*ĞàòTZÀ5ªU¹Í¿•}S0¹ñªÔ(dY^‰Ô¢ƒé*’¢è—’‰àh…`qEÆä•"ƒTÇôo)#›I«îâòĞ˜Šf»ş?µãPå%™zè£ëôIàşp@e¯ÕtêšÉy.gîÒ¶çÎÂœ{¹Â¼Š´|[ğªÕV„2PŒ*ï7¾1ªÔú 2-ït3W‡wÇ:º`Ô÷õ×o@i˜Z3Ë½ñÆ³o˜-ÅÅò‰•¨ØêMÈ'¥Y¨ÓLˆşÛˆjl|5sŒ9Š;ÕÕ¥¥~N-Í[Lèä]'ñ†¥¹gÅ<W+·à×ğ—RUCÒ¡‡İTáx{¡±x—‹şâíÉí
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/b8/7cfe0bbf729a84de329a4e12a45e5a460850a6 squashfs-tools-patched/.git/objects/b8/7cfe0bbf729a84de329a4e12a45e5a460850a6
--- squashfs-tools/.git/objects/b8/7cfe0bbf729a84de329a4e12a45e5a460850a6	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/b8/7cfe0bbf729a84de329a4e12a45e5a460850a6	2022-01-01 15:09:15.657172590 +0800
@@ -0,0 +1,15 @@
+xíYkoÛÈíWëWÜU@2dÙ·ÖÓj…86êØ®e#›6…@‘C‘0Åaù°W»H{Ï™áô«ÉíöËş ÎãÎ}{f¼HôB^í}÷êwÛ›=Ù”©ÎÖy¼ŒJøCy¹³»ÇÑ‹(N’8“S]-#•ËëÌü©øGåQXŒu¾W7o°˜ë¯¢¸,×ËÜ[	~†¹RRè°¼óru k]‰ï¥’« .Ê<^T¥’¸/¶uN+ÄášcUàÀ2RRª|UˆÍÇ»³ky§R•{‰\T‹$öå4öUZ(n÷p:‹H²X›GÔaVë G‚½2Öé¨âs¹Uyoy9¢ËÀ+©j.:ãÂ!ô[KâA·vŒ•\üĞŞÖ¬@âÔé&D	£îàNY(©
+V‰9>'WÇç×W29û(&——“³«X\F³êVYQñ*Kbgæ^Z®á*ñşíåô[&ßŸœ\}¤G'Wgog39:¿”‰\L.¯N¦×§“K¹¸¾¼8Ÿ½‹Ìà˜OÏûTB[é\I J/N
+gøGD²€vI ‘w«Q_Å·ĞÍ™ô•ÑJtº4fB“6q$%ÕåHîò	RjãÈ{q¤Úm(Gò‡ïäJÁ=J.ÏW²%³Š{÷övFò½.JäıDv^îîîníîí¼ÉõlâÌI~úv~—{Y¦ò±Ù?«²Lç¥qÁé_¿…]«,W…I•¨,³ıííĞ+ÊÎğx‘èe‘érŒÁílRÇQ¹J m»×û}œúI(y]”A¬ÇÑ›{Cyœ.I¼¸?fDv7b ò¹¦ÖwÅ9G}FıÎD×Ì{ÎsC¯(Q!>2¸”È—CÙ9èõ,L˜„«Ôga°Â}/IÚZ³ƒ"ôPRˆ­¯a/
+auãt2îeH¹D™ÊÚú¡ñ-²ÍŠp¹^®Ê*O‹}8tãÍáÒjµ@U¼ ˆ©`ÁË—VZ•ï#nÜ´µËÜ"¨ØcPJÙ«—i\¨`„ê1_>±°»Œe«	wØ&õÎ"À»•‚àµÔx9Æø­—ÄöV
+ 2Ä:üÉ™.Õ¾ÍüÆ£…*ú]å´¤‹0$j$<6Ğª`}PFæN÷oŒQHÏ*€+]ŒX ä­}Ì“*Wt3@L	3#¨VÙ¼à`(Nm”-"xKUv¼H)Èc­¬€tjÏ[ 	,bæB]Æaœ¨b]”jÅÃ·»¹F%Üù~äå²‰PŞşíï#z„aõ‡½Ÿ{q8@óğWÙÀLï`¾¿õCä÷‡rˆ\
+Öl˜¼İ=À/›4ÌáÏ½ûÜÂ>¿œÖmêÒúÈXnÒ7 Õ ÕÊCİ¯òÅ3»ÃXVëöÑºK`53«ú'Ò!Y¯‡lLÌé¢~ƒü›!}ËÉ'ëÊeÚ$™Š³EíŒ€+õfZLGÛª _ÛãŸÔ%#g×§§uÅ Y Ù#AÏ@*u©×šM«<Wi™¬…àê%(˜mÄ¸é"6Zë~€HI4Öuí8bp…ƒ ùéÛw“éGnR  ¡F:¢Ù7 KÍíÊ+bœëù0[ƒ(A¶¥KTUíô”Ÿbù½ô8•åæF23½59|«Qæ›J‰Ék¢2/à/›Ì›üi²¹ÆZk¥©Cƒu pu¿€¿ÍÇØ™~Ø±Ùİ.xHğş£Ys<•}S³¿\OfÇG³ùÉÙìÃäb>=1?¿¸š^4Û‡<Í(ÔS‡ƒî¤+¡vÇ¿-%O"• 1¥È”‡VçFö\dâ L6t¦-8î^Èª<Ó Y?BšÏ‚¤IKê|¥òìÜMwiMøDE=^PGÚ€+¦“T2Á§P¦HÚ•Å…§EÕØW  ˜q°}-wÈ*¹‹jz×)u¶%:£Ø*_Î[²C™Ã­3À{Q lrÖ¨Î#¡[“Á5ÙûÌ°QÀÍu‹İT£–£¸	ñ$ÙVSnwêH«¦óÙÈÒTÛ]C@ëúZÿÆy0¤(A‹yFM&Xæ`B’ëÔ…ˆ
+€…ÈK÷¨EıjìÇ€¹:Gzhˆyr©=L†lĞ=²kî#q(×¶iJiÓ“š­…IœZÌÓ¨Ì­<EÀ£¤§ñw§¦%ÈI\ |™{–Q¡s×'x+‚ˆ²¨¡òÜp“nˆ+›z{Ó:â…¥EE³èÓbëÔÙ¤Ç- ‚ppa{ùJG³ Hóİ¢6*ºk`I`4½š‘zí€¤>¢9/5öŒ¨€g<OÍqîéÂøÜCe&ôè´ƒZ•FÈÖ‡¡ßtAÔR‡0/I2p…Çúpò>XâMªïRJu½çSÚ‡6Œ0$dyÑŸF
+ÌŒ§º‹ƒAæ‘øMóÓ©í€s@ô áŞ]ß‡L]¤¦ıªrÌoë×15Ş[S§tlÃTBèì øÖ»–×\éË›Ï›ÛR¬å~oãi¡&‰Ñæ½€µô<>‡¹^Ivô[¸ùÆ*ğµîù¾S¥Ím„5ú¸Çø&n»`ÚLPî5¯0C×Ï@3—Y(eäŠÃHÇ@p‡Ç¥·wÓ™Lå{@ 35~(Õu§ÕRS“®–´à®2•Ğ¯¸{/
+à¢!‰Zz¾iµ *Ô¶M;¢ôPÓï„×"ho.‘é&¦“şeß1paV¢Šp‰
+,YDA¦
+İ„6Z6ÓTÙŞbık)@Ü¼)|Vš­Ìÿ)Íæßp’¼ØÜÓşï8ù«‡ã­îêgú¢aëq‘%ŞºIŒÿ^Ã´‰Şa™ìîîJCB[ßÔ}Ë±J—à>¿uÎé¯Ú9_È?IN'ïfó÷“ÙŸ¿–|¡/>Õv_Ô26éšhô?•ÇlüÓQ°,Ğİ™ ›>qï·@P¦ÿ}¿ı¼g’Î‹ +ÆQš-°¯ÕHìï@x¹­Çs$æñ†Œs:øÔUØpû²ƒi0%2A¸æÂGøÆ5”áq‡OçI¼Âënp^•YU
+cÏ5çtnÛägd@O
+úEbŒJF™†7–G~fõ¨¹²ğ&ú××Kó!|ÅG¥[.˜â…<Î29‡Jæ}J[ãA¯?kÎ™à¿ö1ÏøÌ½—{ } 1\Àù
+7sK$ß^#À1íÃì¦Ô*c¿áp†æñŒÙ}=3³|>{x®s¸ÎŒGÙÀ°Aâ/8¦“öğn&Ô‘'µ°z^x¡zğZ£Ä¹ç¼_j‘É\æxUxK50Ú<â²ŸJÁ%1òkJüÄü§rZ«Œë%ù
+©ŞÃ*·Û­ÍEÌ™‰»®+3t%ÀÏ½şWÁ\$ğéfajº·¯'ÛN»Û¬İèn˜˜è¾ùÖ;»CÜûàzY¯z0Ê…÷Ø•Ó‘8î+á?dİ^ëÎ¼?Ê…Æıõ´ùÍA¼¯Y,à»Õ%şÃur~Æñ”+‡æ¦ÖçwCo1¸Ûû|Ğû"†—Û
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/ba/91dd0078ae6c323ba5e91c5ab4a76e20ccf058 squashfs-tools-patched/.git/objects/ba/91dd0078ae6c323ba5e91c5ab4a76e20ccf058
--- squashfs-tools/.git/objects/ba/91dd0078ae6c323ba5e91c5ab4a76e20ccf058	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/ba/91dd0078ae6c323ba5e91c5ab4a76e20ccf058	2022-01-01 15:10:24.009175402 +0800
@@ -0,0 +1,2 @@
+x•I
+1 =ç¹‹Òé$iñ+=Y40q$D¾Ş|A¨SAAÅ½µ:4w=g]ˆf’“+Ùá$	y™  qê%=?‡.Ö—H£‘-–Õ¬‘„'Ï+R	ÖŠ’÷xì]÷úÉı´U}Ùê·F@\n÷&u;Ç½]µ!g 'NaPÓÎ¿‘ÿ/•”™©j9AÑ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/ba/c297fcf7c4ae75b5eb2b03ba674bcc1f0c2c66 squashfs-tools-patched/.git/objects/ba/c297fcf7c4ae75b5eb2b03ba674bcc1f0c2c66
--- squashfs-tools/.git/objects/ba/c297fcf7c4ae75b5eb2b03ba674bcc1f0c2c66	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/ba/c297fcf7c4ae75b5eb2b03ba674bcc1f0c2c66	2022-01-01 15:09:15.609172588 +0800
@@ -0,0 +1,12 @@
+xYioÛHİÏü-²#Ù–|$v&N&€-Ëa|–¼Ø”Ô”ˆá¡%)_‹Ùß¾ïU³)2‘³‡€q$6»ºÎW¯z&Q:‘£·ûGzû,'W£a·/gfšÎL&oz¯½îÆçm~]úéò)ç‹BÚıì¿{÷®{°·w(ÃyšÉgÿ>Jïë{—YzÎL.oŸw/¾^ÈŒg‡É¼W;àŞdy˜&æ’‡ñ2
+ƒĞÌÄ=]¦YŸA–ÆÒßŞêŞó<•†3ø«¨?™ÉÜ$&ó#¼/3“«ĞØ‹t&i $H³Ø/¼0‘·İ¯á²ñ"Tg~,í‡‡‡ŞÛîs¸ì¥Ù¼Ó=©2dãÅ«ŸùE˜êùPùI?/ÔÌJhë]ûƒ«ÑÀ¹ÛónŒ?“è9ö{ÅcAÅ$L¬zt…?IW…DáÔ$9­õÎÃÈänw3dô÷I¥ÓŞ–àÓıáFu:ÏŒÁ§« 0™¾ÑûCò"[M‹UÆõ~Vn§€şMÿõ:+6[ÊéƒDæŞD›8Íºí¿U\±ağXdş´à®|¢»ìgüxÓOğE¥\¯Š4HòÂOŠR‡‰5O-ä;~6]„÷FÒ¥IP|¥0qùRWøJe \úaÒ›ÒCPkl$‰\›2z	×5Q†gĞ÷c-oŒŸ–&ï-¬„S?7Rğ‰ºy­ªç}‚“Æ©Üæ¦0Ïû’®$^19Ò‡$J~›„.ñ4ÃÉ‡ÀsÓÔOd
+ß!¢uÃÂb¤î™G8!Ã7Ÿ_=OÜwñ—¸o«·(béfÒñß^0ùåàğĞó†<á”…gNÂ¹$«xt@ÅL:ä¥“²£¦òåÄ°$™éÆFØKÔvß,ı¬ˆºy…3' ?†rÿA¿8ÿåpÿà·ï¥Ê3]‚Ê‰Ÿ‡ûÀS:ò!Œ"=šûOÅ<Aaü÷d”JX¨Ş¹i­@%M¢'ñìÖáÚ",u‚EŸ|5]8K´¦Ã8,4}rzkºÊ2“pYÈibn-!šEüƒ_hW†… f8ˆÚ¶W~lZ;Ò…Ïü— ØBå¶@¢ùĞ›±¬…²W
+ÍWKl)W¡‚óÒNÒ:BvPóÄÒÜíEÎñ¸!L ¼·ãóîş‘Ü&!QÚ™@Mu9Ş°qŞxa2QÍ¡Ì	e<"ÕƒÁŠPå¼%<ï6GÚ×›Nş®ºÿ{·S¨?7Ç
+à“ úù(J¼¹£==ïC¿\aJãıõÔæÜæK¹ëÑ±\„(x¬@Šhº¬W‹c«qˆÅyOÌ&·ìl‹-lj¹U”µçEœo­«îA7°€©OË‡¢Zâ
+=ëuˆËæ ˆÍğ6a¬mÂ‰íÙ®õ¼Ú;Š	ˆ%»&ÎÓp²´`fñJŒ\2xûµİœzâÊœ¿æòHÑÜ`9 )Pò®C0|-ZñÔôæäR&`jå®Ü tĞ‘KŠU‰l¿cÜ¯îú§/ŸN€ãá<«v´=vò¤ÀÀ9A9<Ì—fOP#3œ3Ñn¶ó+)èT6ÒÌüc…wbM¿aËjjf=4îµ@òC2ä©CÔv#‡İı½W¥Àp–²V"OR~‘»A"?›kXq¸w©½\|’ÛÿõíGIó?R ÍÈÙË4@ÄolbÀ‰Ägêd´]ûcDøÌ§Ø¦	ÁãÔEˆ•Ÿ¢M™?§åª„VU‰.³8îy£Â,‘· ê•+ÿ™%´/¤"¡•eÍüCÀÑ6*2àç®… Á5ı¦p@ÆÏB‚æÇâ“‘2xêûÏî–²–ñÀSÊ·YÍYàOlíBJÿÄ–ß™_øp‡Á£Ì&ïK‚ô.Pfå+kòaE@ºR;¨a¼tÛ)"Êh«dJNc;ÿo’ÁpÕä¼$¼ªU
+bd§ J4,ÀÇôV»óigı…Xıˆ©‡¾´¶†ØıºÜ“²³Éà‘rÚ™M^1›4%¼©IP&x"ØvÁÚÃÍiR?÷&w¨y£s¹‡„Y¢Rkàu%Ãl9¡--(Û‡ÊYµ±µf“VÏChÀ0L¬„‰lU¢|U°7Ö)([«Ò©U—Ğ•ÕBµÙÒÌ lgVñX3\òXÉ´°!Ù;ìØöcÕCå¸f¥ØWØØKY!ÌùFùã·È?õ¯Èí0)0„ïËß,Äv(¿ÈŞ{	å’ºçR¼wµŠITr¬lowÊNJ‚‹$í²@@}§n“íõ1"Ë´[¯ö÷f"¯ò¿' =ˆwÑ	ºÉv_HŠ:N·?ôÈ?h`iñ‹6Â`¾6úzw3İ^Œeäæ˜¶
+©Wö–Ë0^ºfCio!ùt­tÛì0™™ÇnĞ‘ƒOs\¶õY9xK¯±§¾£FnİÆÓ'[[í|×8j™*1ñk_ñî-¥lGíoµÊÓ;‚mä®õÖï°ºÕššÂsS¸‚ hËS	A›b­¢JHõ!‚¼Æ¬¨bÊ†ˆæ@'¡™¬Oß úœ¥SLÿf¶Cµ¨såãÛ+\İª,¶Áûf……ÜB\Ë‘I§ x”ıÇNûà2h˜M’jvØY³ ƒv\(Ó½÷£
+Yy®*îÃt
+‡ãY|%…)c¯jAmşÖ àÑ7'÷qá’I«ÚÔ¢l4^õ¬Îcš\ 8:ú'”HÇ®kbc\R^&>Ñ>×fòŠB™\ä$@§«¯HÈ|tØ%bÕ•¡êfô/'Ú•¢ôíQÕÙô…òÆ&Ep­\àKÂê9bÓàT,rS%ÄƒĞ†õTVÉZq<ĞÄ,áÚ]@Ğ0^,Ô[¥¦Ş'ğ¶D·¹TA; ®´Ã N?IÖ’”lO™i	¼˜¨¡Ó–Y×=ğé"’ Z)ò-«5K£TUvEef›´tc‡Š‚¢Càòg¹Šª¦ãZ‚ÈÆÄ_Ê¶1Y¥ı†·?á*wMA¶×NXŸ|·4¢-%  €Ğƒ)¸ñÕsÂÛ€´ÃT2/4~Û®±j*»‹°|C˜]mœUE¤ù?‚]Gìÿ=Ø:™×
+Ô­5ÃıãpVÊ3~k@põ¨6ø0óÊ¬ÛùnèbJºŠ«ø&ÂY]ˆB|ÉÔAó‚3§<°+‹ƒŠ	•„²e”3˜<M¯rn#$²F×Ã_÷j/0xÏüm8VÓ¸+m/ä9ÈáVÁ‚µêÉÒæ\âˆçÒ?[w\ÿ&í½NíÉàîìd|r7¸¹¹¾‘ö~séúv|}~9¸¼¾ù"íƒæ’İízİ©Ÿ1¸»º/?_ ½›[ÎO†xxøÍÛ'7ıOÃ¿œ°#,—·ãgŠO`ª‡Ú–vW]ª3*/Ïáò‰?ı]ÇrE¬0!I([2ÚG]øëà
+épÒùğbp7~Ü½af–îC?Æ±1hß,oôVv^Î¤¶{¾‘_OUØÕ5æñ±JRøVX†pë­:Pjòä'hjï´0#sô¸3üóÍõ)ø«~º¼dT-nS™é„Í†Gz}Ğ`Sÿó-§Z{}…Şúc†yƒµ¸Á&ïÒáZ§ˆZe­ÙX"’Î0õOt	•zrqqİ¿;œŞşºÑlqRgf²šÛšÜÕ†ˆÙEÿHÎ½¾Ñ)xQËãİİÆ-³·éánéDŞGŞ¿ ]§
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/bb/42f60aea17ad76b4ec4838a79c8c2f6055de93 squashfs-tools-patched/.git/objects/bb/42f60aea17ad76b4ec4838a79c8c2f6055de93
--- squashfs-tools/.git/objects/bb/42f60aea17ad76b4ec4838a79c8c2f6055de93	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/bb/42f60aea17ad76b4ec4838a79c8c2f6055de93	2022-01-01 15:09:15.629172589 +0800
@@ -0,0 +1,3 @@
+x­V]o¢@İg~Å¤}A¢+j³ínŸ°N"®ñ#ûHPCĞj›ş÷½ƒPJÕµ%„¹÷rî9‡S/˜¢fãîæ[½,'-;”ÍIÕ±pö})I×Ô…Ù6¶´±Şíà¾aí®tW)#ï$(ùÒl5nÕÎŸµUoÔš·wZM…ïšğkğ“WÉ0¡œi?L°!clØ³?€#xÅ!qü*’ÔmV©ŠÔ-/Æ¼?ªê»}S¸’Äf1•{ÉÂFÏÆı±9ìhº)_e¥¼ªHT¿ĞãzêÑÂ¶bÁ“^$„FcÃ2ÇİßĞ£qEÆ#òwMXL³};H¡é¿
+L†æ½˜fË›€Î«hH<âDdŸQ‘K"e+ØA•.Úr{“*z 1İ¶üÀ°¸ÕD\ámIA[$IV"°\Rí#ĞœF±Ãfpƒô‚G}è¶¬¡fík‡zÎÔ#ĞGĞg‹bÄ#’€”Å$ú:Ì\×¯Àß9^ã~+óš`ôÏM4úÿFKr£	.Ë?³éğœp…S9– OîFôù ÑŠGm>o¯]—„mâ!¬õø–¦ù|XÎtS6—¦¹ Ã)™{[(NšxC¤d–‰JÓ÷¦7Ö¾¿Ë§gÑ òy"ÃH)(£ºãySg¶ú±ÓÙr‰Ø€´ ví zùhÙ«§/¶ l±W4÷Lˆs(ÑìHìÙÌ‚=3;"qÖÁ×›>O—`ä
+èNñ+„Âü+ñRf©‹rşTÎ±hëƒ9ÄßÂ­>Ë`Kx^0‹”9ÂSÔºÈÓ‡ÿğ!0§Ôáƒ°9u¥ã_ù
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/bb/971f6273fd7891f3bf1aa9777367e2b54ed6ed squashfs-tools-patched/.git/objects/bb/971f6273fd7891f3bf1aa9777367e2b54ed6ed
--- squashfs-tools/.git/objects/bb/971f6273fd7891f3bf1aa9777367e2b54ed6ed	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/bb/971f6273fd7891f3bf1aa9777367e2b54ed6ed	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1,3 @@
+xKÊÉOR0¶´`Ğ×WpÎÏÍÍÏÓ.)ÊÌKÉ÷Ì+ÑËàâRÎLËKIMSˆwö÷õõ÷‹	òôsñ÷ô‰÷àRÊeæ¥â’jÏKÎ)MIU°)›«—a‡S
+©,H-ÖËPââ
+ZgftC^YjQ	ÌQäü¼â…äŒÄ"­bd®Vj^Š¦5švÿdJMÀê€râKÜ :ƒ«/À‚Dx‚Kè™Ì4... ˆù„á
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/bb/a21a31583bd74dbec86ddeb6f039d5ba3fd01b squashfs-tools-patched/.git/objects/bb/a21a31583bd74dbec86ddeb6f039d5ba3fd01b
--- squashfs-tools/.git/objects/bb/a21a31583bd74dbec86ddeb6f039d5ba3fd01b	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/bb/a21a31583bd74dbec86ddeb6f039d5ba3fd01b	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1,4 @@
+x­TaOÛ0İçüŠ[+¡¤
+mÚ" &1šB4AQÓjš„9‰C-»$M7í¿ïœ´v…	mH8ıîîù½Üù±ğ¡{dètÀqeJIÒiZ“E<¤xãNÆöùµw¥5qƒqº±‡@ÄyH¡Ñnw.D’Ş¹^NùŞ5v&Ë9ÍÔ¡†U½>ïXİıŞÑ§ó}ÿÔÒ·¬¢P/]—_ñqn&öxx~a{îô‹ÎLğM(¸ÓöĞ¹±½Ë©3ĞgàA³	x|§YÅº’	V¡Š©§ª§–õÇÚ_ïë
+fœb®L¦y À<÷c€ÿ:AE™½ÆÛY‰¥@š¶Ò—>æ”KFb‡W•lº†öSÌ:¸¶'W£>¦$4ô'ÁBh…D¦—ıdì}~iÍSĞ,£¡‹ÛÜNÇö)æé´påòXTFÀÇ3@IR*ó”{O$Î)œë¾á!è›‰àÑ†‰9 äŒrµ¤şs‰À§¿”4ÆµS_b±”®ØÁg†½½ZÔÚ„ËË Êy ™àä™Dz$"!¦ßºe•y²Å0ÇbAC¢Š‰QLH8ğ<ñi
+"Âƒ„0Îøı.®ßE^•0(±_¨à¥b!æ¦ºĞqœb%ZüBH"r.Uvå	2ku´_§oûŒ6ÔŒîmı-e’z 8^ùŸüŞÔ‡¼Uê½úVA/7”ÅåÊ¦†å=ş""ÚU¥{ŸšåLp^úåµ&êokëRú`èØ7‡èY”QùÜ9RvÏxµ…ˆ§‹[‘1õ=®[i—¹š­5>µ]œ.ÿŸP}F¸T–m¿º!Ò¯O]Ôqş”ízYE–£çp›äêĞĞÕÄQº(ÇßDw¯=ŒólV¦=ÚN[z=Q“òEÚo§‘^
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/bb/b2ba82d3c14bc54d0960ec69f53e8feb7af1ca squashfs-tools-patched/.git/objects/bb/b2ba82d3c14bc54d0960ec69f53e8feb7af1ca
--- squashfs-tools/.git/objects/bb/b2ba82d3c14bc54d0960ec69f53e8feb7af1ca	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/bb/b2ba82d3c14bc54d0960ec69f53e8feb7af1ca	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1 @@
+x­W[OGî³Åiª]Û˜Ğ*ªm¤bH‚”Bd“ö­íq½Êz—îCSÃï¹ÍìøBÃ+ƒÙ™sıÎ7ç“¬˜ÀÉQ·ûC§ÃbyWšªêŒ’ü/3,f¦şl/ƒtÏÌno‡×¿]ŒÇ·£ß®Ş_¯Ï/F·¸™ææÉ}4O³ÕÌÀ«v»ƒt¹,òÎe~¶šÏMÙ^¼zJäzek™F,Mu—L\¹¨a®Ö)àzcZä•…4·ğåjµ¼)îÎR[Á Ozº÷ù2·oáîı‘d+ƒ›QúıP!î¡¥,©*^äS‚§±n ¨êí4™.Ì8ı×ôpñì›Ex©×¸[M²tú«Êşr‹{RM•Ş‡>IÛÒ$KZœEC|³&R…	ƒE®bXCiìªÌU£­’Hhçk‘Î`l¬X.Çæï•ÉmšdèUá°b·dUVÚµ‚n‘55v™§6Šñm?à4d•"Ê<’N“^ÿy§¬×Àáf7\sºuüï²Uµ8OløEæ’Ÿ&)»eDÅNÙ ~õáç¤Í&KÏx‘Î-*EXRx> ›?¼ö ÉG»èò.j©c:2™I*è(v[a„?®•MJûÚÑ¡Âºú[Ø$«1ÖDY!L;¹èÃ%Yº_¤™qâHjGsd­°ˆµ~ oEm)J;L½Æ—ÅJ:‡HóŠ)Ú>¸7ªû?ğğ T 8"‰ÓSxsÃÈŒXêçâáCdÍòëèÎ’pVhÈNÔÓïÏ2µ†£ˆ~Çë7Aßj‡1×^Ì©ŠĞ%N‰ÒÃÈE­VÀRÔÉÉ:¨\¶êèø„È²ïaû’pm¼Ù|BÜ›`=².¥Î},šÚıÕ(%ü0i…€çii¦–š¡š‚¯Ôü^s«Ì©S"ûh»f -®®PZtşR8¥i«µ[§¸«G€©±G"AÃOĞa€"¢KYP¦x´}¤5RT®nSÙÑÄöĞy—ĞË6±ÌÜáBGéÈŸÊ0o¿X}[NŠà¬j³ÎÍıY±ÊgT/‰sÄxÙ¼PŠ’S„Ä‘CBTàÌ‰°É*Ã„Xóo×¦”ƒ¢µ­.$ùæ@©ã˜{oì§²˜â•ÂÌÆ 7Ô­yµG¦©‡T 	'Ô8ëÙ{nÜì­çêĞİ ‚Á©ø3p„–¾Ó½†^_t®^å2É8E4-Åx¬Qƒ¿ñ¾ñ6†7JG&™q+ó­j‡ÒÒës]Ïë`À_æ2‘^|¾kğßğßÇÏÇ ¾	l×úÆ²µ¡SW‹l»YàwQd3w´·F¬^§¸ 1t Ò>²1dë8„ÎÖî$¯;'g‰GĞoOLw<7&vÀ(b+;Ô$ÄeĞ»é®³ÑQ<U£¤=²,p©;S¡Åæ§jûÓ‚X­2‹ªZã'Û?µ~Œ{Z¿xßhıCvØØ>İ96æÇ…Ã‚u]”sEÑñ6bÉÛ„<jí!0ææøaG¥4qÊ)3ê„/">ˆ8˜"KÎDKä3 Ù…÷š.ÊY”SwÔÎ€k—k;»s}· n\Q¹ªÉ"dQ ¥ÔäIS¦KûIö¬	XS\±uÓ‡ q ÿ?òTM¦ÄF°qÀ}?ñ„kÅÕHGÌ:eç]Iıwæ¤W÷go;Ò™İÙ»[§”øÌÿŒÕ©øƒûÄ<Üüïmwºá÷ˆ†L>Kçÿ ÈoV!
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/bc/45e36431a8abbdb1572d99cba5ea9ab23ec33c squashfs-tools-patched/.git/objects/bc/45e36431a8abbdb1572d99cba5ea9ab23ec33c
--- squashfs-tools/.git/objects/bc/45e36431a8abbdb1572d99cba5ea9ab23ec33c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/bc/45e36431a8abbdb1572d99cba5ea9ab23ec33c	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1 @@
+x+)JMU026e01 §¢Ä¼ä†»ª¯ı¶/üs÷Gúµ?™å·Vz×ğ˜AøD1pL¹õë›q¿Ò.ËÚ–I³ªe^yl‡Iú:2<=ù$Zß‹Ié[Ğ)ÆO›Î†Åëÿ÷EHÇ;æäç¥2œÚ–Ù—°³<OFuÛİµeò‚3;ö#)rf°jê™“Ë6¯íDûÜ¥ö;r™,‘ød&1x\9:ïöëâÛËÏ]<¶÷¯´ïUˆ’ Ä¼ôTçü”Ô"NÛŸ3o­ÏÉì¹wš·EûÃ’ol ‚²bŞ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/bc/f03a2136999118cf90dccaa869146d6fb12ca3 squashfs-tools-patched/.git/objects/bc/f03a2136999118cf90dccaa869146d6fb12ca3
--- squashfs-tools/.git/objects/bc/f03a2136999118cf90dccaa869146d6fb12ca3	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/bc/f03a2136999118cf90dccaa869146d6fb12ca3	2022-01-01 15:09:15.657172590 +0800
@@ -0,0 +1,4 @@
+xuRÑjÛ@ì³¿b /Ip;n)Å¥T	qbpl#É?…³´²îÔ»“Sı}÷;i
+#¼·»³3³»Uf‹Ñp4şt"SÙbº|ºïğ©é^÷pKÂÜïF¸²p(¤"×:OÕ HKéÀ?RîJÕ"3UmÉ9ÊÁ9ŒVmÀù§‹ÃÙÔ­å&ÓìWL¨¾ŸCnUJ¥d¹iv%Y|¯_~YŒİš_?XÚšU SX"8Søgai‚Ö4È„fF¹tŞÊmÃ’¤‡Ğù¥±a`erY´á­aK,|Iğd+StÁİb;Òd…ÂªÙ*™a.3ÒB»p¨Ã£+Y÷¶í:¦Crà€©a`á¥Ñdx‹=YÇ1®úÂXœ
+¨Z˜:1¿Ší­| ÷MV©»ñ¥©YBÉ,ê™íÄ–Ğ8*ÕÍcğ8Kï—ëÑbƒÇ(£Eº™p±/giO/P²ª•dal¦Ú·ìI`üpßÜsKt=›ÏÒMP0¥‹Û$Át#Â*ŠÓÙÍzÅX­ãÕ2¹å‹IØ– >öƒUÆròB*w¾áM:f§r”bO¼ÑŒä¹	¾¼:0ëÄŒæ
+eô®“ÉÅ|-‡Ã™@ĞÆ÷ñl%ˆ7Ö»=†ö·UöñåRb{+%2Â’&ôÇÃ>®óF÷ñax5.Fãá×>ÖIt”#ua%ƒ^özô‡­±72ïSl=…üéÙä]®©ù)>æ&ó\nŸH{œÿW*µô¯'¤ùÆ{Ó1Ms
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/bd/b27ac382b98843bba329782973355e232a8acb squashfs-tools-patched/.git/objects/bd/b27ac382b98843bba329782973355e232a8acb
--- squashfs-tools/.git/objects/bd/b27ac382b98843bba329782973355e232a8acb	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/bd/b27ac382b98843bba329782973355e232a8acb	2022-01-01 15:09:40.213173601 +0800
@@ -0,0 +1 @@
+x+)JMU040e01 …œªÜD3S›¶û¦‡t6<v:seÃ2?V×»2 T¤$”d–¥2¤_şì#6çîßE?¹ÿ7„&å­¿‚P•SÂğM#iæº€2û¨3åvJ™²zø„ Ï.ß
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/bf/0e976ab699922da5eafe84f2e1e4a69fb9252f squashfs-tools-patched/.git/objects/bf/0e976ab699922da5eafe84f2e1e4a69fb9252f
--- squashfs-tools/.git/objects/bf/0e976ab699922da5eafe84f2e1e4a69fb9252f	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/bf/0e976ab699922da5eafe84f2e1e4a69fb9252f	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1,2 @@
+x+)JMU026c040031Qğ©ÊMôÉLÒKIMcè>¶ö¦QÛtïëmåæ'”+ş?.EWV\À`½ìRÈë
+™I	ïœJ~Iœñé†²r†üõÆfq'vGß¶ğ´?áùşãoTe®ùE%ÅzÉ-¡®·gM`KN™÷$ÔlªEå"£Pµ¹‰Ù©i™9©rÙg6{È/ÚûzÉ	C±7'„æGBÕ¥ç—%§ê%3ÈyLL\ıèô’Y²·L300İ3ëˆ ÏtaÉ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/bf/1d3e0a2ccde00b5a2f215bfa31a0ac015b55e7 squashfs-tools-patched/.git/objects/bf/1d3e0a2ccde00b5a2f215bfa31a0ac015b55e7
--- squashfs-tools/.git/objects/bf/1d3e0a2ccde00b5a2f215bfa31a0ac015b55e7	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/bf/1d3e0a2ccde00b5a2f215bfa31a0ac015b55e7	2022-01-01 15:09:15.637172590 +0800
@@ -0,0 +1,2 @@
+x]ÎA‚@àÎû+z©5¬KŒÁ[v–Õ]ÙGîÛp×ƒşúŒ@!˜ÓÇÀLÕÚ
+’İqÇF¤ŠjÍ5c!6$Ue9s©Y8’úÓ©LuÛKgç%Z®/œÇ¿\­1–âbx+ÇuÀ’_Fè^ë{–ß`ÛDğÌÈï Şd^uÂ£%7«Äú¢8ª*k[@—‡Íiz®HbÃ>É?Eû
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/bf/bc7d2b9c3581bbd4c8554276ee7a65d6564a21 squashfs-tools-patched/.git/objects/bf/bc7d2b9c3581bbd4c8554276ee7a65d6564a21
--- squashfs-tools/.git/objects/bf/bc7d2b9c3581bbd4c8554276ee7a65d6564a21	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/bf/bc7d2b9c3581bbd4c8554276ee7a65d6564a21	2022-01-01 15:09:15.605172588 +0800
@@ -0,0 +1,7 @@
+x­V]oÚJ½Ïş£æNùêmn“>Pâ6¨¡ LT)/–±×`ÅŞu×kzÉUÿ{gvâ¨‘rıÂzwfv>Î9f™ˆ%ô.úƒ¿Ş¶ nSßáÁùlnï'CÀ72iõ:»Û±;ø ã•0ó7‰ØàÛ¬X&q ¡Hı˜Cë­eÅYG1œo#ïÆ:Ã˜³£=4äAR„Ş,¶ËÏ×oĞ¹4$Wo6ŸÎ\Ïß;ğÎ²QÜ\É"PàÊ|gRd¹õŸs	Û°äÌCUuàê£Ù¥Å?”"Àİ˜«~Â8PnüÈ.-]¸º‚n¯Iv»Z›ƒŞû&DXy¿g/c&óXpŒU÷ü!V¿cbı=xA,À¢ı"Q°ÏdĞ4Uèzƒ]±˜VaÊ(ï‹vÅµ_qÉê\2rT]:—lYã’-Ÿ¸ô.~²{'˜‘Ÿ«6tÁ.dê'ÕÛº×èä¶wtO¤oë½ïWp†zÔ‰¥š XË+Ë×~¾­	™tf®^Æ|!ƒwş”	/Òñi«X®AÒkCG˜$JP¥‡‰`ªêyPàìë*(x¯8á§Œsx8ñåS
+l™2‡àLgS‹6.ß0©X¬%óCLŸbu)y,â`¬;øØtiY‡;EĞóÆ<V#3heÍËËoz¸È«:ó²KUòz_˜º.©ØÏÕq:xq¼‡—YaïŸ½İÏÃ„ÒšÉÈp°û‡†C^å^¢‚
+É›CàsL’ƒZ3äw’ˆŸ1_û9Nâ—°æÚ  î½7ıZ!¼Ó¯fÛ™Ï§soâLèÔ†	K…Ü‚ñŸî&¥UÛÙp>Dk“„”5-ó¥ŸúXJèš«ßçã…Cß	"˜{’,ıàÁD>¯Z¢p~™;®‹¶¹H,I‘RÔ•d9•nÜ«~‹›¹3¼F/lNY¤¨<±Ò¢¾Z×<ÙjEœìÕ°iQ¯wB­!Ô:p‡¡rf»¹Œ0IÅc÷qH]ƒ–nŞ	À¼k†ú/¶{d•A²6œ8>Ùø¯0˜;gù
+.SÛ5Ñ‡ái=
+Ã¤ŠY^‹äÃ`Ø˜´>:håøsÎ|sk¢Œ]öcZ(WaŸRh‰İ’
+e?Æ|w—«6N`<iFÇÍà‰Lzõ¤CO6jZ†À~6CS'rE¾¬^no#—ˆÖÆ"—ÁÎ —t¬S%¯ª¦óúäOôbŠBF¬—(²¿ä¾V‚:ş²×j€9z¹û-¨tz·˜İ-<gúIŠÈ
+üîQ„Š!ğI„êU5/ùlB¿ŠÓUÚ`_¯õóìj—Af¹AZ¸‹ù²Úú¿ŞXş/´[gŒ‡qdıMA^š
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/c0/038d618766ac034e9ddce4d83b3c0bff1553bf squashfs-tools-patched/.git/objects/c0/038d618766ac034e9ddce4d83b3c0bff1553bf
--- squashfs-tools/.git/objects/c0/038d618766ac034e9ddce4d83b3c0bff1553bf	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/c0/038d618766ac034e9ddce4d83b3c0bff1553bf	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1 @@
+x…O‚@Å;ï§˜ğb—DèTD(*	¢ –Ç%q¥…e4ë}÷Ö­…ûs›yoŞog§f¢†•ëÎ*Êqë€´ıòŒE[Ş0®â4ÈªaTà=²¤J9™ˆr6µü,KJáËÒK¸Ø@à¹[I0ßBä%E¸ØÀi„ŠŒa‰i[!¿"vPæ‡pısôòØKKlğLé/W¿øº›î«öÓöøØûë¦ôózĞ@[„7´EOx€¬
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/c0/d9f6f48b1028167f0191341019d213a6d07f08 squashfs-tools-patched/.git/objects/c0/d9f6f48b1028167f0191341019d213a6d07f08
--- squashfs-tools/.git/objects/c0/d9f6f48b1028167f0191341019d213a6d07f08	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/c0/d9f6f48b1028167f0191341019d213a6d07f08	2022-01-01 15:09:15.661172591 +0800
@@ -0,0 +1,5 @@
+xuTïoÛ6İWù¯x@¾$†ëØIÛ¡ğ0LÍ’Æ@šş"ŸZ:YÜ$R#)§Â°ÿ½GZ®£d<¾{÷ŞñÈM¡7ü0şåDf*¥³ÅõêÏ‡õmï„WRÑ1pŞï¡+CÂì?µ°yf‘É‚lc•C`™Kşr¹Í‹‰.+CÖR
+ÎL¡UÑxgY¼Ìºj'9œ&g¸>ø?…ÿ{˜å²(d…;]os2ø­Úş8hj³ÖÿŞ21•Ñ[#J/*3D°:sOÂĞ®‘ÅºRi‘›šI¡Òsm|ÁR§2k|¬ææ¸œàÈ”:‹/÷+|!EF˜Õ›B&¸“	)K>]XT>hsv¿iBÆ×°h5àF3±pR«	H2½ÁŒå5.Bœ
+ç¥èÊÏX_ƒ‚á'vø†ß£­R…ò¹®ØBÎ”lê‰Û‰¡¶”ÕE¨Ç=À·éòöaµD|ÿˆoñ|ß/'v¹æ]ÚÑJ–U!Ù7Óåî‰Wüõz~uË)ñçéİtùèÜL—÷×‹næˆ1‹çËéÕê.c¶šÏ×<7î
+Û÷o÷“•ÚRrBö`ü‘OÒ²º"E.vÄ'šÜ±6ÁóWyeÁüÛÌ¾®(´Ú›æiig™Ai7À“‘< N®Î9úôãQğá–ÄíáÛSˆ„ğ‹Úç^^ò4ÖÖi5À×£‹ñxün|9úu€Õ">Ø©,Õ©æL{ŞãÉ¬‡}lÒÿö¢$&Š\SÑ¤ÕÊÊ­b·R¹ˆGöU¬–éKØöu¨ióWJ‚:j5„Ô½‚>_ï’ïË¤÷ß¤÷B*)gš£Ø¨¯Dé¥í3£~%\Ş†:#Ş
+`lgÃ›úüÕ¢n9_(ˆŒ<§åÜı*áæ^1mE^:}çû¤|Ã3µşÙîìÔëEÿlòÆ¿d¯@áh­m½I¥iÁ¼ Kt6ÖûF8ü+êI:˜çú:a`ú[rGA-Û<ó[»ô’u@üÉ tçY#:<+rz$ßi™"­Ëª­oıŞ	)~W{? ¨l'È
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/c2/e7d38a321d226266a813d27f75662213e580bd squashfs-tools-patched/.git/objects/c2/e7d38a321d226266a813d27f75662213e580bd
--- squashfs-tools/.git/objects/c2/e7d38a321d226266a813d27f75662213e580bd	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/c2/e7d38a321d226266a813d27f75662213e580bd	2022-01-01 15:09:15.665172591 +0800
@@ -0,0 +1,8 @@
+x½ZÿSãÖï¯ö_±¥ÃÅÛ‡¹I:Äp&ç	Ô6I®äF#lk%W’!nsÿ{?»û¾®63	'=íîÛï»oŸoƒè–Ş¾İßûÓë*íĞu˜ücá&SrI&	MüÀK–IêÍZDÃ©ŸşsiêßMƒ%¢Ù<ö’ÄSì¹cŠÂ`É”
+Xxå•Óh¾Œ”RmT§ı½½·ümïÉß¶üİg¸«©şœÎ£ÅİÔ‹éÛ¹.|o9jEñ]kqlè
+Kó8º‹İ³6‰=’h’>º±wHËhA#7wc?Icÿv‘zä§ä†ã×QÌÎ¢±?YòÚ"cÃtêQêÅ³„¢‰¼üpqM?x¡»]-nDçşÈÑİ„æ¼˜L¡ƒÛ¥`œ1ÃE ì¦~’çƒ|L^œàöL"Š©æ¦ÌjLÑœëàoI>,lkƒ¼¹XcòCÙ~Í!Â$!Ô#ÔI·-o²d?è€~îß_^©sñ‘~îôû‹áÇC §Ó_½OIù³yàC0(3vÃt	0ÇºıÓ÷@éœôÎ{Ã,ÁYoxÑèì²Oºêô‡½ÓëóNŸ®®ûW—ƒ.¼g ­@|&°Y§4±Y{4öR×+øGX2wÁ˜¦îƒ‹<ÿ¼¹ğÂ9s&Âo¦ÌûºAŞ‰˜ †·Ç9$Ba”6è1öá i$´JvdôÜ”úú-=¨Ç£«ÀyÔ¤Á‚qß¼OŸDI…úĞ¡½ıv»İl¿Ùûkƒ®+ÎÂÄZ³İôëjõ/~8
+c¶ì·IÒšnÖm8vnÊ«‘¯±çÜÑèŞ'¦N»ş]íøaJ;ù§¦nlWæiÜHêÕU+&”§¤¨‰ÿOï°ZabşaµZö;§İÚÇ|aß…Nh{ük¸Õ0ouF€Uk>ÑTMßš/xŞİ5`x¡İ#Ú¯˜¨ø“ZòèÎõe•§¤ÄT¥2óf£ù²öª°^ Ú æ>šä:Éêà«R©şvİ¼?8ƒŸ;WÎàıe8pŞÔj¯ò=ê*“nêgòä Ğ°ûç(_º½b°ÍnüOPOÆÍéå‡«>â©ûÎôşŞ­å¤ëô;ïY[Z‚úöè $aæIoèœœ_şÈ’|®~®V«l[±ç$vïf^˜:©{xğ%‰ù³3övi/ÍG/‹Óı¡ŒGà=ÖaBŞä$¸o%­2Š“¤nœ)öÒEÒ°İ=‘Á#¸`!Lv„[y^ux! Ù@Z/„B4™$^*<(E._„œ‰³ĞRzS8¶;mÒğ’+Aˆç¼+‚êJ?íRa ²fo—©— )ˆ¢ûÅÜzãe­ˆ:Eİ…§²ä¬¯•(f˜v½]d=–ÀdiJòWCUhˆ™}äAy¥›íñÁöø“Dlñâ`2LjF„#j¶ëğ«î/ğ¡ëuC“
+}¥+*ÑH§í i	ÙÅ·bÏ´â’n|f[7ñ!çd&Iä"gq§+ëbN‘ZLFã=‹	÷“Î ëô..ßu÷İÎ»nôª€Ã/»	»&<Çœl’%›J5’%ó‚…ÏŒe·HêGTÃ?NZ'ù‡ƒñ¦V€m©^Ò%ª}“Úuz•dò?^u(Yíoà-E,ûÄN9ÙDë¨†zW§SÒ<œIîÏG«VÙnæàÚ*@,ÌJ*†êzÎ¦]±í|qøÚDÎŒ¯VÌL:ç0«d¶²Z¨§f2ª‰X*m‹ŠZ ±v‡ÅÁ¢h3=(gàôÎø3ı^2
+±ı–RË+AXÎ°ÔÈ2ÕŞÙå—=´ğ'$ÙH]ÎJ©™Æz”]5Ş¤jÔÊmE5©åyŞo·ÙŞ+»KíOÄÉT´É%¶sj(€"„E¥ƒ¬¿¹)º¢Ÿ_üÔ9ï½s~é‡}€ù­;‰ÀbàÜAV‚™Û_Ów¤úâújƒ”?kU¼YÅ’xk¥şŒ=À”¼Ùı$qxIvu:ábv‹ßæzóº»Ëa” 7Mk*¼†ãY-—ò]¯/=PßÈâ%{}¬bª€‘P]‰ÕÊsD4úØVƒu]¬•`#®¹Á%3÷ëâUo¥bÒ°„ì†˜}yWfÕoá(æZ7ù ê˜î–¿/7&hgõ•?JuÌqÅRÔ Û¨‰ÅšÍã™1o¥r‹Våa>ãÿ²ÙÎzçİµv‹½»í˜çí¶†Èf7…^o³~÷‡ÿÂf¥D»ÎhšgMš}Ñ`›Tî·$ƒsÏ… ££/Óv3o¦µp‹—¾T+ó¢Õ³R½ògì¦Ç#¡f[]Àî–Û ÚÅÌíB2wcÄ»EË]ªòÄ§?œ÷.~\ëVÉrøáız×BùMØ¼`€Ÿ÷±Mu­ÍMA5_IV¢u)b^ÎZ×IÂn®%k³ÇÍs—3"AÙ37À±:+õVV6-ú*=J/ĞÊpèâúü¼.Š|¦I`¸ó9Fºm	FeËbŸ5§§
+Úû8ä3.’° í
+¦q·,g[^µ¶hvÚuÕ–*£ylY³k¶ÃÍ:>¤~õëŞWÆu‹Ét^¦&¹—Vi5óœÿø®û“:iµB+yñô}?ûºZÑ¼‡î›—4ïáy·?¥ò?uYæşr×+Ä­¬ıµuÇt€ÜÃ”KR¡ã4ÍDV55eVºcoâ.‚Tf+ş~Ş‡ÑchšÒÙnË˜R}}Keı³=VŠm”Â0öR”Q3xå—&è/h'‹ ÌACnVÆa&ıóQ{ít R:Fïìø:0á8Ú6¦iâiŸğ2Kr`¿]L&^|³‰/'~Ó­İ¼e»è|è:çİÎ$Ÿ`Çá¾TfÔS«¹Œğ¤øf2h‘Uµõ_ë¤ü€»•éV²¡„yfº#Î¡f«FfCÚ	½G–¼ôEXà83 Œ£úcz­¡¢xf²`æ„¼d-}°3ÆF<3Lœh´òis©Ğà.OÙÖ:2Â'Ñ#m•'é—}*IÏš¯Ù;…3Piã*ÛrhÈâha¬]\4Ç¿\	¡öZ¤ëx¶Dô°aÖq±ëÒS‚°"˜SÙ3~‘7‹„ïÜqYb¥bÖ]S(Mà«î€0’ÙáQ8ß IG}|«‚Awº„gÜãf†?.Âã÷$qã¥"çZ­Oüß0òbèQãú÷0è_øŠAQxˆx©‡k$!_¸4Jè×$^iZÆT˜#\0	›š xŒÕl3‹˜[ Já,)_àª*$/qÕÃH<!1‰âA=èl{gº¿Ll3áÔÏ»Fáò<Û­ÅfÇ*GWFz/Ğº^FÑÑtˆ&ÙsKFi’-M×)Ì‰s*{˜¦«™³CÇDæ<b|3Id·xÄE›g¦|ßJÀ1³Â*Z9f|‚½<&xãDX8òJ#w$Õ(’°—åQ‚³0È…f.·_{¥Ô^)8oôdvc@ X´Ã“™ìxÎ"˜×[’9!ó³ZŸ/;³}Ì(‡¾Éh%>ßâiG·ÅùU/‡æRà{	×9«ŠŒ˜ÙP†Å0ŸÉaÌ˜Ø1ÊtÇæ6,Äm]ÌW|ßá	7¸YüúuwMxã˜×9Ö+wO˜ÅÂæ7öÏÈ7›æòòÉ,:Ñb4UØ(:À²İ¶ØÉÛl}fÄà¸™tã+?ºÃşGg_Œçw¼™(ªàv_şö…»Jù4»®ª\¿‰^Xé8Ïé;_e5]’Gs„Ö˜Cïøiík¬3GQ æqèÎ^«°Ov2Ñ5F¾).õñİœqäº‡ÄĞ´ğu!O2M'WÈ÷<ƒ6—~ù–zÒÀûT''öBF!4)©©t†ª&…ÆXeÅâºMÆä.¬ÎC¸=ãœÓ• «!çËYÍ"ƒ×UBzPª”©©uÙ³V»5ëà'Û#ïà»/6æ@WÙ2œQ©…`÷ÏXûy{¥c"î¿øÄ—Á°ZùÔÊ}BıCõg¡’'ğRÔæœØ’m$}o& &¯ Kge¥ È“MÅ5,¿”ö0y‰GœPG„J_BÆdbtü<º-ïj–¾pôàŸ}äªbMØ~6hÚ •.;Ñr%7[	N	Òåë=hÂ¡_¼ÕÌp‘åğ«t²xtëşÒF  û.@àìvNEšñBÍB	Y3§²”ëøM–)‹—™â¡pÏAã r`îöû—}s1Çt•Ïã…<xxA£ÄL¯yà-Wvvæ`”vÖ9t¡CV?aªøQ~+…jYäŸeWyÍ(òLIFâ¦ˆT !šÂÈBã§EØcÇ.qÚåT0™¸4â¼LŠ}É®¨ŞÑÖšRSdû9;=à[ö<"Û$™—5‰—µh¤U¦uA«M99gECºŞ…üò ÓO‘9I¥V$@$«úbî—0ÿÅelşñz+$ûÓ€ç1ú
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/c4/277c1c2359f14a3ae9e4ee5fc9509403c2e030 squashfs-tools-patched/.git/objects/c4/277c1c2359f14a3ae9e4ee5fc9509403c2e030
--- squashfs-tools/.git/objects/c4/277c1c2359f14a3ae9e4ee5fc9509403c2e030	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/c4/277c1c2359f14a3ae9e4ee5fc9509403c2e030	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1,16 @@
+xÍ[ëSG¿¯§¿bbW	0/'¾TxT9r’£
+pÊÆÇâ¢„´2‹Å®J»`sÄ÷·ß¯_3³«•ØWuTÒl¿»§»§gu>ÊÏİæ?¾xş·õu×Í¯®òlım9I³k­ÖÓt˜’¡;;ë¾><|}tööøÍşÑïgÿl=Årš%O€”õG×ƒÄíJh¯âaùSÿ¢7Y»Ø#ú
+úä_I¿Ì±ø„™2Ï“ı£ç[ÈáíIšòOA=M²A:lµŠ²W¦}×Ï³¢tD×-<¤W¯’aïzTv±ò6)ÛuOÜŸÙŸå“íV«L®Æ£^	û£^Q¸ã½VšH›4+İá­èdm!{ì–‹NëÎµ¤Ûø0Ì'®‚ìÆ¶+NÓ÷î»]÷ıŸßo»te¥C“¤¼dĞ_æ±qÏ²›oÛX$E¹ª:óI_Ùë³·eoR‚7Á«Oé(i·oebP±0„ÀÈ,”*Íî8+ƒ¿'åQò™m÷G“$“¶Â¸åqüîL¹öØ­¸ÍÎ¶ûb‹-B²y?á&’L’ò°IY#¹êf‹ılQ±ïåQc:e ãD›)Ško0È?×ôÔU²¤4¹èe{<m|B˜O1Ú,óéÎrÊ*àé–Ï{E‚¸åÏÓ„	çe[`{ŠG$¶rŠVá«ƒMGV|7#¼Ydl²8´i­Ó¾ÎŠôC–hçw<ÂËvûàäÂÚó ÍÈ}ö¹ıİÑ~÷õ«_MÍX[«I¢Ëı	±?!şÊ"IË°›)nû”©ÛuØƒüÓÃŒÀßÜ"†©1Ç¸ˆê›6KHù!ÏE/qj¢éÔLô¤­D+nœCã>5DmvğG~öÒ8jJš›A„ª!›‰Ş§Æ ÆSÒÜ¡I@qÊ½ÉàYwáp^_è:´7ãŞ$iµÖ—)KgÃ]ÆÙI—6f(şİ|D‚6 jÉM«Éú}¥µé(ï"Şª-LÅQã9‡¥E˜è–×[5ØBódGo1Í:Æº—i­VõgJ÷[P¥°.ğ>÷ËÔĞJsØ•nğ¸´u‡q“§GæA2,OÒò‚rZLµYî–(Nğˆë
+P]héÆhÒÎèqAı›vpëÖ~C£ÛF¯åöĞÀ¹¥%‡/ÒÌ-ú#}ê*¼JF	ÂwcM*
+ú´gÊ¯Ã_ å5y“~¸øvªH?„Nu|ĞCO¾ëŞT´4]XR²)ı¥Ãê›Æ( J\¨Ñ1®caéĞšÒ²sœ\åc€
+²İkR¡“ÛÂ­5!k“âjt6€7¼	¤¾IWİÙ(É>”ğMª~ÃQA$fçæ7É>"³ zÜíï#i}^åcZ|şFÿ«Ç·›¤-…ÎœÚ}Åğk†¶JÇù+Ò'ù°}ÜÁQ¤d2Hnñ}Ô ‹eÛÏŠdR¾÷ú	K·„õ¢`«›O&8İ±  ”*ûû$ÿ„S,Ğ&t5V°àNIgÃd#éÁqÖ°(úÔ3vT±c]´4£Î)IÀ şÙãÉ‹Äõæ«ÒÓÎ½wÓ
+Ô¼qıxãI^Â·ÉàgÄÈ„œF«±´İú;ë÷-iyKÁÂÙ®«ËFYòÉ¾‡"ìIÒÙì°âSö6gŒ’¬R—p°c¹À£  6!&{Ÿ%ß¿EÌÍÆç­ùŒ†¶(€q,Ğ^Ğ_UŞ1Ë˜På¶‚ÛÜøqëùó('puTiúÌ&¿\‡ÉD,àOc}ß{+x­İ Œ}ÇÿµÁtÕáEêvÂ¦—Ã<M0Ú‘ÜÂ’†V´ğYx9äª4îô}p=	«ù†%ø‚ YÔçb“j¸:İ æ1 ãn%8†3§©(Çƒ3RL˜Ò×á$IÔÓ¶ÏË>°\;s;»¡cÙS¦<"Q„9Ê~EET÷Ü‹ÌªÄÆÔàtënK¸¦ZcşTGÜ| ÕSFó‡ÀÜkG• bÁÓ¬?ùÇÀ3ƒÌxG!”„–ğdëÖR{é¤
+tdKSCNßGµ­i$Ëˆ+19‰ ç¯ÏGiŸrJÔOµ;?kXµ7:¾xÊgÛåø$:ÆÇjl¾€–2¦ªR<v}]êS®ĞÕ’%Ñ+1Ú+êÒf¶U»’®h'ÄÚùÌÌmáÂºŠTz´»~œˆÚÊ%N—S¢°•\yòüQ$—1Kqpê÷2w¸|\¦WÈ‹w~ëĞlP¯!æªÅnlÒ/ÒØ-_cübÍBI´³_Q@bNõŠ·‘Ç¦äŠÿD’µéè?•Ù$«ä˜õ0ª¶^~Àâ:?–Û_5s0ßñEâ®Ò,½º¾â^ÆåCWb$ë¡xNÜ¹$õ4kÅ¥ÆNwÓ]'n'…Ërän›Ô~ñ,ºç²ëÑÈ8‘|kÀ>^¦3‚¤_®®x†oˆô\ä¹;üËÕ+~@‡¿ñmŸÆa_æ’Ádtà­Úc‰ÌÊiâjÎO*·ºb®ƒ`Ú¼â”2Óx¢cPBkùÜ-Š7ê'xë§­­Í™X4;EEB{Û?•À‚	¢ÀZÂ’ğÙÅœ_&\l»_¯Æåm»aŸ"k1€òæ2¸pŠ±nÇ-—)Ÿ4kI'–§–ÀU¢£"Úÿ.Ïˆ–#9íj2Û–2«‘´àşq†]EÊCÜŞ˜6èÔ–
+·»‹˜ò2m€:}ç*JÇ±ïóÆ¼Ô¹XÖ™æKŞÁ?Ù-`Vj56µÑ´HÑY”••è‘öRuÕgøû‰í)…¼âMl'm2´ğ*Úª3\]p+².mdKª7>"ÉpiE¾æ’1=¡ÙÂr:Ôàò²˜¦¾Á7;û‰¼B[OòNCÅ‘}#9ó<ÏGn¿P.õâäøØœe«çÓ×
+œ†'rhí5Vê ¾C£V5‰Ç>˜¦.ÓŒ~~ı'É=Ôrğ‚€Mu‘²ì»ÈŠâ()ƒ£ˆY€†kÑ’qÀ#õŠÀzèñN­ìÕã=§À­³ùŸ>¯ÅÙƒåÔm€Òn[æˆ{ÁÕè‚A¹qÎA<š?ÃLJ@® aµè$ÇÏåš5¦ÃRhHÅg¸@Lì@WgrQ™³§>M?f¥²@-• x‡%G–(!É¨• ÂÌR $šãàáAe‰-Œ:}ÌeïTsßĞSHÚ|&¼½¬şÃûö°÷1‘"	Š;ï@YÇaÈµGCV#0¡®wÓÓd„iØñ>ô½»á…$Ò¨OSÒ·FÄ+ãõÈ¾²PôFFèXi¦"Ìâ+”±Ä"ÚW„9ÌW„îFDÆS»&!r ?è¯j­ë¶!‰J°ÒÌG t	PÙåœüN‡k—“k¥Zÿ&È‰„Šên¹Éw´7*Ã~¡#é9j{éc¡	¸U"Qïß#×R‰m4RÑ`¤©FØ÷YÂš/nf Í=!£‰Şœ!ñ~w& ºÓãUw‰cÄ—f9¦q	OáEŸKàû"?U9è©§~iD­îH4ŸYV.ù¥!Û§§—ïMB9Ç`ï£É@ZC„¨Ã 3T'?ù°›ëŞ$7É¤HjQxÑŸ˜Y:¤
+i¬”‘EK=~ƒûÛ0½ØÑ„ª©H:ëÍX}ğmÙÄnÈÈf2Åë,y=œN»!¢½\ƒ¢²ëİN%TÙÊêûô½\èM	Ÿš£+6CL»n¬};òHÅò}Š»ñv©¿Ùeöxåo£»B¢GFOÒ\‡×r4\˜~×GBw@šj¨¡A7$B6XQ²İöà6ªá-¾“A8.:fÂ`G³ƒÈÊ•Î¸âj ë‡ÙjıHLÖ]g‘Ğˆ» ïr£èiKñuğÛpïFd=-ijªÄ¦ndH­2[˜'áÁƒojkHÌ@.§¨ÿÿ¾›éìVV‚Ñ9ÿ—²Ñ,‹|…8}U
+)‹æğ¦E®K%oÈEiÅGÕÛT¾H­êyPŸé¥_Y¶»–ˆ`–Ü¦97Şµ™¾]ºŠk‹™µ7â,4»¾Ö]îp¨xÙñUDnĞ¹ŠÎ9õ|[…«lwËµdd>× tÓºÂÓª’A,æ‹I¤;Gµïª´âİ†ÿùf*‚½ :äï7	^1ÆÕø±ËG²À*îï0¤ÁÖ´[ô9%ëèy$Njˆ*d>Ç¸˜»˜Çy­hÙ¥Å?/ –¬Íñl×qeòÂaMÍ­{˜ñ7ü=W­#Q+‹BRå3}KÜ²Èö‚Ò›Y–ÅªY­!B!©ÜÌÒÙŒ^ö®´@NÙV–g†­W!ÀêŠ@0’Ùàaw/‘„5ìàWj‘Î®3	=´—¹	úÖˆçgQg•¼ÿOkbÖjĞOtğd4Å0Œ×Ê?Å2_ÿ@-X–¥a}Î‡ñì×j®ê}¹[´‘ÎC#FÁhgÚ,Áî9v«½ B2H®Ñ±…‚Yªy†ƒMm„neTòÌ—æ_&DaN&?nUñ'xÿ¦_O¶ğ#ÈV]×ùP»r#ÓrWÁÒZVt¨ãfü”¡Fò^)âğ:G Ï±¿R°lHb´y²àkX-ÈÂ÷(_)ËT1L>œ­ø"óêØˆÊ¬ˆÊc­¯ó™Ádªú˜FEsd£Z²Ì£ìÆl‹¢]»x˜’`n¨£ÜÁil	÷šÍÕ°(½ëä»á­Ï
+ïGí²9¬wåìµ†#æïé
+·­ èæCõìf™A
+©°{¬]¿ûæ>•_:¡‘húuWÅ§÷×Xöì¾Æ²»ÛqB¿"Š©ÑnÛs/¥Ào·Ê}zÏ½3¨ öúü¯ğÉğv”Š''ËÑ
+´RódÚ¿âm?,pÎ¤R(p[˜,üú?"Ë`TˆŒüàÏ`ºAµ½+ˆ#/ÓıÙnO
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/c4/dcf283916f96183755e68dff4002c49ed42bf1 squashfs-tools-patched/.git/objects/c4/dcf283916f96183755e68dff4002c49ed42bf1
--- squashfs-tools/.git/objects/c4/dcf283916f96183755e68dff4002c49ed42bf1	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/c4/dcf283916f96183755e68dff4002c49ed42bf1	2022-01-01 15:09:15.653172590 +0800
@@ -0,0 +1,3 @@
+x¥W{oÛ8¿ãO1‡ …c8iÒl»8äZœ7ëlŒuœ»Èµ… ËTDDµ$•Äô»ßI=#e{½"•%r¿yp¸ÅŞ¾;ùñoû<L6,„óÑùåxáı{5^áÏt²X.¼ËŞ>nñ„uì¾ô` ç’ùšêÌWQ¨ ä1S;¥Ùö`qøçCÄo£xØ¦’)Å6€œI¼#9.ü4’Eº“È¤¡À›ã“Ó!= ½ëˆÇ1Oa*²ÛˆIøgjş•[q$äíQv÷ÁÉ2f¤RÜJKæ„’1P"Ô¾dg°~‚m¸Ò’¯3t‰kğ“Ík!IáVlx¸£µ“ #šÉ­š_f+ø…%Lú1\gë˜0åK#v_AJ‹*B¿×;ÃqA6,œp!P°¯¹HÎ€q/áI…ßğfH"„„¾¯ÉT	"%Â´o1Â_Ğuø[ºµõ‘HÑ…E¢S'¬dŠ…Ylô!ğûdyyµZÂhv¿æóÑlys†Ä:¸Ëî™Å·iÌÑ1Sú‰Ş!&dñÇñüüYF?M¦“åyp1YÎÆ‹\\Ía×£ùrr¾šæp½š__-Æ˜1Dİ'İ˜BˆÂ¶B2Ø0íóXåß`$Zo òïF4`ümó1óR²Ì8ß-™ôú±Hn›HŒÙâçx‰ĞCxD#«Gb/C9„·ÿ€%Cx\Ç~Ààñá'¡´H†ğqÇoNNNONÂj1Êİ	ü bêğŒeøƒù£ÕQ„:^÷ŠâœÌãùÒÔl6ú8Âòæz| Ÿ{÷‚S´“ÚÛß§½ı}dô‰z·ä0`‰–»xB¾=öÍûÜ3{‡œ„„=jx†âŒÈûXŞ÷¸ïDl´lÉÛv
+2'İ¨ì&Gù%ÅW`±bÖô=cVm»İ¼VŸª2?÷¾öJ”çãW¿;Q–l+îÙÿŒrİœó^½².6qÛyh^ccÀjóÔˆËë›‚‹‰b”ƒ2[M§TºÅ„¿¿"ì°ÀíV0uˆ$AS˜5ºÍˆº&ŠsášK™:E™0Ï×ÎjºÔmîä™ïÜ(aëYòœï+¡ö\kV5\Ìa­&Œ+ËËÑâÒÃ8WŠsfùb5;_N®fCl‹ãéÏC˜Nf¿vn„§«§ıuÌ\ù"ÁÖ‡'ÎğÌÊmÎPo…!yAî=™’N46D¡µ5İyüZé9™ƒÃA\¨;üPšò‰^¿¬_ØÏq3tV'ÜE>GZO€´&E—©Xuø¡.Åp’’j \å~ šµ]zÿ]h:H´9Hë…ƒõ4¯@`!¥öGµÇà…€ÁĞcìMÉÿ8
+òr~–_.‡½^Yù0j¼YLş3†woß¾+ÎÁóÑ”F‰åØ#Š>NG}z¼‚ãÇÿ`3Çfé*eÃT€cÇc:d]ßJ}3š®™~`fº¡!UÑÛRcO½½,¡	_öÌÌ`'ÄÇ³Ú’bx„'ÃÕ¯ø¿¤¥±×SüOÚi“µEpG²²DñÛœn¤´8¸SÙÖ	tÆYOæ§&°j<OBƒM–ÆÒ¾Ô$½ºŸ7“ç”xNGiÇfBü<ÀÙóEvtësÉî”=¡ŞVÅ4œ›®C¢»)œlhNÕ)ğ²H"¨J¤0‘Ÿ.6ôxëñ7ˆ|I£òiÌ{(ıÛ-&pşÍ¤2ÿ –¤>×H¼,q‘5ñsN— ÿÓñ—³ZĞ‘²v4ĞJ9Ä†|WÚÊSt„@µg?(ÅSTo¿ÌlKŸ©hÇÛâeèÑC.óRÙÀn³¡uœoõ®eo1.ÓŠ*2±p‹e—•b¤(|ƒw4×ûam¤‹š™ÅñÂJ÷!ó½ÅÃÑí+32;u…<~^€·0Š¢…Â_±ö¼FöåYğ©èKºoÇÒ¡ÀÎM'ÂªÔ™rèàÈ¬âo;”tò;ÆÒ€–~pGwš-ÎŸr¶tñÂRïbxuÅ‘ ó3‡£ÒÏlËx².oıG7?(B+=ïVQ"T$yrçÅBÜey…\*íQÓŠ‚ÊÒ'&W8cR˜« Škæ\{ÊáE‹¯€FI…Ífd¹]ÙóØÁÀ´gaÛ~GlMYbWd2ÉØ×Àüx<áº~œõ•¹‡ÙÍ4Ó}§Ë1ÁläNØ-kÒ—t¨¬TS€¹%]E}g*z™p“mS[‚tÎ²Å«õ¾¡»Ü­¸_,Â }~m1vL¹mÅI©ŞÑ‚Ú«àZ,B3ÅWÃ­X®28u¶šì\d‚±¬|”µÙh$¸zÊ½tR‡PÌß"£âãwğAeĞ0¤ÔnrËš\¥3SM>G´š]a´]¶’5î†.“Fa§Mİ¨""è5s«‰İrl·ûKQC74óÊâez˜mP¹5/9n™^¦Ïu†fŞg	½ÿøÎ3
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/c5/2eaf6d0ba4c53d5895f703327379c7b702d107 squashfs-tools-patched/.git/objects/c5/2eaf6d0ba4c53d5895f703327379c7b702d107
--- squashfs-tools/.git/objects/c5/2eaf6d0ba4c53d5895f703327379c7b702d107	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/c5/2eaf6d0ba4c53d5895f703327379c7b702d107	2022-01-01 15:09:15.609172588 +0800
@@ -0,0 +1,2 @@
+xµ‘ÁJÃ@E]ÏWÜ6["Z¡)3©Á˜	I4›n¦é(c§0ùwbé¢Ëö­.‡÷¸ŞZé5¦7ŞÕ³¬nõ›E(¾„Ò0(ìçFjTÚlÛ†×‘Tâ‘6;nñ*L+õ÷®çÕ"Oãté#dHY	Æ%X&´¤(ãËŸŠlñ@Å	âœwÉŒşµõ1N~vüÅJ5ÜÕv7mƒ	2^où» ûŞÌîæÃİ
+fÓ9éºô}‡<¯±CÈrxWşQİI‡ÛK:ü‰v†
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/c5/bd71879ccadcbe5a7316a4e294c8df235d4c99 squashfs-tools-patched/.git/objects/c5/bd71879ccadcbe5a7316a4e294c8df235d4c99
--- squashfs-tools/.git/objects/c5/bd71879ccadcbe5a7316a4e294c8df235d4c99	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/c5/bd71879ccadcbe5a7316a4e294c8df235d4c99	2022-01-01 15:09:15.593172588 +0800
@@ -0,0 +1,3 @@
+x•PMOƒ@ôü~ÅK¹T-M9	¦±·&­1ñ²áãÑnÄ]K0şww	Fzz;³ó&3/ÎeŒ·kïbiãªêlqB×Å Q„eTÂµç­İ+Ïõnğ·GYâ.:çò¬Ñ®s`*ß".Ğ^X<)eÈØê…Oö–Æ\Ğ”Ò2‘äuJ8;4U‹Ó@é—Y­TY'
+Şûv©È×¨â-1Õ>0Ôù|€³ä©‰Ê¶‚«¹!Ñ..}àButXR¤èëÃ™º8¸İ·÷y.´#3ôÚh·)i²õSøÏ¼cüBV]ú‡FL
+ôˆ…RôõçaÏô]ºPƒdOôz¿KLİAñ\rSx4p01¶Ã5ã:ûÛ·ş³_Na‘HyŸ{‹»Ÿ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/c7/bb05bd4939a6512eb7239a5aeccc0d25313330 squashfs-tools-patched/.git/objects/c7/bb05bd4939a6512eb7239a5aeccc0d25313330
--- squashfs-tools/.git/objects/c7/bb05bd4939a6512eb7239a5aeccc0d25313330	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/c7/bb05bd4939a6512eb7239a5aeccc0d25313330	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1,2 @@
+xeOkÂ@Å{u>ÅVrHzX«H#‚wû/5é†Æ‹"„Íf…Ø%É§¯šX²æ2?Ş¼™y‰*4=?›8Z/×}ï{µ„?ì-[¿JåIĞ˜‘¯èÌv€ÅvnMª=.’ƒ&&¡Zt_çübØ™"šÏ^ =“÷LÉ®Â­£RK·ÜíİiK¥
+cÍõ‘"íù¼JÍEišJJm2ïØëKy[ß†ğì¦nPv{ÓÄd71^:xÌBU©DCŒGMÑ0‘*S)ÎùïÀúŸ#Ë~"0°lÊ‚ĞÙØ9ZÃ9jîUş 1Õ‚{
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/c8/430a7b93e49266dadca857b623e851135297fe squashfs-tools-patched/.git/objects/c8/430a7b93e49266dadca857b623e851135297fe
--- squashfs-tools/.git/objects/c8/430a7b93e49266dadca857b623e851135297fe	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/c8/430a7b93e49266dadca857b623e851135297fe	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1,4 @@
+x•SÉnÛ0í™_1ˆ/©Ç‰SÄi|2\©&[‚d÷‹@KTC„&Š2ı÷6/ñ©€ qŞ¼y³‘k©×ğô}øeàÀhOÕíôûxªòÒBVªÄ
+­
+2¼»{êßß÷‡ğô·6°­Ô[´‚r-E©Ş0¡ÀÒ™Jyq<zé"‘šBñI*‘eÊáj´Ÿq–rsûvu†RË7FìGÎ+½Âš2±ä˜Fû‰t=Æ3~+ªìã7$0c]L2ËM#ZZoÊ,Cç˜´ĞÃOKÌÕq,y¬álC±úİI \S¢KÇù¤ä	ÉÏ4j.u“´fÌY>&›v\ÌI¶Z¤P5çîbª„½®;uwàä_Çg^Ïp~â½ŠaRêVıŞ6ŞÊıä¶k·êGqànm—SÜÔ³Âr³z.u‰LTc¡ªÑ@u¡lWéAÚ+¥¬§%öü?ÔqwáE„Q(LqÑ¦x&Ñkì†¡Æ?„Óıå±`µˆVAà‡K÷Ç‘5wçGcN]«eìúŞò&ô…T—8
+yÑµçç\úEëwªšëhO;˜ã“¸ —|SíH«Tdä¥/ Q
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/c8/e2b9b206cba7116f0bbbf333ae9024e3029464 squashfs-tools-patched/.git/objects/c8/e2b9b206cba7116f0bbbf333ae9024e3029464
--- squashfs-tools/.git/objects/c8/e2b9b206cba7116f0bbbf333ae9024e3029464	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/c8/e2b9b206cba7116f0bbbf333ae9024e3029464	2022-01-01 15:09:15.669172591 +0800
@@ -0,0 +1,4 @@
+x•VûoÛ6Ş¯ö_qó°Tœ‡lÃ–¥˜ÛåaÌuR?P(fĞe‘E•¤Eş÷}GI~µ)0#ˆÍãİ}÷>ÎS=§³î¯g?œ6éŞ)œ$Aös!l[ŠU*íÊ:¹<&š$Êş%j‘¤+
+õ27ÒZ$#ÒYºb=[R8zÍ:_9
+Â6½>í1õ.Qiªrèb‘HCæ%á¯ÿX›Åqñğ¦ÒâÈ^±dCb#%Y»'aä9­tA¡È`K¤¬3j^ÀåHdÑ‰6¸Ô‘ŠWL+²€.‘ä¤YZÒ±?\§t-3iDJwÅ<U!T(3+Y\XÊ™hx<_y‰+¶a\Ù@WŠ…S:;'© ŞĞ£4gzİaÚP ›jHçÌØ†}+Jø5ïñşnÜŠHe>Ñ9\H N=!œ4—TX©ÇCècrs;PoxO{£Qo8¹?³K4nå£,U©e*8†`‘¹bÂ¿¿½»HïmĞŸÜ³WıÉğr<¦«Ûõè®7šôßM½İMGw·ãKÔÊQû¬àå˜ReKm$EÒ	•ÚÚñ{dÒÂº4¢D<Jd4”ê¶	Ô\Î–yç_ÖÌ¸"ÕÙÂ»	fTKU8ç¤bÊ´ëĞ“Q(§½®<²ø&•úåwšH„GÒ]*BIG4.Xöìì´Coµu:ëĞû¾îv»Gİ³Óß:4÷jwŠ¬.è™Êb}BÿI³ù“ÊÂ´ˆ$êŞ%Ü@ÇÉ›-"úîDéĞ¥»ä"Cqï³ªE&öøXÜ©¥Ü•†¨Ò»¤¥pÉ.L·c4&Û[ªæ»l‘22s»4oÉ*—ök²ubŸ›yìM(ZëğÅĞÑÚºØDv—kµaR“ĞÅ*sd1ÌğuA§çÍ0†s¸‰¥m8Î›Í*3ô25+ózóQ«ˆĞ€bJŸÅ İüÒl¨8¨•´›O¤rúvñ\++rLŠJWi›ò¿µ²Ğys­5*–ùŒ–¥µÉ¾ú1«gsa‚¶·vqĞúPÈC?‹0<CD.,±¢OY¬¼â¼xùSrnXyĞ¼ˆcL5¿>{”`)üàò¤£7şÊÏa&´+8ï‚çœñ4;o+d½…¨‚(ĞÔ52Éãµ…üøO«ºlûÛ•À‹˜åàø¶Gş7ËË•,;Ú?eU¬ÊEV{Å›&ÕáÖ.gh³q+êÆ«Wˆlœò’}µã–W ÖÄÌÿÜX,¹+¾ƒÏ<ûğ5lK˜o¿^£l 3ßIûe¹®ãÃºÿ¢À·Ş!&’ï«V:4(~,…}@}bÙ¡#v6—áæÇ}¡c÷8³ ^P·ãXæ|:¥gˆ–sae ”Ãàán(ÇÀw+@ÇtEÛÔû×¦ıÉw®o¦w>êOxßÈ Û¦/¨EŒ
+”'k8ş³ß¬;~:uè ö¡2Å«d[°Ôë=9Ìhá‚*ü†Å L?ÙK“¡°’.{×½şğÖİ89äÑ)Í#DŞ0â7¶_îÄ¬â¾ê“›Ñíôú¦b+uö‡“ÑFe\Ç»ã—/+Z¿^xmKÓAE:Bá^Yºı§Fu†l|€d,ŠÔ•Úßöş]F·£ µËêøPŒ·úªªáÖ\†O&úÙb u0ÿŒ_U`|¬Ï Bmú¬Uq¬ÒNôc‰*Š{K¡Ñè¯nƒV¥¿Şe^8Â('¼1y1ËĞäë€çÒ(uøÁòï§õ#ˆ]FLøıV>ñöà‘YÍ¿¯y™¬M®º´gªËg{aàæy³JT¦ÜÖª«WcˆÉ†írP7(æs] 5©"ÀÃçæÀ±ï#
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/ca/b6698e60b9776e1c25b6ddad761f11409988bf squashfs-tools-patched/.git/objects/ca/b6698e60b9776e1c25b6ddad761f11409988bf
--- squashfs-tools/.git/objects/ca/b6698e60b9776e1c25b6ddad761f11409988bf	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/ca/b6698e60b9776e1c25b6ddad761f11409988bf	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1,3 @@
+x+)JMU054e040031QpÌÉÏKõ‰òuÔK).`øùùuf!k“ëo±áçBúşTmTÁ¢°œáº‡nWjøw¹ğYÒQÕ­œySMv@úTå&‚MÕK.(`xºp¢Ç×öÇ;SjÊŞK}óI¡Sj^rX¡â£
+Ïºå¿¾;Yô©ğ}ÔÛ»àÌıj…ûeí¸tÎ>àÒWŒşe¸`ctès$eA‰¹`Ó8y‹oäÆúä·¬bL=ºáì«…z¬hÊ2„\î´Å|1y&`ø‰¡}™ø™$£DTE.©Éù)©zÉoÅ[®]”˜i±ùÄGÙ`ëWåÖõaUšÁP—"jyQFÿà‚Ğ+yB%[+½»¡JƒKRÓ*À¼ğïUëñ=ªR
+×$«Ö5Nç25Ì›‚ª*ƒáùïÌ¶KËîe¿àµ¬­’KdSøo¨šÜÄìÔ´ÌœT†äeVOZ¶¯>ªÑy’1bñ{›/¢©ÑKONf“`w²‹øÉUÖ¢Ó{»VE·8 ™)Çx
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/cb/3d87526d5a85ac31cb09a5cd5200cbe078a608 squashfs-tools-patched/.git/objects/cb/3d87526d5a85ac31cb09a5cd5200cbe078a608
--- squashfs-tools/.git/objects/cb/3d87526d5a85ac31cb09a5cd5200cbe078a608	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/cb/3d87526d5a85ac31cb09a5cd5200cbe078a608	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1,3 @@
+xUmSÚ@îg~Å¾$y±jPgk‡¶µıâ8LL.r#¹cî¤EûÛ»{—Ä,-3
+YöåyvŸ]î§òz»ï:Ê4•¢óƒEFªv4›Õj.¢é<fP¿6ñi²lOê%ã‘6Š‹‡öä¤d¬gñä9<5»b‘T±³öû¿7l_XAÌ¦Ì0¸½ó¼¹ĞüA°¢I¨ ğÇÜ°Tûx©-$a#E¿?œ²Py>ØTç6Õ…’©×İåÏÂè±ê5ÿÅ`zÿnëpa€‹˜-—Ø³–äÙœÑø++¦™Z°¯‚}“š.¶g…¬x’zã(œ…7?©€bf®Ä€œöÑ„ö!¯ğ„8ØsîÖJY »À¦šajÔa5è0w´•óT{dÍ —j6Pû7cì•Á†µJ¼’J¨×¹wôoğ‡ÀøüÓÙ÷ÏhĞ&4<‚H
+m ĞÕz¼—N”×4ëcè./ºîElÖ+gC|~&‰Ñ«$SJç—qğªaû¥U0ÕñqÕÊV³ f¢äôºû»öm;LÄ<ÁbAÿĞİJÌ/¬šo«Ššw–µwºeÔ7òR.ˆt!òI€óf(Y»rÙ»mP°s…ÒÚ®AÌ¶–|\2¬6³O¹z‡|à[EBhGt¬Lb¦Íˆ–­e¯UdŸÜ¢ä$Jó© Yf	 pàˆaËMv=îõş``^ê¸¢İø]q?rûŒn½Á¥'–¢;vóß:	ÔÇrO°ˆ®Gı dÛ¬‘S³¹µ­Å™Ê—ë'ÊÄµò&oÓ©ˆ‡R)üaø2'|¶õäF…èbàgv—vr…à2`ˆ1BU@ØA!ÏSÊó‚Wâ¡
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/ce/2545c229d8507c390ac1fee3ca075176ef26e9 squashfs-tools-patched/.git/objects/ce/2545c229d8507c390ac1fee3ca075176ef26e9
--- squashfs-tools/.git/objects/ce/2545c229d8507c390ac1fee3ca075176ef26e9	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/ce/2545c229d8507c390ac1fee3ca075176ef26e9	2022-01-01 15:09:15.669172591 +0800
@@ -0,0 +1,8 @@
+xT[oâFî«ùGÊ B¸t[Ul¢:YH¸xm£4½Èìc<í0ãÎØ²Úÿ¾g„ĞîJû4snßùÎef)Ôº?õŞıpÁS™`
+¿ı=ú®çıè¡vA.ñ\yÕ¬A‚Kf²ÔĞİŠw*ßi¾Ê
+¨Çèuº«õ2.Ïa¢ÊU†Şç{Å¯æİVzÕ.ÿ¹9 „7kµÒltM5"•[¦q ;UBÌ$hL¸)4_–/€ÉäJi›p­î¬®¤j4Bzm@¥•p?[À=JÔL€W.aÂc”m8£ìVi2L`¹«"F–Cpà #EÀ¬àJ 9ÁkØ 6$C¯e!”†:+,U*·â·ÁˆÇÑ·ızOe%Àe•>S9•$µ¥vÂ¡4˜–¢ÊG=€Çqø0_„àÎàÑõ}w>È¹ÈYqƒ{(¾Î§Â¨™šÉbG=±Œ§CÿîBÜÛñd>Ù
+Fãp6Í}pÁsıp|·˜¸>xß›Ã6@@]¡ò-À·{
+)­•FH°`\˜cáO4ICìDÛ M4F¾!nbÚ¤ïœ–PrU•ILN‹3 ‚TE¶šÓ‚ªjäÙ-íÓ([ğî‘Úƒà	#\BPÚØ~¿Ó‚[e
+%[0u¡Óëv»—İ~çç,÷XÎóK´Õ,ÏQ·³ıh¯jµã‹\–Ï¯O)ŠnŸÂa4÷?}8]ßÚÇ÷ÑpöaìÎàöõúÆNC
+'Ã£Ë™T»@A›|Áe,Êá=Ê„3ÙÎnÈB×´bg®¯­|J„Ï´¨’Şá+Iá’VOš-Ë#ı^ı­¡1 ÀÃ|\¸ÁÃ(ˆÆ³àÑõ¢»ùÔ‹æ^ÔM>ÁŸ5‡.—7	í£`zş‚p}ş5—Æà58le¾R*ÇÏÇ|­SSÎÓát2C¨÷{´!İNïÇÃÑ¨ÕèÇ)ã–ñßğ©æÄÓ8MÉÖ8¨9âeÍ¢àOH¢9Aq$¦6¢S.ì?@ ÅÇi.Ë4E}DØ›ıñGÿ/ÒÛ.E'P®ŠìŒÖ`‘şJÂ;Kà4÷_qÙKæ(şg¤®øïÿ+YÁ~^gÉbµÎ#R›Ì.ÅÿA¬¶šDxØ¸/şÇ
+]
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/ce/dc1895db74f9799ad8a03e231b006fc790ecb2 squashfs-tools-patched/.git/objects/ce/dc1895db74f9799ad8a03e231b006fc790ecb2
--- squashfs-tools/.git/objects/ce/dc1895db74f9799ad8a03e231b006fc790ecb2	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/ce/dc1895db74f9799ad8a03e231b006fc790ecb2	2022-01-01 15:09:15.649172590 +0800
@@ -0,0 +1,4 @@
+xİTMo›@íyÅS|·nƒ“J‘Œ}°c)H5°Ó+Âfœ®‚—Ô†DQâÿİå;kå ìÎÛ™7ïl¢xërøóKïDH;øşl¹¸õæ«•³tı©³-¯çÃz2ÊuX‹m”†„3/÷4‹C:|ÿsÆÊ£nºŸòd!Ñ:N‚H.€eUˆF†ÛFë1³™v?‘Gaºåâ^g2Æ’—GR=İ9îúbˆ™\ÓVÑ1æ¸¿w<Å<DqOŒıMyÊdÀ+äõ]Œñ ÏW]á†#;I|‡s–(«ÎŠş¦$DX%
+öèsáõë·:Õz)ĞÒæ] Ô—æˆõ(:RÙÚ?*«TÑ¢äõ—§q*B©ŒÑ`8˜ì}Í“I‡­èÃ¨K>Ò™¥ŠŸ3©ƒ²œ²§ tWø,uÓË¯’ò7uÌ‚¹8éç±HÒÊ0ëUNğ:~üD)e+’-4uWmÂeíÚ¸2ñ†bj<
+ÂéKBF9<r
+”êêÀ¶Ç¸*P§} $=œgûÙ®&•è5u$´ˆú	ªé·!knCÆîÿçj[•Ú'ùíŠïä/#{¾][ºÁ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/cf/3ec7a543580ad6c5305713b3511105773e5966 squashfs-tools-patched/.git/objects/cf/3ec7a543580ad6c5305713b3511105773e5966
--- squashfs-tools/.git/objects/cf/3ec7a543580ad6c5305713b3511105773e5966	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/cf/3ec7a543580ad6c5305713b3511105773e5966	2022-01-01 15:09:15.653172590 +0800
@@ -0,0 +1,8 @@
+x­XmOÛH¾¯É¯Rj¡T§6…»”B›(	ê‡"co’7·k¡â¿ßÌ®_C®wŠ¼ë™gyÙ]n<qïßïîü²½YúƒC1›K>Puj°»³óÁÂßÆşmĞŠî„{ŸÁ‰Ç&áÓÌLü®şm5©ºãzx{iL¸‚™ciO_G’1PbÜÛ’5a.Bpl$s¹
+$¿	< Ûw·…$ƒSáòÑœæBßEƒÁ„AÀäTéÁ×³søÊ|&mºáÇ8áó#q­Ó¤š0næZâ˜0ô#p,P±pá7qT/áI…cØµH…Pµ‚*AÌhañÍÁ³G¼¶^àoâ–Ü×æ'b†.LP%:utÂƒP±Qèi{È|o¾uÎĞ:»€ï­^¯u6¸hââ`"ğ+»cFŸÎ<!™Òöƒ9rBˆOz‡ßP¤õ¹}Ò\ÇíÁÙQ¿Ç´ ÛêÚ‡ç'­tÏ{İNÿ¨ĞGVĞ}RPÌ)ŒPÙTH.lî©ØñŒ¤BtûaDÆï›fÕŠÑò„?Ön"’$qšÀGà‹À‚{É1A¡‰ÌÄ‘`'¡´àı0¤‡A×³[ĞIöİ;ÌæÏBÂ·à´;»Fc«ñnçWÎû­ØGLg’)%dİAÕÛåòî;^è2ø¤—‹úä 3%¹?ÎÌUR*&•dm%®”!~(ooÃáß>BËu‘.Œ€Â0¶TJŒI‰`Hàa)Œàëe»;ìŸw»Ş ¬Ìa°ˆB'@Êcø0~ä³!‡b¦`àG¹tyÒş<<ìœv{˜íÎ™ZV)?5Ëo˜‡¥Ã0¹ı×ÔÑjë3ÁtryÚz“÷8µÓ˜’ÌB¢U«@Êh[©³
+"± ¨“£È{«ÁIT-C³·
+š½4{höVC“¨ZDóçåë`sXP(¨‡ÇU¤ô$@
+óLÕö‚gÛÍâœÔkïåêkm×ÆF~ÇRÊ‹(ôo}qï?¯ÅÂ|Å.R‰¾hçË¨ _z›I^]±L9ZåÒF&{qÀ'Ûl×å´ëàşFE‚7Q«êĞ‘´-b³ä~À|³»>Fõ‚¯ÆFô1Epz>M¦™ä´'YEãTli˜§ŒúJ¹Œ Áâ64ıÈ´×!Ç^öPu&¶„Mß²Zù‡FO«9Š‘'¸éT9¸ÓLu¶+~½uÀ]ÜŞ¾­éeFø¨Šáp¦³*©´òRÚì£B#H"ôH„ØõĞ,Œñhr«Ñ,ãÌ’(/ø”ó¦»RZÁR)ÁÄYûj\Ic/•J7’Ù·HS)‚™‘ÑˆW‚<änUÃt‰ÿ˜»DgÆ8§V^â@xVšyö\šI1I9âãöo²÷>½æçæ0ªp62`êh†ûx@ÉƒE%±Ä×Õ_ÁºÂ_¿ba…iäS)§FÇFˆònÙw,İ¹Î=øMT Šóvèµ
+|„J¥fÂVÀÉ0Tö˜EÄ<+ü© å0&TPƒCuM¢?Xyÿİ«&©ÄÜÎÕŞÔŒÁÒı	ùšª¥¬6¤lIPSæÛès­Zjª¾ˆ÷ªfâ½‚É'j	q»vlÏSúdê„RbÂzsPÌcfW¦k[x—ñğp‰kñ0¢c´Erx¨—œBßD2½^7P<vk…©*1-T·G½$axúñ€úaîd¨·'tmºLa™w%Jö ÄæIo7pn‡ÉxSG3½š XÔBïp§Ú‡­†EùNyÁŠ¿Eó¡Ğ¡|OÖ»$äU¡0n)ßsÚ-ãBÚãI¦å#¬ÈÚ'hÀÆ†nliyl(°Vˆ¥G½^§W­äo	t}IâŠ7?š‹˜‚u•ú†çız]wryë@·~”ö'½IÑK†™4L$—¢º‚ã}/{ól6ÙnI:áì ¿­fÒâˆ~è8XxóÅRI8¡-^u‹H)f„TÓS
+Ì½…İ:>,£˜”==;L#İEè%~ôZ‡GÕÊ“üùêzgî\­»°î^ç¼‰+È‚¨Ä’x“ÅŒy‹Î(	ù˜°ùä,ªB“Tx‚2çR¯(û¯³haÖkÒ„Ô¦
+“_gqg8D´±mXÛÃœëXu!4šJÙ*Œ¶>Rù.W”4ˆì)0ëyûRıêL]W/V*é ç*T£ìÅ’£%‹~Ğìöv”Ÿ¹VŠŠ‘áÿ Ör)‰(	æŸˆ”/Ñ†Dyo+«é(f_n6:ğæÑ$…Y¨Tú°œ“FhgşéJ%kYPÉ(S»˜té0¹¡~ÿ y·
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/d0/54eaaf61f1f602eee07131acb476483e1a4f78 squashfs-tools-patched/.git/objects/d0/54eaaf61f1f602eee07131acb476483e1a4f78
--- squashfs-tools/.git/objects/d0/54eaaf61f1f602eee07131acb476483e1a4f78	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/d0/54eaaf61f1f602eee07131acb476483e1a4f78	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,2 @@
+xµK‚@F[Ï¯¸ØFC´²•­|´“$ZŠã\QÇôßSsaĞ¶íáÜï\Z	
+ÎÆ™Ù6Ä‘w¬¬®	™—<«Z† ÅŠyùÍ*´)ÄMØ¹äL\;Ä¼ù¶}™ò¬Ç»›Ó+g$Lv<¥ëÆ-İ—•B©ûw…°`©JMı¦| A@¢j%‡ÎïÿHÁ/(•ş±{Í„„¶y2	+cK^?²!ş5»²oÀn
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/d0/feea85c7bc251a20d6197aae81970a35316e94 squashfs-tools-patched/.git/objects/d0/feea85c7bc251a20d6197aae81970a35316e94
--- squashfs-tools/.git/objects/d0/feea85c7bc251a20d6197aae81970a35316e94	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/d0/feea85c7bc251a20d6197aae81970a35316e94	2022-01-01 15:09:15.637172590 +0800
@@ -0,0 +1 @@
+xKÊÉOR06eĞ×W.IqL«ĞK.(àâRÎÌKÎ)MIUP‚Šf(q ~Ê
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/d1/59169d1050894d3ea3b98e1c965c4058208fe1 squashfs-tools-patched/.git/objects/d1/59169d1050894d3ea3b98e1c965c4058208fe1
--- squashfs-tools/.git/objects/d1/59169d1050894d3ea3b98e1c965c4058208fe1	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/d1/59169d1050894d3ea3b98e1c965c4058208fe1	2022-01-01 15:09:15.593172588 +0800
@@ -0,0 +1,29 @@
+xœ]sÛÈ•†÷¿¢Ë7cWÑÎxv“ÍŒSSEK”ÍD–’GwHHBL\€´Fÿ~Ÿ÷œn ”ä™T\“Ø"İçã=Ÿ} ëu}Şşùûø¯ğÌŸg—áÃäl2Ÿ†‹Ë÷§Ó£Àÿ&góIöÌj}ôKÑ´e]…Fá¯ûªoüñm–…£zûĞ”·w»ğòèşùÇ‘}Nš¢óúfwŸ7E8©÷Õ*ß±Á(L«å›Qşø–5yõe]Va¾cõnNÊ›İ]8Y×u3
+ïëv§õŸÆáûŞ¾ışõÛÿşşm¸œ³0ùZ45T”mØÍ¦ÜíŠUØÕa	9!¯VaU¶»¦¼ŞïŠÀÚkŞèË²h³Pß„İO®ËeQµEXÕËı¦¨8Ÿõay—W·euÊ¶¯ê]È×ëú¾X½ßßøsÑùæz]hÕâ®HÛ·á¦nÂfB›Ä!‘¬Š¶¼­œì]ş¥ù}şê}“İ U½CíÖŠ#£woBxÿ 3Õ®É[ˆŞq–é³¨Š&_‡‹ı5œe§‘;x(«]Q­ü¨Û}Ôw(GG…ß:Jße‰æ×¯¡f#:Û=éĞô•Ä¤µÆ(²‚Æ6ì[ ©$}8 -$ÒòívFÄ§ÉÇX´W‚NÖCç»¶?Rá±¼z5´4aÛÔ·M¾	÷w5*Í÷»»ºi‘Òp°2Û·®SHz9¯7E|ìà¬Lû“`nYƒ!Äwı%aŸ-†o0VVí®ÈWo^…pUïÃ2¯‚x}¦ Å$	nQ`]´>ßU¸G®Û"ÿ"”šP“”GúJ`hŠ›¢iÄĞ 2N³mƒÎağÅ>OYk;¡7Ti¾(²»ü«+8n®söäfô„¾ğ2¢´¹5$ *D‡¾BT(o´u¸/Û»W‚¬/Ë¢ä´,²jY¯PLc»-°¿]–³ü8xTB6q F{S_-¤¨MªP÷.Ï$÷wfU%_ªúŞHÔ¾«Z gx¨n[ÓÎ¢ÆvÅÒ„Ôózh­Tè@B2Y6…<ÏR¾d‹Qìÿº\e`U.KÂ,€­Äá‡øNâ›ïòö‹…íï›FvËçX›¯z“-Œ°ÃS°èvãëØ`Y4»†Y±…„òº\—;Y™Üu‰fÏjTõ€ã(şM½*o_Å	_¿æ›íº¥Ïn×î—w!O¶‰¬î
+Nh2,u8ØFDåá¦`#Ñ¶Ùã&o…c¹X–è±ÂÈ­ØGŠ5.W™QVAüUzöœyäÁlÔA¥bÁ‹oñoòØgŒ[éèhï€kpÄ"\~|şU6YRÿ3È{ŠpO\Ûİ£Ó]±m
+/ß¾ì)t²Ë@ê˜Qöò‡W@;w,£Õı]‰P%£Ö¾\·8}‹‚­Eha€­GC³ç`<ªqx)t¼në‘é¢È¥1ó¸ÛÈŠâ¾ŒQ9àïeœcÒ€ÃŞÁz‘"3ñ °ã±hŠóBëUÈ	„ìHór5]¬ASÅè^*zÎˆ/Í#­M!c*Örö¶ÍñÇPH¾p_dFŸ¢ş%!r£Ê ó^´rÀƒ(ÅyX£Ì²Ê×#Îp–c‘íJ›zµ_:zZ´:•(àš×rÈk¸WÃÑw,Øîw–¹S9ÑQk ªCÌİs’Å1Şİ‘Q¹9‹h/Yî!×V²­¾Ş)Ì‚;ùVó _ëw/+2ó0KüJ)‘#~³“ĞÓÆDY­Ê¯åj/¢B}mÄéÒ,¾
+Ø„Oôoq;JÛğ7a¨ØåÍd-ä4Á„àˆÍ[ZxÙäxz¢ár]äòoPˆ"Cî®»jåĞŒĞ—&)yy0-¹ÇLn´Ízíşpö²”7ËNä
+w(ß,×#CƒQß"Ö3GÛÒtÅRe€¶íÓğ·séÅdöiÆgÇáèüìxº˜ŸÍÃÉùŒ/®¦gFáx:_Ì¦ï/õ•-üt~<=™õ’ÉïßXõ\Ú±iˆO…îëæ—›P–H0h³\rR Ş®ó^!¤÷AwõZ‘¦Í%ifC6Š
+:Ô«ÌlÚåµ| >ŸkHıñâÂı‚ôº@Š£Ìàíé›Åˆ„xõ²”^+×¹›¶œvË6A/8Ö ã7Â„Ä7åWÔG,±]œøáu~ÿ“¸LÏœË}m[Ävî¶u#üxf1Ê"]‘!äì‡ø!|¹ÿ%c÷@½’#ÿ¦±l¡îó[E²—q“x…DLäŠè@È,«åz¯D^GÔ+ë’ôÖ1ZVpãP/†§¿P:‘_fb^8_­È$Ø¼/ˆy/€÷˜´å«g%“,ë[FrÀ¤e–ğ“õÙ²Ù|‚í;©âŒ  åmiöO8ewñ-¨är7Y³¯ªÇ¢‡yzJ{Š•CD³NŸ Š‰Ÿ£¶2I¤Ô•ro¥‚úLÕÿ£İ•;•ˆQíC eIé/ñ‰ÅVyNÄã¾DÜuA²n^‡üÅ¯ŞdäóĞ½›@ÖìUöi/0©~B‰bÒÎÂÃÂÛ7Ñ`‚¾YCoˆ+ZQ5`ü»v˜ÔH½ÊhR¦­.Ùö”Û¦ÆçƒsÃ,F…U»-—ûzß"8³Å-«pì>ÙªÄ$ÚÀ„%‘H9i{¤ô&zmËu^n
+D§4à]øR[™„S½ÌS´ğ¥d“±l¡+ ÙÒ>C…×mQáßØV¼u[“v¯<£ÔÇêAVp(:€`¬Ø§h,“åë•{×#ƒ¹RŞ)-Q¦SöX&“\íİC[.IÎ×nÌ©vó“Å–ÈjøDúˆf=ŒxNœHMª>Ì ÷_cñÓeĞ~è‘c>À;
+‘+‹w*q=fôlßz¥µ· ¹ÜŸ±[·Ä„ÓaÖi®}èŠ,åxc¡¶%óÈÜÛ,¿¦à~—@ƒì{C«È@â\Şkê?y‹&ÕWË\‰‚NrJÀùM¹F gIjÉ<Ê¼#ä¬ÍC¾µs/äj‰Å¦gV¾ƒ ¥éluÀs­˜.B¸~B‡aSñ9ÙÚ À*rEËŠu.>]ù=5PU$ºYSëöYë¡N|=r1ÚöÄ6E}£ŠH±½O›ˆPñ˜%Axf™[cÙ¬º] oeÑ`"ûËW)ïDˆ-Y©êfcI&).ŞP}¤é­ª{!l¯"ó8Zì @t•
+£”52ıä…e‚=®ŞWÜĞúˆĞ±@¡Y7+"- óf2ÁÁÉÉ7R
+‰’\Ÿm’WÌe¡.aÂfÖÖIÏŒÌJÁ”k	¹m] )İ”ğ¸zÉ¡*f(;<ëğÄäÎ¼2¯l‹¬Óf^hã;â“´M]¶‡L£Åš6,%À¬í‚U¾uøZÒ59ô‰¶KR3éÊä×eaîê'Xmp‘*˜][¬q%JU‹Õ¶P¬³Ş!Á…ï-¨^ä¦zÏCŠÑ‰›ş¸”!üß¾T³ìúd0ÃÍŞ¼ÊºŠ-•RÁ¿õçxH,tp5_EÖA2½ÉĞFµ+oÊœ’Wlõ˜7Âzü²tşMËYXR3ÄÚºb7ëê*3ıÃ´C@jLXFH¦J÷6ˆ˜F€Ü†0Œ®X%<æ`©pj£hÀ'Ò¬#ß,I‰Â ÏĞÊFïÉ·ÒC‡/Ùµ9ÍÕn[6Ïƒt’‡ñÊXcJF*¡§#xŒ¡”˜okûBë!ºøTŠ!ˆ¤Úòê÷­¯ù<ˆ¾¿ª;óˆLªEyvL4;â ÀğÖ+­Çál54_šÑÄb*…{Eiâ'.pÁƒ$[İ5‚È—;ò<ÒHrÒö–Å.Ÿ\å©íÎ›ÅŞaÒ2ƒ×}£’ #Üƒ¢»w€àâ]zñ(BË¹øµh¼†wR:S—õÚ$ßé=
+{P?ÕÙÜZTMµµÏSŒmåÁxD¤F’ùí­¤”j¦Xò82‘dĞÃ²Ç©V´‡ Iê ¡eÆéák½æ:‡‡¢—¤†º*ºt¿úZÂmVqíıtdãè0)»×”Ö¬Hñ¬©Ç—¹ÿîó­”õ°u'œü¡XxL=1,VÕó˜ıĞø#DÕ×ÿâgôãıp´·¤o$CpÛ<~³ø|ŞZdø„˜$êinï9Î@í3Ï b{ƒ Ğ§Oã%!y«lüvÚĞgë|/kZÓê/@o‰=KúäÅkÅri¾yĞX•%ª‘¬¶ƒnî™L"±bÛ²c
+Ê[Ò+®7yS‚‚–7‰RóÚ­ñdìêybHBö”3”íÉZ®£ğ5_ÓA³Äšï¬î•zeJÆhXÉáÖ}U)7jA6;ÒÏÇcE*µ©1ue¹½m±Ôe ²O‚*ª¢‘f%Í(¸NHàG„È]ö¶Ãc‰ó-ebTç¡rô Õ×ÎF·ıoëàœòwNş>ÕûF‰À=…"Q,Y­CáZb
+²“ù gá,«£²PPÈ×‰ŠÍ1
+n$¥IòO]ëb	(@j«êJ‰¨<%U[·½†"pê"@›=ßÑ'Ê¶)ëù]ã5kêòSpQ‡ÙçXH²ó=­—{×nÌ1sI 1çàh3wå1§Å®İ$6	¶ˆõYìÚfÈÓ®–Oä¥T^vGÏ:øÅÓ	¸&?2ìOé¢+Î!{[jõÆ¢…ÂnMDÅ·d4íkd­äİòôz“äL7ee=Z/Ôâz1Ö.›rKJcæNTKñK¶Qr–4¥ûW¨ê‚í9Q<-;ì
+B2.\MãÔÔËz À¨¤ÚuŸBWlÇéf`ù3	 `ërÚC<F#)µ+ãÎˆúÚ
+µl^õ~v“ÿ‹ïÄ^ZÙéKçPÆ×–Êë¦HÆ‘ÑHÓ½š\È÷L(^=&9ŞCşU(áÁö•å-VCtGedŒÊÚ…Dù»?”Aş¦—‡DÎù½tk‡áq¤6™ú2vWÊæÌoYİš£xMD¬KmZˆæ!®
+Òu\3y¼a£¿ÈëaKFm3NÚ[ßö	k¤ıÑÓ#%xÊFëı­D—|»D¡î%šx›-5ZM<6yÔ-ÃR†ÿéSH U²Vª?ŞĞXÊè i9H%ÈæT·ø•;V]:wñRDd*ºØT{	Plw™¥8Ü±§+à¹ã¿}ºÜ§®˜‚vmÄı‘˜û+é•kÒ<eº(ïı€¬¬3CÅNÉW´İu¾ñğ…	Ã“`"¬Ú
+)Aë·Ä„âUœí‚RÊ&µ9¼2Â¨¦ê`==U7j$šb£Ësş»Ù³“ô¼.sJSİ]u¨¾Ö¤Q	péÚ†haRp¦„œ8ôc¾¶cŸ/ÌØu&ıUö¥‹TåA1=‚`!•©àdîòİ>…£²_}İ|A¿îëî˜ë¥xà2¤»ÈuâS~ğ›5pV “a'H¦ÉÉ«ÓÏ²†ƒ¼W-Yµ½†Ù~j±3"fu÷È}[DËS’w÷Ö‹U¢ Õ5>ŞìÚ¸öP^‘¨ğ;w|NqG¾]œ$raÅ¤Ö“§şôÆoQ%s>i·¤-,Óÿ%¡®­÷Eğ£¨„İÎ£eé~:~µw@dwı‰.œ‹•DN—ı?s/Š–¯Ğ†úÑrO%1HĞ›}ÃcŒ;'\pÿ¬´ß)x­óÑX¼®› TVo¬wŞ[RVñ
+‡Â-…¤Ş…ÓCol|ôÀ0ıß7´h<®-&Úİğ,„íW·ÖÉCJ gPœúU7ãB7ª½İÇ"h1xmèíšğRÒ±û7ñš¼lÛ}Ñ¾)7I(—.G%‘ö—´O$L1åT‘øYBBµœî=õ+8'µ°|'ÇLlxA?¦#LÔ½(,trj¶¬pAÆdçv-âo? ğ²HúSrY\á6ñ˜ ®ÅÛ·Lµåf¿f2¡ğ«"Rô_—^ğ÷bbFlZâ"8¹4qq¤,Öé‹‘_É™˜ì”Èöd¯ÌU`Â8RB§ğp‚Ò†CJŒ!á\Èbç+ß¯IæĞ¢¹Y.ëª„‡×6]00îAšNÁùÉï# W­h²P«p…3äMk@„üZü‰*Ò’
+øpÍóX]‡?Ù@T%ñ^#$åÎrkÃĞ‰§†à‘-˜ã Õ2
+|’¡ aé`p™mÛ§Š$İĞQV^ÃC¿f”…µ!<ôÚ
+İËıš1eÙ0I«A•%BZ¹Î¹ÚN.¼k¦0wªJ 2ïI:ı"Ó¾õá­O³”¤†2¡lx¬îO§·í¾1–,$±ˆÑ“<uûÉ­^‚I“5Ò_Ä)m~ Ê]¯M;[·Î®³ÌıÒÕ£¤7Y•¬á,mb½l_©Ûo„š¿“!ŸV;
+·ñÏC(hWÜÒ›èJ{ƒf×ã8P±çü©Õ‚½áqYâífiÙ”­]Š†c*ŸLEÍzOT”°g·ÚÅ¬e]çÌŒ_”ßÓ¦¦İˆ—·OIb\$¡İ\W,I€)µŒJ®PÆÍX’Ì_ Püïàš“,YóN€ğö[yîóTXÕZúlEı¦ynç-öµüÅJñã™V¤á'É<¥'úÄ½+9)$v¡—f—»Á	İßÕµUw UşiM×8jmÓqšC–Íc–>ëd·ş¬d¦¤Ğ0ÀU	‚7Š†¦oQîÏŠr&Š1ÉÂ5æ'gwH‹SØæH.Ò˜¨•Elu£4$w”†nOñ"ß$eP•®˜JN¬ŒZ‰rºíƒDrŠVx9ĞO‹sèôŒ!^Õ@Û·…®	·¯1ƒ‰ÂÓ0¦`óÃ+šİƒ<BÁt{zY„7sp!„ö·ûÄkêC„BÂNM?€Á""×Œf]2‹$ÖÙ+Å3rü£»™Öüù€DÌP¦ö"àz¯ëU4è~Óêôz4ÿ>œIWèK£LÕQÁIj¦r7ÓĞĞ h«|óüXVL%•ÄÊšøöæâm¸‡ÙN.	ğtVìê™‘|Q²AÕ²Ûxª¿<!
+™ÖÜÌ®,×<Åi#;ç³”ˆûˆ•¼¶M(ÅÍd¼špU;_*DÇ{æMø+ªıæºh¤™ƒ[GïåÜÏÜÄwV|í“:Â{#æwX0`N¦ÿB¾›æLÄ˜]S>”jÊ~@ƒÔPMD&‰?—O§	1S
+LDÁ=É÷•Œj-ßu8dóä´ú×!ğŞ_gXC‹ìì€ĞuñN¥-ïê”æ'Õ {šç^Î0 ¿eT}HViu`Ö!·‹2É*y<&],>ñ—QÒ ©õğc\RÂ«œÚ‘‰z ÓÍÖäö5M¯ìİìŞÆ£‘š2Ã.t·‘û}É?:î„Œ½ÉÀ^ßÙËL*ËÈZµ]Õ…Œ-F¿‹”2 èœ¬Y1Ìæ·­…åy’ˆßÖÀÈºÍöx±"ÂÎ³æUğYÂ™iß°”–æ İwª7†Æô¶‘ş-+hŠF:QYBÀæ¦kuĞŸÿsv>g³ñÙâJ·.o™f{?9_Î'añq.fçfãOa:Oïœ‡“ÙdÎOÂÑÇñìÃd¤u³‰V÷ÒÔì`VÛÏ“,&g‹pÁ¤ít±˜‡÷Wa|qÁmã÷§“p:şŒˆ'ÿ8š\,Âç“³ì\ÛBÏ|1ÖÓ³ğyÆlîÙÛP£¹³é‡‹ğñüôx2³ùİ?pº=.Æ³Åt2Ï`ä—éñ!S/ÆsÈ~>OÏ/9/
+BÌÏ®Âß¦gÇ£0áÛÉš.f“ù|rœ±÷ôOørzvtzyl£Á#r‚3è\œ›hÒÚ´;Ä°öi2C~g‹ñûéét:>™.Î8Â&ÇNùÑåéxÆ[³‹óùÉH¤ÈoŠÀgÓùßÂxEÁşırÜm„t‘ÿ§ñÙ‘)j ©Iì†«óK¶›Ã÷)¤~œH@¦i	j''“£ÅôÔËJ™_~ráÏ& ÓÓp69‚Şñì*Ì'³_¦G’C6›\Œ§ˆ_SÓ³™v9?s‡Ã¼Ê%“_„Ë³Sq;›üı~A‚ö mæ@ïÙç)‡KC•?²Gø¢Wş0:ç½Ä«`£Ú&ià™İ,÷!* EÎñ{¤Áë sj …	Dğ>˜ÌGY£)¾ª9
+ó‹ÉÑt|j zèúÔ¥Â››¿”ù nÆ¨ñeÂ!ğ“ÊdƒÂÚYÂg?¶Ë—ıÙğ'\œ#_v;/ÆÚÊş~?‘éÌ&g‹™Óøèèr†ii…  óKŒmzfJÉÄ/_->NgÇÉôÁ8œŒ§§—@1œ ÄÉçˆP[Ö¤)SHÙœ.¢0¦'uô1š®6*î#ªx?aÙøøÀq<'ÃæÓh7m;D9~ËÛÁ­=ıÌ€¿_6'ïH›WÙÅØ&ŒÖx[Xã¯ä™ÏHŞb8lõh¡+"ğºŞÅ•™‘6irÎ»îas²/ÏÇˆ–^4èN©Í¨yy÷‹‚N^œƒr½Œ•¹J5%¹¾ç,ÖğY°âÍ¹Ã áÁR‰½Ê¦ù¥AŸD]Âî=Õ”èwmFã¢oİîöõ›©>‡"ó¦¬êjÌÈ2Nej`›ßˆ5QÜ=moÉŠ9›”lN'Ş°iNÓØÑ»¿´â“…d_™F×ƒ–å[äåá4mëoÚV¶ï‚©/c IœX²ÿ¢Ë^P[3S!ĞkªíBSgÓé#WÑIv¥à<JÌ7Té¥â¿hÃç‰î¸( Şx©4Uå[3«R0V·*rqëå$•fÇ¶{é£®Ó;ÙÑÀÂÏ!üÅ¶à	Ï~vŒ.¤òxŒÑ¤\&Eüw©x¨eO“û÷ÉìP>ìTŞÏôŠk{?æ/ s¶’[¢cé‘ogTıë¦±îc1¦{"Ûå%JÂHÈ±m8Qã’íhÖĞå›Pëµ;:?èa2eg˜êä=vşèµñğå˜RĞ'Œïi`2^û©)£wØÎ ß¶x»IQÿĞ=GYÈËvø1+¶1/Èüoóq{˜‚¯@DûÛM§G„z0Ñ´¹QsõßÌ•»_€8ÿóß€Nõ*£FĞPlÇiZ#wî„±{{É@”ÌºĞP[SWåÒŒk›S(àûJ½BËq˜Iûp2W¦JçD|ı„Y3:=i„Sæ[ùÓÌæ$YgşI"Nâÿ)}']ëqğêCE6N]¯^N*ÃşôãèÑoYA»Cè¬Ù0xškü¨ieü~~~z¹˜œ^³éwVE@„İÿ§½ğzÿİÛÍC^jèúè£úë¾Xë9¹ƒ0@ÜY¸?èM©v£Ú·ünHb_`ÿw[U„v¡ãlx¢ÏTå?ğtD°Ñ.ßA=Ÿ&²íV·+8Ÿo‡\Îo8ƒW[­±£Ù¶x0¢èISC]nc¹zõÅR%yÑŠc¨:Ñßxbo"‡y f¯6tT‹×KÚ\ñÊ.‹Š«O.æÛ×¯åË\i5é×üW„‚¹‚œÈ¬½¡7˜m	—úëúÇ^br"ÚnZ­}Ÿf¤‰){™¸ÉZÕú°§H6ÀmsX}ËTvÇu^˜~$Ù¸™Ì*½]ßúKß@
+&`ï„;5le!OA§5t_Õô½*„<Õ/ ±k@,0Äã”­]0uQp<`ıs`%ß.Òl´kÔ¨1o´±“nÊ4Dÿ‡©š8ÜÇa5ác¾dˆ‰}âD¿Ñ[Z<`iuõ3¿Â„lÁBû…&,‹_ŒÈÒ˜QIo‚ıB®;ÀÏc«oÈxß^R«PøêWüÖê}p¬½<›¤­ö èp­ÉzMcYwg8›ëUtİİ=Ú¹ü“9~VRu¤„TÃ^İ8èÀG×Ö¹.³Íy4©Ú²ƒš’P¶]q/[N0NAˆrÉ.l¬eĞ2µßá†íbô~“ı?XÔ‰S
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/d1/962088554d5b466d307cfd6cb4286d6b4ecf59 squashfs-tools-patched/.git/objects/d1/962088554d5b466d307cfd6cb4286d6b4ecf59
--- squashfs-tools/.git/objects/d1/962088554d5b466d307cfd6cb4286d6b4ecf59	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/d1/962088554d5b466d307cfd6cb4286d6b4ecf59	2022-01-01 15:10:57.689176788 +0800
@@ -0,0 +1,13 @@
+x¥Z}OG¿³Ÿb"ßa»IiªZBwÆ˜„Ö„•¢JÖzwì]±Şqö§ûî÷{æmg×kzDŠ=3Ï<ï¯óDÌÙ/ïøåo{/ûñö˜ı‰Õ:ãy‹”ÍË8	™XXä‚íy/Cxúçş°cB§K¶|Š×,/×k‘Ì¡ìƒ{çlşÈB¾ğË¤`<õç	˜Ÿ†¬ˆ8Æ‹Ç57@³?º8ÿ<;Ÿ¯'WDDµ'Iœ-Ø£(Y(Òï¶ñÓ¢ŸrÖÙú”ğ¯xZ0Q’Ş‡Û³ÏlzıùóÅåKâ”ƒĞœ'b£X
+"?]ræRf…`"åL,ZÎ%#‘O˜rğ à¡bòb~‹2O$ÌªÌÁü‚%ÜÇÚÁìßûqBê‘b°äiåÓÿˆ›jÊ‰É23²±·k­ÊV7·m–Ú“Öe“Ûóá;½bw®‹8É¡¢9ñÁö£¢Xúı¢¼óı4î‰lÙxêK³h?à¡4Í•ĞXæä)[˜º,NóÂO©NàÏüìQúC™jkA`ò›[+YJÙ‰øs¤Ø®Ü{•à“Û‹vÉ•èW A †#âf³é‰9Ï¢rÅ³Xê‹5OsQfïÃ¡•ÂRû.îošD†à¸Õ&5ƒÇ“‹SìX=I­å¼—NÎ.ÉU­bŸr CfXÄÄ§‹œ4·GtñˆõË<ë'"ğo‡MnÛÕ)Íş‡Ÿ¦l$’„ßç`èÌ8Ÿqs‹DDbÅ×ş’˜öªBÁqñŞ<Ë|-
+©ı5”~Ø‹ŠU¢¯+S°Œ¯E"{´xòŞRˆeÂ««u¯Dºˆ—%¸")•§+ÿv´ûæXµwÄ<? uã¹”½¬°¯Ì}Øf8¢mØ£-‡uıõ|htå&U'Tßn‡*Epm›2eÈaôÀG*ªRmÊ7<“.3çE¯Í}ÿˆà¨Ÿå‘(QBæœ•9T+âO®ÜıXÑvh›ÚJ¤/¢Ä¦'¿–£Hû¹KIÒIŞI+wš>ƒğú?’
+±1sH=³lQR–Uœ³ıÃŞûŸ¬NB~Â±¦òrÀ hôgT‚s¶òÁõFdwÖE™Ú¤‰ğCåÖ~pÇb\².ä2¸Ó‘\¦ı+'ÿ«ùö:\05 !KSTr=¹gàe
+`£_?Ø0Dj‘6š§câAÁšRD¯O·Õ¶Jo¤ÿØDêÊ?|ÿXu°B5¹µ^¯§n'W:í´bH
+v2üü,`è£Ë¹çıQÿgxQ¤›	ÉçlÏ«LÆ¦kÄ‹G*I¦q]Şô0*Y 3¤ü5šÊN.o"°MQ-Rüd)²¸ˆVt2XªfJ@äœßå_J?y1ÛHÛ¹ô+D²M ~ñÇS 1M…LMØEV€ÍZr${†J\#ÎW>
+’ñı¢ÈâyYp¶3¼ººÌ;ÍV©ìe?R›¶i”Xm‚[ˆÌQtíëÔèJ^TM^ÆF¶DãŠìnû…Ÿ-Q÷xzg"•^(xNİ éJ•¤hR"t]ë+óÚ„_YªÁÛÀÂÔ@J”dÕøzrm£Ofö=6•= |…Ë”@mê&Î#ö@úÍµs”-¨ÎÒ 
+¯Ë|j!A§•Fœ.ÕX·€Ûoà§,ŒsÙ?JR†K\.UâÀë¦¢«yQ3‚Ñu™”W}‡…l·%ïREšY#š$¤ƒ<^[¾T×_¹ÜÔXéi•ê¦9MíËÎ=c”´íÇ×g“;åèĞ©+2?/wjïìÓhr}2V9°{ÖÃÆôj8™lµRıyœzŞùoÓ_§O§³‹ã_§jU%>ÆgH‚Áğà_òšÈÖ9/C/&Sˆ‹?½W9Æ.:ÏÄ’¦¾¹Oû
+OŒÖG ñ,èÉÑh ÈÙ"ó—Dˆ?@rî~)y‰$ÎéÀó®?59†s˜4&P·Ô¢ûXìâ»øQá·‡‡Xk©jÂ€E>S<ÃÜníè.X÷we}ª~İËÙÕåp4öF§“á‡)ûçë.Y÷âÙøÇ{³?¾ĞLt°®‡²|2;=›Œg§§ÓñÕìøìjzôş”‚“ÉğòÃXO/®/Gc‚şğézfWnö=úóõ›ú°úçk‰çwšrö¶Xö&gÇäİd]Dd5|[yñ‚aûoöİ©®sğ¶ãÔ=q·ü
+"Ó„<ÛdşzÑElÙqB²‚ínò$+Êåx:½¸œ2é¡4ÄÏ2ç¶’¹º±ªÿ˜§”„„v¢üĞ”r(Ş@1UåuLh@Uõ|˜`ÏÔw'O§q*×j¬üŞvcåÓö}4ĞQM’İûYŒ'¤SôĞˆ”~7äI¬³õj­i *Ák†tÙfHRdeH£RU§ÍªÏ“«:f%Ğm¡g*Tˆ€²Jµ†§jitı¿ComQõÕ[ûM?<U2ï³Tù¯”«MÖ£ÏğXµ™¤F·™!áµóçùzxÚVŸû[TgÏˆ(°èÓåØŞê•ò¤ÓÓ )Cc^ÌÀŒ®U25Å©ÒM³@A¼s|Í.€—ÅĞS‘.‘›Øâ<v@n‘ŞµYo_cÔ0ŒR:Üæì°i—Z‹'y3yZ˜çÉf¢®İCõ¨A{<Éy-ÔÀw[E6KH²Ô«Î©=Ë× l‰F‘ÕŒ˜h~¨—tƒ“&3òÈ7ÚT“ÉÙÏÎ¹@İ]âF¼7ûª”¿®QÌø—¹–ªñdü$4­a
+_w4Ï:œ‰sù
+!ïT‘+»„vtÆ©(è5Ã²İd¹º^3±‹FXöÿ2å61†îcpÕ)mÛIĞ6ü’y©V'°*Í~rÛE{é;3—ÈçŒ­ĞRoLÅÔûŞsèÛC«….VßYnåŒ@äÌ{¼uß’pºT«ß”˜/Ì1Zbòn´ItêÈĞét*1jÄÈ%1îaT{ó÷à¿z&‡ÓÊÙO¿¿ë)RÈiÙ‘£÷ùãÅ§?p-zM”ç~×ğ©¥-0ŞÓŒ¤‡¦ÆLÀ¢Ñ¢J/©Ê¥W5÷È×È­ïdQ3:9‘­+}U·N‚i""è#‘e¡•yÙ°s¼e.0¸£FÀLOãFT­dc¹ y€œ2"3…T˜Bô8‹O=³DL66Ü¡D¢‘}=n·Œ‘~è›šU$†Æ¬1ÏSãÆ“½ô5ªXr†`†ÕÊR½ÈóÔPCÓpÕDí‚*ˆŞ€‡>Ï3SÜÀh20_v¢pwmélN´A¸ša=Ogù¹·„±Ğm†Ww+Ö ¯šIµ%LõÑÖĞË¦Úš”È=ÏŒ¼ˆH5ü61Ôßt6(×¡ag—4¾#Gcã=´p Ôğ9Pƒó³<çqII?oup¢­gp¢¬¾Âx­Á`µ%Ã³&¹¡Ú´†bŞvAÏÙŞ„ïmâv?¸ß¶m•Öz
+\õtPŸI›ª­×SL#ÍRŸàÑœ>õ»¯Gß«îo Ïìú¹‘ø}´‹Las»xĞÙz§NOL—«eSn÷¬)v­¥%4U»¦:k¢qØ†)U‰sÔÄ±5»sbõvC…®1}c¡kŞ¢ªFM`UOe©t]'§nË'aÏnìäéææ/Tß6>]¦*]PrV‘»hjŞ¼NÄTtõ3ÛŒ’½_8…ËÀ¦1zÛAG;I:gá%o¢w/B„WÀ]ˆ~|"<îBt¸Q¥U«»JÊjr1ë)p­Ö(¯º¨"Ó…ÙÇKÓvU®9n[:3Í©:«%'µ5ğ^É_RwG&NÌ“ŒL^:-¶@Ù×·oHª†‹ ¡’zò`ìf+Ö]0¼üÒò1Êi•UÍò6Ã–¦ì’H›.]ı‚2À_™Nİ3ŒêßÊ{úÓiÕAı¯x¬»ÓÎ#=’“‹©yø?¼$åˆ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/d1/e6c2b69e24bd1847dd11b22a852572b230345f squashfs-tools-patched/.git/objects/d1/e6c2b69e24bd1847dd11b22a852572b230345f
--- squashfs-tools/.git/objects/d1/e6c2b69e24bd1847dd11b22a852572b230345f	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/d1/e6c2b69e24bd1847dd11b22a852572b230345f	2022-01-01 15:09:15.657172590 +0800
@@ -0,0 +1,21 @@
+x½[{wÚFßÍ§˜¦')8Œã<Çé?oí˜¼mšõái0ZIÕÃ„¦ùîû»wf$ÂÁ‰O9'XŒfîÜ÷k&C/ŠÖnkûù?š›±)‚p¹WãDTíšØÙŞş±ïÖ6?¡±ëyn(Nƒôj,#ñ*TÿŒÿH­x<ŠAtÕH¯_c2ÍïİX„QpYÇQ$¥ˆƒQ2µ"¹'fA*lË‘tÜ8‰ÜašHá&Âòf€Ià¸£¥¾ƒ“±‰Œ&±FüãçwâgéËÈòD'z®-N][ú±¤åv§Áx,1œñŠcÂ¡§qÇ [‰ø{Bº ‰Åø-vê"ˆDÕJÕH!M¬¿™ğ,àaæ60“&/Ò›“å×çíÇAÆ 	¢¦`§J‘Ær”z¼x ~=é¿=¿è‹ö»÷â×v·Û~×¿‡ÉÉ8À[y#(wz.3#ËOfà	!qvÔ=x‹%í7'§'ı÷DÁñIÿİQ¯'Ï»¢-:ínÿäàâ´İ‹nç¼wÔ¢®€|°š§b`“ ’Â‘‰åz±!ü=$;ÏcëFB¢¶to€›%lhÕšÒòÿŠÉ&¹âì	w$ü ©‹iäBA’€9'GB;e]<ıQô%Ø#EÇ³l)¶D/¥µO@›ßqøuqÖÛ;­Vk«õdûy]\ôÚ†ïÏ‰5˜FVÊ¨a8Áï¥aD	óàô÷³v¤MÂHÆ¬-iìy½Ã_Du·ñì)É•O«ˆÍÂ‰ôAHPT´XL¬™˜ÑuMŒ“$|ÙlN§ÓÆó­?İì©;×q2ñ ¦Y©|ïú¶—:R¼:–§î°1~]}`Lq k?È§?0ØWšMqğ¯·/EÛq€$Ša{
+tœ¯z'Ğù¾òÔ¶Å±ôÏÍ{ £Hí•M{@Œõ’y¼hÌ±`Z7’ûŞ‘#×—ÌËÁÛ£öáQwĞ;ùıh£JÜtºçˆÇâE­R‰Ø¯ÜÁr3tVo×›p,“ºPÏŒÁ}=Ùu^»Jõ4ôûzÀ¿+p“i¨U>U6R?v¯|°Ê[‘ØtÄ>d'{•Z0HÈÏ…1¯Æ«T!ò4ñ`·û"ßZÉÓ
+4m¥Ú«T6ğ‡@?ZÓª´%è^\WÔu]Š&&”<ÊQƒiÔ(ÔÅ“º ükÕ€ PUyë}Ñû}pÔíwpG‹şàèü¸&ÀŒDŒ¨õyš„ğIÃt4‚;à;G^0…?éÊ$|"›Œ_¿C2Fæ)/oâ;R·±ógĞ¬÷ş÷>ÿe~·6Ü¥²†ƒQ¼Ë¾( Eò‘ìŒ Œ0q(mw5á…°\<²’o†‹ú	³ 2Ü¶Z9¢š<¹míÏ_ ®À±xnù
+é;.Zê›ı¡/$1r%|£ZÃ0H‚b,-D5pKA‰)FÊ6¹x
+2ÑÖÂé«'^ÏÓa¸€ 9¬(Q1»öXı	ÑAğZF¾ô±‚ çÃ‚Ú^‚Œş#±óô)˜°4ºØ¢YUöú5,RÜ6ygnrëÙí³ŸÌÍŞÙ½}ö.Í&=*Ãòém/Ÿİöò¹~Ya¥ç@`“ˆêFûHò†HadğJCsÎ‡5ßUğ€p †ıP® D°İh!i•Wæ^â
+ö*0#ãÜã&»Ä\Õo£0ƒÂ‹%?Z2I»Ô/¸Q ÆşÆ|«%çoÑtxPEùbå*Y§¾ä$5# jY{ÿ‚eW—Æ•Î¾zEººr3HAWNvb
+´’|5ü–Æä5ÑA¨×*ŸOüMOM¤Øqÿ‡ƒ€¢rZ˜1œ{¦:å¬q0w¢ô…ÒÎN‘ğN0²µçşd+(HÎÜƒq°äÄúl676*Ù¯Œƒï|^™ òø›ÏëwÛGUîƒµyÉY Ï¶TìÉ5R,„SätàRJãå!p³ğÙmş×À,&Ìóx‘ùXŠóĞØE,Ş35:@.8:Š{Ÿ™!Ò£ÒŸO°·»oXˆå_Ü‘À^Š·ˆy¹Ğ”h€¡Å7“miˆ*˜>>’-°3BLJ­'… )Í%M˜Xpw³sØk1S"²hÄ%oÌNÅ³Q@*6é£3v¥í=]@Ş´ÛP}ë
+‘«$.'v9ÈÆÂ,DFaGé•¢2‰¡¼r}Ÿp¼‘bHƒ(ıÎµÙ=ïÛä¿„"fMŒF±Lâœ>Ò»â3Œšf#øVİım!¯vğõøñ¢UÃğ‘-%ŠÆœÇÃÿju!s¬©M!Ã}á+ œ±ö_×¬øÂJ~/W™kóÖ¯ƒÀh7qŒv/k5±õPÌ$4s7I¿´C)a§ˆSD_I5œE>„ÿò›DÆßÁcpÆÍ^8wS9Ÿô2§¬_}Ó<ú°ˆ
+GBV+nÁrQ Ç™h!Ù|è0R
+ÜÁ×¸aár•É‚tgŠR“L @fÕÅ•êw ?L}®0Ûı3
+TfÒJ]L‰Äº†ÙhµYnıÚíkÛ¢B·¹ä°å};Ì2Œõ§§(òG"¥Z 5	Î¡ªÆk&vjë›3.Í•"ŠÕ7÷Hl~4·F¢l"²Y\©½”!AQjh=ü”Ùd©ĞµÈæ½Âß<Å”a)üdú˜Äæ7Gb®À«‘È,æ¥øğĞ¹ä/VF%œ2KÉÄ¦7WÛ@I	!­¶jÎ\ºÙFø6ÚÇ)InŸˆ9s…ıYû·Áé»%o:«ŞtŞ¬zs~|Ü;ê‹Ö¶0ÙïÑGôo\Î¡<XzVh¢µà4Ä™5CßZY?Á¢ÔÖÍ®”QîÓ&!<¤§Ùs˜?‡ÃüÙqmêZÑŒ«ÿü…Š+ùoB€ª0ğloyWn È(q¹êG¢$?g£Hõu„¤qXCT›æ'[çZ
+E[Y«’ùv"^;«9vÔ…ÖE8D–ÅáÀ©\ˆrÉ$ ê‡i¿»8=ÍyiÖV«ZW•¥G€à»ÀO:°Jdªä„4\3©± §¿¼¦`«•«aö©Ú fô|´È,/B5¯´Œ„üò|ôxUÒ?Fš¥¦6Œ,b³¶odÀWÆLrÔâ(Ê{Ñ72ÌÊ•=èz«JıìšK™jÖ¬·¤ÀJÏF×|OqMx÷5Pø;ï³ \ëæKL•}él!Ûÿ!›¥3
+’…8bÕ§lıÂİ¨+Oˆxr³w¢àÆu(Û²T{ŠeøçÔÅAiõ¡¦E‹~9•Ó1:!ÃÇ;[È§mZµ8Ô¡
+ú„24ûé§íyø r àR/,çÎ˜ŞÚ8…:-TG#±ôT¿KCH‚²P8F8 @'8ÄQ EŠ ®ƒ.êàÑÙ–ˆTÖºÅGí×ç2ÜP\”cK—NAwUXä½nt”«¿ÌËmŠ-Sˆè;=ÑÀY }^} €PÌ›àKKÌdTÆeeÕÏt@1@@„Ú‰.„5|~FögÎÍB•£«¾s_—E†:ÑG>É²¹8‡ˆ2=™›t w%µß£“fNÜ&2A,VK•P?€z_ÔACÂ[VÏ!gËQ s!ÚÁÛIù,ˆúÈ’ùø¬±bd|uœ¼¤ }†y¶…™Ğ6˜ğŞ8CsĞy›o²@øÔåÓâVv¸“›¤‚ğ¨¡/FrªJƒ©R…Bñ¸ÏÊzTRZK"¢dñGq?û­øf§Ğ\”z™iÔha]ìˆıó¯!biBK_ÀèdDİ)ŸÄÆO©M¥zêÒ©‹ÿ‘	9Š#^„"ğmÍp	(ºâ52møi]çÚœ—\Yë…–¬@Ù-.Ìè'>{6Uéı*çôé˜’}j‘mM,e”60¤ˆE…àáDœ:T®OI@¶1ÁäÍCŞ<,nŞÁæaqóehd‰p‰°€D¸	‚Dˆ„CB$é¼¡EDhÁ<i„>E„ÂáBÊ¸oEˆ é²¤$8ûàùÉwëBI²ıñacç7q×?—TÂÌ	‚¶+ûTSXë‹Z'å½˜Ú¥ÿ·/ï`ë¾îÜ7À'÷p÷¾>½o€ÏîàóËBp.SÀR-Õ†Ñfd”à€ÈBbñÁ³_¢›Eµ–úÕ_J)¹ø’íåÅo:ĞÛËº@×kí„¸Ñ»!‡(¥îîÖZ±v¾´/NZÌàÿNR•O‚f•nŠ¸lòL
+Å*Iü÷mè y¾¨ŞÜ)…W‹„ïäa¶È¤µÔÒM1ÂMÊÕÕª¦kİr©ˆßBñZŠEqşÒó7Ô±EXÅãWØÇWÙğWYâWÙÓ·[Åíºkf»6ß+.WLíL3#ß™ƒyè4©ı^Öó\îA­´8]ÊåLÏ›” sÅš%5\	Q‚LGqLWû¸ÂÒ¥­±·B$r]İTÇ +±qA‹·)]­…Lı‹‚'O±€ÍJà&àĞç^Ó$w®£Ë˜%ZWzĞÅ<ºÕˆ$Tèåçn(Çˆ?|çÆ”{×~0ÕäX:¤­‚=”€)Ñc€LéRKLEÛLĞ‰İ<C¨aº‚6ğá?º“t²
+´Jd«½_´{o{ƒã“Ó#¾ZVÙØÙQ¿}Øî·õ¸LìZ=éJªàU¹Kü®T3Í@m9¦¸
+QG‚ÑEÖµ¨›®Ú³é ‰b'A„ËªÔãW¸Üm+p!¢æ#RE/± ìX×œiSµlé¢Ğfèràª­­ºÇSk¶
+{*ù}Å$í¤ß¦±‚
+_Û„º“cWô»UĞ‰r>·"]¡E®«Ô?¢Kx±¨ªóª:+”ühÑm*ëa¸ŒËf`Ùªnßœs-oÀã
+î¥ü€›ª>#–hñÍãzUÀjÑÚ*+PÅı¢q n2şí6T’åè‰¥ -^£WWFnYµÜFÂj¹–Š¿şZµ÷òæE(™şß‚F¿–Ÿç¹S^gÒŒ¼±‚jİwsÜR\m‹sCš«cÌûâßÂ\t·öQÿ–ÇZS˜»Ù°pad-(*ºa±zXk9ÀªÂ="Iô<‘;œéû.Yd˜¿"U¤…:>ê¨û+7
+Ìûª¬…û–Oqÿ¿·QXöÿª\ê[h§µ…ıTuEàøÖo[_@&ËğVÍ×9çú9OS}TÎÕ´b¯Ÿ£ÑfôLª¦§¾Úöt]oQ>/oM*æGò_êIwâÌşeØ”Ş-Ğèè« ú¸×Ä[„1:àĞï.™ÃIàvZÃõ±Ôùj?Íle³é½Ëïyš·%×ôh¢	9Ø4Æe¬Â6èùëëíçg.ş[ÉÉù;ZêSèß|¹F¬şÃ‚.œy›3oƒ©¡‹.Ÿİ'mó—ÙîJVû´?¸…´-@¿#yæ0ş^i4@sÑŞ™ĞÃv§òŸ£Û©ÕûÜdºsŸÔÎ_«¹+¡¸÷t+ø+ü?'S'v
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/d2/8d8542563d5f76f9710208b6afb0a22e2c8910 squashfs-tools-patched/.git/objects/d2/8d8542563d5f76f9710208b6afb0a22e2c8910
--- squashfs-tools/.git/objects/d2/8d8542563d5f76f9710208b6afb0a22e2c8910	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/d2/8d8542563d5f76f9710208b6afb0a22e2c8910	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1,4 @@
+xuA‚@…;û+½ØEEOAaFRnÉÒiI]Q’1ZÅü÷í
+ZçÍ7ï½Ië&wå,lâ!Á;6=Z¥¦U9/€±øš9QÂöš!¥
+ùªà‘¥ñÜñö32„
+ “k5ƒã,¥ŒYİåÖéMğvx«ô5ƒ×‚ÏQq´=²ˆ\Âón„æk	¢}vY’Ã¼*&üÕˆ|uòEõ¡/kªi3]êñ@+Ì›^¶Ğ'w˜sŞµó[
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/d2/d291c8eef3ed2783f199e4f346267f9db4be73 squashfs-tools-patched/.git/objects/d2/d291c8eef3ed2783f199e4f346267f9db4be73
--- squashfs-tools/.git/objects/d2/d291c8eef3ed2783f199e4f346267f9db4be73	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/d2/d291c8eef3ed2783f199e4f346267f9db4be73	2022-01-01 15:09:15.629172589 +0800
@@ -0,0 +1,2 @@
+xUË
+ƒ0E»¯t¯ğ¬Zš4¨ûÁGB’BÑÿoLërçrïŒË{D–e·4E9¬¬M@lµ›•F"™÷¬%ª!ö·uêA¼–w¨xvM¤@ğàTğaÌÃzıs”øŠ_Vä¼êd^T—| (ÎH˜ ^eEŒîMßícİ´l³ÂÈ{‰‰®€Öíğ,ô\ÓÊÍV|v$N
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/d3/0b75c1280b2fc77fd38f52bdf75043e8938c89 squashfs-tools-patched/.git/objects/d3/0b75c1280b2fc77fd38f52bdf75043e8938c89
--- squashfs-tools/.git/objects/d3/0b75c1280b2fc77fd38f52bdf75043e8938c89	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/d3/0b75c1280b2fc77fd38f52bdf75043e8938c89	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1,4 @@
+xu’QKÃ0…}Î¯8L­›ní„UÖœ0ğAÑ'²µ™ÌÚN§nÿİ›6I·©…Ò¦ùîÉ¹çv¾ÊæÁI¯‡q>“Éòúáîq¹~›_$Œ
+™¬Ö)GëhoÙbìéV–†¹Éä;ÏKgüYrœ¥³rÖ…f
+ñÅíBf÷YÑ…%¸L²TÈW—}3ZŒè}‘åp"ôGèàa¥S-#ø.Aª8:ïYŞmô7“ÀEDÕ›Ií6*PÁ88%iD­›"OÈESßè“†.ÂŞ•‹mCY;ıiµëì6ÚD­A–ÿ’ğ§®JD]ú¡<…”‡g¾ëœS^”æ“J¥‰·.AíÔ3 ´êh; ESÈW·h^xç°Ìºª 8Şó£ëm
+•ÅVÍJ™ˆã*35«a£d¦H±E4+z¿	J®’°/Iş£è[E«EÍÓT÷½#ËêÎy¹Î%ÄˆíØÏÀ²
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/d3/cb55d4ef6638e1a913784c2c8b7271649b65a3 squashfs-tools-patched/.git/objects/d3/cb55d4ef6638e1a913784c2c8b7271649b65a3
--- squashfs-tools/.git/objects/d3/cb55d4ef6638e1a913784c2c8b7271649b65a3	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/d3/cb55d4ef6638e1a913784c2c8b7271649b65a3	2022-01-01 15:09:15.633172589 +0800
@@ -0,0 +1,45 @@
+xí}ûSI–îıuø+Ê=a™¹wÖv{Ã`{L,ØĞ³AÈP˜‰•DÛ½tÿïû}ç‘za÷ÎíØhÂ©*ó¼óœ“'³²>ÇŠÍşÆÆúÿyô¨Øı½^NÇgådíôêjiéÕètx}VßÎÎ^œY»ø.½¸¶öHÿm//Ç£G/Ëó)›ÄnÙíÃÙ¤\ş0«†Ò*iFÌ˜(@ÌùxR\V£êr0,NÇ—W“r:­FñäL«ÿ*‹³ò¼•Åì¢œ–OØåveûİŞşÁ«ÃÃ“½×'[Gİw6ÉËyqO»õò~ËÅıûí÷ö_uß|³½¼ÔAHÛeÀjmşf{éåè¬:Aa‘S7ò~7u[GçİÜœ{s«‹³~+ÀÕq}³ëú–3½4yš`0¬İÿx´U&eéûb|*¶V h>„Ç·A éó!lŞ
+LŞâC
+£Û
+Ävj ö³IuZáƒŠc^ƒ7‚hN‹Ç·¶Ø¼µEÿ a¼74K[¯Ñğf0½Ø¾T£Go¶U's¤"oƒ¿‡!Vë¾wôhï(%k4¸,§WƒÓ²xg&Ş¦¸YJ®ÒEáÊÒéx4ÕhV|zY®‡³—Õé¬“ŸvÇé™¾/úëO­å;£Ùã~ñéíõåëÁt¶õÓ¬œZG´[ÿÂ–Kåèú²XºY*ŠO[GııûØşnúß-ù@Å†oüÓãği3|êÈ]HĞşn.ıdÓÙ`VÂ‘’‘Ï§ƒÉÉ¬xğio0;½x]àüw^Nßƒ:¡h÷;ô!ğÓãği3~Ú²0HoÉoâåÇÉçÍäsÿÀÚ€Èğió;¡“¢*>Pjûãéûõşæ1È?¦ÓbÛ.ïŒªÈ¼ºş0¬NŸ€ÈôFo¹¸)Ø¢·ü´ø7Wgvß(ïÂä È>èáp<›š
+yŸª>å÷§Ò<´NA{l¯nğêèäe±€*¡ "|{VDœOÃå‡—¥»XnCèÜÛ(=+z½ áùóbc¹XÅ¯e%Å°ZŸ¿Åß`zZüıáÃ•âÔÁç„Ÿ’p« (²_–~‰ÜQ–`mIä¸½[ÍÊÉ`h»ÿä‰~ê½=Œ>–ÛL#<Ù¶ÛÅƒ	¯Ú·•B¥òÓå‡ñpYìÌ†YÎÊ/”„¨Ò¯ğå/ür6.ğûÿqcuU‰´~*öéMb©Tˆe
+£(NJÍj¦ïüñšÑš &ÅHFÏ?BîôÏ3…óù¢–½ª¸C@Ç_n‘Œ±òl1	—"¥KL~úKÍ$«èU¼”n	¯ÙX_/½Ğ‚ûË2®üz²‡úÏ?5'Së¨©Fî¸ådÖÃ/‹XÛİİŠØËÍÆék–ÄV´&ş|@ŠüI[G_12#¸9 ÿZÎöşËŞ‡ñxXˆö0Ín‚òr;R˜Á+ÂÀhçfÈœö¶q”AdTƒ*A‡«K†ly0'PW7­Ğzî/
+¥úá÷‰°Å(²0öÕY`{ƒ#µÁEš‹è,Z<HÜœ[ßa¤µpÙe4¼I9»ŒT¦°9:ı4*GgL‡4˜WòD‚­YrÄíCdåT]üÉéÅ–µf!hìJ?¹$1Ó@\Y±Å"|{V¤°Ÿ†ØÔøN†ãÏ‚Ş{·ã	0_Vgİ÷)‚“‹êã…4	ƒƒ[Y(äS¢VÜí8y*¢êÜC6rÆİñçC	i¡$ckc¢ıµñßÚAÉ‘^äºNËÅ0m¦n’áóÉÃ^u–ğà\$Êo¥ËiWUkeÉPMrÑŸş¥Â™ÌÌá.ÈšD‘äVKKf'=yÆì-ö’øínhP´Ñì†ãÖ‘ ?lµoaÆ(šö1iÁ¡lI6§›”Vk¸c.L=DÍ	 ‰*¯Ø¤eàzk;­Ğ°î²ÕxIcJt·!k×x‹S]‚ú£ÚıSo™Ó˜x8Î˜öM{m³ÇeNÉNÎªéìhğaXrâÙë’>(úÚÁİbÖ´W»¶7˜~êmÊdB€ƒËñ÷ÍK¯u…ïnkÎ.7;]>)ÂdÖÒI][—ıIùcOM®·ŠÉ„ÒÚ@’›Äb&û¥‡ùô¦ô-Z
+(Ğ»`_] ñ:ëàş¬½^ĞàóW£³½Áä“µléärğ…¢“ô£¡œCiùEŒñ7(Gş°{T¸1-ºYÙs§_ôî¤S‘5»/rë¯/gÃøÕÉ»Ş½Ş{µ÷îàßuÌ±Â{ŒÓÏ&½ôæ£ uôm²Aá”a¤ã^ßn¦¥Ô,h³ú“¢‚dFåçâ-*`y/V¬p§C›ı’¼(]ô¼Ó¢7Vy‰šá|şÇ¿.şÍşÍÛğoşÊø·êlİJÁÖ×“êÃ·¨…õÈT-¬TÍ§JZ<ÙÆ)Zv˜ƒ*™mßÜî¸\ŞãÛá¡Éâğ6o‡‡&‹ÃëÜÎïÁíğ|!AuÓ¢8`S½¡7/dÃùÍö\Õ½Ù¾e|°Áb ×Àˆª…€Üå°cüXŞSs˜r³Eb
+²Ô‹ËBMZ|ÿ}ñ	r)~ş%::q¶vssÙü¸»İÔ#î.Ï¯JÖé4ó›._™sZ³„Ñ0a«±ªjİŞû	EíıÙäÙNâƒŸ—çÀ¥HşÁÎÛwÿÒÓk«ÏËYÒ!ã:–Sv×Êa	ŸìYÃk†`SLª¼ M~Å?rwïd˜Õ=2#jÉFV$U²I"27d*dOi–B5Õ.1É ş³tL.²mš£eúğäİ¿O•f*‚ÕçÙkˆVdÎòîj6U†Bš³B¹ğGô{ƒ/»å¨@:‡tz©ZN„$Ë5ĞJn3’—õõf)SldcHYB.cËRaz1)±¨‹eÙé«ÿ¼YPH×>ÀPoÎ/"Ÿi'M~¤†Zôf“ë¤täËbµZÉiñüûâOƒ?Q9§Å3|ş¯?ù¨?-V14de…‚có$…5šSodl…ÄMÛ_2ª¬ISÌ„òğ¡~Té™Ì™p¸fÀ,4<51XIDªl~	N×Ÿâªûø¾Üã÷ø¼W[—Y.ÉêwóÎûõcŒÉâÒ«ûd»®Ÿ°÷—Ç+ÅÔFJĞôe¢õUá¡óÃ£—{¯Ş¼{¹³·Ÿ$±pRÙŸŒ¯ÊÉ¬ÂLE¹Ü?x·¿ó²xp…XL2÷şöâ`çÅ[x<6Ğ¡û‹ğÔDÒ’ §
+rÊZâRZşiâºO\èQ¾¯°D±$™w¸ôU«‘ÜØÈ“üË‚XÏ e;/Ÿ<É&d,½½š¡­ı(…Á¿ü°³é–GŒ!0í¼ıÛ‹İ—/şª¤ğ¦M´Óht¯]ÿ6Æ–˜lg­f Ê®=Ï<ÇÂDd¾èS˜‘€,mWŸnIyM^/†Ç˜F]\ş	S±êR×^Eğ5AÅè-•foË±şÔ¬Ä*ŸĞ¡màgúVƒ ræ8û‹ğ¼uxt°°rÄaÄ¸*I†ûï$ŞÊõ¨,w3uÏ$û0M`[	§t tG!›"ûs7t‚v#Ş„=uT¤Mè»ëÔ
+ğÓi;escÃ’ ÛC],DæóL¤™§Ä%˜w'Œí¿3È…ôÿîİnäñAKğE’˜à€¨{ªH,ı@‘dæfO~xUSl­³H<	ùŸvZ¡ŸÉ¸Šúkw!¤-´¹é¸7ƒe¨¦4Lp`|BSÛ¿+ìÁà—¥g"ø•üz=é”ˆÔôìE¯Öğ™İÒ[°.ıs2,°Tg¶Ï;ûF^C@Nçóôïkè¢Ö,”¡½É6ŞBP'‡qÏ¢zòiv^N9Ô¦=å!áª¤È½–ˆ%|,¿FD×µ¡/ş%©¯Â<cGæà‘›Vól³È´’Ú´GúÜoN~¯Y”l„D ÷Ÿ»H–ßbFå<Íjœ¾)«¹²Ğô#"º„ÛŒ#­0ƒ
+Áuâ·YlÆmµæp•Xe;Kì±°h1	õ„ğ¬,C	Qº
+úÕ"EòÕ2õm
+÷.¢ÚEûß–¸ÂîdwQH	„o‘Uü±‰É<ëMğ°Íaºu—ğyÓ¿&k
+å„‹FïVc³,·":¥s†(“tş7¦õS<¡3L}l’·sXşçu9šUƒá»kNæ±­»x0ö˜´1§ÖØjàÓ>¦CŒÁPÈŸ9¶eg=”Â|Èœ,¹!Ûìz™ƒ€ëı3.£Æİk©ûxPüS~;1â“îd2¹&\õdm PÅq¤·WK7¹S¥÷PSi5Ìd*2S©ô‚PV¨(ö¸8VŠ·?ìî"9›;ËRîİ.zğ—/%ÁÚêÄH2¸ XE/’ sò‡52<­à›k`ºD–Ò¶·PY'i{H Œ`S[	M:V#Å¦¢ÏÉñ&ªkÖSP0uºeuÈAç:´Ó:CÜ8‰ÉH³d¥FCw'ÕTf{¨¼ÿ{¾ÍÊ¨¦åÕúîxô±å¾Î™µn‡&Ldôê_×;®ot\ïç×aX 5Ìkª‰€ ã“Iy% Ğ½“„tâ±,ª.Mô;ûœ©
+”6¿Ü:m·Ã~}=¾Ä*÷`tZN¹¶¿Tt™CàzåÇÑ*r6L5e5èWÜ=D§DZÛ³Ø|1¬>6ä'Â‡îQõÿë`úz|=:ƒ9†ÚãÉøjV]^_‚3Ÿ6ËÖ;¿¾}=™Àİæ÷gg•ì;¾;?Ÿ–ÜıÊ­äMÏŞx{ãKˆĞ•	7šÔÙâ«lh}ÊšÏê*M]õŸÎÉWŸ¿¼¾¼Ä÷È™×üÛF¬côUƒ“:õ^Cm’o$.oN?}LÎœüûpá D•Ñš^OÌG5åŠ{Ô¯µ„ÒöJV^]Òïqÿx²a"iHm-I‹7=I1?¨¼)i m4T)Çhä65`8^Û|*_HChK#£”Ø NrùÓ¼ï	¼#n@å¾ğ	MMTA×ˆµ*­.)&“¤Öî.ÂF¿ ¨¯ÔßQR1r9¨ì&•†¡ÀüáÊğÀ¯©LH‘p×©2á&öî»ˆÔSÎr@†t(ÈfKƒ„†fœH„jÃÅ~dZ7›óª5º;œÀòSÑ­ç<8:à.¤Ö>°_[/ÔIáB=XªFC>wgBÆn(Vü—ÌîÁÙ`6#’t†/Cj±YûFVüxGÇ>ë3‰ÕÒ˜…BÂƒCgYK?ÂøØùX£…d	MÅdêÁ#ìX±H[˜÷†åH…íËòŒ[/ˆ²üòÚ~–‹Ër0š6Ù(M÷	–±PG‡íCS}qà±á“î+ê—P¶w	—Ï
+œ¹‚TWÑûj:½-˜QŞ»oS]¶°%ç¿°nîã Å¶^j«AF¡×$NûÎm9%ôÔPhÛ,ÛTƒnCŒîYèòáuæƒ\v+ô	èÕÜíáa1b¢÷Ãr—<âFQj„:À†/1İ]ĞJG£Ç\¶ÖîRâ)ü]©˜DÒB¨ÇŠd#íš¾g6Š1!
+3¾Ğ Ğomƒir–ø0"MVÉxªc¹ÚÚr"™ï0
+4á’òçi“Ë¸±ú<uëŒ+Ó‘3È729P=.¨•+V	Üçá.:g¶"'ú5ˆC]M	#ÊA¤½¸Hœ-dEˆ¶tP&¡guªm ]²=ŞÓëÁ§°”"’p™æ´š\E‰gdcÚÔœh,kÈºèB"6G4aX—QÕ*V%3_Ñ(˜N¶Xp^“iòóÉq[`	 ~"9ø¾³í|,¹áaö¢ù_‘›iÃá:ê;_<îykÔJn£Ïµ„ùš’IvD'
+ø_İ úùSŸCy£@ vn\Á7Vãë)Y_)î9|Iç„àŞòJöFDù‹åÙ‚Ú<éM‹Ù§&ıZÒ¯²6Ş´[OÀXª`ÆÎO¢C“²(jß÷{û$×™êšm.lnÂÁ$0QÁ‘¹ñûbØú-pÀ6’tÃ‚ÃHe†Û7¢Ã6½Ofå•c“±°?, 3Üİ-GÒ¢§˜Q›1{%ÊÒ³\ø‰æÓŠ=jbf—yCÕğ¡Ñìé>ãÿ'ä– «Ñs¥‘GæàlVĞˆ¾€†&µÑx‚cºÕ„–2 æiK6ê£!ã¯¹"nË íé{Q„F)óåŞÈ-ØhÁeŠŠaaĞı§? –õïé^ 48‰À²-y/·]NÁE—ËûmVØ¯!±AÑÜÃ¸›€şa<İ-GfjbÄ9¶òÔ°¾:ª0sÍi"QöB²nÓ‡yq sDX®ÈÑGØ§ó
+Oÿ$ßÒ2è& )0èzÆACˆ¦qÄìÏmB¾ÚyÉW}hZo¸£3W‡bJLŞ}ƒ*«ÍœºÄ¶†–
+œÈÁY@G.!±»åMªª	Ïb¦,ÅMÇ	/òû 9à.%i¦â’Dë°õt<±üª¥k÷¼ŸÎH]’ÔĞ¢<A‘à‰úAº‹à]ÓqtÔYk¾»lø.:89|cˆNè{U\ÓLŒ´KÍç>à’DNsÖaâç».•V”ñmVæ¸¢¾€Rt‡Jò÷¸jê2† €“¼upÿ¢ÜÖ,D,D¯ĞÿEği9%gÍ`ûSìÁ@ n©Ù¦Ñ¡‹’Û·´,ê¸F“BŸ‡ÔfJ¤àZûá
+óíò ¼òøÄ›6/ÒvØ@ÇìÏZÊ˜ŠmÕxj=\˜4j”§`Y9s¨
+3¡a!x”BĞ¨Œ%I+Å¸oäwC	;Óœ£dR²â}wBV.˜”,m<hGIƒË
+…”1`Ë"”âI˜È¹NàH}*ç¤LĞdO[£ZÂ5¹ºPâhpk•Ğ,ûqÃèóo±â z´ºù:ÀùØ–Û¤ÊÈŒ´Åğœ¡9#`3—ä©—x8›0é¤CŞÕè´ŞNid\¬B–TàRõœrşcşï0'BldlÀÒ˜¡õ›kB¯8ÚB8T›Pt7°ä\…G¾é@JÃñ¹4•2ç?0Üèp7*3æ•Rı€CzQ “Vr’ìg‘"qĞ‡9`š7P¨Æ¶Úíj¶íO*´”Ä´‘¯Û \ë…Öš†OÆ+¦u0 ái²·/ ¬µIjeq»}Á¤à ãñl5&¬šs¡®(³KÜåĞ{K¥ÂŸ÷Ş’àë,õ¶®n±¶!ª“'%‚ÔÏÛHØ#”“£ñ¶Òºu¼dÃTƒ<?Áz¹*^î¦dJ)]58™-³Æ“†%QÁ¤ˆaã*í%—0¯„8‘rëT¼à«êá¡…>Ø€ÔÏ/ÄÄ^µÕì–JLƒ±<êpÏ°,X|1iáX¢o®0i¤g“ö¶5÷ËLûÀv˜²…ô"
+1D¨ˆ–¬+¨IŞ·û*È B[äpÒ¼µ­A^Z¢é)€@sƒ’òŠí$ƒÉô¹°ÃƒõfT07Éd?T‡RÓÈ‹C$[Ä4§D„„Ä$Y÷à¼‚=‘G€§
+±Ä”ŞôLC*Ô¶GÔUb´gåh%çÅç“pxVk>Z¦‘ >…àš’¢VaL85…[9"ƒãŠ¯5m³¼I{YŠÂ†§#eÁLÓöìQ£še·1\`‚×§Œëeîş1#	¶øNg»\ÄÙ•q‘•ÒŸ>à´Olnè¯ãP©6! OšU#(‹K}$ÎÔ‚M/~TCŠ@7å¨§áÌ1óÉÊiV0ë‚²÷Ó^5’óà
+˜G°6ûYáf‰ñÚµ‹4ÕÚÍ|	»Æ}ØkÈ¨sA´7Ş\¡´šp!"\ªùtÀü¾xLmŞ‹ÖÏn©ÃÉO¾
+ÿˆÁ±nÚ3a|À$ì\ñ°GêfkÍfåå•_B6„qrC*Ÿä1°\ğzÇË@d–\HD`—c®ŸgñA ér²R–›Ø9ÛpiT!/au§B¬s ›¸Âmyx¨1tÓªAˆgp&mÒØ·ét>kVîÑø-†# Äˆ	òà»l%$‚vCD¯ƒšë…‡ …Ñ@=Ló´¦lÁ„D§®¹ˆŞºÛ{aÓ;§Í#}°Qr(æõé´,×ıHBTØBÃoZf‚ÜYRÎçc2ƒ”qú.uÿıÃ‡Úucó¡µ‚¦¢âo“Êi×Êº=Ç@.L÷ı²—I²(ÖCi±‡/™òãoªÎPÖ"Ò˜~Å@˜¬˜z$\†ÉûÒkÔv•Ùü&#ÔĞ±ä€¢ÆØ3´Mc)koc«–	B X¿1ikÇ”Å!6ò¹`ü”Î¹’Y3€`AøÖ,ŒÅ›îX\^°Y3t‡]PC’Çè94İ+ã™©Í²ê;ÈŠÁnºËĞ=•tğt˜ã×İóûæ8dH"/­wb|K:Åa”Ç@§7×¼Œf»ÁÄ‘ŒAÚAaÔ»ˆÉàÈ 4Itğ„ÎõàGMjTËV>"ww8ë…Wi6¼¸géò+Ğo’ç>Åu|‰¹’èI/²€qÙºÚîè<¢˜g`ş´Ûq„ÑºHA•8g¼­YZ†lø÷şWÆêªDj‡êeU‚áƒfbI™Û$Æ¸<,•ŸJÁ”j€è£fÍ-zC&¿h¥ùecd0—ºæÑYª–èZªWE/Œ$Öøe]¼’.gFF¿Û9Âú]¾€`jÃŒ Ïcè`¿3[bÿT EqKÖÄ–a´.Yğ¾	;¶yš<™sR¨N0m&i?dQ”¿qCÙyÙÄSª°%ÏÇdKÄm5à5a¬äÙ²k’åÜp:	ÕFëÎI$±6í8³áš&ë90İ®C†ÅÅôÈ.qµÉ:kT¬”#¤QÇv=:L*nzÍdQÈ}^øpå¶çË„©VètüwçÏìœ±0BÆşH+;O3İOZ³o…İ£6ıš©=»âdS¤y¬Ìä£ î–ƒ³Ï1TùÍ2pö¼cÎ.u¥ÄHèN&x¹PWGÒ>­qDshtwJÂm²€„ñ'Dí[rôz[™+‡“t”ı
+•X6·ÓÇ†mù Áz˜Wé·øÙ?é_1ü$ó·ÿ<uå˜•µw‘S©l_ iæ·>¬EKñG™N¡ ±v»1;NnÎ/ª­ùKrtGGºŞØÀ„;âv½$ôØV=‰°6ÿ.Iö~©¤[=ÍnÂ@\<G¶.­
+©© /Ä:Ë-ø6Ø-ÆS/Fz,Š¦×ésê;æÄåì'Û½KHÚş×gæ.Ö–ÊAñ]Ş£6·5Z­İ3mV½´Æº¼#lwÜ|ˆBÌ7l‹à¦?&ğôx8+P­BªÚG(VJF;{øŸbÑ’´˜1ÄF•SÍ¡ZSCş{úï~²x¨Ş ¤´XJy§:*îœş‹:}ÇÁñÇôr{ò¸Xâ»CÍt·Å<1I5X'>Ti¸c9õ÷ôİ¹§?zæD›¿§ïnXnß¿§ïÁÑ«h~OßİDB²ı›Hß=pÏOH»'ëÊGú-~öOú—¿óC9å¹UÙ ×÷UØ\>ÅFn9g <Ãù¡úÈ4BÙDúÌçõ 0›ûÿèŠì±Š^èŒj›íVïéAS½ÇıU¬nŸ/# ÜÇ[Š$SÕ´V¤‰œÒrX|Ë¶,dÙc¥¤ºYJs dùa7yÒNñ’^,KwäPé:°æL›o×‘+.1\¶f·¤`¸ÖŠÒçQSÔBHÇÁ &è·?}‡Èç=§ËEmŠ ±ÿ.ÏêÆLN·´kJú›~Â4¤9˜C/w~|4™m-²éPÓ4ÇµØ“¡ùC~l#5	«Ò(ÿ÷>"JCâùí>!*sùø4×óô!4êæ^âE[Æ¼?q
+åvÜ²d…‰DŒ 7ß$à­x¸\åme€a£˜S7…ÓIİ:1º=ã¯?p,[•¤£&ßÙŒÅR¸x'T ÕŸv¸±9*éÀyn GLm<{¶ÑÇáñy!ˆ-Ôß'4’|ş w¸·[ Ï™Wu?j}P×·¨f“‰3ä5CçÓô-›€ã>bLë[ö2¥1·Nt5vŠ ±.CHvYò”ÌD­@aaj”¨”‡„‰É;Ô¦y·pSO×Û[Q?Ï1''zöZÛçf&¤:é#7h%”'„wH
+˜:ÎV(–xÑ$·¾ŒÇİÛÑBuüñE>n{ T4¢kÏ¨zÊwÇhË6æu ‡j_[âbÇ,”Rï %Gæu†£¦“¾ÊEd¦ÇÓ¨hšRKv[HCãóo.;M„£\·(ÃÔŸ°c°ƒZÌ’T]MGaÎ]OÆ&šˆ$§: z3#ië8uÇ“IZ©Úê¥¯­Àk2â±vÎSrŠN¾‘ü:Îf¢øzx=½ğüp4şŒ:®¶cíö^§ÛåG7ö´}}ËØy~(`y‰½øZ”2²ZÚDdPí‹5äfã^ÏRª±ˆqtQM‹óë‘¼ŞB¶Ô}Æ“8Éµàş8¾ÈJ.NõèÆËÉ§×ãó‚¯¹^£«| ¢ğ3‹WW]OÊ(FãYq=-ÏÖĞCR‚ìeYê1”QÙ=Ö­³'şÃjx+ïıL*+l	"ë»¦‡½õê=ô|$kªûöh6*{læb™g5ÚÅÃ0ä;MEi@'hçÇâu #$<S$(°AjõşDQ8Xíç·ú’L\Ó£+é„‰3RÖC/<é ØñH55š@rÌ®ÇVrµNÁ0Çx¼„Ä İãôñ^4>(Ï®OK>âk£Åf¹±Sx%Ó iée5)O…Qn¹p`8D“ÎHNÏ#Ş˜f AÔ
+÷¯rÅ•rPÒ>íİÒSHPİ/>IG;¤uÖÈÃN1á¦GmîØY“Å?u’¯£ãÏ-çq†ıZ? Œÿï¦@ÁQ¨şj¿Ê³ByÙAû!ä8+ôã¤œNwFçcye†|3×7*Ë³š›‚zÂ‚Ê¶œİj&8“/±ğo=f‘¨¦pá Ğ)6U'´R(ñ+¨~yr	tj.§~ÜôÁÑ~#´C8FG6Â;@|hO³VÃ†Â=+nB<ûÅ9˜^”gÚAi#ïFåÖp|ú©ÇWy¤WŠxÅàá’ƒIsN¿¦G¨™ ³ AéÉ€BÄœ´TæüY9o oI:àø/êgÚœ M¯[0QEba£µôc,$(€ú‰¼_c†f_	Få©—“ ÉÄØLU}µanY¬x$®ÊA;1â÷ô Ã	×w¢ï•š¸Í²Ñü¢ª4Ÿ}]aSúDvÛÒ›d€àÉäõ¶nêÖ /Dê$¿üıÑš_WÃá¾zWYÑÁóvj™¼ÊhÍ[âiÒËĞtL åøîÎ¬èÆu²Z@¤i(Ò¨& ¦m§¨‹šdjˆ¸‡¨áŞò+°¶@¹;˜¢îf¢£°à,IÂŠ&Nğö=†­£"sî5a•tš1é[ÇæE‘¾Ğ™<pCU{{qCc[G¶ZbnMb—'ŞÁGîI»×ÕCgü@\–0/äD
+é|21äMáPô°â¤ U¼òãºäX€vÉÒˆÁ¿‡A ü
+ò$Y^`ìòÒ”9Àwñ:ˆ9ˆäSÕìO1SIîA[ÊÚLglt«øØ©^‰Øê97Ù…Àü‘Ò,O¼=Çô÷Mg9#fÍáÔ	´Vş¶ÔÁå9Şìq>Ù(d[-§ˆ^(í9•«G…eŠ-¯>ïH?¹ŒÄ‚ßû)d0»kâ©Ÿ¼ë'8ÖxïWØGæ[ëúòÚò{µÎÉÛw'¯şmûÕşÑÎ»·‡¢L!!{1®Æ¶µW“ÉxB©qsâ«s`ŸyúYï¤¢HŞMoÅï‡öP~™¦ñ	ÁÖ‘¦/ß}²‰üçóë5a*34[m m!Å§'%«Ñèe^!»ŠLÛÉy#-0Zl
+#*í¯^O»¤‰º‹–7ĞC\G<'UZİÈïoqñ,ÂoZE±m{w,ÔÁûOmlA°ß2òTqô¦8\ÔöÀ¥O‘»õ¹HêÇ }İÓÖüblH&p´"'‚sÜMÆys· ³Ïò¬1Ä­œš”8
+/ÕOç1™9ÜÀÜİÀ T"š¤.·æù"-Ová}­ÅE¨‰6Û|Š«©§»"±Ô§?ÔŒŠƒò
+§÷»½È3“óëÚS€ûø‹À#P}™@wñø¦8‚Ğ¥Êá« §bQ•h†ÁUËŠiQÁ¤À5›1±o´Iæ¯_#îŒÔ\‹Üçä†ŞıÅÈ"k«XfswCqE‰ÆOŒ m’ÄæÑTó”Ò’âw$D<·ÖEªù“Qƒ±àó&ŞÓ|˜ŸB­ëÌ^ò@_™9CH%ÙUOŞ)'Äıd{sj`µ4æ9CXáÑEqc°"ÏQµ}LOœà_ur˜’ÓçÊò¿‰EZïâ|<?%Ù™dÅí§²M'‰ß¦C±GTH1¡†şBxŠ\&y’–5õĞKV"©¤Äcbë’šíì¦¥ÊPĞ4í È·•5e*Á&-âÒ»	§¨ñu"Ñ­D=M*“¨’E…ôœK…°“„áĞG^=ÌÖıâg1]éråUtd[g`ğ:©¹$„—<‹˜ó„‡
+C”ÅÛî|’ùÆ“'V8EÕõhRzı”GX5EBÈ_•ç­(40ªI*[ş®—ß#S’¯ƒÉ€ „TØb¤Ò¨øu«ÇD¦?w¶|mÙò/İÓ½ğºÙhLÚ†wWWO|SŒ”†¶ñ.,d¾ÌÁ±dÒ("ùM÷+i€°1æÎÃªŒƒµæë£šªít”¹Ï[ÀMæZ¤³PÏçdÊ{æ%Æ
+´1û¶GPU>Õ-°õb»âx54ÇNµÖ‚‰àş),šGsî,R“sJˆ¼İ./ğ°2MZ›ŒGÛrš¸ˆ’ÌÃ9S	 >eÅ3	Áé”¶¬æÎ¾1ÜÒúÔf~–ß^(`«šô½ä÷Ë]AøÜ"c~Ş9…#ñâX
+‹"ã’çÜjõ7¶Tñò·ì'íX´¦O]dÑèÖZı×ŠvY)B‘3ó¢QeáA=`MŞÙ—”DLäJ–Ã¼:oIÎŞ–MôµÚ8)ËSYUf·±<°u}~^N^}9-QşÀjô}…vã†RÆŠÏSÑ‡ö^[[K½:yıbgWï'DT_Co‘ò:øG_×¤[Èò’_Ò¹ånÚifÖF
+¼YúCHàüu¸	:»ëÿÒÄ­#©£§‹K¡£?…³7Pºü A…÷³é‹@_kè-ÔÖZ†'ü<Ó±.¤´˜gÿÿ#
+TÌŸ~\‚XS¶„Q-[]–œ+K‚xˆêğ¢:×•xêHF{mF«Çş™O•Nº3·™Äf‡“Šräõyíæ Ñ|®Å$§±óp	 +RÍŞÍ—à_BÌ›T!´V1i„a¶éRÙPï’X›ü
+¢09áM“|f•gÕ:q®£¼Â4É«“Ş„Ğ–fG`ñİ2ÿ 4v²‡ÿCdj±Õ,lØijEÒ2q*ñ…!1]õ¥!iîº±xUİ6ó\Û±pçş/¿,ı7AËğ¥
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/d4/44f631930d81e3c14a14783ad713188d4e2aff squashfs-tools-patched/.git/objects/d4/44f631930d81e3c14a14783ad713188d4e2aff
--- squashfs-tools/.git/objects/d4/44f631930d81e3c14a14783ad713188d4e2aff	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/d4/44f631930d81e3c14a14783ad713188d4e2aff	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1 @@
+x…A‹ƒ0…{Î¯ğ¢=TXÙÓ–BWXZ0u¡‡=íŒH0î.í¯oÔ*–Òö4$óæ{—+“Ã{ÍÂbs<®•2‡EÅ˜'T€qÊyºë$Ic±aû•šîîDÔ/,mƒNµ¨VŒı‰0ç§ì[y&Ñ@;hªÚüûÁG¯á§¯šÈïõbMÖN4m .ÏÏv½1–£`OM’Õ%}g%í³…_[J|êÙgù”åK’Ó<%1”%×êµ<>MÀ´`*ê c×Š†÷(¼Iøˆ6D®éİ…#²çüp±®
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/d5/af57a1e73d0739ba006676c06e38c79885d2e6 squashfs-tools-patched/.git/objects/d5/af57a1e73d0739ba006676c06e38c79885d2e6
--- squashfs-tools/.git/objects/d5/af57a1e73d0739ba006676c06e38c79885d2e6	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/d5/af57a1e73d0739ba006676c06e38c79885d2e6	2022-01-01 15:09:15.665172591 +0800
@@ -0,0 +1,15 @@
+xíZmsÛÆîWêWlÔ‘CI$-YM;±#&´EÙœÈ²JRITÇÃHPÄX ´Ì¶ùï}v÷î P ewÒ4š‰)ònooßwoï®Ãøšÿtxğ‡Ç{[´G—Qú÷¥—ÎÈ#ı2Mi„~ºJ3Ş"Î‚”ğ¿G³àf®hÏ‰Ÿ¦ş„ß›P…+ÆTX…Ÿ<ò"^¬,Ê¨>Ş¥'_7ğyx Ÿ‡òùD>úb„a° ³xy3óúf¡ßYºZqrÓZŞ¶v!l‘Ä7‰7g§‰ïSO³;/ñŸÑ*^ÒØ‹@ã$H³$¸^f>yÑäqœğ†óxLW<¶Œ&Ø0›ù”ùÉ<¥x*?^_ÒK?ò/¤‹åuŒé,ûQêór/¥¦3Hâz%+N™†¡Nc ö² ‘ }Bïı$ÅozÒ`qBu/cRŠ¸úVz ÃÂ¶6ğ›³5¡ ’ígñ,Ì€LİAœtíÓ2õ§ËPöƒèÇŞğÕ›Ë!uÎ¯èÇN¿ß9^=p6‹1ë¿÷U0_„ƒ0/ÊV	SüºÛñ
+K:Ï{g½áspÚw:}Ó§]túÃŞ‹Ë³NŸ..ûo]ØĞ RûŒ`³Li
+dó8ñiâg^¦–ñ+h2uá„fŞ{ûÁ{ĞæÁL™0¿3ïë…qt#lÖbçSŠâ¬AwI ÉbÁUÒ#/ÏUÙ ¯¾¦¡ñøtzcŸš4XòÚ£#Xöó8Íâ¨A¯;tğäğğ°yxtğ—]:–¥ñ¸æQkÔ·¶şDãp9ñiÛÎMÓÖl»0n]`ÄÎçe<¹•f0­±óÚÑ4ñnæ~”ğ/YhÏdŞuè?ÛÚ
+¢L|6‡•™ÑQ]¤#{“ Îb ĞI?šìnıs«¦‹ÓÏôÇõ*óS:¦Á_/;ƒW§ƒÑi¿óòu÷|8z~5ì€5}Ş¶Ò–¥#İ5+øÛ‡k{ç'İŸ6®Îé´H•‚ò­Aü¼Ö†ıÎ‹n}›cÔ¿Oig‚p¡âCÀ:
+£ğ(%q{«VÛ&ñœ>ì„á‡Ÿ£í­ó™(xĞk“†>h+ÉÀ?D7½':>¦ƒ]‚kUâ‡Œ?‚2­%~¶L"ö/»øùv±ìéöÀ0÷Â0×Ei¢‡i}æ˜Î/ÏÎv¯ûSo8º<WÍná>
+'„Çf„,ba±´T²$ö9¶ï¼…r™«1µĞõæØÊTéH¨O'÷´P4ë¡vß.Å¶6[§¬ª$ˆÆŠRé´s6è*'µn¿ÿ¦ÿ ˆ$SZVUNµm‘šH‰ô?¦İ(T6â½Á?ÇÏàÇÎEîl¹ÃXüEQnæÉ-3÷ùaê‹ş¶â®¢ù÷ mñ¡8©0½d	úÆú8~ìï«ò9$ú—p„cğ>îÒÇ–¾Í£ãëî°sÒvFƒŞßºô”µ\«i}Du§Ü2XøÄö°SèG7ÙÌºÂ5¼ùVü J„oƒwñfÑ¿¥±Aõúxæ%´·ëâŸË.(ù{LU5)»B‡	ª}.üì¾êç$!†60áÂeÃR½3áÈÉè0©J3Œ‰İ XY´ú·ÿÊ'„~‚Ã±	p°vQËeaG¿Mµ.h°®PÇÍf-t§ûÉE]viäĞşògı‘C¼+²«Õ¹½EvĞ³*¦6÷çãÅ*×ï}@hß*?Ç«hÓà~Vå(0Mó|iÔ=„X&RT™°‘*õ ©Ø3ÍNÀ°õ>ôğotTGíÜDp$ö*‹&Áu›V&’CG¢>^í1İRœT%û§.±[l°N¶B‡†¶UÛÈt¡€1ÀóÖ…j3—{ò j§´k¶³Ê« 0ül‹e„3ËrŒB>ŠQîIö“ï0‹’¤
+x8ÈdO§©Ÿ‰x Äµâ2â³‡cXñÍàË~‚zQ¿€¸\ä‚dÖê´:µO…ı±”µbëÂ0o—å¿^\:ÃyéÛTD55JQëh‘%Ø® Œ¸¤øöQç3?Ø+¥ò-J(X/ùGnò“ŞîLîLŞ‰oA.Ÿ7,SópS9dğ+^Íä&†8¨àHó6ên	WS®½Ô‡Ó@Û#§‘T~ƒcëİt¤¡Á–¥9ªïê¢£Qoua\bËóÎ ;ê¿9é^u;'İ>ìèQaMƒ,nÑëñ ‚8ÙDË†}%ŒN¥›ˆ„,Z¼LtîÈíÿĞ9ëŒ~ê‡}6©ÖÑÙFÙ.É>Ğ¼-lÆ0ì„AëF€‹S7²¾pNyyÙ; 5+fÎÄ7ƒjB,!çaÅ»­1ílµ(S¡úãáwô/ãP¢’/úxŠæ«"˜¯CÌ3ŒÉ¤ÂFËù5:UhtJõãY½z'-`Æ°–¼B9éõGÃ«‹îS©óÀˆáºeî	 ÀÚ`xO©’óŒ	K²)¥InŞŸaàÀc2ŞZödê78Öh«#—
+Ã½L´ó/#,^Pğ1±N‘ƒ0Âr]Â¡4ÛÜ	±AcHKW>ïOJ`Èç
+QIV_#òßò7>”Õu¶I_a…¬ï)Œ>®±*4ÿ‘ÊQµÎ„…JãUŸ§5Yñ€Ú,-ÿC½öÎº•~–ø7ú`>®µ
+$Ÿ§4…®ÖW¿ûrİÇÄæ?MO
+ZPÍ]jœŸêN\Yi w[mq'å^&á¾ë»ö-Ñ=½ç¦´cÍX×ÍñºUæìò)¾-è¸yaƒíŒl¢’¾:ëFTWÚAËéB·'Ìv[àJ³a|cN•fu»]^ Cô1Aiá%ÈÇthV¸T±ü;èÓâÃ(P€óˆU‘k!‹¨*Å„f{?d=hüUh~=ë?û¿ù·­CüwÍŸËàBÅ! dêluŸäëx~‡.1¸z}Ö;ÿ¾Ò+ÒÕ<¢Ûê¤° c	¶3ÀÏ0ª,D©®2ƒÅBÈú»™ªN–£µ¼.1pQÎ‹M…˜Îc;BhTXäÉÂ°„ÀdZÜº'n#=±nÌ©ÍN]İš¼å]İô\O)ïuë¦ƒ[Û¶ˆ¸ ”–«G÷ˆ{1nŸ‚i_#·ÆMW[Ze?w 4MŸ*†3–Ü|Àee¦ßA&_ş|ğ¥ñÕb‘º)yàŞ¢õÀıüìû“îj¤[5Zë/^õİìúÙÁ¿Ñ|óÃƒÿşãf;¹åW5Y¦ş72×5-$`­,ıŠJÿ´wúÆÊ~Môƒ7/¾ïİ$fƒƒ2Ö‰?õ–a&mçµÛËè6Šï"-RHÎ§¸	Ã•rŞtúÂ¶1jN“Øskñ((µ°PÇ£SgÏ¸¢0²ŞÆ2÷„*ÛXˆåØ^ -‹—q*qheáÇ$Igéz9úÉ[S©8:Şv7‘_\ÑxŞyİuÏ1vø¾:qƒBŒFõºJ“R"_.’î(/o¦vâÆ»ÒêÖÚlqİ3óWÑE‚H˜|Œ”´ùw#ü(Í	ìO¦)êÈ4¢7°6à4ÂJÛŞS]§¾¤DÔA£“ïDÒQ¼H[¹…Ô7Aƒº<4[%hçS"G4Ä*ÆkzŸ†5.³u
+eÀÒlãC…†mÙ	dp¼4Ú.šfN¦Ôl›@KÃˆtß-m$™qô™ì¸tg€X˜V ²Í-‘_væùdÀ7®,T<C¨+”úï1íÂúğH§VÃûLóó,Ò»y~ğ‚7Ù
+–q‹G3<¹Œ"¼ŒHS/Yé¢b¶¡Ï¦ß»3ô8Nğ²OdPçóë]ÂïB?óñÎGĞ^õ¤t‡,¾í}iKX˜"¼ 25 ğ]zóIÄÃ@Œ…ïÉğnÏrü$Á+^ôŸ&p€=–…=˜šÏ1]¼á…{ª¸B­ì:¯/-wYê´zï[Cé<Gš½æê›[¾,Må"Ô‰mš.¶µ×’êÄŠîmÇ»IG,;<ƒò™ßH@ï®VãÃU©“\nµ¹P˜‚`…yKF¹-©X!P!ÑZf*<¥—Ì}§¼‰Ìø¹{ÌÁ):Ur—\ÜQAğY|XroCAÀ°ßóxKÂ ÇdŞac`ëó½¤ÛÇ4Yé;áŒqğ+óLo*‘çrh¶èÀO9ÕYQ82„1§BÆ˜0Ñ-Ü”ñŠÍ[¥o©~€zÉ¾á]Ş}}õgµxyfE›ÇÙİk71ŞS°Ï,ğV¿Ñ¿Cßlš‡eå—µo±R´™Wõ<´YûLDŞÿgXcİV{M©Å|TÁì¾Ÿ±«dP³ëºÈuNäÂBçù˜¼áº´.ñ†=‡)B½ÌGÉöıô/Ú¨RG‘¡f;òæ	³°;„è/~[.•ìÍœ×È-Ò(¼Ã¯²ø `_–È5B>ß5˜;Ï|K=‚á÷L›ÏöFU!40©4ÛŒAU
+‰±ÈŠùu‡8ğƒ/~Ò°[xÅT«™Âa_^ÙÅ u‘‰jelª]¾•vÕlÖAÛ#/`»ÖªÈOÃ˜2sº3U›¿#äç–öà¹ãÃƒa¤ò®•Û„Ú‡ÊÏB¥÷à%G¨Ì‘°%İHøŞŒÀnÇËšm—Z
+ŒÜÛÔ\C)œ€”ö0qi_F*´¸Œ‰Ä(úùI@)»ğ…Ã?ÊÍEÅ’°#üİ,Óè—­ı·ó
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/d5/c5ed910fed3c6564a2b5d82e2f9d28f06921d2 squashfs-tools-patched/.git/objects/d5/c5ed910fed3c6564a2b5d82e2f9d28f06921d2
--- squashfs-tools/.git/objects/d5/c5ed910fed3c6564a2b5d82e2f9d28f06921d2	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/d5/c5ed910fed3c6564a2b5d82e2f9d28f06921d2	2022-01-01 15:09:15.617172589 +0800
@@ -0,0 +1,12 @@
+xµXësÒXßÏüG5P Ğ®«öµS[:ËØ×”öÃª&„›’mHØäRÛªÿûşÎ}äE]W]™IÎ=ï÷eÆczşüåú/«Mª½¸?rƒ¨ãÕÎE*ÉÏÃÀseGäÇ	½¸§}áÅ‘ÔßíÒpÿıÚYûöâù]\M%9^ƒz¯^½j¯u»ÏipªS÷&ŒoÈaH»û²İ]kÔš«µÚã òÂÅDĞV*'AÜ™î”Aa0®Â’ ºbXXq¿—xi½DUHÿV&®'\“ws1>¥2Yx’F{A(ÑP&ÂÕ>ÖˆÃ{ûNöağƒÁaŸšŒ¾YûL%ºMVÊg¶#öÍhp<Ú{ A$èúõÂ÷E2î9=ÚÚ¢ÜğúN
+ºé³wœK°¾õ‡‡ç4¼g‘gÂfsç&&ÔŒÇ	O¶H¿5ÇŠ}‹RIš¹·gâïEˆ	‹ÌàÍy{"M5¸¡Œ-™AÍ”¶É©ÀZ»À(ñ9Œ=>
+|r*‚i§hyHTÕâ
+†3Ÿ*o`øÍÄ±jQ¯UeÛ;ì¦³0ş ¥¥±
+–˜Ó£mêj­Êa	ÑX˜¹H"BdNŞ ^¦âÛBU‰ûóç‡'s¡•É¯q Kfÿş‰&¿ì ¡×Ë¹¬²ó•æqú=ÉD’Áì§à˜”h‘ÆÑU\[4ì÷ßŒ†ıs•'l±"Èò b;òşè`wp¨¢®jîÍHö“$Noê&(œ{­òœ|§ş>êŸœmĞ“ô}T‡¿ï!9ÃJÎĞe~ˆ37¹‚Zš?¿»|Èt7ñ¦ÁĞMŠ“yoWCö]éİTôoi2æƒ¼oÀ2 ›í†aì‘Ë¿pû2ğ\Ìæê è¹şè÷»ÇÃA{Ï¶}tûõ.Dÿ‡vOªİ÷z°>s¶±—¶·©Ç…÷ßL¤z&‚ç.R÷Jl`à`ŞĞ–Ïfn4Ù¡-ã…QäÎÄÎûœ-ÍÖFJÎ€D`bZ?ùh):I<#Ã¦„nĞa€¡çÅ‘‘L)öÄ“¤†#¢'®’@Ş••¥YÚtÙÕŸñåD³¶oÑznz!êˆq’ ­C	e±ö[Æ­§¹]):Üö8çã¹ˆ•Bk—-ª'ãÜï˜œ×!(êá¹E±$æGA4_Hå¼ÿ¨˜XP«4½Ø‚².:÷„İ4ŒAà›´íè,fêIñ²g‰`@r2“ØURgä§ÄBc@ú 
+$VŒsw
+GEâ“ıqÿ–Oœ§“±ê¶ÃGªNO8O¶´E ÂµË>=²Z1IM›<at£0	‹U¼{X¸¸¥„ÈbS8V¨$vº„^–Ï´X’<,F²*¬7¸zÍØ¤Š8•¢:İ—(e…²¬¡äªªe‰\TÈ—´í¨]p‚ïÕÑÅ ’ëkh‘Úk@9ŠÚBíØÚ9^Ì¸´ÒM
+VV4Û±ØÙzI’bFMŠ”ŠŒVr1Y«?éu'dgÏ€†ßŞá¡×"<£±©`Ü8ìoæ—¢×>}¢²¾d«1~u•]{/(bBëM!vË©Àï:İ¸IÀ™v–HÒD¹!ù‹Èã{AKqã†1s¯-Ë„ÜK6îåf¼?ÆºDqË¿=0ŸMbÑıÀnêŞr£;h.. m(áÊ!–Ä©wgfÓ £²Úª›¥3Ëy¶ ùXP÷†|Ãğ|óÁö¨åÉËöêŒ©ÚR¸ºèGu6JçS×¶ÙÊM«¯EHÚ\Ï¶w˜ÁœÚË@ğm9ÍSI;H÷qÓğdœÜÙ*áÄµ&e‡”›†ÉÌ›3£éA.f÷ïÖù£~ş… ŞêJ¼öuÃaQ‚•bÃúU-.İ¤¾¤½m,Úò±{ŒV‡Ô¦DLÑËovÍ¾2
+‚VÙÔ§y`8dIW|æøU©bmUŠoñß&¶…#Ë6à‚”Íkå—±ëÜhF}Tˆ[E'ê«3LÁ6ñ–9¾B[†YW.]>ŠçzèñÇÕn¢YÄ1)Ï«á!ö–m¾ß‡˜ÂË7•µIw‡Ù¼´Û¹¬ Éq–ûÎâ·©wÉCğÙê³2rÑb&^ÖCÁp)êÎ¸·2(Ï'~+ø«èGö†Úü¬0éã•b%h+ÊD…ÎÌËšŸæ—›ziÔ<Jë SóÇ¤ü[{QÒPı»d[Ñ²RÔÙšX«…Q¦¹¯`Åæ>¦îı Wr»hW6;Y.‡®Ìé\¥/ğëNPª1êRl­ın/¨<óÂ8U–gUÒø6ıƒŸ _¯‡º¡=µ}¥Ã«t@•õ}ëìb®}ñôpz1GşÚ\‰UËuIÈ’¯[ŞÉyQSê±ûUì
+Ok˜Ü¿Éœò
+R:¹Î‚ù— tİË¸õG'ç'Gı£“³?u8‹6ÛúR*»øCp&f˜¤º~ÕÚÇ¹¥Š¿ 
+ÿµ@ŸL C‹KOaÔÀ"ü¹öiMY#
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/d6/638a5a90c0bff76b4da37d42932fb594ca9ab4 squashfs-tools-patched/.git/objects/d6/638a5a90c0bff76b4da37d42932fb594ca9ab4
--- squashfs-tools/.git/objects/d6/638a5a90c0bff76b4da37d42932fb594ca9ab4	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/d6/638a5a90c0bff76b4da37d42932fb594ca9ab4	2022-01-01 15:09:15.657172590 +0800
@@ -0,0 +1,5 @@
+xT[oÚHŞ×øW)/!"BÛÕŠ&Z‡pÓğÚF«•¬Á>Æ£3îŒe«ş÷1÷j+õÅ:×o¾sñYµ€Öû­ß®y*LaüÏ»èÍw=¯çGCçšL\âÖæ­·|.™ÉRC²U»*ßj¾Ì
+¸‰kğpßj[«—q!xcU.3Ôğ1ßş4ûì†ÒËFùéifÜ@®ÕR³˜jD0*-6Lc¶ª„˜IĞ˜pSh¾(^ “ISiûàJ%<İZ[Iõh(2„õÊ€J+e0™Á %j&À+‚Ç0æ1Jƒ6ÑëÖh2L`±­2ú–C°ç }EÀ¬àJv 9ÁkX£6¤ÃCİB(7¬°T5¨ÜÖˆß#‡ØÆOê=•• —Õó™Ê©„Œ ©¨µ¥Á´Õ{Ôx…Ãé,w2‡7×÷İI8ïPp‘)òâwP|•N…Q35“Å–zb¿öüîRÜçÑxÎmıQ8éô§>¸à¹~8êÎÆ®ŞÌ÷¦A¯PW¨|ğóBJ`+¥,æPøœ&iˆH ck¤‰ÆÈ×ÄAL›ô‹ÓJ.«2‰Éiq:ÀSª¨ÃFsZBU¼˜£¥}eŞÿ!R{<Áb„;J›Ûnß×áY™BÉ:¼ºpÿĞjµîZíûßë0ÜC9â¿wÑF³<GİÈv³m:Îá§\–_?S=ÏÃ^4õ_z>œÄsÿhõ&/#wÏGñÌOS
+Ç½CÈ…æ\£ U¾æ2e‚ğeÂ™ldOä!1­XÁ‡ÇG«ŸÂ/´©’~ Ã—’FÂ%í4–GÛ7çZ‡ ÷W"ø{æÃ~&Á›ëEİé«M½0¸15ø
+ÿ:W$Ü=~—ÇĞsW­sN[øŸĞÊQ~;Ôü4MØİ°—İy³GbÍ4W¥:+H·‡övÅ
+c÷R-%7˜ØQC·Ôe!hAWô¸dñö2Ç-Sæ¹ÒÅñ†ØÔOÔS$5³ÇvÜ¸İùUëÂØ»ƒ zuƒ¿Èá4oáŒh¬V¹FS]œ]wÎ8şˆ>ì^Y*ªŒ°[jÓ#ºK¾:Wv²ûqtvZ…Øq¾uú(ô½
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/d6/d05d6cfd5c85999e6277a06d3ac1f03e95892d squashfs-tools-patched/.git/objects/d6/d05d6cfd5c85999e6277a06d3ac1f03e95892d
--- squashfs-tools/.git/objects/d6/d05d6cfd5c85999e6277a06d3ac1f03e95892d	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/d6/d05d6cfd5c85999e6277a06d3ac1f03e95892d	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1,3 @@
+xÍTm‹Ú@îçüŠ©%Ñm„rE-Ü¥Rë•S‘RŠh²Ñ…d×n6g¥Üï®›Í‹/W{´~ˆagæÙÉ<Ï<Ëˆ.Ám·[¯šMğhSÒs†ÉÊ£ä1îø›a\aâGi€ 6æÁMøÓY×ª‡å
+I€B˜Ï£¶[ÔwDxé¬?Wˆ8”0a)sªn‡ÏiÄñí£	ìÓ ©€éS’p¸ÉÒŞ$ÌW¯6L£	ÈÌ/‹²Œ_€Fc(x*±#Îqh¾Î+AÒ7|gZ–É2‘@84öÖ–@¯ÜÍH‹FÔM6´lÈÁlØ×CqâYñµiÙPnÃù„øm†ˆ™yq*rÏÂ@ŞZò# ÄèJSÏ¼¾j>4‹Ş{Ğ’Ÿ%|ÍèÜk×u¯3 ÅVz»GZ$(ëOƒío}`ñ”‘JIÇx4ÍJ…±	Í¹ÌÈÓ¬ü<Vîì9äİ£)f(*’$êàªAğ­I®öş·øó¬ôV°}‘\Û0š‡êy1ïï_„÷:Ôäw	G±Ú¼	½Ó¯™<>Údµº@±/Û–[·‡(F¯Ô“Ë$Y¶ö“SXNUİY¤¤h©åÜP” ÃĞ’Í¥ü"¶R¦”"rmuÄ_÷„jÅy£¡vº¼ĞèÁÖ3šób@ßğ÷ı÷5ëb€Ïu½x™pºõ³|Í“£JÎ·¬ôšûZÉ»p…Ku…IeöTûJSˆ<`FIŒÄ0*Ö—PIºÙPÆa:xwû5¥åJsUjŒ«Şüçîu1Ç’â	®¸Ï9g|'É:éBœ
+qœÓÅ¡‹UUqÍîøïô -à7wú/
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/d7/482d8a6557f71e579a001b5a7b85096e9534b8 squashfs-tools-patched/.git/objects/d7/482d8a6557f71e579a001b5a7b85096e9534b8
--- squashfs-tools/.git/objects/d7/482d8a6557f71e579a001b5a7b85096e9534b8	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/d7/482d8a6557f71e579a001b5a7b85096e9534b8	2022-01-01 15:09:15.633172589 +0800
@@ -0,0 +1,2 @@
+xµ‘MOƒPE]¿_q-[%õ£.HiBäQ‰”G€HbÜ¼ÒÑ`‘!Ôá¿KbÒtá²ÎîÌäd¶5o±¸º>ÛT¥á_{øôE5·dõŸ»ŠQ°Ùw­.	AUÓ6ºÇ™®âwö|.,^‡ñÚ¯«Òs¨¾Œd.‘?„
+•>f‰w/„‘<Â:í‘~§²w0ójn(zŞx3×~9{×µ¸D¢Ë½~#¨ï†Œ»¼]M—¿È].Vb1ãœ6ğ´Î–ëé	ºvêşt¸ùO‡Üøvj
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/d8/7eb1914ea4f18a4b1bc97a76412e4e948246ec squashfs-tools-patched/.git/objects/d8/7eb1914ea4f18a4b1bc97a76412e4e948246ec
--- squashfs-tools/.git/objects/d8/7eb1914ea4f18a4b1bc97a76412e4e948246ec	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/d8/7eb1914ea4f18a4b1bc97a76412e4e948246ec	2022-01-01 15:09:15.601172588 +0800
@@ -0,0 +1,22 @@
+xå]ûS[Ç’ŞŸù+ææÖº$	ÂãÛ)8¡†¼ws½)•€C¬²TzÄqˆ÷oßïë×9’q»[µT0:óèé÷ôôôQ.£·õÕƒÍ¯ÿå‹UwøëMo¯ºüüÒml¸Ãí8<®ªÉÊÖææ£Ngcó¡{ì~MÜIïçÁèg<Ì/ıKw5ºéõ‡nõ‹••¿÷‡—ƒùUå>3€o>KZŸLg“şğ§Ïß<CãUuİVîíËùÍùhü¼?›º­±mÿŞÌ+×j½:Îîoµ;îÉ“tx;GÀxp>šõ®Ó‰à²^×
+°²vÎjÇ9Àìhôs%°¾Œ‹îv^œwÏş¹ï’ö—Ç§G;‡lì_»Ö¤7ü©r@Øi»[çŸ<u¶ùëº–üiÚî7×Z½˜_¯­µ·İ‡¸âÁ‹îs,¸Ù·İl6Ã¤U|ÜvaÅmw1š¯M—xöL8U§Î­Â¶ ¨ëÔHö«“½ó}]L=Õ!Û²*×Ø¥tO&£‹v‹è¬AFo³¥ÜWi;†q±İŞÜõËtH“.³ÖÄâ#‰mXvÃÉêKÖøvÿœŒÛj×]İílâ·Óv);ÿsÅA.	Í`×êƒª>X¼³	I¸j0­\6”xgC1¾ƒáøıhôëËòmW`³íÖİv¢Ãç§ûûİ0Ìi*µµÆl¼Ø“.$s÷öw÷öuÔºôoú3 x“* w5Äæ¥Hè»7ıL®Å B#$!\qÎÂL·KG!fĞ=>9÷àvíòÀY÷a7G46 ¯ú°M
+VşNşJF'‘ù­¯ïÀáÍ_PÕ@ëğªm?Øxw÷»ıİïû:ø÷f4¿>¤øaYÕl>º½WGG?t÷OOO·ÿ¨R<h’®H»ÿ
+‡äû¤ æO²QÑ‡ä.%Ì2›4¢ nu?aíÜlj{æ–8Œ†ÑK|†­)Üˆ¥÷fŒ‰Ù\õ!ËœN ‘Eïâ¹‹ŸŒ¦Ü*z¿¸d×³YoVIWÜzãøÄ¾=¬†˜r8z'Ûîı¸Bè8{s1Lmíœ·1è¨Õ€ü„ ïú?½HJ”ØÓÊ¦$äÙİ7£şeå6˜Ğ¶åZá3U#â€fp$éŞªõoéç8lÈ^ ‘ïŒ &ò¶'®2Ÿp–Ï7Åù\°@,ø$ĞÖlÁ„A`E ›³?×ÙÊZû3ßñU2M“”F¢¼ƒáU•éÙşğ*ïëäJøb>ìõ§³Şğ²2İi½­ÍB4Ñg2t ÷l0š‰ôf= õ|ÄnQo¨}Ö»3èÿ4”Y	*ÒxŞ»Tgı_±Õ†H4ŒNW?êÍ.ßõ‡XÈ%<’æ³qu‰va¬‡6˜j†6È¯Ö–‹È|Ê,ë'ºz0=­Æ®e^Q<ù><?H4ü@¢b2ñÛMN% ¤õHuü Œ^6Öbã—Û<²‘´š¦u½€ı0rwÒ(@p-ã§Ê¹cÊ”°G„ïZJÑÌUvÃÕ´5rkíò¸æZ
+	 rE‹CÁş8:|Òñ(FGÃ«IoàZé´rpĞz	Ÿïœíëá¨óèA´é;´sÓWEcñÇ‰ñ´ûm5ƒ^Œ0ÂÙ¯ çàÀÜ&l<\Ò{É§q[q‘ñ·§r¶íWÎf£ñîèfÜà\º7¯¿ú6D`ğ3o/GÃéÌ=?ÃYÕzYıâÔë¨N8Ymıè®Ü"òÄA#ü×Yw[ëîşºsğû%~†ÏúÕzÃÌÎW>l'übÜ½w°Û=:xé=Hgn±ù‹şØ’9SÙ']êzƒw½÷Sw%Gú«ÏWvpTìÏüóÔ«wéŒ©M>‰Áä:>ÎÜghıŒ@ßõgoFhô°àp4¹éú¿‚c£áÊñ|ö¤VÓù@>9wöÏîñ÷8y”h´‹³æš÷'“Ñ=ãg“Šéh"A8 ëŞî±_ñ-ËÀ§Í‘dèOßTW‹Ç`§E2ãÅ`>}ãnz“·HzpáFxkncÅß¹ƒ!xx¤˜üğúÒ¢õ‡î‹³óîîÎá¡åVºšQ9­z=@ãÙ­×÷s;¯%ÚÆL€†ñ¢SáĞI²Ñ>%·ä#TÃ¹ùpŠí¦ºrÄƒ‰ôÊÇmtj
+ìoj>M_oş¸Î¦NÒÔÑ¦­¤iK›î'M÷$Ğ°âøâ¨7}‹şVËÚ4[ÓRÇŸ/Úmˆ¹“MŒ?6m ®O»TL@úøóÁ¥/æ¹zsºñ+)gñğ|~-»­uúçl]¸õã3û"ã°Â†iÅ#¬Z8ÖsøòMuùv¯—K[8Ğ8äØÓqîü±ëÙÎ=4æ–’.9Üîü$ ¯FXê¿ÎŠÃy]IiKÀ‹ù!ZÆ>Â!Z)#î9•¼¬ã…ZêIS$A‚ªdÜ->€¯6ØºdLÍ V[°¸•¾©_Óñ $¤«8ÃZT¼ß¶^•S±8l›î·ßrêØ¨(aq*o<«Ğy¦\‚.¸{NõºÍtåà²íÖ<Îµ Š¯ùh×üÆ%Úù˜è•ÿ‘É³Ö#h?`àÇóØIÀóS‚Ğv&á§ájsÎï Lü$d)%%Ê[÷Û1ä<Av¢³¹¸ûÁC“´™cªÆOAkn;ŠašYÚ7Ä5àgÇßTpd³-®†€Ğ£ëkš¡`Ik&7Pù’@ºè{e×
+[o#x‡İÁ(z‚nÂTç µâˆ{H–<¹ˆŞD@¼±&s×<óÓåìØ/)=L4­ëÄ{OİaÙø„Ó‡L’Räl7ÿˆ,!†×*Šµ5„1®EÉµu’!•êùÚZĞHÕFì—À‘ÁbIW âšiïƒvØ«ú’kÚİÙ´~¤qîû:‘şÂÓï9ëçâò ›&vK	7ƒ\ÄÄ­yŸ…8’‘eŒì§”*|³‚õÉ>—cDƒXó•‡Û “^ ¢aA¤ S—§!skOébîÁK§ş‰QMÌNR„ĞbDfhÔğ´c\Á!—äÔƒã¦şİ-\ä©9ªIáæµE¯~àŸû³emï ¤…ˆä¨,CÆÑ{S !ğÉœÔïô[ÄËl+²–­©dhQl³%ü©×#¥v&Î;Ç×ˆD;™r<¬$– L—øÔlf3‘h\Î3à\ùJŠë"¨Í’ı¶S×m42v¤*ÀUX®ûi¨AhŒjSSd.€_³-ÂoRÓo™SI¥Ë-!§\p9I%Q[ù*)Y…èˆpÎº°R#qåJ÷ó•è'Æ<àÏR$ØÿP8:Á/ñÔ4ópbRŒ]‘Ê™Ä£Â$
+‰ÆÔ‡A7Ø·‘¿øÄ97é*	ÊA¢xYhÍÑKz×ÀŠ€şèzã’A2ªÖ¨Ş¡¼‰Ëø4¯EÏr51LÄjê<ƒ 4 @Æp!>¹hº±¨P°ôU±î‚¾r)S¤ÌFH©ÈÙ†[®ÖÌ.ŸÕn`—e³S†;	°*Fj1g~¦×ù¸F6ŒL,Ø¸€¸fV6ÇämVw}x«x3rw’¸7ŞL«"MñSr¥ak5wÑƒL¯ñäåæ…fu1Ä}f L)¢ò-Ü–
+ÛGäÀ¼krãB­Ñğ{kÌÿFèõŒ•w!‘!§;âåáÌ6d7İëÁ±%<$•æïxqû›{qÇaçzœ5šdÁŠ­­mS`Vj8¿ÙëOªK½ÉÀ4¶q|µñ<q‚0R—à˜m­-Ö¨„	÷Ê¡$ÈPWËë•HLNN²OV¢)µ=8&ÌN’R O|¾IŠÿF­Ñ6¯;7š¼Ê0†JEH­W2,
+Gÿ-¡;«Ü@ı	‚X/VQôÂ€íoOqªœ¾Íø­à«Ú9“}ÑÚt¤/ÚØØÈø&In:3ı¼4$Ê¡âèEµ—Û*}.‚)%KB1CâÛIƒæ¶Ájl.F–±uJu˜Kvhå
+ƒaXß.³ı+F³	-	·2FpŸàpZµÒ³VKi'âé3BR…m…ÏÈÁ¨é`¡T§ç
+PxBeÂ½:%©¤8á‹Õ‚)ÉZ¤M*â~Ô
+	¯ÎS¾˜sa=hoM`%¶á”Î¥Jå½»êî\ô¯Ğ=2A,´TGKr—›y–„YhÃu¹ŞmŞVMî6ïÁïœ÷¨˜—+Û'0õßüå…ÿÉU§ä¤ßÒë6¹ ,5â]‰hË!“ª÷6oL‘Ÿã' ê'4ÖÏ#h¬Ÿ@Ğ˜?h­q}1¢,·Ÿ¥Qn‹Ì¸—ÍÙáœËS/‘0ºgÉœÃØ4Ó“‚]ÔNP!	c+Ì‡bh#Ç5àp•?¯!-‡»4à‹Ñk†H/S-u™E²Ò‡Ø’ˆA°I]Fh”‡Şá!’‚ÚÀîË4{D=x€ËùäPZ­g lˆ±›Ksœ®K ìa¦°±«Pî–áäJxt…Ñ±"” ·`7Ö®>USD`Í÷8¸@`âï¹"Ï"_œ^i¯^U¸¾•Á˜\2Í&(G¼îÎÜtÂËµVhhs=l±¡>;½Öó¹—3,# Ê­HB³Ñ†>^fÅŸÕ¡HI°$©õPbæßüî²¶&«â>8$rK¤<ÊVN;á,a^ƒ%!Ù­øRƒ×ÖD7š%¢Ãd@~:Ø…şÆ†WP¹šŠÜ³¡ú—ÿò×Sïëz™Æ½bz¯O8!0ãn9DêHı³Æ&I(…1$@åÊQfém¼ZÕÏõù'jvz-5=w’¶¦^QšRÚØa^–><mdñEÈNñ’”ÓïûFñSh4%Å¬¢9ş~{^‰]¸Gşy„B¸Æ{üLpÍqZİ,¼ÅoË}=%/hør½dd6>©qh,o ¹Şâ7˜hq­\lƒŸ •ÉäGÒëÍ?ŒğÏ:*8=ºÄ§|`Mæ[¿ÔhotÍæO½»œ¿İÓûq3”KéfæÂµ…”7Œ?mr“´D½—öæŞĞ›Ãñã¿f	>Çkk¡Åp´¡Ã[ñ†L¼¾õäÇ?óÎ@Åi7j×AÊF÷‡DgyÈoTÙXz²µPk×yy ç¬¥p ‡RB.º,nPIÕÍNvRÆUò!jDM!J2F­ân ’òÁvRÈF!ëş&Ké%ß=ƒ½ß˜ô¡rDØW®øk¡@”‰§/¿où·“Ò’âè|–9yÚı^áu4ã˜¬)7<j,(*:†Bğ&†€,šøoÀóÄ$.À2ñârÍ÷QÇ"PsLxW¨Vb}–
+"«%=Ä×{RxjxÑÙûqÅ7A*dD…’WÖy´«_P89CÁŞx@Ğõ‡c”“á±ªw£q¢ÎAÍà:ÀëÃÑÎùîwññtÿdåƒÛfÎonŞƒ@ï¿c[(À:Ÿ¼ßã œ†©è’È·"¬B÷­*«?¤¾«C7Í•»Ôa~¤Gîãj&&RvH	p²¯¸Sğ>G^‰Rƒ«¶í2ñ;˜Kˆ‡0ànñ[ªjç‰øäº_É\ou.-½8 2ÀTj¼`<	ËòÄ&N"@ì©JŞOP+Sãµ‰Ğu™‘Ã’™1"¿a±_/Ä@³¤Š@ğ…ïÏ1öÕÊ7b;÷©*ö¥¸?P›LY:ä—åda—p8”ÑY=ªâV2ÆçEF †¸Œ×ş¯ÄDôÎ@Çs_÷Ø?c@Qr”@ş¥GQeµ
+5K¥5H‰lÁËh+tù+‘”dì9,nşX»ˆÃ„İ~„%+?¥Pé#Ì	zajN	s.òš¤Âu@iMa9+Ö#Õ2É€óük*–¡!g¬Túë–àó@FØ)”xİëCVÛøx¢ºàB:Š²÷]5_`o-¯KæÚeB­¶b€o/‹Ùš+OndKÿãkú£<SZe#´.¥7»Y¬a($êüI¡a5XÍ´ËËõKé·=HW²[ã±¶òß‚daó­üi—ŠáÓb”’Ãpßå¨ÂelËsÛAù¸Ú‚Õk"IA˜L3©æ€¬î¦g_—×İüA®El|sŒãHoÖ†Ø,À»\6,\3DJ'Å¾†ÿBP4¤ âçøÉì>æ]Şéÿb¹JÂÖÃxÂÎY±Ø†¨~˜æÃ?ìëxø3+Vô¥9 e¾Zë]"#¯3Lí¹á”˜/)VYÄ¦œQË•¯‰Yu½JÊ@_®˜ÛCÆÄt5ZB]M©JJUª4“u#)TÉ…øËU¸õ  c-×ˆÈéŸ]¥"::z¿FSÅŠ~3CÂ¼†&¥eù´u+±ğ	B–¬‚ÇG­;W²0g…A^˜jHbEJˆÌ¸ØÂ¾CÅ§!’tAzÆ+Qı¤"•BX±ø¤¥u1^º8£€€|ËãËF¥)Q-k»Oê¶\Aè¬ÅPqgj²´"#+4€–àÊ‹ùùÖTPø\ ¼à´ÄOÈ &uı:/eN¸Õ¸C±K!­†ŠL<Ø¬23E!H°lı~•Œ‹ÙåQé9CuPbmÌ	ñ»¢{ ÒÅïNœeŸô/ÿåo¸ñÑõ¹¤·É"!…g™4¹	±t%_z<½Ì“Èiîìª7ëiºd‘+Î˜VGÀÎ×¸¼eláåßŠÜà°Xæa½×8èÑ/HÊ€=øQ˜…µì†*Ö*$t«êJ_îDDr“5‚öú—x%öŒ…õ9eÏG£ÒtıF¬»ğ$#•éñFÊn}dQAdVİŒ-õ"­À^ÓÃÏ2®ĞİjƒbúC"YšÕ $Ä‚ÂÜ0E0¡ m	45Ês¥‘×8“²#ŒöC+ÕŒ”‘ÈgŸOæ•ş)Wké4A­|16KºÂRO$‘ˆ7¸ıé|wL³™íü•<hJL˜ñup~â]Q¼MJ¥ğ9Ğ>?é“2ózï;Ã·!Q¨‡.xà	_Ò…ùzh™¾îó¢±ø,n^^	-¿¤icŞLÊ&0“¹»´¹³´‰Sy‰(*Q)fÕè³SdAŒ£zÙs>‚0RñYJÒ;äEI~ßƒ«s°ŠÏ™d÷ÙåPÑé~ï†Ó×©ùq]3Ï”İ|êV‰èÕ·˜¦wDšŞ[<@²¢å?óò^”ÚN¯AC&yØ˜"‚>;ß9uÖ}yŒ¯`;Ùß=xq°¿'Ñ¿¢>šù![¿±ˆ¦ó@ü!F…ZU¾Ìırô.„ş¦$xš×%¡ú#Jt>.¥ô«g©Á?qé×ÆmGF¬­ÁãËÌ	Tøù¯ãG2V_Ï#ízÃ=ª‹—Œ°#âY»¿¿wÖ=:>İÇ7İ¼:§äì'¿/·Vİ[ø”#‚WÌ“ËR!¤/œ…%L#è°ÓÀDúE#Jl$SLØG£C
+±¦c<–Ğ4z2D"AçüÜÈ$?4¹ƒêúë6İàğü)Ü=Úùáù~÷¾Cğì»ı½î?Î¿;~uŞ=Ú9E‚bÎ#›X˜`í9££5òÒ\¬Cávw^şğ)8Ñ˜£¸Øİ€$"sRÉCÅV¼|áTIê\¨ËX<'=ğÌ\gdNªoq#Â·ûçí¹N«¾%B¿ÒQÇ6ïÈÉ4D²{©ØKøŞ{<Q)îÿÛ«ƒSh‡Øtã?xÍTiˆ¨C»â5'÷(…~³g7\~Â ÄÙë‚‰E©íÆ©–UÄµr©âŠ¡º¹¿çëÏbø©WóVDŸÈŠ0n¸>k°@©–ø¯E:ÇÙ”HÁmš|`Ô<9`.fÎüX[Š[“Úç8šAÈhd\tEê&ŸÀÃ†îXú¯İºÎE˜.f—+‘K¦_i‰	TÌüiRMqÇ€rçO°"¬ÚÃjSÉˆÆFQé—©I˜±{XLÙĞchè46&L¼†}ğ|À/*?Ei4z»ó¦êñY}ìN’|€Â9‹íj§?ñ2J5,.ö4 …¯Ã,4EÚãhoq˜{)Áåèü‰n'¢Â¯I+1§ëÉäÈÔ‘ç,ğÿ‡0¯«Ö%™t'#ÆD@h¢	‘0S%z†za3Äš#Zé‹g“®·ê°HB’÷k(O3CŒq1oÁ@É0ş’#UwÍŠd±‹„q!†ó±[Eú-Xø©üË©4àÏ¯óœÖæ±š9ÖøÀÓZV½Ö„ø,ıRõûNrøš/Ï+)8²“Mç¶‡d§<Èƒó³ñæõ¨„¯=¶("²;Ÿ`œºdÔ
+è¢h”İqºÊ°¤%Ñ‘*"Ì”4=€§õ'C¶x s¹¸yVmLò¡$İ&ĞXò,‡†­I×Q°· “?‘˜-¯£P,¥ƒŠX^‡©E‡©º'_.£ü[´@<:lÁ\ãê>hLS	ØÔ#>Æ»§Âe _ó
+Ü›j­­qó-:LBĞ‡tJÄ 0’"3®ë ‘ª™(·ì(cR"|ìËqò&rP¸l-ú®¸¬vµ†eµƒ\LOBŞd*çiÁ36Zß$Ï¦—å1Pê}³<İ‹IU09–ûŠƒ³_wƒ¾c®Ç?š™‘Ï8¥%ŸåtÀèB_í·äÜÕÌÅhÕğ¦œ½×¿œıîõ 
+á½—­U£ê¤8) §J0E•vÊIoêu1ß>©ê®«J‹|?_zvc{=ÖbMÅÜb!ŸSet*\Z|õ?á?*[Üwrz|r&_’©rRÖ¸ÿÕË³W''Ç§çLm%wB>Äc¹ôæ$zCª\sèMÙõ–‘ÇRW[Ç‡©ş»&WëóNÊ÷M•'@è`,oJdJn\1ëÒúßšù%ñUt”Kù +à>Ìı«ûšK^¹/ê'ª.NÑâ¾ôØÆ~,08BÏßõÈ6ßZnD›ŠryUË‘öCq^VïÖ]£¹y­H³×úN(¿êT¡ˆQ9Ña<ùğ*è´G2í¿¹¢æLœE;Ù W”â‚ëFÀ…[mË˜gBµ¹ÁPiG×q†h	€hÈö°áúå@Ê6å¿jùÑşgp[«‰f±Lr¯Z'…ÿk‚E˜<ğ§TÇâ1>@
+9øŠÀ	ç›W¸ç‡Àcê2ò‡Ğ•'qÜH·Ğ"#ÎW±˜$°ĞC'wãÅ_ÍRvN+öÒÿ4kâÊ‘;ö*qñv‚aaÿL¦¨Ä†fKÙã.V7©ß€·ÀBÀÄ¥†jü­tİÁ8S™g¦¡ÆAÁÅEÁ‘ø@Ôa|ŠáG¾âOCôpZ¸ëqB(+mo/ß©Òj}eÌƒÏä–‰É×x“´Ìda`nL²Ó@_õÕÇ”ÙqD{Bp%„`¡fı¨BıòĞòË•m4R˜&j÷_ÈNcqÇ.ß4™Ì¡e÷4£œÇ×™—Àõ-ÊÆÈ=õÄ–8å±¥GÃG–ò&•!­¨ÆÛ/š=2yÍbÈeüPÚ	%Ç9=cÔŸì´™H8
+pÓÃ0Ò]ádí#
+»à+r4Æwnaá ³½e9ï…şĞfòˆ±2QŒMÙøaå¿ª?t
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/da/d3ae8f11d18502c05dbc2989d29b0b435c8ba3 squashfs-tools-patched/.git/objects/da/d3ae8f11d18502c05dbc2989d29b0b435c8ba3
--- squashfs-tools/.git/objects/da/d3ae8f11d18502c05dbc2989d29b0b435c8ba3	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/da/d3ae8f11d18502c05dbc2989d29b0b435c8ba3	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1,2 @@
+x…AKÃ@…=ï¯x’ËÔ4ĞSm*Ø*zˆ=¸÷°k'¸°Ù-ÉVñ¿;›ÖC‘èifó>Ş3.ÌfÅYcÚ6ø|MMõ*Df¿¥u½ÚTÕæ©^ßİ?×"cÑzú¥‹HíÎéHX¼8İ÷PKXïÒ«BõQY/ôf"€O £¸ï<40¸á9‡¹Æ× ı>
+Z‚ş Y9WŞéFy‡`—'“e9à§|“Tû%ØmN…G¥áoÚíéĞóXS÷,æ˜Ø;UH™h£öóòÇœ‘ßÚF|[C†3
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/da/fa40d55a089031c6eaaf809a0ccdc37baa8f64 squashfs-tools-patched/.git/objects/da/fa40d55a089031c6eaaf809a0ccdc37baa8f64
--- squashfs-tools/.git/objects/da/fa40d55a089031c6eaaf809a0ccdc37baa8f64	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/da/fa40d55a089031c6eaaf809a0ccdc37baa8f64	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1 @@
+xe±‚@D­ï+6Ğ¨!±1¡â®ÁÆÔúÜ"—À®Sƒ_/Qcc9óf&Su\Áf/¢äPRİó´Pa+„o2Ø€Ö²H*Óo¢3áÏ®%üs…êîf<Å}Ï¦+aë	qŞ“ÛÆğÙZ1İqpK99„µ)]À72Ú'şñ#ç1 Kj6–.«d>‡dl#^¦¤:è
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/db/44571ebbfd7e90151fea9d07fdfaec4b210d0c squashfs-tools-patched/.git/objects/db/44571ebbfd7e90151fea9d07fdfaec4b210d0c
--- squashfs-tools/.git/objects/db/44571ebbfd7e90151fea9d07fdfaec4b210d0c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/db/44571ebbfd7e90151fea9d07fdfaec4b210d0c	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1,4 @@
+xµVÛnÚ@í³¿b”Jœ‹Ò%!¢õCSTš§ªŠ¼4«/²×IEÕïÌŞ¼ãæ¥OàÙñ™™sfg|ŸŠ{8½8{ûâ¸¯7‘d«£„!şz(‚ÓÁàMx2çğ¢"‡Yü˜ŠG|š•÷)_@"V1Ï w/y¶HË„ÁÁz8‚GÁ˜o&"ay”-Å]”qÙ™xè­»Áï àª\êÓWëğr–‹uÑ ¦9cÛ}ˆæ›qšŠôbú©0•»Ãìƒ>bD/y]‹8)fí2Ö.]LRUUÀ„††+%³˜ç¾m/~ÎeÎâ•o½ÍÖdçæ[oÊÕ&Úš`ÑÜ†<ù2¹fK±ÄKOÅ#Ï†8&?ÇŠvC‚åÜ‘°‡ğÛ(“g§À‰¾„c©‹€%¶P‡«ğÀá=qæj?<Ônuiœ€š›oü»/b¤T¿SNJÚ>¡jW” ÙÁqÚâãÜâåI©¼æ¿qLK^ÜÙ&±ğÏ¥4­Aıì¸Õ½k^ÉYQ¦Ò*æóûL2Àá¨â)<ª…'r&Ë<ÃŠ§nÏ$ŞÛØÛ–´©ÀË¬3¯%Ş›Ÿ9²„ıª•Ã)Tsæ½ğ:Áô;¢Ì£LÁÂh¼‡ZÌ¢"™¢ÂUPĞV‘£¹$aµú/5apWÔv¤UEœ_œWJaoU=Y+F+A$ĞìàŸ®Ów§#©sõ%FgœqújBÕÄÓ2†!ê—4‡¡v#İô”×Z§"zİŞÅ1`°tx«
+
+Ôœ2Á%%rñ'CÚ7ÎSñÆOY5±ñ™?³?Æ…n\$ ›Bí¨¸æ¹½a;*Æ™ÔSJ;L¨q¢~úÊWlwĞŞÄ+¦ñ0³BÆ7¥Ù„¥‡İø*Á=ó´yx¾5„§–j}y«Å5Î}ÔPÛÚ;dÃúŠİJì‰ÇşÚ¢2üg-Şèô^Åƒİ·ÉXTRbvë¨
+ö0d'mVÔÏÄh[9ÆÅ›4´s´U‡¥/ãµµqÌLRI·Æ ª¶#\n¡)ˆ-ôfÅjJöı>ŠÏğlq±­Íátıt_^¦Ûtş·Q"K
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/dd/25eb4eb7a1fcddf867d6fc6977daa94b7c0c36 squashfs-tools-patched/.git/objects/dd/25eb4eb7a1fcddf867d6fc6977daa94b7c0c36
--- squashfs-tools/.git/objects/dd/25eb4eb7a1fcddf867d6fc6977daa94b7c0c36	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/dd/25eb4eb7a1fcddf867d6fc6977daa94b7c0c36	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1,4 @@
+x+)JMU0440` b3Ç _½ä‚ï«›y¦„-\?]ñ­0Saiñ±n[$%¡‰š³Ïï‹¾ó<Şã@¹Ø±Üskß!„d”æ&ú})œ1«Éáçã²EçG;~]¶]]C‚œÃş3J÷l°[S°ÁzÁ‰Æ²«PUNE‰yÉ`w1Ôqïïvñ!)ÍıáÃ/,‹ïécÍÀP–Áè°°âáÔÌX†”…"‹ägGWu!ÃeîÒƒÜúÇë/÷íıàübrO'vµüâÕ9‡·ı=µÇ£ëğî¸ùğJ ¨uÎOI-{»WõÃÕóıûŠjÌåî/	Û/-i`±‹Òïàm§W…*/›Ú¹ôìºàK}*lI(
+=ÍLô’BØ/Y±DD£iÑ“—‚Â¿ò'`ªË`àºÙ½ÂºjCîN†“uYkö¸£¨p÷ÚjıEÇ·>wşåM››,4·,£CYƒŒï©z¯^Qõæ-Í[n>ĞëÔ¿¿óŠ²à Ç y+.¹Ã¥²¸§ óàÆ¶£ŞòÂ’$!
+3nır¸Å1ÁğØ«õ³xÎ®^ÕŸ‚bb„…Ğ<üÌ¥¶.OB-…Î&ß˜:³má6eÛënÄ§INjºwh‘öòÃ|>%-Ë¡Ê áLÊ¥÷ïì22eÏ‹3Mj_¨½¸Ñ©´YMCısÑ·7>\ûô$'Ïdóásä6hCU€ChˆdU_„`ğ¦ÄííÖİÜl]n{l…¤$ƒaÁc—'­GO-ÒT<~ÀòJÔï§ë¡
+ a4åBÈ«õ‰¿1½{Ph¸fK™‡”Š¢†ËšŞ_İÒpÃø}\ı²À¶¶¤50%%)izÏg¶]Zv/û•ğ¯em•\"›ÂCÕT€Bh£Ó¶ÕŞÍ9}~ù†òs®gİ)½>IIƒÀË¦q²{Vûü=·ñãª—Q‰ÆñF`Sú«ÿ+ÍJ:zóGP½¼˜ég–G¢(Ê`°5yİûï¨ÏÛh³ŞÃZ7\3È  N.²
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/dd/3963df57701e25b21a2a9ac55c6e628dc98e8b squashfs-tools-patched/.git/objects/dd/3963df57701e25b21a2a9ac55c6e628dc98e8b
--- squashfs-tools/.git/objects/dd/3963df57701e25b21a2a9ac55c6e628dc98e8b	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/dd/3963df57701e25b21a2a9ac55c6e628dc98e8b	2022-01-01 15:09:15.629172589 +0800
@@ -0,0 +1,4 @@
+x]İ
+ƒ †wìUH×¨+på0˜³íô£E!ŒºÿY#[;ôá}¿çµ_NÓó)qİN	‹4B¡Qv
+Ô¤I C¡{+
+ç5å2İD‘û'xåñvêõÕ¸ø{•8ÅŞ-	§¢&=ô=ÅåVñÈ£©àNyõÜ; e•SHàR4Â_rÓ‰`.²ı8î\¤ƒ#à­±Üvß±Šzƒ´ƒQ} æe
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/de/5cb5eb8935ef90395d0e610a6da69eacf5b40e squashfs-tools-patched/.git/objects/de/5cb5eb8935ef90395d0e610a6da69eacf5b40e
--- squashfs-tools/.git/objects/de/5cb5eb8935ef90395d0e610a6da69eacf5b40e	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/de/5cb5eb8935ef90395d0e610a6da69eacf5b40e	2022-01-01 15:09:15.653172590 +0800
@@ -0,0 +1,2 @@
+xuÁ
+Â0†=ç)ÂvQñ4½ø^J×¦èÒ±v ßİ²!‚‡@òıäo}h±96›šXr¨Ôé¦®Pç…–rŒÙÌLïÇ8Ğ3Ñ X]*xAMbÙ°¤,›ĞõÅ¨üÔi¥}Úù.dÑ<ô°GeuÒ\y&‘'ú"ÅcúUgTÜù[p.RÚáoÑ÷Úniù´U
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/de/a1a734509aa4e79ae1a8bac7521ef184adc1b3 squashfs-tools-patched/.git/objects/de/a1a734509aa4e79ae1a8bac7521ef184adc1b3
--- squashfs-tools/.git/objects/de/a1a734509aa4e79ae1a8bac7521ef184adc1b3	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/de/a1a734509aa4e79ae1a8bac7521ef184adc1b3	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,4 @@
+x}T]oÚ0İs~ÅU÷£b¦©t“ m·hEƒ®Ú^"ã\†…cÓÄ¡Íªî·ï:4At¼ß/Ÿs|ì…Ô¼ÿğñÕñ1Œ…š'ˆı•ã¼ŠË,B8ê÷¯~ùêV¨Hß÷WGí”0ÃW—”ÄÄ&ÁQ,ÆtÃ8ÂxNFÁÅl:ò.àÑqL¾Á—pã+sò<Ÿš†×*5up°‡L^êd¢“˜Iñá¸e‹;èÀÙœĞß[‡K–¦à50TNÁØd)84!ö‡gh<&å‚ñu£Â{æİŒùZ+}¯üxã<ÒÀŠOÈsNû³å“©N‡/¤fÄi$·0gD}°©ÑInSğÎØêK¢\¡²KÑ ®XºjíÒ-CR…ª‚ÜÓñÔ$gMò5ÅÏ‡õwQ¾Õ"‚ŞnÇÎ-b—ä†9aó¬ÎÆq/û¤àgx3ù6¹¾„~0¸ÍÍw,ÄÙü<¸˜½>w}%LÇõgx—¡2‚I_ÍL‚,†®¨¾
+D»Ğµàzğ%²ËâN	lWäz‹t
+ûñĞç{ğMá?»¢İGZ?ìïUnÑPøŒ¢Uß«Ï¿pO½"&VVÈ¢°rq1j’Å£-’-$Zp–÷Â&¡[ôLµP“¹ö²$!©°s=Îª<ÙğÕçq3Š¢Ò§c\ê„ä  öWµ5Lw¸m´$ ÿ¡w¥ÕoLM!ØL7"—3Å‰ì0åygqœ·;©Ñ]yÁJM}İ¦ÅZŞ«Í]^İòrîV$&c²ôz©„uÍXj¾®|Ş¬(H·
+œò‰9%¡öˆ¿/WØëgÁWW¸><^­;ğa½ ×°şÂ“óD=9ÿ ñ0×ı
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e0/a682efd5be548750d833ef5e7fa651868662ac squashfs-tools-patched/.git/objects/e0/a682efd5be548750d833ef5e7fa651868662ac
--- squashfs-tools/.git/objects/e0/a682efd5be548750d833ef5e7fa651868662ac	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e0/a682efd5be548750d833ef5e7fa651868662ac	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,2 @@
+xKÊÉOR044dĞ×WprÖËàâRÎLËKIMSˆÅ{p)¹™y©H"@EyÉ9¥)©
+JNE‰yÉÎù)©EzJ\\¾•Î9‰ÅÅNÎt*,tL5f§æ¥d¦q 'ı"J
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e1/2e20575d77a98f3270f46996483a097979d51b squashfs-tools-patched/.git/objects/e1/2e20575d77a98f3270f46996483a097979d51b
--- squashfs-tools/.git/objects/e1/2e20575d77a98f3270f46996483a097979d51b	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e1/2e20575d77a98f3270f46996483a097979d51b	2022-01-01 15:09:15.649172590 +0800
@@ -0,0 +1,15 @@
+xÅıS·òıÌ_¡¤Æ$’×iCœ>úl`Œi§å1Ìa¸`îèùœ„Ò÷¿¿İÕ×J§³¤S†€‘´«ıŞÕJ9åçbõíÊÚ÷ÿú.Í£ÉPŠç‡yQ&ç#ùúêù‚—Ã4¯Òs¬ó{wc[ò¡,pba¡Õún(/ÒLŠŞNÿ¸·¶svpÜ?Øíîtz¿íííntv_›â^¤¢ñ>6E!ËI‘	oñºø —I™ÄñŞ~ÿÍš€¯ëít\•IQĞÇ>”ş)»É×ÓuX_L¥ø5Í†ù—ƒI)òIyö…şZò^.ˆ—b³·Õ7ù0½H€=ÏŞ‰‹BJ‘ŒF¢¼¢ß9LÈ¡8Ÿ\\ÈBœß‰˜Ì ß-CÕç<ŠÎŸ7‰–Á.`Ù$âåÈ­i.Ü/‘f¥H—“Ã|¬”r†à»Õº-`æ¢ñœèaP¯>ÜœuÒRÉHïõßìyÁpe£±8umÁ·PKc€A ¼T´ÅÊºHÅ{q½?¹éÈ¬Ÿ‚Æ0¾´J‚Åø52„åe@ÂÅ©ó×Ÿ¤§D`!4[t~#€.x/KË*§vš¤ŒY±*İŸïÅp¢äÀD`!¿™(€€Y$tò/¤ª»; ù<Y%sĞÑM‡³éPŠšfµ¾®=«ƒˆéåQÁ,E€F<§ôäm7)WÎH„äVÄsXJºÕ?a15¤üc–SCÏ<ôÍ¨†–ZCBW"cšaÄ£ôÒ"ÏŠ+şÏ3ËEÃ¥àÆ^ QÑï¡aWGÆ±¡¹©¹fqMÀ]€|û±·stÜéó¤v$Ëít€i2)î0Ñ6€ÁWø	nÅ)XÆÆ¿…N‚ÿƒ	ñA4VÅ{ÈH ĞÉ/ubo6	§-ööÙèìmoô~Â U‡İ/Q™¿'Ç²øŒĞàÙİ;¨Â–5…j»µÕ¦RÖ$A.õIÏÚUn„N”Ó!+€&Õi¾Îş³^¯ÿ‹üVe*Ç%é+.MÄa°èÊc3-Çqé…[yVÊ¯%®cZ‹`Õı0UM(Ú¤Šu&€hËİ*$K‡Ó8õ¢ea61™\ñhF9C¨€ù„¸>	—ËWy1‘&,U8qêÊ–O‘,’V Ş¡Ö7©d3i`ãSÅïí ^AnÆ‘&ÜÙ%Ê:yÛ’dÍHTµÛLğj„¡	\É°ÚMÆ×@¼·­x%Vcš\ësP½:ä…W sÍ)#vB@[4Œ^­R5Áì@a€ñĞª—2àº£²ËŒ¼‹îáŸ2gü¿½öá İc­F© `––élµr@®rMG.XDyj/Ê¯bI@å®C3îjÃ3;ò­#å˜äC7‹¥*ğgKD´Úu>QVí%Ù¥áQÒì´-“›eøb÷á¨¨2Áª±ˆÀé´¦G@’6•’ŸT	ùI¼o¦{,¹í®‹Op˜ P,èGK>zÀé&i¶u•§Ãİò÷É§S ±ÌÅ/øÜÑœô§ B%Í‡¬‚D“2“EÈÁWŸ¿‡GöáÛ%›¨2üT£ø(² vnÀ)^…hˆ†•Sµ4óÊèfh7îXZ_ÆsºÅh]k¦ÆO¥
+u³X@\¢hlØ¹ipFWW“€b&JeğÈËìeÊˆ4¢EÄœº]‡LF±b
+ü§–Ô¿‹Î¢¾^&Ù^†¥fı<D\ rËæÁAÇÀºßÉ¡üœæ“ñŞ˜N«v¢-¨c†Î¾ù[ÇÛÉa¡ 7ïJiG…# r36'?6Ò’l Ç'hV| úhªEÅAÔç§'—€šJöó/ ”Êv™ê¨F¯îÓ V-6„Ş;’LdV¦É„Ma€nîÎl”_§c€küqœ¼	(ÄEq>Ÿ¥\¢(«SÃÊ8©&3T‰v[ìw:Ìïá~ÁAdëçïÄ¦LRY¾¶ãæt‰Í4·wĞüœŒ ˜—“àL¼ø
+§¸eWáYş]ÏÇfXÿ „RïDF¤³,¤ÈçÒz=LÊDM?Û@N—4…2÷ÖòQš]¢™ÁºÜzÊ?ã
+Õ`t‘Û™:í’Œ|ƒLO•ùÂT«õå*É†³®÷ *r&!ÔÔ4:?ˆ§ m·É>h`8¦C¼¤Ï«?4¡"¥=PfDá§qíh¼¥dŠD·GS,N­h;U¿ÙlÚXäê ÃTGÃ
+'R5(K>e}Å9qyÕš½áK\»mtf¤ÊP	Æ¹…q¹ã[°:¹u•EëW†“ô·^4h8"
+’ñÚÂÖn?Éò “8ÚXCoS+§xN O0‚Ë{¡³í’ÿ¯iyew˜KşiäS¨¿Š¨ÑB
+1r=ŸÑ(³ÔÇ ñú(Vê¢<Ã ßµIQÉD¯ø®ä<*ŞÏ¸Óy‚nC<A©!ªÇjó©ZôÔÇ`ìpb¬n­’KKÆÕŒrP5Î„á“ÖÓ½Õ—‰¡¦4Á^ÌtØĞú½ã71äaa³r2$ûN:pÖÙó4í5Ãp	G …ò ,Sl«z!ÓuçGÄ9‚İÆT7Jb‹«Ñ§Ó!<†îê¤ <vr;™3Uäñâë ¨‚P¥/¢¨Š¤0Ú«’U¬÷<4=!:<‡ëéíMîPM1€^nšMèºÙŒ©îŒûòêX A6L ÎÑ|¨ æş¶şgø&òõTå×Kd•JNv À0Œ Ç'«XÆúC+ˆ‰
+	EHqÌ—åc*CC^(ã]a?d‰ÊÛôèã„e$U‘ÒZ %ßÜ[`rİàMeƒPwoªº›M•¯ëµ*Šon1şPãÒ%“òà:wÅœ
+ël‡æ!EPEï•Ûõº4‰*šn7Ó!íÁª	g8x@&…ã›Wø:£Ãy&ÄıÌT!ºÓÆÅ¨EÇ·j%I%û3¬ÅYL‹E >„h¸_>‘7çŸ'BRA4,t.ÁÈ smÎ‡šá+dH+E÷'O §‚¤\‹neÖ<]ö‚¨ÁüQsY±êW]ËÓ~ş…QQIîVÄZÃàÍÃ{Åf‰zMšYx¡eJ{q½“k7Dİ6Kíš¦¯Şc´HPıÊÈ³ícÃœ½#WHóéi®Mk•ÉÜÙ¹'²Ãä.À¾°B1±}æãFá‘56:°¥ëšáô¢ÂáN]A´	ÿm&Ø‘«çA¡ÊÈƒ~‡ˆ¹”=§ök
+—"öâì²«öIjsšY´ñòÌ*Â_>³bğ—Ï¬/kéª+œ(şØ‚=Ø»çûQ]ó[	É½ ­¶À±½o×çV a·{{£¿áìÖ‘jÏH[ùíİf2¸Ş„§º×øàGÕAª‹À”oY"Ã¿M©ï-ºF¢¢â?ønµ*Œa”]kïºgÂ~À-7»£ÉøªAd‡—ç‘gZ(ÕêË,ïú
+¨°w75—VîÒïª, <½ÆcAQş’Œ&ø¤Šnt 1â3f¥ZŞƒR„â/´YÇßK†Ôøg[9u³AÔš}%6†×iö•¼GPJ)ZlLôÆöôm
+„©€EàNÚûØ#ş.vÔ›YöLˆmî]&ª»@Sjê{]|·—È„™Ò}E;S¦Ù«&ì?\Á}‰ïsàI8_tÃ}àÏñúƒb$ØTÇ•úY?<äß?èŸá‹µ†¹Cî¡Ä•L(¹ø×vÈ¡é páB_iF¡éèÈí…SøNÏÛA…­0¦ĞBØ:ò:v…è€Ô‰âGdŞ	ÍP„¿Í¢–^Q-²tÿ&tÖR@çV¶p%ìlbë¶<Ÿ\â­¢§1Ê£Aóx1¤ÅÈò’*
+ncğò¶Šƒ¯‘„Ü4nÏ‚`€[VR¼øJÄ­}á(Î%„iWpû@Ğ\|áI,.
+;ÎéTáş€èşá—¶‰Wôˆ#ìÛàƒx+şúK™yo#oA°!¼İsĞQôKÖ9Ò&¢íÖP3³}ÒsùšñôïõÓ`¯éáš'Ùê³åx W&0×O((ø;è¦ªWfÓa‚5kşÂx.eÄÈ‹Yà“‘±427{`­˜³XÎ{²¤_şÂÑ9`ìa)ôd×Ÿ¢
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e1/9fe387d1b2fade668609f00d14b720095187fb squashfs-tools-patched/.git/objects/e1/9fe387d1b2fade668609f00d14b720095187fb
--- squashfs-tools/.git/objects/e1/9fe387d1b2fade668609f00d14b720095187fb	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e1/9fe387d1b2fade668609f00d14b720095187fb	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1 @@
+x]OËNÃ0äì¯µ°’>Ap¢D$**".\¢4Y·V/ŠJäëqS¸°—ÙíÎîï0Ÿ%Wc‰¤[QÉˆcô½¶{¨†ë A±©¨³Éä>NãÙH÷Ü`[œŸÂ´mwF—¨¸.´…1ÔÊV¤çÉg¾Z/ßVëüE¥-ıcƒÙ–¦­ƒ¤K=Õ£Ã@ˆì²ßd×%[çñ‘ZwùU”ÇLwä"\„eÖ=÷)!/i#Pé+ó1µ™o¨¨!]Ñßç‹ÆoÙ]¼‹oOÜúE«5\8{æ|*BšuOÆp	Yœa^½yŸ’­´?îÿi»
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e1/cf7380d24989eb14a0b37aa26de22d588d6e11 squashfs-tools-patched/.git/objects/e1/cf7380d24989eb14a0b37aa26de22d588d6e11
--- squashfs-tools/.git/objects/e1/cf7380d24989eb14a0b37aa26de22d588d6e11	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e1/cf7380d24989eb14a0b37aa26de22d588d6e11	2022-01-01 15:09:15.593172588 +0800
@@ -0,0 +1,6 @@
+xµYmoÛF¾ÏüÓ~‰|—ª’ìØ®İ ¿á$NP»-‚aPÒ:âY"].[)ÜßŞgfö…åË§°ÂÙyÙÙÙgf™É¢˜ĞÁàpï_è¢(—iE3c§eöPeENAw·G'¦Jiğf'ùáëO’\Ï3KwÙÂĞ´È«4ËmCeqG°•–ÓyöÙĞØìRR£MÓÜ‹Š‹Ñò¡4Öš=fÕœÒ|MKSÍ‹Y7¹2†¾/Û­ªïYgÃ¢ï²â^S–rl7I·t[•«iµ*}ølÊÏ™y|yÉIrU,±€Ì,fğ>O¶tC·Â 3ùkó!J®²OyÊÿcÒ™)“ñÇtzofWUiÒ¥½ÙÃMÇœ„H„7,¿âHU8¦PtŞ(¿+0|Nn°âÄÉ¾ì¼c}nËâÁ”Uf,Óf³Œó#]8GA‹¶OR‡>,ÈÏåjÉFI&^e_Œ7Y7Nàô—Óí¬g™pZ p¶eº.Š³œ7b#îÕP×oªÎÉEí,¨#/WÈ²£³ $‹ån‰ÇMú‡Uµ…ãË¡¨IDÆ8¾òœè…ÆÁù’å³i–M(#^E D1XH>Êgæ©î6|Ş E›šn`gSIöÃsÍe«áíØÇÜ¿táÔZŸé,†p»½ö³%ªíj5qqÛ¶×Î’jå[6Û¯'údÇ> bVlŒÿŞ¹šö4F«Ç>µ”åís°ã„/ >%UŒ³‰² ¸‘ÎSË¡Zœ¥U*RêÙ³?ºBø±Úè´‘ü‡¡/I.‹ÊXJ'Åª"¼§şi>#“O‹Àòeô%!a_Y¨YdUô7È ¢× H¬a<0™kÍqô˜Is@KÕœ ¼LK`!b LŠWü–ür>|wûëèòz ¢À -¤Øy‰¥¾ø"RÍ¹ü,Å#;›¥9Ji=¡LyÏÉš?VT•¬
+Õ­,–@şÒV4YW"ºàÑí	FDçOU™Ê»Õ¬&ú-]¬øTw&Y–ëĞ1ê=éãg¹¨CmçVßIğÄ“ÿ^ŸÓzÜ¿!b'A?ÿLCú'õwvè_´f!'Ux!•
+Bƒ ÔívE´§÷Tİ¢L|
+¢ûA”EğôjB"Ä„m:©RÌw+;üŠòÖ¤5À×6R4IzO½½¥ûó|öZF}i)aÀ„Vy{ecs ¾+üÍRÇÇî5³÷˜½ÂxÃŒ€ Qß>ÓƒŠ¦(Ú!ÓšX§îş$ä¦ò°¥¼)æ)áTØR#Ş‰às€FuÀT™sæœ/ªµâL¿D^“°±˜7Ì«LÄú×K€¢0%¨§8!×™£J(ß¥¶NQ$l K™ş{™U&%‚¿gù°ªÊl²6‰n	ài±\š¼RÛÀsÆ(3[Ë8ãñE!¥‘XèŞ6:¯æY ixæ‘ùoéÏW¯^Ó«/øé=œòïğ‚üÛ?}>fqiõÚÄExQù>ı_Q#É~ü‘òâJ{’sÊÌòæ LUÊ¸¶; «*-+]-@ÌÕHÁV%/Í““øpwgM%ö¶O•ÇY‹¢0Æ®àØ^zÀm©vmJd­—£³££ö	¤N×`'ÁRçøxGª˜øã~½~0Çğ%»£NÊz‹ 2@M{÷ÌtUÀËğº˜ÜPÄµÕ·UkqsœğÏ²OÆV–:8(®	Øi¯‚SÆk.ÃÒœ¹f€È®5hÁEÍ,®¡œ]‡s£kŠ:¸à»]Î8&Š`â‘¤á—wGCë§ î ¤û À¶ä İÒªiÅ),­ImŸ¤,ÂGVõÓ†*æmëÑ¹Z·5a1²ZQ5dUÑ´‹ü–«€êª9dGõ\â±mÖyÏ%“…ê&ˆ2Œüùhn‰E®7ËîèŒ—(S‰ö¸àëÓ£hd¯²åÃÂsQp…ˆ³]‘­sŞ4å.Š 4²ğõÜ ıA>µ'4u0v’ú(é¢2%.”¸Zß*õö]fõ¸³ÃQ¹ôW,¤QÄßˆÅ—gnPÜqÙ‘ñv²#‘å3ğG=Æ9f]ëšY›7%>z²¶X÷nè»€º¿1İÃíµ¶u$À½Öã ^ã´çf³°
+W' 6†ÑÃktÍl]_ğØ'\˜sÎ-¯qÉr4h·, P¸*‡ïj4DÌÛ¬ûÅéÎqUı7:B‰ŸCwëæ_´şà¬é‰Âjõ’]­ËØĞ(Xì@´1CÏ¬rOØvÜseñ5I4¢•æ„^`lñég:ïxJŒè4µSøq
+Z×|™Õ÷³œAÆÅwY,T0ú;ÛRtÉ±‡R§OÙ:ÒYÓøE‚»Ü†Ò!9›QRj6qVÑ‘QV Q§×`Ñ™¼QQü‡ô“ØB¶ö«V¶T$Îå­=\>Ä®µCZ9ÿ¥PèÔ³æÖ'à¼eC8IÎ·à£×®11fzgAXB"W‹ÙÄ”|£³Zİô#â*¿G÷•ó'‡Z,yª¡t»ØcğŸÏ’Šæ²4w¶0šñvÁØb9\"âiÃäÚQĞNòºñ¶q˜ä‹H‚GÜJy®cßÚ·SÛªĞRA8(çm¤çÒ÷Y¬LƒÇàúâ*ØÑsÂÉR"ËD/4²µû‡›ÕÇóY›ê»ˆ’¬¯&e#§¡“åƒF¾Í¨2¯±ïÚI]#Ë‹B×ÊIø(`º¯_†Üòûènu¦NiŞŒp›ÇEb·=%\’ †§ìù).'ı¦3ğÿ:QuÁo^ÚßÏbwªÒZ“ù½×|ÂõÉîd×ê³òj(ìñW‚‰úÊ.‰Q\ñhT™ecCY®DìY°„å/§6äJßÕAVÿ}ŞÈçz”§ó´¼Å—6ökÌ¿ÒpÄ˜ù)½HŒ‘fôÓàÜÇÒå„ €2eqß:'¢ëz]ş†É]‰çB™›yÂNrÕwµ¯M\Öú¨,.$x’bí{®Â¿c×ä[ÿ_Ë¬sWaj•¢­cãK?‡^T YØĞ[sKË›.NæÄÎ¯±1{?³Háï£³ÃçRÿÍŸ£qXÉ}‰ÿÿÄéÊ_`Øã*<+¦+ş„“ü&ej
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e1/fe14431f443936ad71ae46c7bfe2ef2b121785 squashfs-tools-patched/.git/objects/e1/fe14431f443936ad71ae46c7bfe2ef2b121785
--- squashfs-tools/.git/objects/e1/fe14431f443936ad71ae46c7bfe2ef2b121785	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e1/fe14431f443936ad71ae46c7bfe2ef2b121785	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1,4 @@
+xTMo1íÙ¿b”HM{¨§ˆP	hÄ&í¡ªĞâ-Vwí•ím’Féoïøƒe	I[‹Æç7ofS¨œ¿÷æÕpU–Jİ_*³¹x•jƒúlËØ©Èe†9¬×“O‹Å§¥ÿ»X^ÎgËéÕÅ*™®ÖÙ)yPÔß(•äE!œÄ‚‰ÕB~?Û0&ÓM•r„åx`ì§$U!lëºË•4nBèÍ{+CcÏŸØo{ãÿLÕ~Fn•†N•jk(¼5¹–o¯ï+$Œ (ë¦Sú’ñ ôø‘ˆ²*pŒ+eìBÈÚD{.Ja1sÇáñüF¾tã\'ÛTS¾Ç1{dÌX]s“€åƒÒ%sX5·œ\×ú³ËLWË=ìÑÈÃ÷wµQª€E]Xá,!-Ú9ÊÆJï¢õ$ÿV‚–PK‡°Vh(©æK\oQãÌ4%¿»õ¼¸“ØÏHüïî0íŠÍH™w.">>TéöFówó´0ØƒG•sd¼HIĞ·Çã®©eôEòAm|ŸÃÇïã£G"Dî[~ÈàºCVÕ›BğÑÑc—J!w ÀvĞN’"Àïø’®·ü´ ™ˆí%$ƒ Ñƒ)ÚÉ‡eqøôÁï€›¨
+uJòõ[×ˆ_HZ®+½@BĞÂğ_?—m¨hõĞV€J+Y­ÑìÅg¿ù³òj&j¡2’¶“$Y¡­µ4#ğÒ•CN-_·‰ÃkÚ"ëT
+Â€TP¦4éÌ«ÏíÆˆd×”0Óô¿u}øô
+xwèDÀx³~hñ4À¨Í\ÅäI½qÛÀĞÜy57ŒøS'OÇ´¬ìıEQ¨[ÌÉ 	ÆÓáº—[Æñğ<­ˆõ#œñ™Q1ÇX¡ïx'ªànW5kü	“™´;UF¤Z}§HÀsöÃÑDè
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e2/b8c3d289e3f483500c550a3be005e0b883cfc8 squashfs-tools-patched/.git/objects/e2/b8c3d289e3f483500c550a3be005e0b883cfc8
--- squashfs-tools/.git/objects/e2/b8c3d289e3f483500c550a3be005e0b883cfc8	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e2/b8c3d289e3f483500c550a3be005e0b883cfc8	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1,6 @@
+x½UmoÚ@Şg~…Gµ)¡
+í^”¶“RšuHdE„­S5)
+äBO9”—u¬í~ûìË‘†—
+MšøE9ûìÇ~ì'£PŒ }üîÍ‹f:b:QÓC1nŒg³JeGã0óTÔ7ƒ_Û*>À½î~>j—\ìù5|q—×öd<MR?ä£Æí´D>Ê±ó„ºYƒ=ŒÍ#®sãš½ŞUÇ½°Î¿\B­IÖ,Y·¤|6Ê&àğf3bÆb/å"JèâñrÈet\8¥0qe ÈğãOÖNmîo6œóInXùS kÍËµ„ÿfn
+ôÒ!½Å¦Wî+ < i„3Ì§ã@ÌÒ,(;À3ø‚YŒˆ»Ëâ¸Õï‘Ì¯Z‡>Œæ)KN`¬
+¡³j]f¯/¹¿¯Ë,91EjÃ˜ÊFHdèñX©ÈrìùGl±–—æù~Ì’d¹œgñRê¼,JİPeXC~pP¦f3vÉ0ˆúEüğI>«9şÒ·c>\š˜2'ÛIÁÏòò•Çiæ…y‡JmËv;W¶İÖ¡o^ZîÀ2/®İ¡U&û»aJŞÂ z,“XÕM 	5U¹,AR°TûÀêY¦£ŠMR\ÿ18İËâ´÷¼xÂúŞ„9¸|¸£rÇJÓñöXh-8=…vKâÂÅ“*Fë¨íÂ‹X:Ÿ1C•GÃ93û]¨]²´ÈhóˆO³i_×ğre$DNÉL€”lºá¹ŠƒàµM¹lVÃ@{?c3_NMØÂÏBöÉ‹üiCëÛP«ş`qÄÂ£vÃÃª®£~l\•%5ëHŠVjx¨úÄ”ê)â]½HX=xxPøZ½ ¥ë%•XM±Î)e£ÀÊ33üDÕRkâ¼ëµ§ÿÁ¿­=ŞX]ûr«> ùrD[ïu"ü€\ŠQ‡±×ÅêÿYö×–€Øí?Új+eëëùPü'eùÑ3¨/$2Î­¡+4/èIå^ğ˜XzÄG1µ™¨Ì·z«¢aÇv¤h˜i‹¢¡‡mõûjá5ö/Uèÿ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e2/d6aba1e3661bb4cc83e341c2903f5a082beccd squashfs-tools-patched/.git/objects/e2/d6aba1e3661bb4cc83e341c2903f5a082beccd
--- squashfs-tools/.git/objects/e2/d6aba1e3661bb4cc83e341c2903f5a082beccd	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e2/d6aba1e3661bb4cc83e341c2903f5a082beccd	2022-01-01 15:09:15.629172589 +0800
@@ -0,0 +1,4 @@
+xMÁ
+‚@†;ïSLzÑ‹ÕÉè`‹)40(ºº.-¬;²iÑ»·–Ã\æãû‡¿TXÂb¹šQ
+ûKÖw'©9>‚ªm	q¥®TÏkpòGâ\)ú[†MƒšFJa58ÿÜôå¾£äÀ&4-;¯DTpC%¹O^@
+o>`‡ÙbÛ^ˆÚŒ¾¿¶’+¯iVÄgI–æ–ÇÆ ah{o /²İ×­5—‚¼	!›ŠIG
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e2/df3ef4a518ef900f9f73b6cfdf24409d31af45 squashfs-tools-patched/.git/objects/e2/df3ef4a518ef900f9f73b6cfdf24409d31af45
--- squashfs-tools/.git/objects/e2/df3ef4a518ef900f9f73b6cfdf24409d31af45	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e2/df3ef4a518ef900f9f73b6cfdf24409d31af45	2022-01-01 15:09:15.629172589 +0800
@@ -0,0 +1 @@
+xKÊÉOR02µ`Ğ×Wğp6IÒËàâRÎLËKIMSˆŠ8I.e 73/I„K¹¬ÆÃ9ŞÏÑ×58ÀÑÙ®YPÁd,ĞP¨ÁñAA‘ñFØQ<İAÊKÎ)MIUPòpÖËPBáû&fæÄàB1êH„Ğx$1ˆé©y)™i\\ òL”
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e4/8faa48543c9d11226498420a6259cb9d291d99 squashfs-tools-patched/.git/objects/e4/8faa48543c9d11226498420a6259cb9d291d99
--- squashfs-tools/.git/objects/e4/8faa48543c9d11226498420a6259cb9d291d99	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e4/8faa48543c9d11226498420a6259cb9d291d99	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1,3 @@
+xMÌA‚0 †áÎûv¤å&Á¤èBÔMğ¦-¦R‹ş{J]^x.oal.ø, áJVª]– t¾¼“ˆ±˜rFÙ
+kkÛ"“ƒ±Ã¨¬/Œ.QÙ›Ô‚¹nJÓW
+ŞïwñIÂU¸\×ìúVş‘k§ÎØâåßa$ºÛOÄT¾7ä£…4ö
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e5/a19148c445875841dcfd647ce11dde65ecfe03 squashfs-tools-patched/.git/objects/e5/a19148c445875841dcfd647ce11dde65ecfe03
--- squashfs-tools/.git/objects/e5/a19148c445875841dcfd647ce11dde65ecfe03	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e5/a19148c445875841dcfd647ce11dde65ecfe03	2022-01-01 15:09:15.637172590 +0800
@@ -0,0 +1,18 @@
+x½[mSÛH¾ÏüŠY_mÎ&ÆCØ„¶ÀÀ­oıBaÈŞ¡(aË Â–|’œ„eóßïéî™ÑH–!¡î.•€-u÷ôût÷L®'ÑµÚØ|»¾õ—W¯Tç©·?‰B¿1œÍVVş„ÃÉ|ä«Ê í¿4n+îÃFã•ümEÓi¾êŞÿ„£èsBpî"X;Ò¿ÏƒQŞn’‚¨q»GkŒÕÈ¡?ª^ıÖîm6kêÏ?í£ş ÿ½;8ìjÙ’»ãa˜Nˆ’åbW(ÿU¨ªîïWƒ£³«ƒvoÿô÷«nÿğ¨:&~M%~:F>#yXïk@,áOå)* GÁø1]‘Ê¼pÔˆ'^œøñã:¤qŞ´¢ğ“§ßzµCÌTPÉëâ‚ªïMKÍ¥M*çi0a¨<±Î¿ºû¯èÇ¡?„ÎE° G¡pH·øáğ6/=>õ¦ìş—ÔCUiUV
+˜ ‘u	ğëÊÊ<†TèMıdæ}Õ[Pñ;v,x€ŸZ¹¢‰º¹j'½3õ^=ØöİJ’zi0TA8mƒ´“vª]»wV­¥úƒG§ƒv¿×î÷Ì’QØÇÑ;¼t¾6FŸš½øX,Á¯h\u k„¿¯ş°³ów?Õ(G_ª/\ š”R±ŸÎ¡Í²ıîÒÃÂ'/Gñ´=Rïß+ğ{uÒÙ?;îŸvEW½3¬úÕº«}…Iª†·^¬VïZ^˜îO&ÑĞK‰ï
+¾«0J•gMıißW¬ârØ§¾7:Šã(&Tú¢|ú¶ú·8H}Îß,üŠcÙ_ı{õ°â‡ó©:Â¶Çİ/şd¶eÖëĞkò§.\“?Ã6òâ{şzì%éÁ}ê'ü­¤ˆ®şf¾Dò¿‚T>w½tx{Œ$çÇvÔğo¤Çvh>õçBç}³½ò•tlüJÔÓ|ˆŒ£î²ÏÉÅ%$`yT§òs¥®TO^ŸİÏü»A0MüºX^}¥5	ò—o†ÜdäyØ	¦Pü’¦’h4ıºÚÈ–8|.âñÁs1;­gc<óäÙÜvŸ»&Ühu‰¡m@¸´ÿÍ Ço¶Ÿ„%7Î;q¦ê®7ŸŠƒú	\W§5×¥kêUÙã‹õKäCğSŒÔ	ö¸”ÂX§ØñŒŒ«¨5êªò1<O¼G)ÚYÔ®ÿçh‰z6Oi7SÑ<5/v0?Ùk4—Ã
+§MJü§¢È`ïArP´ó—AŒvPq<
+q½£x›zñ¡PÙ5úØ³”Zóz_Á8ê5Œ¦³ØOhÃPTl¨5u±^WÍË:U8Ş|’î¨¦ªN½/5—Â(£0²©Lp›or¸›ªú¦{C_36-ŒyíÇ*#‰ Ï_S$2¯ÁÂO›.¡æ—É°„Æ™#ö&Š³§ºF®Ôå˜ÚÌQš=Bi%.•-—£u—Ê¬L¦Ç°›.ötüĞ=¾jÂ*¤NíJrûº¸N›uunÒ-şq]W3/mÂéWİ!eœŠ~Ó»[Ù”_[øu;ÛaNuH¬ùQïPŸiÄ¦6Rı±’âK‘sù±œ‹" ûéÈK=5£©¢ò9ÌE&4.
+qbÀxû/Âıptô%H«î~HíS˜¼kï¨“ÄB]%\Î8MÕMzGŸÕÚ†»rä·ˆqì±sY¬€E7¼T, Ğ•E	¸nØoæS?L“³H¶´N¤UÊXpû²NnkkÏà\Àå8_œîp†æEÂU¸QB3½ ioã
+Ôn4¼|Yc*­±?U»ˆî€Ê³è<(¹ÈÕlñà²–ŠKPT„È´ˆ[mÏT]¥j5©«óv˜n6Õ‹OŞdî‹…ø#C¦¨ìŞË:?¬&5*×…¹b%)
+±äÑÈ	Zb{GI¾%mˆ„ü®
+F^ šíNeì*¾¨Ş«Îß>®ÿ­|-#’{jıË±şSiäQ	‰×ÑÌ§ñ…;j,²ïÔÂ¦XzÁ¼¨¯D?h0>@eM@¡Ô'ÙM3§T‰ßóF´Õ€ú[Ñì>nnSUÖÔÆÛ·o×šëë¯Uû®sâ}šDŸ”¢'kÍµõ·ˆˆ ò¤„²A¢?àŸrwBâÀÖ÷lNÈ)Xz³%oª‘¦7¨GÖEQ58åVáéö?Í[ê<Læ³Y£$T×^â«µgÒPG£ …˜ÜëS9Š–P!á´£a%‰nçJ}Åb8J:zÅ…‚{$jÃºBtÀ¿òX¼XKºgä]j¢«n9ÂïÓøÄğr37ÚŒ¡W®º•Jé_ŠŞgx[E!Áİ—³™ˆ-Ty9m›ª,uÑC§‚¢[“ËÆÙ­ûí„ì±ø¾ißg–±ùOˆİ ŒqöÊ«öE…Rh±Zò^áøbï½imÍ7g8O÷Ş£éË“mĞÂVk¯åÚÈ±§^hóa‰"­‹l©—//ß±ÃpÚË
+vr(! Û¶W¼\ePx¹¡vwU“}/‘µ€%ÚÎˆu¢rIİg©WÔh¬êËZ§…-ê¸`"Z9J•«G•0.ˆ²:>ë†Õ^’jË«é‚w*g[è¬…í<¯Nãš“\	ê#ÀyÉlÆÒ¶lÀûì÷¢EµS¹®d›‹ŠvÙ£(>aGªqÛ¨}ŒZàÂd5Nm²Ñ ™b“¦÷öu9¨I–±RGÆvü˜Ç–˜·Ÿ÷Êz)k["ô=ì’İl$Ûy¶ÑÉ‘cg2ƒ)KˆÀt¼ {2¿Ö>i†sG‘ô94qƒ‡6efD*wj„¾ñ?š„òæµŒj³e4l ó8•Ä)‹ÈÀì£dm‡šû¼§èuhÚ `³¯à´º÷pã“4ŞmüÏQ5Ş¤"}b:J¦|"ò­v˜NÕªy5˜ùC¨ÖV[–ã,—P€…şgÕbÖ3ZD\•¥A*õŞ‚¦•ÆÏf?#BÆáŸÊÑåJ¦eyš;ê©Äk!†ò1LMøF6­–ÏU”g @Õ|$ı²üà>^ÛëÏP«"ùî“ÔŸÊf†º->ñVÓøÀ”Öfº'ê‰ez2-àŸ{t*ŸäÈõ:5,İ/[W¶!Ì;¤c¸Ro‚ÏwB÷•ù™ÖŞšy‹rÜ@ßæ/@şÿ:ÔVùViå„Q«  Jq](#Z·pXÈ~.xQîùÚ^‹vÁ‘ e<©®(§=ÏŸ„L¹C=âNÎêl*ò>İÌıIG9ª[SxÀx°l³Xæ78Ã[¿ÙV2ıRA¢0ÿW_ğdÌH¨èiâ„±Uëê%ÑÂ’KœU0”´pa²°T|¦›·slœ¬cèô±4­ÄõˆíÁ„Oe£yXÉ~k{äÛÄ:Ô›ô–OŞT«‡´`°¥_\—?nˆ
+‰F†H7Îò¨*_@®SÕí‘¡(üP#E9ı`>c@¦ó¹]–î›tŞpÀ«B Ö½ç“j5ÁjWiMpk:YzfK‘|@&$¹CáMª^S×©³8bˆè…BI§
+I(!WÊ‡:—ÕêVrá	-{·‘ƒ«ş¯­šC„ÒH«”bÔ˜)'OM«H„’ãRIv¦C"‹ÒF!²bTÊÚã0Ç§#®ö,Ÿ•%Â®1	‚à³ŸPm¬¿ş‘¦ºó Ä¨’y ¸ĞÁ{ÍöÖÌæW%_‘'5ã+g7×Õ*ZP•»mÄ¤˜™³˜›äu%]æ1šBæ2â4jÎkñÙ˜h]âì‡’–Â˜º¬inŠ¶.Q¦?úxöˆgçğ1ãYÆ£,“uc:x™È1·ífLÕÕà_WÇíÎ*÷ÏÏú9µÒòå*]˜`|…½X\VüqÄcIšÕÌôˆ´RL»F_o¶<5®•÷«¨V«	ìš‘¿Äf‰Œ>8ŞtB!^t¤ğ¬G|PJÏ­ùŸéWÿ*zÆ‹Ü%£WLùXÇ±o2¿È^4¾Õé]ß?°y…&$§çÉ’N‰¤.ëÙ9ëš<¶è¥ß”ïx®6Å#º÷ÇàŸò€¬ İX?6!£ŸêmßŒö†(ÁcØjÑ$9òéN<’.9ğYÒÎNF‘;;-ãù˜¿ò¥]QéôFµùr$aß©`ù¶òxO˜ÑÖèç™€°øX~É¢è2¤Ava¶Ì%\¾ğé¸0MáF¿Ä9SK˜ôëÍw
+‰ÒxˆSt¤uÒWÂôğ|ÖºÅÚl®á¬ŠÏO\&°Fz=”ÈÑËŞ6Ÿ¢åM0ûÒÛé‚4èğíıRGóV…ôë83C;Sô--Ç %æaØEı¯­àL–ç] Iª'‡	ùvZ0òÌ^ÎÈcI»N^P¹Y1¿­È«»'X’ÌYà¨c=éûXrñŠ<å½ó™\èwsÄ8%Üàùğs8Ñ¨ßÇŠE*ò2s‚ú	nØONû'íC…BrÖ>Ô÷aÈŒ’ïpõS
+	¼ÆhıĞÎHik¤ë0ô§ lbY’—Ô¶HË¹`ß„Ê’÷ˆ:ëØK@œIíœwùH˜…Å­’XF8T¥Ñ¨”ÔC)„ÊÜ2ÓÊtnbõò%ÂµÊdzúš¶“V¿‹İ„(}ğâ ·ÀØ&¸~øÉ…]äR–'zúÕ:]a’ô[Ír¾Şì¸.ç$›d!Ğ–9w(oæáµÉ9Ørà²$·°ük,—{ ·	r:^xş=Ç	¿¼X}Å“£Ø?mïãò¡Ã|Q³´ÁQÕªf İk†#½mü2‡Ë8ÖÊt?»l|J÷áìê¼½µÀÇúec>ù€­òT„~ÊLEø2c¹ìn.ğŒGÌU¤ÿ¨ÑŠÀ%¦+:Îv¦¾ƒÁÙé‚şğş:IcÑ`•@jÅãø™¿H÷'‡n¿ßY ‹÷´ï]ø‰úYiÏ¸:;=?R;öëñ~gpä\N¶¶7ğQ"¡N;±a"Rì³z–!Úı²m²Cn®v‹ÙÂaÆâsÅ
+QèHº892•-üKoIW¹æ­Ñİ^PæÜôÑL1š1–@¢…ne¼q®b<0”:\†¦Î`i7§ĞÛtƒ—²Ö
+·¶ÇÂW_à2ĞF£ jHİy‰¡¿8všKûñæó—Ó£ÁyçŒÚn—WmŒ4aeä§“1qŒşêÈû½:ºê£¥>îuû§¿ç'&e4µŸ;ÊL~
+×}åö‚h¨0·ÄCkBî[49M=•-,mKÖ¹ÿS:÷y˜7ø4Š :±Š,e:ÀÜyIIßc:ÇU¹èç›%ì•·KM|dy»¤‰ÂtyAÊŸŠfËş{õZ x6–…îÅ]Po¾¦}22¢!øä ¥ÁŒ&ÒAè3ÁEËİÑ:Ü/³
+#GX<›\R8xÜ7¿c!GëœµÙ2y›œ ¥pYPD!¸—	^AÚ] ¬GªÂÉ‚ºÏü¾ì%&–e’ÁÚ™Áä§'¦F¢’dµhÌe¹JÖ_0)_f¢üğ_ZÄ*ëOìfÓ¸ÆM¦]“±EÙØGÿ‰lùÂ^Ìæ†ó¢§W´µŸ°±äAâ'›ğà€J9º¢Æ5n6I"ÿlA·œÌ5\\ÂÍ~*wÚô=(L…‰ª\JrÑq¯Ï$ı.p™¨¤tº£iohZîp…Èa{ÛéqrÙF`s°ĞùºòNÂ­g
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e5/c9e45b2f4a0222f652ca01f2b2cd565f2fff4d squashfs-tools-patched/.git/objects/e5/c9e45b2f4a0222f652ca01f2b2cd565f2fff4d
--- squashfs-tools/.git/objects/e5/c9e45b2f4a0222f652ca01f2b2cd565f2fff4d	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e5/c9e45b2f4a0222f652ca01f2b2cd565f2fff4d	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1,2 @@
+x+)JMU02¶`040031Qğ‰òuÔË`¨>rÄb½ã#iqKõšW˜Š|ËFRá’šœŸ’Z¤—\PÀPŸåeôüéE¾ëóW<{»&úî”ƒX”f0¼›ô5è}¤›OTa¸rõ¤«e;¾º{")tÍC˜yùtè•÷iW
+Wøèt¦ÌN]ŒEiƒO|ŒÈ“wwz×‹«z•Ü^óüˆWTapIŠcZĞ/Ïg¶]Zv/û•ğ¯em•\"›Â ĞaŞ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e7/52ef182e2a147d314b184625de22d0aebfb4c3 squashfs-tools-patched/.git/objects/e7/52ef182e2a147d314b184625de22d0aebfb4c3
--- squashfs-tools/.git/objects/e7/52ef182e2a147d314b184625de22d0aebfb4c3	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e7/52ef182e2a147d314b184625de22d0aebfb4c3	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1,2 @@
+xuÎ=Â0`çüŠƒ.ZL?TPT„"ˆ‚  “Kh›‹ÒDš¶C½ÑRÄéî^^.S&ƒiBæm¢”ÉƒP
+Ÿ5­¤Ñ j¿K&Q´ qD£,áp7%œÓF™Æ]ç:S2nŠTjğCB<)4GŒÍo,9O[¶'K¤Æ~è¨ÎUÍÖ¶âN!‘üK÷Ô°»c°²EV}ÆhÕ¡K»+¿¤³)ç%ZëP¿êŠÅókÿÖõÙO¥‡šKA^ŒeØ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e7/7ec59692c151e62c52fb565d85a9e204ed0e58 squashfs-tools-patched/.git/objects/e7/7ec59692c151e62c52fb565d85a9e204ed0e58
--- squashfs-tools/.git/objects/e7/7ec59692c151e62c52fb565d85a9e204ed0e58	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e7/7ec59692c151e62c52fb565d85a9e204ed0e58	2022-01-01 15:09:15.669172591 +0800
@@ -0,0 +1,18 @@
+xÅ[ûWÛH²¾¿š¿¢‡{Bl0C63{=l8áµ<6™	YÙ–±&²ä•d™Éÿ¾ßWÕ-É/’İÙ{nN¶Ô]]U]õÕ£;0î˜æö÷/¶şkcuÉ¬šƒxô˜wƒÌT»5³µÙÜ¬ógS~nÉÏm»aŒÌI<¾ø‰y5Òÿ›şcì¥ƒ~Úˆ“»Æøã>süõ HÍ(‰ïohğ±Ÿø¾Iã~öà%ş®yŒÇ¦ëE&ñ{Aš%Agœù&ÈŒõ6â„†q/è?òÙ8êaÁlà›ÌO†©‰ûòå/g7æ/~ä'^h.Æ0èš“ ëG©ÏéVçÃtà÷LçQf‘‡+Ëƒ9ŠAØË‚8Ú5~ ò‰¹÷“ßÍV$âÄT½Œ¬&&q`ü=šĞnl#9xZŞB¬	"Y~ Â $!ÔÔi:¾§~ÊzĞy{|ıúüæÚ´Î~6o[——­³ëŸw18ÄxëßûJ*Â ‚A™‰eĞ	™8=¼<x)­O¯¦GÇ×g‡WWæèüÒ´ÌEëòúøàæ¤ui.n./Î¯Æ\A+ŸëÔôAl'¾éù™„©ügìd
+îÂx÷>v´ë÷àÍ3]ØÖ7îVGw"&8)g×}ÅYİ<$$‹E‘ûH¶‹­¬›?ıÙ\ûPo.B¯ë›us5æÜímXöqšÅQİœ¶ÌæV³Ù\ono~_77W-'Î§Ïí‡Äü¤ÑiR¿Fq’‰Şıbª'¿œ¶¶jn8JüTfœà/o2¨Æ„A'ü<ô8ye£lüÑó¢€N²ñéóŞl,-ıwuÃqÏ7¯Ò¬ÄÁşÄ£4§Ÿõ@zòâ“bê²sÉ6¼r°\zQnâ¹%N8~)Íà]¿w3ÓéşÊï?˜=óÛRå7³üé‡—ËuC5´O®/Ûï~xY7›æK]Şâ?u§Æ\œ¿=¼¼8(¼—/¦·^¾(ğ’áÔ€Öåéäûl0vf]¿¾9ı±42yÉ4GWp‡?g7''V¬¿·oÎŞœ¿=K_vsµL!í. $ƒZš»Ng|Ùº/yl§Ágï7ó÷ı0†ÿ—FÀĞ€Y$‚AKK
+Ê&ıq$tˆ]/S0Ày€+Ø]7†d†İÎ‹íÒ]8ÄÔZ—[,<YI8£¿~ˆM:ò»AÛî¨§Mª¦ï÷v`±•õw°ı@	Ö)¾â¯Â_Îqâgã$JeÒşŞ¦©FØ#`&ÛëõÑNh¼äNeğ{5ÔMÇİ.üIhÒó	ùÊ€.E ¶ÄwQú½:°MnÍXFP	î˜f:Ñ˜A4ú ühª~ã®ç÷^ô¨2oèc{k‡¿æ,ÎüÅ¥\ÂÔÏRÌÀ¨á§ğ8¢CİpÙ^ì§D/ÒyiŠÕ»E(ÀÆ8ÉÜ>
+Ÿ€¸hu±ÑÔŸûÜGm»IÕšÉY*ÌDvÿÎÏJJ$Ã¤ãÉ†0ÃÀèu€”Äv",Éb,,ÜOÓÌrí²}ƒ·|wà%fyÿşCúà¦vkKÀ	~	v—*:$‚Jaß• _¬t‡£ªLÚÄ¬e1«åšÙƒÔ1E:æ•ÎòA¥?fœŒ\ Á¤OŸwŒL4Ã ÆÕ'o£åV­TîbHBõù=~ÿ‚Å+ä&K7?ğñ²¿Êçï7?˜ïöÌóÛÍçnÍ8©â˜‚Á‡†Ha‚µ5;B„Œ02…~T%LÚaÊ%¡À%ælXF1¦nQ¨Ô++ä”—`«¼˜ß·oŒpißÔŸ×\ÃMıĞïf ŠB••Š©Tf^±t½2’­­Ù§_ô%4k{S›ÿ1‘Y3M³c";¾“øŞGı,SåGÁ–ĞKXÇõZös³¬¬,Oíîôöb¹ÇüTğ	¿?„×ƒ“9F—CØ„é©¹v(Œb5A–ûíF™ÎM3ò¤uÚ`V³Xàş}ş±Ò[‚«±ŠgÎ@)Ì+8ìÄÈ—}ÓÜ´n´Ğmr~Œ?ŞŸkÚ&sÈM7á€ÅP¬Ê¹sv Jªp¼~EhSN¾µÒ"êaãtŸ~#UÍ×Lµ
+Ÿ¯‰X5ú&§|Å~
+vQ]<GòRÈÕO<e-D$¸¥ Â’øŠÅÎÜL'ŒÖ\ñß’XÄ*+ÃŠ[H$6Eií®~|Î-´_Ş<¯Q3V¹[/ÄÕœiÛ)ÃòüÓ§ç#Ì#3	‹0·P±‹˜Niù›§Tf¡¸ì¥ğ.ûu¸´¤¨½S<İÚ]~%9òú,Ë(åŒÔ#5“¤A=‰¢ÇKÈ%C0Ôõ"¡&XG¥ÊÜƒq™RLw‘dùŒ HÆˆíRË!Õõåÿ	Ádav£ø!2ˆ²6ƒÑL,†ÌIå˜IÔffB{Ó|qˆ”„s"H2¤K"ßú»\Ë¨·˜,a%T°<LLğ@ö™j e¶†Ìr©ÎdâiÓ8à@‘¡X¹¡1—‹U*ëMD€–älAÒĞ¦Âé%™%c@î[8Hü¦„T	ö±yª9hšÛÄŞ·Õ<ÒèQèPOŠDâÆ|¶±D‡+^¨¾áv¥GgÈ%‚|qvE¢Ùf¿,™æ/ßàL(‘˜À„™ ªK-—}Å§A‰%Q,æ”Lku¤fƒ¸¾@HD€šşJÆ%¥p X.g¡ï’ÁM¬,È1UÀ\’y)€V0-ÆpœŠG ~O$g…•úl¾Çæªmáèä­¿Gì}à©ÁÇµ­¿W£µ&ÕThflı~:m5ô
+$/š³¥€ÆjÓ¼zÅŒmeÅPÑ3šæ˜|Ğš_•\©†?O&²…
+á¨ÈÿÇQ^z9ı	èÔKyJ¬ºU3¹®gò­\eT‘ÕVIYèYB‡Ÿ<i§ä,‚A`Ê÷zöİ–MşÜş¾!ßìŒ-~Y¼2vf{ëMİ4_âÇoŒŸuùè96¡ÙT¾ÁZlrL¨ÑÑšê{RXÉ6O›Ğ^É›hî6æĞôg"ìàëmÅ¢ä–h‚ÒLHãÁyNå~K	¶`v?ğÑj³_Ti).ºsx3¢§Š"4|$…z¢#ÊOj„|9î‘Å >"‘öÛœ@Ó<¶"KEs¥)éhÄ³TÑÃ%HºÆà ‰¿­Óa9´H‘ÛöÏHÃY|ÌãÆ}Œr|uºäŒZu®ÊZ,;'{WäœÅ*:(îRè‡ºHœA€Æ`ƒO/fÖ(’”·n¦9ıS÷FKd+›†µA'HÛñ™XHÎ±^ªq¹…n¨P(ú^ÄD#·í|µè…h_ÀÓtŒMçd!ğ“sŒAå44<†Ç®JTÜ1W½i]½>ºjŸ^·~j]·ÚWÇ¿ê¬< ÎN+‚ŠmÚú›ßæ‡Y€Å$‚¨–t®‰†Ì–9¯uJ–ŠÜt&Öà­»ø;(kUÀ@jÙÖ|Û³h0õ†QŒvæ!¿ÉH®¦ã³«·­‹öÁùéEûüâúªº’ÏB¶TSdK ¥Ê¸òK'\1ãI”ñİBø¬KÜØ|”^í=j8IĞ$“îE ïcØühœ ×BıBƒÏ6ƒÄµçu­¬'V(–yºèŒJ?`3;€Drlp8sŒ¤°ßGvK3yËJºhc…Ìù¤,¥ìDHk¾ğh$éFn«™n	Ù'Œq@@À;9"B^^×ÅU8&v1[U=JKÉKlÀ_%¿…÷®ŒƒE î~İ‚äT€Í²#€Q´ÔøŠÅºêh»sÕ[şsåAuAHB¶?Ìs"f8ÿÀ™c$òA˜`Ç@úC ³jÁÉY©²œØ@êÀfêx‘A=bF‘4™ AµT\®Şr¨gCF‰0ˆ4Ä8y[O‚^Ï@†”æ‡&W‰À&YˆøŸ2[Ô³•jW®CdÚÓõˆ73§‹†ŸÎ–‹#ß–¢ŒPÃ^V‹ #™R4˜fá¹e±’"«¡Úÿ•ÜÅŸ”»' Õøh\°ßlı“z¡©Ç0ÛtîÆ	úä™AßòV#“cÎöZ _vZ.]MúSI4ÍŒx1DÓ©‚™ÄyOLU¹¾?‹Êå'Få¸,›!Nåw¤İdd× bGÇNèu±Íb˜	ÙÛş²Iq)#–1ÿå–Ÿj¹±¥=C¥|y*dŠÁa—Ñacú³¿oÔ3ˆ¼ZœLGQ9ÙÂº«h—8OÊç4—Ùü"sóì™:„|éàäØë1O²y$f*øô“x(e	ÛÁöxâ;-òÕØBbê.ŞËÜ1HG¡÷˜{ùÆ«Ó‘B]óÉ:º"¯<q ^8§ÿcnù^9á”O%,“Ş8%	2—üı<gt‰QiPî‹6‡şƒø(hõ•*Z›mN?oÈ5<œpJÍö\jù6ûi²ßdõ`™Z¯Û†¸„" µ–°”?à°ÒÒ\VÂı*–µ§`l9ò7·Ù‘œ]#"ØÃ¢7Ö‰ò,Å|<º‘ã‡ÏÒ#ÁY]|WâÀ‘¸ÍP¨+j”ú¶È·<åcåÄÎù/Ô“ãÿWXñ¥òÕfòLiD8Åù°´%¯+ğ	Úò±‰E‚X­‡öoJhØ|şæÄ…¼TÇV ‡šœÅ•~Ï‹·â8¶n~RÙıß+ú¥8ÒÓ§¶Û‘@bc¿¾1«ö÷"µ»UGGãf‘+èó­ÆR 
+ã“‹`d¿m"ä(Ú“ÁYç²³ödŞîb—¦#æäeM¢¥.æN'éâ,Aëû+¾²\zÃ•“Ó†È!üÌJ‹!…2+¡Xlk&7`ú-
+÷"£š¨ÍÉ‰2…3ëFñ	Í’½‰[9rQ‰ #;>9Ø¥é{fEÕµ¾Gó7?4
+Ê¥‹1Â†+ÏaYX¼¹[²)Tø%ÁU®µ5ÛTŸ9¯v½Qåó×Í ‹/l[Á›l…*.Ìh¥·!”KaŞcx¡ËòÈ-§ªbØ„ôö¶“Óëª¾P³s†o-Ô-XşÕfZ’©mXˆP|€V½Š–ª®!5/]:Eá^‚j•”ºïøjw‹‹Å<·©œK®l—9¼Ï!¡Å$Ğ$)>õü·÷ôsštë&¯£pUŒÓ‹UÔZ•\°€¬İ%ÜÔ‘?¼èÖÈ¥q1°o¨å àğ†C&Šª¼Î/HHO’&¬ZpP@'ÉÌOX¹jyr†Õ¶$Ğ–·šı]r1}‚;" ëäªÀ˜E6ùÁ”SvJ{'íâòğêğºıÓáQëæä…˜#à~O§&¹h°Hi¹ëhN€)È¡¨ÖÖ÷mY¨
+¶Ÿ*ur[•Ôö#^>³6æ”ˆ­­TäzàÁëÃƒ7íƒËƒm\%ÖûubpëûJKf­¨†Üúˆ¬ù¹(í„¡-áÆBİùxş]¾½¼a·Ú‘Â©Ü$mÍ˜Ü0ˆ§¯±Š«¨íRHE˜oÚ‡——ç—2s"Ìs!GC$f]y>ÎpFiÛ†½\px@“îRîÉ^íEUní7»ÈÙŒ6RçÉr8­ñ^í”"<uGUõ¹éõĞÁy{/aJg'c6¹oñ|v¢E[
+oä]?¹i…nê²Å
+Ü¡Î‚¥¸v÷µØswÕß9¥µ~ÁV`‡±O‚nGÚÑÂÎÔ^ÔĞø	J–/
+;%˜áÓ6F&]Lcqæäö!i–Aèå†¦Ã`ˆkÜ{¸s}zr|z|MeNAÔéá#üeÅ$BûWßX±œ`ÃÄKT®Ç
+TTÙ¾o`cóØâ³›ª‚Ñ@¬Bõ¹#iå*Éo0µn‚\Ëø2QVSÜª
+NÏ¤é·™±wóÔ¥šuı½Uo4öó™-æL¾ÍìÎ¢ÁÈ†ÀTN¤Ò™!ch•·ÑmvË»ùµS¶<qö¤k’q£s£K¾ˆ,¹+ÈÍµœ;­œY”«µîqçPoUj¢½cp_+1(â‡ÜW®/XÍŞœÆÖãÑ’7¤+ŠZ&†ëÙû«üãşâ)·Ù*˜ÒP’Ó[qw½bAÀ§ëÁ"µLUEó?tàè??”%mo‘¤zï™ÏlCRŞÚ<ZÖœk7p>	¯“Æ!¯~ÈÁ¸r;-ƒqgä¼ï5Ÿ¤ÛXĞÇd	U{êPpÄ–réJÃJ ¢7äüE×öÂ”×”.;[îò•şéóJÓ×œÑ+Õù4ş…c{9¯‡
+æš8¬×‹{vÚlÖãàZ°9!znÄS Kƒ%+>â?!Ô7Üp}ê¾ñMìú®øÎ·EzböKé¹Ü.Òyö¥<áˆòÅiQ~ÂS':hê¡Pšì)Zb“9N@RßÊG>“¢ãİ/r€ˆŒîêøüŒõ,ï5/ókqûUÿ÷Á?Óÿ9
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e7/924c8fca5b37f192d62d85d6d5812af497599a squashfs-tools-patched/.git/objects/e7/924c8fca5b37f192d62d85d6d5812af497599a
--- squashfs-tools/.git/objects/e7/924c8fca5b37f192d62d85d6d5812af497599a	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e7/924c8fca5b37f192d62d85d6d5812af497599a	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1 @@
+xKÊÉOR04²`Ğ×W.IqL«ĞËàâRÎLËKIMSˆqqt‹ˆ÷àRò3óR‘…€Êò’sJSR”ôôôóssóóô}+Ã3óRòË‹õ2”°*ğK-÷HÌKÉI-©àRNÍKÉLSà  Î)ø
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e7/f930a003d1987bb15e4beca30799460cca4951 squashfs-tools-patched/.git/objects/e7/f930a003d1987bb15e4beca30799460cca4951
--- squashfs-tools/.git/objects/e7/f930a003d1987bb15e4beca30799460cca4951	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e7/f930a003d1987bb15e4beca30799460cca4951	2022-01-01 15:10:16.089175076 +0800
@@ -0,0 +1,113 @@
+xí½m{Ç‘6z¾R¿bÌ\’!™¤ŞœMV²•¥%ÊæF"õTl/íH‚$V À@KŒ“ç·Ÿû¾«ª»g0 HÛIÎyÎñf)ÌLwuwuuu½uõÁp|Pıáß?øıÿuÿŞ­ê^õv4ıŸ‹Şô´êUöãxZ†ıéåtÖ?[«ª½ÓÁ´ÂÿzÕéàätxYÏÎ'ıé´TMú½£j<^RQ|ó||~9A¥YÕ9¼[=zğàÑ
+ÿ>ÖßÏõ÷÷úûoúûıı£şş;ÿ>| ¿WªşPÕ~ÎwoNÃáà¼z5¾89íOª/ÎíÅÄPÖÆ““µ‹wÏ¼CËùd|2éqLÇ“~¿šgï{“şÓêr|QöFÖÑ`:›.fıj0«z££ûã	</ùîbt„g§ıjÖŸœM«ñ±¾Şz[}İõ'½aõæâ`88¬^û£iŸÕ{Óêœ/§§@ŞÁ¥j¼dv½ÕË1 ÷fƒñèiÕ ü¤ú©?™â¹z$4Œ'U§7cW'Õøœï¢—Õ°‡~DÙµãÍÃ:ª#5:>ÇNƒztVıêbÚ?¾ª=à úvsï›í·{ÕúÖ÷Õ·ë;;ë[{ß?EáÙé_û?õÔàì|8ÀÀ€ÌIo4»N8è×;Ï¿A•õ¯6_mî}_a/7÷¶6vw«—Û;Õzõf}goóùÛWë;Õ›·;o¶w7@v»À
+†O ‹qZØÙxÒ¯ú³Ş`8™œ¢wÃ£ê´÷S3zØü„¾õ@¾çì™¿²fk8h˜(jqÂyZ«Ñx¶R½Ÿ@ ³±`Õæ‘ÕóT®T¿ÿ÷j¯ôô«7ÃŞa¿Z­v/X÷ñcøWãél<Z©^¯W=|øpõáãXow×c8¾H§k‡ }ÿÖ­ßF‡Ã‹£~µ\|;].ŞÇèNß÷Î×Ú?q)÷fõ±¼Ç“úû½Ù¬ñ*7İŒÇõòÓÙQ‹çN}®rÿo¥Ÿ5>Ì.ÏûÓµÓæk”?ëNÆ-Ÿfƒ³ş|0'¬ÃÆ—áàl0kÀ8d“pËıâp†Õˆ}ïxÒ;9ëf]=¯T÷°${öğ4ŠşÏEÿEgã.¹`‚Rø‘q%Úƒèƒ'ã³®==½u>;eîô¬ÚxÒµ7¹ĞXĞ‡îl)õH/ŞºuÿWiğ€)HKøp<šMÆÃê¼ş3ìƒÑˆ•bîßŒf$áC°îñdZ}Y­>|Š×Õóÿüæ‰¨s<éM`ğÓşL}Ô?î]‹J€  ø‡üƒ] KŸe9ÖÊÁÅ	!ê?”±ŞĞä9úy<ø@KÑ'jûGk·æz„z§¨Õ=ßUÓ¯†ï€wíSÇÓ.ái\ÓŠÓ<ŠÍÑ`6èÕªÜzûêU€ËT]İãoŸŸsÕõ#ìd`µ“•QCÔ×İYï +8âçêAõ÷£h‹8Z}¨Q\ÎúD9V»¾ù+Ú1»†S}:LÊÇéåYñxké¨ÿSñŒÚÇãüüôÖáioBJõ½§6F ÷gãÉeíC"åSìÿö¥‹™™\Ö tùuÿß~ÿûÇÿöã<¨òëSõøèé-0†ÁÉì–3|ïb b'êPı$=4Ji¥uIçÀÓîÿz»¾ûÍËİîæÖ_Ö_m¾è¾ÜYÿ:†˜ÖWez	™¥[¾°ßµˆšºSG£qû0ŸØ†SÊ4èÆËõW»+Åñ8?aÏO±ÍLfİ!gwoçí†AÀÒ[8éˆrÑÍ{‡X+ ~0
+Ì“ŒÇ³®¯L{s8^œ@ØÄßd<C z0Ï¦ ×u)øz:¡tæİY±]/0µœƒ£Ü£nfhehëÍ	ÕŞHªcã+ gQÇU¤ÄÃ_¯ş‘½1j]œ€|Ya}óíhÜÕnÂ‚ß­ïíít_l¼´Oäiù£ğo°4ÆS`L†ãñ»‹ó.Ù÷ş€òó­¥+·–@//_lîø¯¯ı×«­?û¯¯^Å¯çßD¹Í—Ûşuwûy|şµ`n/ÁÚ—$ö£³?Wìêë½ı«f‰áO§ŸVG_êŸÙ{}¶}åˆôõ í+‡¡¯Gm_‰}=lûJ¼èëyñuçí.ê ÷ö\ìÓIñùÛøl?áóûâóÎ×;o¬¶~@¨×Ïßê”ƒzíí½o¬¶~@Fª×Ïßê‰ZíïĞµêoìúîÛÍ‚Ó|Õ¢6Íï©.îãj)ÈW+~(b`Ş‰¯£WP†êh|g'T—k˜/ø^­T,XëğãøËŞw†‰Æ+è_ŸÎÊ~7¾³ªË‚{WüNÓÁ‚© uÿßßµP~2§:èM:’½õ|e‚mi¥Ê¯ÎzÈ•)ğˆQŞÅZûÄ•Á¨)ú»î«Í­êá¿=şãç·n9èşy·ÿa0ëÜ½õó­¿ßò×Ø¥ŞC>Å.6:ö'úºä² ¾p«€ ÑÄÒà¸3Î†ıŞæöó¯¿İÜÚı¯•ê—¹[}Éı.ù‘
+Cşš]vv÷^@}ê¾Ü|µ±µ}÷.¾-mììlït–3J€«ch1ı£è3’½(TAŠøãƒj™µ––}À?Œ–1æ¥%ü#v‡¥¿Wı!4Íò½÷líı²Âğimì½áä¬>ô´×tü×gFs»úÜ*å½££.E ãáø}G/l*ˆÙ¥Iv1UÍ­½.fŠNïnõEuëOOÇ³VúÒ
+åÙ3hs¨FPØñ1•¶3ˆ§ƒóáe+8ÿ8èOZaŞ¯Š	n°l—îõ¶<‡Jz0'‘²æàB÷ø°ÃRããNYæ.)”a5@%”>I	ßmîußn™ÀÓYŞ†Båô¬­v†Q•{`s.(µ9`s+œ¦¿ıM42‘1fÂ§uMkâŞ]‘b£»(’Ã 09õ£­êÓê3JXs£vĞĞ…‡ŠDR±Gµ_ƒo_ÃúRcb3hÄ?P¡„ïR¼øÌ%Ú—)VšÙ;^N¯VlfŠ’Pª(®¢ 4ùÙåu
+Âˆ2LåÒâPsÅJÔs÷übV#™êŞ¯T†Q"[¤G:õ?ÌÎIQõÑPYJÔhDvïaëw:ª,®>s´ø
+w§âbş,T’N£%aã}¯À†2p“›uìø¾ÿ¶&)°™t–fÈVoºDo˜&ì“¤¢K6•£Öá'^oèìô[Ñ,ÔfLÏAo…}kÉP[âŠ;@m´W#ÏIi{¾¸Z¨)ù=¬7›æÕ¨~Z‹1ihå4^«‰–m’.ÎÎ»êW-ÉõY[€×ó	Èü¸³üº÷ÁÖ÷mì‰Zï·nOÁ	WÉz¹JŞVJk(ù¢1ÕŸ¢’ÓÛj<Ê}:[ƒ÷Y·êÓ£´ÕoÎ<Ú[®:¯ßì}w¹ôÎÍ_õ'v€^rÇ œj™{ÿÈ¦¢ç4Á2“­L;fçÒÂ©Nû°’ÂB$ê‡¬Ó‡:›-1nsƒ˜ïmz
+›L‰EÖùóõW´ìîmt¿BßQ™ÕgÒ·5¡ö¸øQE@WŸå.ìó'	~ÁÔ”(ÁÑ<…OfæáşS~d[\™ÍwŞ®×u°$ï› q‚İû§ş¯Eb½ÃìQ³Ã|çvÜ5‡C”¸DHËf«WMX4©®Ü/ÇcZ’o	»Dw}@6{7 §bºwº0‚&/‚¸ ?)l¾-D|ÜqzK`L®÷ëmdSA =Æ§w>¾&¼Õgé+k\ñÙK–³ü‘Å¢0­@:I³‰¢T[‡[†ªWhzÛ/[	I¿ˆ³¤E‘0Ç—Tñ×Ø@WYÌÄ†Ó†-«V$r½%WY0$®øv‚OÔZĞ°«;wZ›ĞG#´"Û¡FVÉmV[fÂ9U1]€&ïŒû#Àí[ëˆj­|A]1ÍÅ+’OYÃx‰Æ\RY5€ù;û%wš£áFË-âIë¿Àrn{“ÔÊÕêK8+fÇÇ0r×6m‚®½œjKj©®µ*l`RØô4Æ!6ô¥9…MÔ³PØcE—Ôtê âEŠa Hñ”‹$wA~›)­ºÔn*
+Oû4Jøuböòæ*Cñ–5Vï½»Ğädü§lèà)şÃRUäVğÆ§óşHî üµ.ô™2åÀ$„$%)	õ…ÖUk>2¶|£
+ŞŸT'I¯‚lšXI ±ès©1èEÚ?²=JòŒQ)ŠCxÅ×p¦õ*¨è-wÏ³ ÁÍ½ihû>˜>‡âêV‰[aÀ3Ï Œ£#Ì3U&†Ñ0Ä‚>iºÒ'÷?âÉ¼rˆq`ä¡°íIããã
+ ïTş¨1D(ÚÃ[®N&ã÷S„9Ğ‹'Ò¥¨>õM	›(¤òñŞ±»ñ!LuÓ
+f¶éŒ¡‘ÃŞ„Öğ#‘ù–Á‰"ôĞHÄz	–L—
+òj)DJl›.Qì¼dl*†Ğ¹ú,«§À‹qz´âóªp‘Ó8"1äs>W(äyÃ°IÄvd½$;< šàºÄ|[‰]Cåœ3ÜC³h•³/ ÊM¡ğM]Œ„01q“TB?³ iqv&N”Á Ü¿-†!F²fıà6=\}füÅ:«^¯?ûÈç)	7ñã++†(Îäƒ´¿ë| TöÆÜ¸Sƒ”4Hß»óÊà[´A$&ô¯À^†!ıe£ş{›òzKÆD¿ˆy/8³9&|ña<B¦­Œ»rŸ¸îNƒDXscCvİß÷>»\L˜•Ï¢Î¯hZÅŠĞT…à€å+\vI€aØ¨¥h–È5i>]½Qm¢XûÎùrëŠ?ÑZB²$µXnJæˆ„úvbf+‡gåc;asKKwü[p	¼"Û¼V\]×\±\2i[/hHØEozäQãäú¦Ôàçûâò*®¡ªjÅ2×ŠƒmêÚş¤¶]ßƒ‹#NÌ…"—!­¢M:ùpïp†0)ğ0" ©:\ocü™8_ñU~>¢	³fÉ¹´³ô~‚+CÒ2‡í
+š'a™NÇˆ4³ú“ş*¡İµqpêÂœ£ZÛD¶¿—uÆ,¿Å[ZNæTñh<Ë! K(A*ó†a¥diNj†”şÄ„ÉNDöÃMÖ·ŞôÈÉ££âl	¨íü4è‘IÛØóìÕ¦wáü‰MYÌÜ¦,sêë1Q³MÉ¬\Ä(	ä©ÃY£w’‚–Ì¤Z,€‚›.kªZHGªfBĞ\J=g½É;ßlTŒ‘}
+Ù°Ï©GˆCê£7ö&—w1TPUÆ£Aíp¡¿C¨á9#èVDc¤NÃ¤Ÿùs¤@Lw6®‰c¬Œ\>‰vAE£8dp¢OqÀÙ@ôëqı0Lf´ »¶fMlëcr‡†¿úÌi'1éĞC‚@ƒpõ/I”†ñ Oì¥˜WTFÄÙ	Çùâ¬E†xÖC¿­¦@p$Š¡Ó@£ÿYğî–ÍØÎXNù½\e	ñ“qïè°+Ì–Ú`]HeÔ²º!$Ôë"©ÊpYÒ,»µ˜dK:eIQŒXÁpakÙ&ŞæÁ§ ½ §Y¡2ÓmIOó$ËÂ7"’p/Ôiåó<-YølêXÔü3@~¾Ô˜¥À´8F@üÅSSx¹lÆÔ¡êş)g¾|“v›5hµ˜¤v0V¹?¥É˜(%Óê¯ıÉò°­_n7 ~S1Ä6 ıÀRñ4ÉP€Ö£ˆ˜«şY;‚è’1ûç¬Û´DioÁ„yH4Ò~z’@‡ı¶QBsõÇ`X}`\qåè‡õêpd@Ñv´º
+–—¯í„I‚Ÿ3‡–TPîpå{×¹ØèJş#´]“ùØfGz“
+JE°à>¶2Šhªá¢CC)–'fš¾–¬'1ákò"î‰¿ˆÂåöRŸklÇ-"ë:Ü:iéö
+A¯ç0Ä†ÓäÃ/•yÃ€^GY¡Ë@V3£¿Gz"qp¡ûÇ,Wÿ©ª–_ÒªãMË×´56;c¼®!)zÀe#k¶˜Tœš@Ü¤cOøå6:¼n¨ïŸÏ%m¬TË«é?ówaÕt˜êO=–nğãÚYvŒOônğÙgF%X¶Xİ©—“[Û¢ğPÂÂZ¿C£ûéõùx
+è£N/	­.2¡0¢ö¶÷àéúf}g·ªı^Á)šÌ.ã'G½³¾áö§|LŞEHzÀ­!$±O"Ş”uv¹ÿğQü|ÄßO«û03{N5í©pg1ôbz¡Å÷`Á¹8WOeQ9Ç.ŒaD•†õä¼7¾‡ïUò[UóÚùíìáêœ# 7B^ßA´î—jQy8c3¸¸ØyşÀˆ©fÁhG,ÈVÀ5Yéw¤Ä³¢Ötä-	'ˆxApáòí#¸‚ë`‡5¾€ƒóÛ0Øµ¢âÒ˜©»¡‡C€ĞA±x$xÀ}-rÖÎ™Ğr‡pø	¸>–f¶Ú?|ˆƒ> eO°`È<·A&ÈsCƒÙñûÓ|
+“cêµ°cqßxøÀ\BfXX¾·T…W¯ø ¬Ïæ„€:üµúìü}—”ÇÚp•Û,k.N&'y.ğÓçÂK\g20s³á€şOœXXóÓQ|Ñ|<*'¤ø¨Ÿ«ÏN&>%`©ñp{
+–~A×Á7µœÈùîîŠ¦T¯(&ëÂÒái,+g‚ÕD¤±­Uˆá8l†ˆf@BzFœpí™!Éµ®=#(™ÏKÁU€‹‚®Ò¹
+Æ§Ÿw«U&ãáÛZ§#Æ~oˆP<}†ÊO5*8¾ÄgÂĞZŒ±Íµ#Nú7è0ÿğ´ªË^Oo?>ZÁÿ¬ëY¶ş3šğnğ-™ïâˆ€åù÷w4Şë%;e´$‰mıÎG
+D	­G«·<²?=á0=[}6;ë^öqtCÿş Q¹öê
+Ş°»şâ¨‡˜7û“uØ`üı G×J¦Ïı· VlÃA0ó'H‡Œ4ºW­>³¾x%{Fï8Ü(9™,°¡À0çª£!%¹†ğ•íla«Èoö±“fÇÍtÖ›Ì0F2]±é$Èº6çPyö„Ìóbî|Kö†Ër®ÔÏc³\N6ß'(°ØØİæÜ‘	9ál[}¦A”ô/Æ6_"/éßÖnÎUSĞNóÊ¯G”9~®ã×Ìæ?d){6{]H8Œš…€,ü×|[«j8X}FŞ%gÁjVH“ä³$AÄ…«ù²>Miµğ _`˜Œ.Ñ©ÙMu5"¯¾7ñ\%"ü”â¿0ï!N.Ò‡?Êb€ÉMÃ$ø½õçeµ%0OPÀ¼rQ…”]=øp{8D,¿
+A¡‘Úù^Š“#ˆÍè¿ë°¯hG66şÜİİÀ¶¦÷TÿŠEC¼ƒ§ùÇõ$nK2©uğw46÷ã1,pä¬œo3)H·°Ÿc§$÷ÔŸ}ÉQÛ¾J	‘½#u‘Ø÷t½Ë·jdY&ò£ñc	§[œØL:NóéúæÈìdÀÒòÆöËà“ÔbØDƒî„&5r*MÒß±şƒØ„7—Nv:6®¥`˜b¬]+Äµ£ßŒV52•ù¿…FkD{kÇMÑÎqÔÑ4\öpiÉ¢zKœ„w©1Õ¡–‚“1h‹§_¿Äaû éHv%.f`P¢ïA>I?Ÿäƒ‹¯7öÖ_¬ï­ww7ÿku±L 8áT¨!¤–¼IÙ>.´}Çz%ê]jÁŸŒ¡!Ø	âÏÊ +ÿEÇ ªN¼¸ƒ†u[}ñ> ŠAPà¯j¿±ÊiÑxâŞªÿˆe}›R†­­l šOç;Ÿo¿~³ƒT /„(ï8Ü–ñQ±8	3#;ÅÅ¨xL#ùfãùŸ»œ¯M×h·šê DšóÇd]
+›ë§nF'€Í„ÿ–bµÑ®Ûï÷èb ®Ì–cº£Ó`¢Ô‘&•èdY¦¥¿—ÕéĞ¼¸èù/ƒcUKäUà°í•04L’òµ‡å(úÌƒwuGŠÍò³oµ†+†Ÿ€¼¯…šÁ¿Ø´Ğèd¬VÉÁö¹ºHğÑ3xò¸Á¢ÏÎø¸©T]²b9©·¢Š‚ÕÚ¶a§Õíoœ†î´EÇ“ª"ú&[´Àùt	ı–8&tâ-İ¿ïÌ´;lZökÁ `•²MÎê‰Ú°óË }ÄÆB'£T“²ˆÜßDÏõĞM‚¶ƒ'’?ƒU™h²´$>‹ÙĞ:NSËÎ+$:‡8ÈŠ]'0ÌƒêIÒŒ$8}ÁgudŒZÈTëARAtŸé8½f8fpaìgè;\‡øïgıå/Ÿ˜É¡Š¹“óøB†”À'K'9z• ñû'Õ>x`Ş>úQœ°a(÷Æ„Ì¼tØ¦È­ı=*`Q³†ŞéÏ½>	ú KçÛ:ëÌÜ’m9HPj[$±fÚâÄ¤ï#i££€ÆQam(G@ŞùEt§íMñ…ó‰Vö'¾ÖıêÌ:ß¥5UŠ{¹C×ß‚3´ñÑ¢)§>Ğ?²HR¼Ro@¯ôñ-8zÄÑ\µ	ß„?V;i<fõÿõJ˜ĞBå—ë*Y'm$Iaşª@ğ­
+h¡u}•$hR(†š©’|"VàZG’MşGÖl–Õb~áem
+°IUcğMÁ!›ÅOc5…© ıÄ9-”$ˆ‡ VñWfz'¢·ƒhÆ—¿`ÉDãjvÕ5¬/²HSP­4V?v¨”#lIçY‹·~ë³/¹e)®‹"w¢^²XhKÚÆœµBü±¨g§œç6DªÒ–’y£lM'o’8ÕÈRT%HYsnyÇÿÅ¤ÀŞõ5&ÌÇZZÉÖ‹ZíÌóFªšc:¢©”ÆRdXä*Å®ÈıŠ;Õ±8!<ë‘Ğ}ßğğ+õÁW€ƒ¶^¸¨]Ğ„™xcmÒè!¥x(ÙÖ˜V€÷Œ¦cƒ
+tl~,™·±ÂàŠJAÖlhİ€p4&„w# ÉyŒài¶"flU{ÇLdÆàÉa '£nlÊ\Øû9xjSôÂ	jà/ãû¾Ÿµ·9Áp!,ŸÌNAŠÃF}á2D—-­m›o–jé0Í¾³›î›¹}²%A/fFĞV»LÌ¥\uÓ9'#·sºà0`ş]©à™ÁOfâhc1øS“”¢Ë\>lNõwè*C¦rµŸšş2;ÂX˜'Í²ºtÂR¼R	¾˜æ–@úÅÇ;|†qk­aİ©¸\iÔÜYæ’Û×‚³Å"7Şf¸¨‹Yâ/ÜºŠì<‰©"rTt×ğŠ¿µ‡Ô·¸ËÇFˆ^AE¦`fàøQ-·"ÚòÚF4åÒ¢™YÂ'h.¡/«ÿıà„Ö×‰Yåªp«Àİ»\g‡§¨VVEºğ_ˆn4E>^uã7š¢Ú
+ÙØ(NË4Ù\ö…öYØ7ÓîfáŒùÍH±¿Ìş§Vob ,¨›&$ñÑx‘eî[%U@©eô‚¡C¥‡)Ğ]ñ­äôA£0ø7ß[Œrx(•¶‹`>Æ`¦ˆZC*ã­”|,\Ö|ŸêŸ6èr—†®<Ì›—Õ“,8™.L_Ìnjq"°$$Û3p¦€6şL+sªâ$Ûz‡C°4DM)‡ÍLËÑ9´âöåçowŒëT …‹i…" K—29ô/‘+BÛ4XMN.-Õûâ‰Â\„Á:Şë¹Ë*Z†’KŸ<1Ğ)¾A¥•Ô¦UÚV1 s^hò™s³TrSAqf´´¬ˆº,o$QÆ•¥öuœ¬hš4
+’ìôÑAbOAAlYÀ½DsKŒ4¤Áh;¸_¼³’Îe‡ÀJèu24`Bı¡B+ˆˆÇúYı²¬æ2ÃR	}PÁgE‹ĞC‹şÈ©è‘èÅ|8Jé-èDôŠlJ––Œh~²¬p¬´|eânìH­ĞÍªfòylB¨šÄj8ğC¨ï}\óõ€5¸|¥k‰æ€“7{ßìl¬¿è¾~»·ñ’ômîm"MßmìäuŠ¿ójÊrQT{¾½õ¢^‹¨îËD0àÛ³³äˆ³Ú~³±¥DJÈ.´óõæBd"XÕu´ÀTÏ<Vì¸Ñ·To+>Ø^–yJ1Ì°U°’	Ù¢4À–´R,‚”Ûù¤ß«QqÅ;*—BlíÄKÕÑ[ï2•Ò@Ô.‚yU,2ˆ4  šê×Cwëµ¸Rø¡Øó‹±‚%’>,êzˆœ|İ÷ˆË÷mV?ä[ìƒ.Üırtƒ°£D5$D•JYa®9Ğ4İP˜^û$Çòui×4¬{úGƒõ÷);©±}ı]àæ¯¿UÈlºá×Ï½|‰\Çj`84V¯Æ8ò­%ÂÁ	%æOppÉg·B¨ÿ–‹)}—Tö%¶F(8)‰¿éS ô/xH(¹¦xH$ˆ§/|JŸB
+GE ïèâ<Ñw[ëkÚ¼MşŒ2ê“€³¯$”+Æ&µçWJGî±ñÑĞËàtœ•…\Â”Än…KuPœğI¹Vÿét†¯OüË>ã¨Ş:ßzO=1¡Ï¦[ïË×>ÙçÆss¢ê×òxÛ9”ˆüqx4mˆ™Anš•š6ËšÚš`íË=ÛàıŒÛRYMKjH"Y€5cE*¬GÊ«n+Ï]ghÄÉ\jÂ½Y43_üAŒ¶>ĞiôC|O»Sq¥Úî>ÇÆ¼'ğv÷Ûí­WßWÌ
+×$„cÚÂ[Ø¶#‹Ğ8Y“&çÍˆà4şÃşÀIÆQÔ¢ä•#Èr°¥·ÕP~+<OÆìÂm-0s‘«!A9‡ÁXËêÙk9˜9ö*JLVi§×²Ì’Ìä–¨¹ˆKÙ«s‹xÏo¦šIw	Ó¦öéù%LÚÇÄk˜®¾¶Y_"ì"!÷ïà@ÄL“Oc'+çà“Í•GÂÔ!8Ø& y”iŒ»¤ƒÓ xÓÓ>³ˆÛ‰ÅIÛ>úÃp‡sQ£1DYñõ7`1&É¶W÷D×Tü„#ãÍOÑ¼Ä—Iè®ÑQ”ŸÇä'K_#jÀıQÿûƒI¿a¡+¦¬²…	É	Çx.Hê ¬ A­)P­ùJÚ!ÄP–iõYŠ7¾í/c[fCŞ‹#,WG‹XÍÊúâj3>J÷°a ‡=Ik5”Ußm<¦—zã¦; )qŠ[ï?ÚR³„f[)1Ø§Èo¦s–·
+Ñ¸&³€ Ë
+¶íä¹‘Bc”ÒØsÕ«QÅXy·Ïd#nğÜÿçÍ{Á-bÉ•ãbb„(ñ/&Rx[Œú€RG¿˜`Y3š#Ñ‰D×”¨Xäã³##µ iºÙr«-Î¶dÄÿ[$9é#ömíÑ¾E–õ$ÃgòÅ–‡fE(VÚóªïVŸ	d×S#AàF9­Àá?ƒ½‹¥Ê;¦4/ª¤£w‰©EÒ¦Ş~¼İ":ºÜFÃ8\æÜNÊ®±!œuÑúZ[ßU6¾º6ï˜Úäh}ÅqÄ€#‘ºáÇNDú}¦,îî}ÿfƒœ¦şé¤O!ÖÔSlÄÖDræÎŒñØnòé$Ø)<K m•âk™ÑvR5GR\Ë÷%{¥Ùïİï_#=ôŸS×£j~n™Ç¨ÃÜbÁêÆ“Ã9«‰Â È"ZH.™  k¶PË8¸*§&¥×¨çšäãP’oŞèV–¹„t&dŠpš£Õ¥ƒnK~'/ 0¢y÷‰^›T…F¡y‡~YX° Æxuâ*VŠ9QÜø½´L%…´åMi¸QR!_>\|ûè¹A˜H×qÔ	ùiê4„“&/6şV5¾â\Jş:W÷ÕÕ•qÄ0×6S¶Œ]§H³Äd—À"—2)%K¹
+{;A£:–b±›`„š‹:	/˜Ì‚²6)á>àÒthş“Î„`\ĞIx:„÷h--Á®„.á8‰g¶ W‹jBñÍc]ƒr<Ğà£´É‚
+²€dınìZ ½ ©ßËtc cJ¢Tm…î†¹®<è)OCr0yEI}Õ]¹ FHÅLóÁ5bØÁ[¸^RãÖ->¤¦Ç=$\‚øƒ©sE$Ô·Öe«#Î`1ÔÀ–ğØYnÁî!ûÚË;—us~""jG—aÙq–xõ:¡†vïúÚz‰sh±²Ÿ^Õ¾µ“9ïÌ±=¸&Sn.©ÔîÆh[+B>e´Æ>ˆºa=M¼áªIù$ñ\›vÈ!H6‚ß‹I§¸^¨ÎïšSÂ£‚{‹&¥ñµ}Z¦ğËi°ZñheHH
+f	d5Ç¯O~äĞŞƒ22•ª—D$”Ør[±Ø'nÂE#-¦†TÅ]Áê^%u‚)cFÎ’²
+°‚•w5]7ºÌ‚USæb}{tYü?;Â¬Ñ<°ƒAË_Ùør£H³F]nrw~$Ú,qı6Ä‡*PøĞú4„†7¿rğY£¿6 ­îAhš¥C—ƒ4ÛMZòÚÈ$ç!ıêH´Ô‘ÿ?~QÓ­Bi#·'Íˆ>#ÎåZ`šÍM[Dš—Vm»Iü«…ùAiss/É¾¦$6ÒÒ”—$S¬³DĞâ>’Í’E­°Îã§ü#a™¿gJ«muOvi_i\$gŒFHÚ=é®æxí ¤‡ÁEdfíĞü1)è.Vm½Ï·p¨Ç/Àˆ¢ät¿åÇ5O›PvíÊòÅ€£{É³¸…dšÑh®Îáj½·è4ù(œ´i:ä—EÅæ|Èê"sNê!'7Şà7gÖ‚v»¨<;‡QynqØ÷ğ:Í*‰2µZÂ{hqÊ÷¬ùô§÷?å¤ø†J	ö=©×BÌ'j1Ä'àğ3h4é»O/vá·aGà£úŒãüzÆ›­,è›SOtˆ’‰¬.¥‘@nH&Õ=ş²,ÔÔÕl
+Sä²¡õ[%ìPÍø},£ÓÔ¾À˜»æ °	åöŠÊ¹fó×øªyáGÈ¾OÈ ~â|
+¿4ùm%X¹´êó+¤vî$‚Ù	Tsrû'Ÿ ,ÊpOìEA^|Ah](F\<£µˆi·÷ESO˜F™N“–aXFT3dš{O|Óa³ªıÖiŞ^Ãb­ŠxŸuÙCw[Q2Ëy¶v
+y ñÜp5d]B25Wµ`:*èÉ		ÍÊÃP¼Ã+7ñk‚>F„ ˆ^aÚÏÌG_P"Ñm«H$Åa[œŠk&˜	XïùºhßOKGÖÌ4æêIˆm£YK{SÖ‡«ƒÁş"Ù±(È—à¹GÎcÜ¶†:ÎciêX±ù¹“
+APBıj}à2ÔpŒ…ñ'×E£„óŒ_ĞšíÚP_‡ÍX—¨P'&¼ãÁ6 i­”=Ÿ7q’hŠ¬¿­…L
+¦ZÒ8¼ñİŞÆÖ‹ãÃÖöîÛ¯°R }D¤å­•í?|ğèóÉ­X;÷IR…ÇĞh)O}à!YcÍ‰Œ,M¨Ğ&mG<?œã×«tòXêH;ìÇÍ0hÎRŒ^ÄYÏÍ5šKS± ÆFöÈC»—û /·9#wà±Æ(ZJ›.Qaî»æø¹Ï¤Vr(-7Â„b‰íÈòk,ğ÷‚!"Î7sOQ…DbI5ˆ¾C.{hb¢8©ë<e„×iKrßú:×N(CPûèjš]²ÔM/V!¾˜îŒlL~|ÖïxÖ¤8sœr€ÀF8›òêşjêhl §8àé°9#»¥·†ºİªÊz…ëİÏ½n ¾é¸VÒ0E6w1qÈğİœXôv0y”€CùÉ¦È”08Æ`6{Ôgn^fëeL ,{^É1À“/†N¿}É\C ™[‚Í¶É4Òë“l¢Í6ºYD« 5èTË],iæöá®¼)ã‰páp@ÙYbÇ|naMÖÜ,%ùUÙÌ‘?¶Õ­ÛF¿ Pst»mò>¼_4¢ÇGĞì–K¨båÀí½Æ‹N;Z­ÕÛÕ›õ½ov»ë¯pXg‚M ª$QÛÍ3/ü »w«ÏHGõ>›kaá.öˆÛ,¹¹DGo¼—n¿”|¼üg¿ûgŸ17$ß ½yâÉÊÀÕØZçDdJ¯b’_8M¦RqÔsSlâŒş{›3*+Õˆüt-š(-öŒiá½@A€±gª/<‚Tœ£¬¾ˆ4ğæ³ÏlgoÀÈÉqIR˜)¡D‹:4¯I´·óúJiè¬ëz<‰ú‡¢¡B]Â¶S:®ÎSKBÎ¶0„ÆPr…ïéx$ØªKê\2(/·^wIú[ë¯7ş¦‡Ííú	yçõúŞóoRU$~÷Ök(¬sÑ=<é8©Œ•ªbŒÛ“Õû²g‚@Ú®˜úü’Û]ìvÛ™Xéı`8¬È°>8Ìk^@Àü˜ªHfd¡f‚ü‡šOB˜"	öL¸ü›Øº P©.>isNCº»¸Ï£ñhULÙï#:f/£éúYÆÕºÂS‹Ëá^dDB›¶vÎL­ËN¶Ëã“ØÓp…ÕaÁ»‰·R§ÑJÑ´ [8%”R†a³¼^7¸¤Ó°™1iiêéè" èX~½Ú4Q¨iò0ï¾kjÁcâ<y»Xe`Ÿº…ş(İ &YÔa¬:è½¦ÄËŞ…(NuQ0Ï¾Q¼%$ª€ŸÅ»d9°Ô\ÿS‚Yyí&’´Õ†›:jj½^ÌA®KI±F¼=\y6–CY~ÜÒX?æê†ÆtÄ•ËÖ¦»0æÔÌ–n•Ë¬ÙààÍÀq~1Où´ì£à‘3–,wõ¥ğQër˜CïÄ”A¾ vìÄğÃ%k´.ì²(;†q6@tÜIÀe^­1ô¢ãs8ğCêåæYÂø3òÄ”|Æ A¨³’º»è'ôğg€s¾[”Â`kæšc£ÇOœªMŒ®‡ëYl
+çfj÷š8Êë?Ä\O0y'ÀŒÂÌ¾ª¤İE!_¨n:ØŞd„" $‹“‘Õ1SÉJü«ò ª«/¥èC+
+8<b=Rs˜ÒĞÖZ
+ëŠ;Ã—æ:”Â»BK‡-Ç©’Ôãá|-}Rw4#×qÖÔ9x–g¿zkŸ]L
+ºğå,ª?ş›g½¡Ñï”Ñ¦)jDÒ%kX°¢Ü£Ä±HÄ“x ãøÄ P‹PX$»ñJ¬	Ñ| ;®±ñ˜‘$Ûí°dZÉê Æó
+bùÿ8óéºã>P2çËÄ×öÅQŞÎÏ±/c™É4S¬‘d0C	¶X¸€h		'mqgŞ˜ëNÌ 'l/ @¡Œ[b3V¯.¼F ×yx?Œ‡ 0U?ÒY¼ÿP3ß7î‘Ã$Àzˆd_$ˆa¦äSÈ7¹‘/§³şd	©å0àğB†Üœö~òk„w¿Ù÷Hv¥m>şú¸ŠèD˜cc@!m7‚GËÏ×Oœ—cåŸ½Ãğêüa0;owwş†¿õ¿Ã¿B6ğ›Ù¤ñ!“lÑÜ.&ª@K
+¸8&vÄFâ¶äÉÖHz‡”¸ÔGD™=FÕ°ßİ=ôÔ;¬bñ>'åü<½Š'»‚®qVôtµ0J'³f¶¯ÃÉ:©Eñö.p“!®6V<k$’„ÏÄrJ'$íÙmv'˜¢¤«’™*“ÜtlH Iá`”·Ø©ÊÕ¸
+ÍÙœúŞIò(}·pBØª˜Rø
+<¶ô;ğH±=÷{>ÕY[|¤æ0ë2ûo#Ø˜ØBÀ)Ö>ş’b0p,›ÿCÄ[ó2Éd&f¶HÕ\ŠÉ>ÃØ4ÃœÌÌ‹6çOíCX8§Ä§ÉëK+$¸Öı eGˆË;l;°	óAt[Æ’¥.Åî¡âŒ¹£€[
+eÌy’ÈÚ
+¾*KŞU‹3PÖ½Å}³µ)„ J©V9Ş)™ôòHìô¦¯ÎòñBø]ÈÔ8áf!¤Ø¸‘Qsz_Øû&pß?1U-ÁUD0Á¹åyğâg8`×Ê“õïÀ>ùsÚ±ww+Oãš¾aÑÚ*ÖpÆe†Ì‹ŸÊ°ï¿#ëv¿ú~o£»PêN7á®Úz±¹¾•“Î¿Ôİ¬=¿Vîö4duè&O9¨0WI–ohÍïØ´{Öûo°:€ÿœ‰"Ìô¿ü=Ì€•yB°cx"Ãƒİ"öú‘e©u(å3¤O(m¥§·~gi'#Sş?®Óeÿtğ¬9Œ²“zù<×iôTİ~N¹ŸÙV1¥7ëSãµtNRÇÒ´şÉè3ÌğÎåì‡›^LÑbVÎ ¾u]lÑS–>'7ı2	X:@Uİ^{t\ıÙÊvôğZw«ÏwTû
+ÿîGÏç³i…U´?îQu_^È5³õé¬}íĞI¹†^¢ä¦Ä¥s63-E¬Û:­ˆâLÔIØ…·	âEO89Ùc9¿Ì&(\şAß]®ìn¿ÙÛÈ+ÙxºV™ÜOUjAf?bA¥œdİ.ÒQãbÆ“r½¢-2[X4
+©âúNî‚#Sß,-ŸÇJh! 5n¯<¿
+ç3™e…ƒœ|e÷÷b şPaÕˆ‰PØøœ´FD”š ª„êCºaOúÛõJ‘sXIŒ=•£ ¸@8ÿŠÇšœ¢<c£-é¬„²Z/¨ríí©¹¤•çwÎm½ÜuBK(ßøîÍöÎŞúW¯6êÓÌfY1ùe›<g™ŒoOc„G1'À8²]#IËö‹!°…‹‘Î<1†LG¨Ş_ø|>îhmKò~ÆØl5’İÚî¾ÜYÿúõÆÖÕr:£‡/‘4‚Ç-	D\³J®9Ìç^Ûk´ mâtG¹ËÁµJüåş­ß÷.§¼w5Îxâ¬¶¨Õë.Û4iEëë¯¾]ÿ~wœ*ˆŒ¥Lªu)9ĞüİúŞŞNƒ $‰Æ¾ãÒ¿
+Áå„…o€Û¶>´!Öåš}Q}^ëğs%¦æA'Ã1Y%h„>|*›²I÷Xàüù‚´ò­Ø^DÌÀGàîÅ=7ic•Ú=ëâD[Z£/Ş¾yµù|}¯mija¦ÅoâÁ¢2|Ğÿ5:¸uqv Ë³›¥¥ä'7Ëé½ ÆÀr=7Õ+ÙË] Å	k…l‰u@£q)¹–ÓR¯†3Tõz¨Åw¬ÖÒŠ–Í 8“¢¨<I,Zph0"İ•¶S©[T†m7à@–.‚ÌÁBgZkÉØ$û,†Ù˜µİF…h+æ·,¹°)]˜×–_ñ£ËÛÆÍ—[ĞŒèC;B£%¦9å:×JH×õœ‚æè@Hj /m%	±‡ªu´ _éË|‡HvjåOjUe
+ZJ»¯ˆm— #® öhÈC÷ø;Å œË5P¡èÂş•ŸØÊ'lZêÅ9Cí˜öÿg Ï-H…ğƒ­âO’Ö §Ñ}m\2!aëLPR8.^¤t;/ÚRà¡	„]ÍAtGcËEWÒ%ù®€1·±¸ÅşIH‹÷ï‡D˜18í,C¦^6qòş}÷KwÖxÏ¸Ó¥;¥\JáÜeL0×ñŒd¸ÛÚªïGæJæ•iå¸åî”û@A·ÔÀÎóŸò-#I-ßæ[Î™ô%©;‚õ!(ûEËØüÔ¢O0
+3¢ÚÊ–rCã®Kœ¥crj„pã„¥5€ÕØ—éŒQ	¸¦nÈÒµfA|qúqŠKÖ[!øíåg°şö ­a²Ğ	Zk50Yê"ÌÖ¥Är¥.ãªƒôƒjhcNñj¾¶Ş‘é$ÍcñÑp‘Õ[¿uåÃ™vÖ$B)ÊúH
+M"@˜»Læ÷2&—l‘¹€ÑÙÒ},†ÙÅı8áÓn+f…>7¢õfš·°¹ÃIŸœ¼ŞÅl¼*ƒÈ"a©´Z¬TN{tÒõ'ƒCÄ®¥ş _ï€¨ŸºÃÓåÓŸ 3³¶¨™zviˆÁ¾ÔÒªš/¡ªX¿Æ&É\»{ë;{PÃk1ü	-ıD|E¬ş{Ç‹€?Çkğø	šŞÔj‚s‡v#çh\Y'4¸·HúGè:ârªp‡ì}^,ã	®.ÿ'_ÁF<rÇ3q"?{¡ˆÇ…+]@}È‚FÑ‡µÍã)ÚQc%ĞÁï]7‹;„’ç“ñ6ÜKğ1İğÆ‹ÏÕÇÓ1[•DQñ_mğä*”RÜ»¿ŠÃ““N}ÁERıé€,­b'ˆ[Uq:¶°^x_eN²(%ÏqÄ¤[evå‘y¹k<s ƒGyb-ì}t3EÀDé¢ÏèøÅp †Éu[<†n=`ÄÕ2;3E°,¸ä‘XSšN˜øJtšXsayAÃæV÷/;»›Û[4
+G%üÛ¬ô,Ç¼^ÿnA¥Ô”KàÌ—ğò¥…¿Ù*`y%ğÉ9ZÂXĞ.ÇYÃÍ80q•ƒ·?©''¸ì;g•ª©,—C tü·¬ĞkØ•_wÑÈ 
+rÒNŞ'2×ÛÂ'¶Ğ0,ŒñÂÆT¬,·U^aÓåÿû{ú%µÈ^şKMÒ"¨ä2âBğ°Û_>ó·½‰öï4I¶¤Æı)ïk ô¢PQ½­rùÕî^Xÿzó9äÅŒÄš+ÔİıvıM“í:¡m!h*6zäcJ={ÍÅş†ÙÏ,RäGpT­”ñù‡NÆ™‘‚³/Éu‘Y%¢‹á‘\òBğQD“ë9—w0iÍ"•yD»É@ŸBã\ôä“ÇñŞmmÚÌ)Ú@€ùÅ›P±I2¸oé%…®NÂ6ê[.$»ä-ı˜;0M¤ä­G_H,=?ıÒf¹¹Åiîî¾}³±ãéùrg¬³ÿ{ÕóÿüæIõB×„ H‹,ûòyûİkœ¹÷µè,¨T!_ø}ÃŞŞ¨Ò,Ê$ÏÌİ¯œ¿­$c²ø&DıMôd"M0l`i2A—­V‰¬±İÏG§zÊ…ÑÚFÁ×;©VAJ?{ûI¿•ãÓ70—˜$¾:­.¬àúŸ|&uÊ½3¯UÕ,™h1¶–a³‹¯d÷op„L7ˆ	zìB¤„ùø©¥ÜÊÚJqSÔÂ‚¦½Ï7ã@ºIÕÌüò›.ïs/»‚ÑàJ?ï‡æ:AK‘Ù‹¢\~c…‘Cÿğü²£õÁD€Z³YĞ´%ŞF-*Õ³Yr	U:ËúEŒXö^Ç¤úĞÖUMÉAÉ °şúğ²4€› 0ÇÒØóÄşŒ·lƒpËL´Éà(|ñİ)vcÏ¹²Sœ. ôë
+å"†ÑÓaœkmTPI¨×9fàD„ÁÇTÙ‡äì™×Ş”Ã1¬µû¸`®51®Ğ–íš È?E¯ìª5ÅÉønÎ©‡;K¦ys%’y¼˜3'‡I£à›´ÍY¶™¹Tz5=¾ã*ãÍÎÍvHOTj†æïÈÀ˜ºQnİÇXh8–±.”+§û˜U&T´ö¹³ª@]‚â6:¶oüÏuñÖƒ6ëù™Ì[=;²”¶{ü.2kà²$İ(ãú=9­Ëÿœµ$pd©;¼Ôw©é¬Îÿn„&«Rá,dæ27ÁëÓÊMÒÁ½¹!×OãE7æÃKˆÒŠáì9Oá¹Hz•KÓU¬n‚”ßår±¦W¹”³ğ1áz·Ò«\J~î\Bùkìø	‚¿¨•À`y’qÃ¹„è	!¹P~—ËÉ¶da	X~—Ë	TÍ8ŠÏ}ÊµZı¹C­Ÿsí@o{³m_sİy£~nvş[ÔsÿL.ê/ŠïrÈÔ
+èM”Èvó„Ÿô*Êdz†“ßE©éZ›¥5Ò¢ÜÜúîBy©÷ÏËÔÄ¶†˜E±,ïÆ¾Ô2I¶‹k¤Å6|”0øŠòFgYãõúnïTwª×ˆ
+ØÉvçh!j,¹O…”úıeõºÍáàşu	¾Éë”i?ÏM~çbTšÕ\.½*ŠåyÍåò»¢àtmnåsŸj[—Q®ÜúÙ $±ıc(½ßù²k5ü8sÍÜx~×µkÀ|ÚV¯×Ê¨ÅR!8mW.«³lìº!¾{óòû•bù\-ç×írù\iMz#Áæi®c±d®Ò…ó.°Ù!“lCl+aóêšCC7BZŒ)µ"•¤ÔIÒé7såMë™«u%zçJ· w®Ì5Ğ›Ü£”†²|átüØÄÖë+ŠtP´ab‹
+^I‘ÍJÇX¡³¶ ¬	ï£ø*¨Ñ…ÔÂq*šv­ÂS0¤I¥)tĞÙ®Çdt£k–ÂÄZâ
+@ÂÁcù²Ë0x>-ï£j“Šİ¹Ì—)©ºMò¥ìèúÎÃµ+Õ£µRÌãßyª;fOşŠ£!…
+é=Š Á
+o¤È²"H«Pe†;{ÛYfó«Ae­i¬ÏzúG?•‹AŞr;Lœ"Àq÷É7fL»+C'‹æõÛ©øHnE„(ôáÏ<¥WİÓN¥&~d0ß`–£Ùr<š¸‰ÛmPäÇºÏÅñ—'š3 ‡Ÿó¡ÑÆÆEÉú‘*D39´Âƒk
+Ya”7wt#£#\wÚa_°<ãöºrl¸6a°ë8«”34 A¨ ¸ø¡ê˜0´‰qèË—U‚£Áïó=/  ¬O)Mä`‡ËiŒCÑÌç§cÃ•ÊĞµô~0n)4	»&™`8fÇÈŠA´ó]ˆPŠ¢’XdÎŠŞÚ(¸PhÙéŸASo+¸şàí ë›†tüæKs V¯ˆYK‡Äà°â¨_¨0Íµ9L¦ê8´L{B9P¨³\LG Ç¢æèµó`Ñ’íqì¯pºóaÇq5ñ–îsa&)ÆfjZ@8<%&˜YOÑˆ¶g³W;Ì‹ê‡Šá£_™¹*½auĞÃUÀ®mFDï«I´ÁÏQ1~`>ºo=˜xñ;İUª$ß%Òr‡~øÁz4?‘Ø(o¾¶#ïvµ5GÆƒŠ2|.æv~Ä×l«8¿L&ƒUĞ‹z|#ÏÂ1vB2^®n;:…µÄiowoZˆ8N0ßtu·ÿ—d÷xdi	'B`õcÒÍüvá‘)S~ı‘óM8zY
+p…EJñD°·cÖ{˜w]Fs·š ®Ë`ïïÛá’{ÖFGYîa‰+ÂÉŒ¹ˆì,Ûà€ö`k¼gÿ|i­	8®„3PÚãò™H¾¬Ç
+¨®_\¡]6)…EHõ.òÁºKÄËÓÊ!“â’¿`0jbkŒàÀmõ²ïü¹SBák»Æ°Kr:¾ _G(•èÂuA‚ãSÜçY8µ9è SWÓñÅE&ôì¨T–ãÚ®ßã`z‘xª<ö4÷ÇÚ=…×¼#²€+³ó|ÿèDº­‹QHº¡#á" ñ¡Rp!…À!Ö,zJ'ºi£¡	‹C´
+*+™Œ‡‡ñ/ÍÓÏË+y&Ö“$€3àâO®SZÖf›”AÖønL$^/m*VªO0gÄÀß†g¯ºMŠÏ¤®íCe® x»uƒE;­om4(; Ãn#ı¤‹¨ı{úÛ }ª	%(±[%—òÍKº#×¢u¼Ãå¤k¢±Ó ªæ vkkªÜİzb \º‡Qû?°IDğ@˜Uˆ/9zdW^*¢ÇÌ¸Ø›é$
+Ó ”GO­Z×4¥³Ğõ2v‘YÜÆ`ß µk¥Kæñ+ìŸEÙŒÊ‹t0¯]¶ü`µc#¥†MÊÕwx‘'©•ùÆî´o”-ùº´¬ç—%3¥²B>SË"L0µæóåjv|^¾NÓ:ÀIpÀ$u‚&|­ÅeèF·*3—ƒ×!£!šôÖğT#m} m*„+jq‰o­åZ}&*]Jdl^+’ éM~V"Ï?“ùÒ/¦Tsqƒ"Bóx"(ÆíšXj
+ÿ)Wü‘ƒµkªƒŠì·Üqo®~µyøe‚B|`ö¶tĞAMIV0.ÇccÈå»ßNuÌò·ÚĞ\ïõ, Àv³h¦Şw‰¿Ü…y‚?lğˆãªU5)ÆÜ¹sá—!€XØ#'˜ÄU¤.ihéTmã®wÂ-.{gyÄñm‹İÑVˆ–°'(¯$‚Z00™÷¡Ô²,mmsáŠÿ?˜ŒßAqPÛÂË¢J¿ÿ›aóúø•’’,¹×Ñ8šáŞ=œœ2bÎw¼@ƒ­»÷Y$«©Wc0üğ 6‚‡Nck,qÚ8?Å`¿@ÉÇˆËÑîgı—–3±…‰ ¹×=5¶œ)–Ñx#ƒÉ«Çû.q©>Uaºà­T¸
+·IóŞ-õÆûfWÏä^ÍwŠ}ÙJ µK®Åìt±uÁ	2–8ŠìrÂáh"-p‰9y™âm¡7“¢hç¶´{¡",ÅuM†İØ}Åb¦ÔÜ·×Ú·ô%ëRNk^—íó¬"ãı‰ŞDS«UHñ&Wb‡ªËñ²ˆÌÎÎ÷ÅcDH%Ø.ä|\¾wáUO’Š.KĞ9•eR?Š¸äëØ‘ÚDöEÒ¿'"Ógİ;¶¡yZ£ø$EJ=÷àpF|¨óS	ˆ=%eÀR¡ä­`ˆê¼Å:®¯”Û0¸%¹:Ö‹BˆlS9d\‹zbod4³óÂ[=Ñ ?»o¹Ğ^ u#&[ÿ“ë›Ş/Xd";
+}š#‰mbT¤F¸JQÓ&
+ªc’±¬;P«^ =TWê4_zıBypÍ©Emà¾oåïWè~)–Ô´†<QXß¦:ÍCK@8,‰®œÕW‚+±7y<4ÔdÑ2	güz°ŠŒ˜áÊËB¯9ëO#s’ÿÊßƒ÷WÑè_. ÌÖ`|8v°Yìmn?ÿú[Ä÷ıâ-¼Œ6ŠØ8Yx
+©û²³»÷bûí^—vÌ­m3û8ùe • ;2âqïb(µÛê„éìp<¼8ËG¶ıÉ)‘˜.@ÜZ1¼÷­½Gæñ£CĞ{oØÙİdçŸ­pp‚B‡§¸¬gt4ìË­¿Úy­2:+Š ²5$VœİÚì'äÆ<tñ¨ı;6±À£ß?ÀèN­X¦ã
+@e‘&,l9®³¹·ù—¸é¹ï¤6ìô¼˜µ[Sœ:êÎ•½VÇ–ÌRtSëh<öûç;u8èH"Auä”h¦°ÏÓ´¹µ·#Áºa§JÀƒUÁĞ«Âmå @OÈõÏ€~ÚléÜÖO÷9²>t¹,U„”-ı‘½OÃ@_m=$\Ì—>‚6Ó]zh†¢Òñ8²TYC¢Á‘™èäòA*•µWÜf‘8ÎˆÁöçDë­×úˆdXí½„pRp7zp}€UŸâ‚a¨êiû­6I$£ÁJBİâ­LcÎ&ÃÁ,‘ü‡tŠÒÈ"Œ&æ¿ğM‘Ë‰’“œõ¦ˆÌp.cŠà0…wÆrû_o7÷äñÁïoŞ¾zNyÆŒç6lå…I–(š¤d¢¢…	mÈpŠ†0QƒB'–ğ–Ïò-dxkèŠÏh›_IcI`9FY3¾b\ÊÄ62[è†Ô€™²ş‡•‡œy:$t.‰rÃæƒœnğõ&˜å[†tœ
+Ç\Ì>ç9aÆ;XõÙ•* (Ê´¾¨ˆüp:şG‹U2ı@¦áYÙãÎ<ÆÜ·X˜W vocçõMp{'h%6ßÁÆh±äÎ¤Ô!÷Ï=Ğ$iûlp°ÿHI¨¹éİ¿„$+/p(j°4ol¨ï½ê~ó-Òï	ñ›o»ëYß|õüÍ[/wÓ—åë”©G0âë*ğ‹§Ã!qâ˜wZ´_)2wèœQæ
+Ó¤ùÆšé’Ùpüök²‰s¬aÊå¡$œ¿Ao‘âEm×}˜´¢Ü6c‘pˆl2!˜g»`	9îtwŸw·Şìl?ßØİİŞÙíno½Úæ|€R§0Dº-lt<¿/P¼RÁãˆxôèŒ2Àùğ²­ø'B=9[œ _Ê¸ÿ„ûFc•¾É}L~¾X„ÎgRÎşÎc ÎƒºKE~®ãQu¡Ó´~[ÎSŒ¡ÌÚÂsÃ!¶ÃÉà.½HBZóo ûµ²ÿXj³Œ#HkÊÆç´Ê“oBO®É˜û‚S¼^ y	µÉuÄ}e¡Ó¡=‹C’g€n %Ì!ÿÀa:íˆ7©.;¿Ú;¥Wü¦ŒµfáñF™i¤ÉySœYæ‡äûiï·ƒÈâ;†ì=@Ïé‚tÈ^ÆpYt[tÆ#8ùÍxjÒÔŸ;>ÌÏµnÜuLåQó³¶!¥ø)@À1q w`5k{+÷m-6aóV¹ùGcI0UMB±bÕûÂZ%§ZK?F.¥Ó.æ§%é|åÙ
+¥U'¹UH0ÍO}>e\Êì‡¹÷€ìíƒ³‹3óéËË/	€v¡÷8æcv=œÏ;$Òm†u!è€r¾£G´xaSÂ-E¢»tî2!‚ŞléD…¤¶ªHæcàûD½š*ÓiuŒäÆ¹" #	†€‰çE%b4‡ÃØ˜áàü>¤â¤}ói™ñ1¶¢+–/3ÑªÆU2Ğ‹°j‘W¦IL;»è§\ƒ†‘†nÃcxó{ô¸eGF}2ÒŞäm}(GYzÀ0ÉãƒŸãs†:AÂ]åôŸÑaôeK•{J%”–© pœ*âl€Øï4ERœ×¥y’bÌÔıÃDÿĞİ‡*3ÁCAwhñ6Ñs7#×œ%àùéxL šL-èéËÖÀq[°Ìc*g6|›¬©{• GJgä=ßâüé#®MyWšuÂV·íÅªÊå´´ö½›#/œ91lq$y´m|ÙğÆ»d66Í9ë“|M.¬5İäÀ_"£0ÿ#›—I&3P¯'Jòø1oÆãš r4Ê=¬ƒÙN6S4ÿØm0{§ô@±ÚÃtp…|É&ƒ–¬ºhÃa@›ÀÂ®!Ûø‹±mÃ@F;±=µÊzYĞ·îšÁûÖ	w²sşĞNrBöu¨.˜MÅ	Æ5©®sYcJl7„B7~04,1è7Ÿ’	÷ÁßÄ
+¥Ê´uH‡¦çuv^m¾ŞÜÃıl4ÓPW0Y¾Lø+—ˆË˜n*ÇÂ¤Œ)Ş¡¹ù¤ªH“¼Æ?]èÊ.OZŒ
+ª}ƒU½Bò¹—›[›{ß›÷!Ì~póc´Ûo6¶dYê¾^ßùzs‡“m$øØ?xéœ¾Hö~fû6Øt† ³#„Œè_Øl«¦z®,¨iÒœJMjôï‹/çš—ÑZØ1ÎjÂÈD±ƒikM¼Æ'’6buDJ”ê8Yk²h²{•õ˜êC85Ó,Ïd€“eÎpvI
+8…ò
+Ùİ¡ñë#5ZÜbã6 éB.‘ºp+AR§¸Pˆ¡\ıîA¡t];ÀÊ$
+Z*²pÖ†–²‚7‹a‘ßaãBlˆ-«úÍkhç)G¨a{s¾Oª’ªmâôã˜ÛÕtÌXÌ>„·HFÁ‰D²„º*ëƒ¬Eiã‚®Æ·Læ¹«BÂmaÄ“ğÆ ÄÂJZSƒÈJ‹Lar	¥H÷'½éŠ
+ rœŸ ÕĞ‡^0Éí;ÚŠ€¾9½÷(x¸ˆSe¡S”³ï›vÙYòÖiüÆ}wYPÃYĞhMeÄèİšÊØ%½©pÆÖT †çşã$0AJÿaŠ ¬Zî`„Zİ‚Üfã€Uö§e¸­ci‚ÃşĞ@Á?hˆd®õ«cQá6bh–‰“‚ÕÁBu’}(F•ğ+)%Ì#¢–ÔêvÑT®´‹¢	QÆGêÎQê…iÂìwĞçüœ`—ß´ ÂÃTÁã¦ÉÅ-<J`Î(G¹&ÏÕ:æ}n©§fbî$lèeª	l×ƒ…²ÅD¡B¶UÓşfy7Fo¬gÅİ¬1HŒ/Ş˜$9×’_'Üà`Ù¾e€Á¥‰F·X‘"ËŞ›ŞDÓbƒˆ ·'¸Œƒ<ş6ÌaòSÈéyªh®üH#ÛCÏçY-O3k‘ywÀíşBTØ7cLf©Ã¸çÆfdŒÕâ\ÍÇÑE—m®é¶=?¦à*wGªå,x5Gœ©#ğ@+İb èŞ¨'¤™BÍm“Ş^áèÛî‹!)Õİ1`ÊôÎ˜t•+&)ÑVöedÅ­lu\S1$Œ¨+»§´9>ƒ@º¶¶¦éû©×UŠŞ9I®Ş@«WÈè²‰C`àØ‡‘­1ğGçun-¡	e(íôà«Gãd?5K«SHÃo=¨G(­UPïÒMÆ,Î£{ÿ !×'oÁH½Ğ¯ üñ1§¢ú«èä¦5¿‚<h^¸püñ°°1iâBNû>ı?WŸşíÓ•êÓûü³Ê?8nÀ„wæº€<~48Ì`8£†ƒÎ;0{'â`RB1Ş«€LM”àDS°ÖĞ	²6İÙng™HeU$ÊÂ<^?Ÿ<|Àâ8‘‹G Ê¶ğ¹(kÚC~´.àsÇG12òŞãëĞ}ÖfÿÔQ”®—@AƒãÌ6ÁzÆz”‡›0qé‰:y,¤Æ¡/†€ÖĞô¥?A	Û¿myÊƒÓŒpÁ„¢3İÜTøNÓMróˆ÷oêœœ¬,P»áÓ€QoT^œø)àVJ;SW&m³“F{7ÀÍ­áİäP<dm1ZÅx
+%»¥úï)¡¢IÉŠ3Å©DU®…Z›ÚÄ Pã5gèÖÃ. •Ì•Ö×dß¶D—WŸşÕUBh(Éºóé—ŸÃğç’Ìí÷únêN•ƒ˜€–;Ë?V·ïá6†ûú‹(ÆLŒPß¬§õ—Äúı®n?FõÛ·Q5ĞÊ{e²äññğbzŠl¹4à·9®#EFvÍğél
+¿-h9A™Ÿã*’€¹™TÇÖfãaGîÀÁ÷ğÉ3“f›Ù|¤¨ÿ¾Á…pÇCØYi= ¡Ş;°£ltôÈO""¨$´ÌÀàÓGƒÀùén“ÍÜuVÒ"xx¢GIÖ4%wEN«EË*ÔİÁ‘¼Cº8öÕöÖ×]œÿ—‚nëß™âm©¥,ƒN~Í_¾&Ó˜aY¦¹J/œã0äÑ6ÒfÑ"2…ì@ÙÅ`zŠZĞK§‡Ød'Ü]E?™È³}¨Re¤¡ŠŒ­İ“-?é¹è¹¥üuı¼“óe®şÒ|»ş)ºkXcÿÖtğOÀfa”²J0¾ssFÈ¥æÁØtÁT b1Na†½ĞöÃBâ³
+®yØÀæºGZÄ²µ.½ëàÑ¤äßÁkÏUå	&;w«òâÈs:ğûùÚãªóèÁÃÏï?øıı‡îJ‚(ªÏ/-¹óünÅ‚Õ›S¤ıÅ!¾Wã‹õYFñ¥å/Îíõ„P¾6œ¬]¼{ö³7ß}úƒâÓ:İ#-hkí‘då›gï¡i?­.Çnÿ'M 1øé;º?X‹Í®â òÎlUˆ5Ò¹—¼5_o½­¾f¦IĞè›‹dä¯^@Ó~;@Ìö9‹aïM¦ó—´Fîz?+İÊÆÉ'_u•G+Í^‚tà`Á ã¾’»¤\?’k6!m!Â2^h–Ò`OaEÃ@¦d?¦kQ³ƒÕ‹cbs¡ÍşÛÍ½oÍW­o}_}»¾³³¾µ÷ıSTŸ‚?VJMW.Ÿ0?ÇÃ¸xÜ5Ä©=ÿ@Ö¿Ú|/ÓËÍ½-T/‘]d÷¿ïìm>ûj}§zóvçÍöî†‡rí´ƒ\<qrJjs†ÓìuÊÛšÀzÉĞ(£p)påCÿpŠŒÇÚÿ±àå0%3!Ürí*Óö,c]¤(2ta<Fé+iéø/ŠëØ!•1Ù¬.g$6.ft5«Ò0_ İœîŸ³\ÒL"éÜÛIú{aÍ`ßü–”îWo_¾D¤à‹—ëo_íy¥¦^¬ï­ÏÖù›í„Qå¼~˜u°t¡A%í5Ïy»ºÔTgÌäP†â%ƒÃ’Ò#ĞG
+p9ôqæ
+‹Ò+û`BLõ_!{½` V‡[ëöq·W<„}R"'¹n©°¹ØñğU;Í{ £‚²œ:fëğìœ{öOû´Z,¯úê[¶>ÄÙ’–r^ÂOO$^‹~--9ÉSâçæAQcúh{ƒhğY£ ‡åæAaÔ2dX¶[â®z4^µè£m`=&…$iÚhÅI&_q<?4£vÈ(H2YB)«w­Á\³‰å8Ê®1
+O×ÊE´c§•Xu~4µ!¦ä£“ó¸$Ÿûè\ÕÛÆ"ùì³g«Ë©}Şêp{ú¤ZÕ=¸pi„!3¶C”KZe¨`~–é`Ö¡¿uDÈ¹°¯E¾¿j,Î¯ñÑ!ï‡QŸa#ª	¡z´ôIMş¦`ß–Š`=Ï_•ó4øÜ!xuœšÛ^ˆŠî8XN¥\x#vˆÙŸz¸1èpª6›K‡ØÒyà¾(1Å®ôîØø²Ê€1¹î4\…sn!«r5p¾D­¢ÁHzEûu°ŞÜ¶ZqŸ;vî³sìšXo¶½÷Eó%îu· g &?ÏÄG¦üªIàæß>	óspŒ<0!ıëÌA›¼Ñ:¹o¿é<´µ¿h.Š.üæ‚'ök¡ebˆkˆ,aÌ‚Áâ½›RçGa÷ÓWÈ©!w,?¼l„csâÁp<™uĞ^læWQ/Œ×v†IÚq–]—wnÜjÿø£ˆŒiôî&ÛbÄƒãßxÓ£r Ü9÷n¤“âGß¶;\…ÚIÿ¤Êbq/q#Ä Z"È8©
+ÀºnW]e ÙJµz€Õ«<U½ª‹Lø/3Œ!ÈD—n¦ãŒ‹©î°˜ˆh+ş_9l6(!
+òßù	*¿òwÓ×±¬mš Ótñ¦]jcĞ6Ù„Äç¼G7¿&A¦üo£à[5Ú’\;ìüQùªÒc|Ø4A¿¡¸ü#‘A»³êG²zĞ`nŠŞoó¿
+jüáb«ŠÌ+‰ÿşÒE2<LKD^_àÿ˜Å‘èax¸f­-DÇT§c=¶R~ãW- áoÍM†™—ü3u~3D¯İQç¿ñÒ:?øWPÔùÁ…â7EÔÑà0„´ßjñä¿Yl—Î›É¥‚¦n„¹fİ›¢qø×³ŞªåÈù	¯€ü¯@ªéF¸ô*7EáA’`yp×´õıŞFw{çÅÆU@<ã$ìÆÖ‹Íõ­Ú‘o›øÅ¶¶oğ+ù)?c±UJÏ5/²?Ö8ö^müz_kRÎrft LÙM-Œ±’Üº4¼i´A»Ú;µªZ×…İ'ÌŞ~Z4åÙÛY¾‘¼¶/,~*`!dÆ!\µŒcH8¾upÃ4è/]Ãğ„y’¹m÷àyIí©šç¬Ó1%ÅÀp>®<õó?r¡fØ8
+t1ƒÛ¯ákN Ó|5ä†ÅHøÄeC²9ÇRå&Øî÷p÷|‡›¼¦Õ¾şÑâ,è~?Ü<E’l":4¤¥òÇyÓŒ[¹~˜­ş´oîì˜ı0“·?1Á¡š5#xÍŞ²œı–œ6Z#{|³³e°Gû°‹şX}ipı0/)}ù=ü1RÙ™Z¤„­¹Œ~ğà«Œtz´Ÿåê¸e—‚ïî|ˆ©¢_-M…ƒÇ$·ts4Şwûq&’{º­^@ª ~£ÛÚşnûÍ^wwo§­{öu§»@^X€Š8³ÚP/ö³[ u( ÒŠ]å~úX‹îÂoÇ‰åÿmè0Â®
+¯õò =çûö9Å\škœ3‰uO1}À7İIvLú+\æÓ))*ÌC·^yÜ N×eùôõ|­ÕÁ>O˜zåpC€yÇy6Dù¸‚âúïšVhh˜Ù_ŒÜ·¢†ùÙpŠì‰¡C3h÷Î%,
+ XàìÆşÔ£àEuB«[ñ6-âãšo|u¸Nîs ¥ÙÇyp6–Z×Ûº3_qõxŸ¶8ˆœ˜ë&®Ìó4Ì˜¤Qô„z‡‚´[ M÷a«sÔÄÂÎØáù¿Î*€]ÍúûÇ áX7BÊAz×ã£ÅZÚöÓvÌYÜÒ÷£:oe4Ê£#hlŠ­Ú~ \Ğ§Ó
+T2mó°ŸS:)›‰föM™ß§ÅËÜäÀÇ“ı0j×û–ßëö#sÛGŞÉÔîñf_&û4ˆi2‘ß1æÎG@Â6¿„À|v»>J…%)ıØ039,PqƒdKdıÁz_AÀ‘>ttˆk2óh ½§Ü Uçd8>Ày”_ !‘ñßí`¼“„¤“RrXñ*tå<d…|ì˜ÚAÛ>Ì¢ÖXx’µ¬-“@Œ
+Û!Àôğ…TiP¡Ñ!Ñ$)¾wÔƒ¡X(O|‹ŸÛ°ú9¥†Â†FÈÑYp­ók@<¿	D(³í#ÊÔúøÇ+û(ï£0³–¥“sW:+T¹¯\ÕóØ|õ_¯×m±›æqX³~á¢ ¦èuot£—ÊÃLØ»º"70[Ñù‹—½rv€.œ93._¯5YÏ~Uk}#Ü=­z¥`áXöƒf&ô\†\@¿2ÌfØhJ@5êp6i0ÁœÒa<!CÆÑ~F¶±[Î%Ê”SÛ—Ñ‹~Ø¸!ídYå‰M2Zöí
+¹®Ìbeø¤—ML¦g>¸íDbnxKÃ@ãÕ(ÅİŒ>ûLª‘y4x ’u§pbŒa#;úÈb‚¡Uè‚
+RûïJµİİyä2ßÃÅÅ5Uú‚~.ß6îíV%¨9jÔû”~{è§vGã»âõõá <ddwòEÔ°;(UfN6s…üÏ³³TÁª¥8%×"?Q(hB4tå—Td{ÑD>¶$ûM.ù ÛÃËßñªˆŞí!vëÒcUGLCìŞQ^¦ôÄç~.¶ù)„R†ş)‚X—D[ú¨µ åÜŸª¸Ÿœ‡Ì­ÚeÌğ@İm+újûk¢¸qtê+eX±Œ
+H£Á'¤tƒŠz¬i,WÕË¬íPqæ­Öç3H?$ß¤}ÛàŠ^SKÌ`ıªáˆ¾-Ê!¿ó°úâ‹\XÓµ¸»uÀ~XğoØeŞf·ñ™K?v¬wär—|h€ö¯iTßyäÀsÀlş²³Ï‚E‰Wqå­gŸ;ÓÓÁñ,'q
+Q­<êŠ,WpŞ#aºy/=›Dm0sg—•„ÒÖ
+æÉkùÙ’F›ñ×éŞ‹,/8V]kB_Ô-©Ì	ä:mƒj9µÌA¥¢’ÎS‚«L²dqàir³Yå|ØÅ™É*§Üé²‰XHÜ
+õLÙPÔƒËTmæ27j/ªÙ’ıÈÀìóMà—Ãğ|{8kw;ûPœÍê-"vÅ(‘€ÌÂ…µk ¥º7éB­j Épaã­ƒEê7„Ûmi‹{cûP¾t/ß.f¡³içjğ©<Ù¨qÿd€C<ÔÂ‹[Í©LçNè—~7($˜ú6¹°1î¯é$ü\“Ú}5V—Å¯ì £i“œfo°ıNf7éÀ·w¦;:Ôx]vªùé†¸IÕçú“bL¹IúĞeÃµÜ>9Ve2<×ï(%3ŠÍpÖÕz}ï yá0³ÁâtzåêI¤ô)8s¥”g1HÇĞ‘×ƒÓAô¥ø@ÉĞßëÕŠ‚åÉC((A‹îNq8©ÃpP¤şôÛ™‘/fû¯ÖùsLG¾ZW×ë4
+n¿|‰ÛmeÕšİ™ñËW "°Á@ü¤I>bÓƒ>ë¾>Ûü»Ûµ›°Ş˜G%ç‘%e—ÏØ2d–\c‚Æ¹pöØş§¡OÒG—wD¤,09´ß>Â1­(İ÷¢¾ƒøZ’ûı‰ùZœ”ü@ 1(z]ì€ ³Sõ—Š&„j‡B*³‘N:·•e„jWWV@‚`ÍŞYé”-˜”Ú
+ÇHaV6Ğ‘NxQai·¢ùt;Ër	äƒh¿õEP
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e7/fb6986d2a6de6bea13904aa686790a14b257fb squashfs-tools-patched/.git/objects/e7/fb6986d2a6de6bea13904aa686790a14b257fb
--- squashfs-tools/.git/objects/e7/fb6986d2a6de6bea13904aa686790a14b257fb	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e7/fb6986d2a6de6bea13904aa686790a14b257fb	2022-01-01 15:09:15.637172590 +0800
@@ -0,0 +1 @@
+xKÊÉOR°´dĞ×W.IqL«ĞËàâRÎLËKIMSˆqqt‹ˆ÷àRò3óR‘…€Êò’sJSR”ôôô!È9?77?Oß·2<3/%¿¼X/C	h\j^Jf  Ù¯
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e9/03493013a15ec14dbdb1c24f44399021b764de squashfs-tools-patched/.git/objects/e9/03493013a15ec14dbdb1c24f44399021b764de
--- squashfs-tools/.git/objects/e9/03493013a15ec14dbdb1c24f44399021b764de	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e9/03493013a15ec14dbdb1c24f44399021b764de	2022-01-01 15:09:15.645172590 +0800
@@ -0,0 +1,9 @@
+xÍWmoÚH¾ÏüŠi#E6%/MÓ/¡D¢ÆIPyå"dX‚¯ÆöÙ¦)‰r¿ıffwıBwªzºË‡ïÎë3ÏìÎŞùá|<>=ıåèºk+\.*•=oÌÄ\·{kõ»îUe?½@VP(˜ú«™€·İõÌÂ‡äpñ••è°İë1¾›ğWC{4î8¨‹då§.4 wêàÍ|íMFnÿ‹	±HWqK×á¹RIÅ2ò'©€OS’$àœWä‹Ã¤qå©àTÁê•huç{Ó3\À¼Òu$( Å,R¯ãN¦hPŒn„AõÆNı¹´‡#Ü÷æ`,ƒ_)Išœ7g³¡˜˜LYoIšûøäœïƒ™h›ÂL]ô£C·`”wã)ØÆ5²şg9d2Aš$:¾˜$BÇñ-ôf­azZ–-IçyÃ3;	#OÒ0F(™Æè¢NÕD€e<ˆ­³Zá5ñ*ÉRèNµš	î3àªÊû¹D&pp^ğ¬ÙÊÄÍ?Ñ?	jDå9& éoE)B ©ı2¼(«LÉ²FFÉŒÑ¡N·al)1£b6ªéÂKW²Ä‰»0ô3#o^&Ê,S“sI©!w^V‡Bo@ädzØĞÑ$>„Şı.¦is¬­øcå}›ø"˜
+ÌŒÙÒLÓÉtÁä4Í8$ñØœàh	VË5¨&)æLmHæ+!šjxØğYsÓî}8A}XX¡lø6öÑã4†ö…Õµ[OıÄ›Õ ÚøéÑïÎ`ÜûÒëßô _û«TÄªŸkĞºé[0{°üÄ
+ƒT|§ğĞ”åüê6±ÑéS1¶³³¾µËÌx­d¯&ƒ0ÈjÕDN›Yz"˜ys4Tİ•\g`õ;öÈBò8ˆÃûvë'å$!cÄd=4¾ˆw/âp)}¹ó}Vá4 šN§9ÙC§DNÆŒ–ÑØ²l»e·ŒElêÎcû¯@©Š·I×]­¼Y87³›ˆf¹ˆ5ÀÕ#Œcóv¸>/€}½ñº…çÉ£Ë±æÍ5KÜË¨S"ÊL6*Ê(ë•ÊÑÿUJ7Ùg$^eùF°t“”S–W ­ñ)ÊëŠé²ë9©¢Q<¥[NÚAù³³Ñ:iú~8¥±Ü,‘Ÿë+^B0òĞş6õ;"0èN¬)Ñüâë™ãÍµsºÿÙä17Z¸dÙdñ¦…}Hd¢:Nü<¤¢µ¾¹éá)Ât ÅŒ AÖ—ÈFÙ9)ên5j°Ÿ<’„jívl¬‚”:“äkW,/b!Š[tS2ŸÕMŸ•™í‘´ªû)Í2û×/§™,Aj[,Ş–’´ˆûºäUYX¦­-q°ZN®è¼G‰e½Ë·¢nß¼ù$Ñ0r~0/Q[6æ.ÿ2­ÔŞÁ*H¼û@Ì€ø‰<¾O/oev,Á'ªKX$É5æ ª%9™,*%I  ÊcĞ†ãDZ5jÆÁ(ïÖ©À0tË¸>ËEçKq¡„3(t¼—]«,j‹å2ü&Ô¬É–¯iŸJBM8( Y"Ø-5TñÈÁïx17HT"ÁáóO\â¹¼XÀ²W{¥aÄBÿ„%Ú$1³4]G²lSÆ2:òÎ™óJ>íeT:öÇ~ïAKßV¸
+xbÂvÉåó¬$`#àÏ
+M¿Âº·îõØŞ¶{=¼hZ¶ûÙ¾l÷`ä´º¶sÕoåÎ„ßBš¶ò[’k[­†«´ÏC$Õu—»çoÏäg^™4•â¨æÂŞàªtñ¹A¬1_ªP5ÿÑÜ\‡üm¥èFïCâĞôìˆòi»½~–÷¦Z³ÕÂİ¡İ±›#CÊq†¾¦Ü›|Ï*“ïŞ•
+‚O¦×ÕĞ,5é¤=8(ªÉ
+0Ênq»3|ÌáKW‚ $7Pó®ÛîÜÑÀ¶nv[ÅiÏÛ"A )İ2.Èñ“
+.·H3§&Ÿ8#Y^l‡Û×½¾§$1ÁB 2÷­É¿¹-—Ã{üÉ˜~¿tÕht§ïÊ7úÿğ/úI
+:İßi!>Œñô?ŒqkÔÎ>nä€y|üç±5OZç)•ô½ß
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e9/a4fb4e3d9a8dec7dc71a49ef430c86cdbfcf76 squashfs-tools-patched/.git/objects/e9/a4fb4e3d9a8dec7dc71a49ef430c86cdbfcf76
--- squashfs-tools/.git/objects/e9/a4fb4e3d9a8dec7dc71a49ef430c86cdbfcf76	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e9/a4fb4e3d9a8dec7dc71a49ef430c86cdbfcf76	2022-01-01 15:09:15.613172589 +0800
@@ -0,0 +1,2 @@
+xmTKOÛ@îÙ¿b.`YÂ!}œ€¦j¤VªpZ.Ñz½®WuvÓİuùõ|³vbCÉ!rÆóø3)[ĞûËŞ§4ÛÏƒ2LkJÏ“äDW¦T­V³‡Õü×òîúv¹ú–œ ¦zFº‘M[*šÌö3­'Ir&Dù¡-©®½§J7Š*g×$œ¬õV%ÈKmnÚªRÖ­T(ºÀWerµCDŠ¦!ü&%dMFíåSâ=zmş SÖêbD‹Šl‹lUR°T*i×§¼§5wµ0dA‡1e1U"â•))Ö‡ZyE[Ñ´
+À3ª·Ú¶>âé† }ÑXùwÁ³®pÌèP®÷*øt<RZãu	ö“A‰		2d+ò¶Ñ%ÅAÓ—;H@ÚwïûQ:ĞNC.˜â” ƒ¸¶à·SÌkÔ")gtnH4A‡FDÉX‘«×V8-ŠâÄV§cft|dŞgLË´@ö ü?˜Ñõø¾:¥Æû!`Wa‚µéÎì0Í®šÖ×ÎiÂ+?¬îæùı÷å°•§9v6jM©îŸz)o¯»%ı"‚( åü‘Ò²ÈbİıÂ„«Ë¸<½÷š?8(ÍÛÀÆÅ}Ç|÷/ö…ã/+FVó-òë›§ †İÈ8?µ±ÚÀ8&=z„è›—Ô]Õ)ÎÇJp;jŠ?mÎ#<¼Yee³âŒè»pN<Â—Í{ÇUƒˆ‘Á¸ÉÒ|ËNıkµ¦(¶a`ø,ôÓY‰ûUeÆ"G<ß,_äûkfNé‘qgŞ«KµŞœ}Æÿn_WÉ3M¢
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/e9/f22e1fd1ea01d10d67aadafbf8f3fe5589f71e squashfs-tools-patched/.git/objects/e9/f22e1fd1ea01d10d67aadafbf8f3fe5589f71e
--- squashfs-tools/.git/objects/e9/f22e1fd1ea01d10d67aadafbf8f3fe5589f71e	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/e9/f22e1fd1ea01d10d67aadafbf8f3fe5589f71e	2022-01-01 15:09:15.629172589 +0800
@@ -0,0 +1,2 @@
+xKÊÉOR04¶dĞ×Wğp6ÒËàâRÎLËKIMSˆ
+Ä{p)9™y©p>—r)XŞÃ9ŞÏÑ×58ÀÑÙ®YPÁh È¼¼äœÒ”T%g_7½%4ßÄÌ<(—rj^Jf ü>)Y
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/ea/1c247fbc7826a591e8edfbf6feaa40233115bd squashfs-tools-patched/.git/objects/ea/1c247fbc7826a591e8edfbf6feaa40233115bd
--- squashfs-tools/.git/objects/ea/1c247fbc7826a591e8edfbf6feaa40233115bd	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/ea/1c247fbc7826a591e8edfbf6feaa40233115bd	2022-01-01 15:09:15.649172590 +0800
@@ -0,0 +1,17 @@
+x[]sÛF²İgüŠ¹Ú‡XU´d;Ù½I,«Š¢`µ¥%);~IPD\ ­ûëï9= í«R‘H §§?NŸîÍ²b¦^ÿòÛ?ûÛÅÿ\ß¦ŸïCu3½ªû‡«a4P'/ÏÏ?ı<8?¿^ë/~9{õZMË8¯Ò:-ò8;?G'—Á_»¼¸	û×—Óh:/Åz]äê~;ËÒ¹¦ó$¯õR=©×g¯.ÎõCÁÅm8í«U]o^&ÿÙ¦OïE^'yırú¼IÔ\ÿòî¤N¾Öç«z½UóU\VIı.šÜ½üõ×üöò5×¿º»ş¬†işåİß}Åjö8(²¢|÷÷¥üÃC÷*ÎÒÇüT©“òòâê{J^]*¼Å/Îñßû»ÑTUéÿ%ï~ÆüB;?÷}s9½	U0¸»½ï>G£ê~|÷aÜ¿UÑ„?~Œ®Ãkõ0ºÇ*à³Óp|;QwïÕôOà½Û»‘õ	ü&¡zqÒÿ0ÃÛp4=9=S¬&aOCH¼~L#¼s×Ñd:®ô”ºõw£	ñ0'xqİG÷Ó„Ê†÷Óşh:-·Ü™Ùº6Mc“7Gl‚Ï¯._Ÿ©ëğ}4Š¨ÆD¬©x(å„!P¦³-#ìD­DÛïÍšˆ3ÑøT¥¹ªWˆ–V,åç4G€Æ™r²Š²×úb^,(çµ(æÛ5b"æŠj‘Vzùd¡¶ù")ñ^Z©şc™$|ªÇw.®Æj%qù.K–õåL”€8_$¯TµUˆl¼çëb÷sqíû{JOæùcR©º™÷eñXÆk½¶¶Ü±wñr¼XH~î¿şÖ˜ñÈ«»UR&ĞjÛå±Õó¢<*Peú˜æq-¶\–ÅZCŒoÆÙ36×j—u:ßfqéãLYµ|¿öéç>:æ'·Xõ“Òk5@Ét©ÒZíâŠêÂymÓ)(‰²;'–oÕU’-±hş\ä‰Šçuš?*,¸ÿìO•š%«8[QR—ÒN0ô­W*/j„ç<Û"Úy…Âv«t¾ú]½ óèƒ¦¢U×Åb›!ÖU±¬wû–EèÏ‹üÏm¥¡ñ.­WÇ04!ãb8IKUìr8([¥ÍÚTQŸ>!Ä¯»¢ü"*xb§énÁàq(h’»(MnÓîj“”ô‡)imâ¥‰!D2¶˜=}‚ZaµÕo.OLQZ¨{˜:¯+¥5B˜òWäwœ®+c¯x–%¡XÎÉĞVü&.Ë“yRUq™fÏğø²D!%òµ%2•ªŠ!®DÌybè¸8cè‰À„.]ÏÒ¯‹?»¬~°™®h<¶ñ®gOŒi­S¸¨Û¨DsĞxcAÈçó¢\Äù<±jú(ù]ìàdœÌÓM
+Ë[LBîV…*a]D£ƒıÈÆºÏ:ß˜ÃqÖª Õ7”2%¾³ªK{s¦P³A P—ÇÑ‡›é^ÛÇğ.#£Vu}<ÙÎşLæµ,æoR"ò¤–ùFí)©)Î/ˆB6‚ÅÜ%œpà,‹ğÍ‹üeòˆTÁ=…ÜÎ»tËâ9Îêç—K:„àæØ¾ª^P­¢µÂÜò+á[BŒŞ\vî°L6%lU6ø™(qÊXˆÁ÷B‘D·M?{Ÿ $–E‰"ØD¢”ˆB™µ¸¶¹‚¬iÙz,/©§ç=e OôÁS(Å¶Dˆ_ Y(´¯äwjccêHMµë.ôö[¿ğKìD; ìßˆNgøÑ aG¢¥œñõ«Wd×šïûšn 9~sÙŠ$ƒ¦Ö=šR@/Šõ:ş‚ø TöPÿ²¬Ç)–K°Â|’®7EY‹Óø¹Ü¥ Öšıˆ<¶‡YÎóÔéüq¯š’ıím‚[ÈT¼Ù TÓĞ°­Y¤á¡nYy„æˆAÄÒ•É•®±—ı-`mÍfL%qIh… XZ¡áBD¹‡¸ê<†I+ı¬¯!”1®Ÿ€ ®PíûE˜ÎJí@ïTÁY€e\œbÊ—Ø¡2Òr ³W_Á35*šº…ä8|­°m08‰š}Îqr»sm~êá È«j$4K
+œ ä[ÛÇÕ!ÂÂ5]Å9F+aÖ,ãşN`ä¤V 0ârš÷]*®ª-Bô@ˆäŸ ¹bušÍ	 ‹64“­r‹/j©Y…èaü O›=EW›e($[4>X¦‘—ZÒ8Hs¬3²Cñ‡,`«!>|>KãYš	!+<óa–ÍJš­nä"@/@ÕfhÊ š¹ãDl¡ªßÖT6üFsÃQÖ¼Èu_Ã„K¾&å<­Xæi-³M"´s‘¸«ÓâpS?!ªÁ@~I^'­™&(Z™Tø´Ùz•Ì·(Z	[êCà¾½ó$ƒm9Sïa±äk¼Şd€7h–i‰@5ã4šs¯H€’æ&v¬)vÖøÈ+‚^¸@8:ªyMÄî(‹továYÏz½›µî>ñşKÅnqzp$I…0iˆ}1«¾äÅ.K ‚Ø [¨¶Ëe:'?D XrbÜ ßOFkz´ı…N`‰Ø¢yÛn»I[jwûÿæìwAW—?Ÿa²òï‡h,£š=Îxø8'#ıVJ®ãgtãEÁBwÌéä)Á>11ír¤ís0DÌ±#	döq•#Á›"E\S¢y	SÎefCZahGSŞ²b[:ÑÎœ @Së×œZµDzÖİïS¢9£/»˜O¬ˆBº'ş°zCGı€2øUˆ\šmïàñ•Áª?1˜àÒİ3Q Í{™iñJ[%­-”IÆe[D7QRF¢/Ä¬{˜Õ—)p™Ö9#,Ç)fÊ²Ù–DÎ[8õ»C#ßÒ ,`‚“Ø:6E‚
+,âuŒÉ•o™`lÁY
+üÖ?U4{18Ì‡Jˆí€Ka'«™‰xNšæ:ˆ¢Â ©,°çê­ã·İA•b¦a7ŞŠTş»Ó•UK2¡’6WwôĞc‘
+÷”AS¤Œ3Õ%\Äx†AÉ I\-•âšÒÁ)Øó¤Dútª|EıN„†öPŸˆ?Åi&c
+QKîÏ¯t·ƒÈCÛâRfX¡´ [ŠYNb”Œ#Yë8ÏAÍ²²}<´Név­æÛª.Özø¶‰ˆÄSn`…×P2Ğtİ’¸Ã5¯^-1àÒÍƒó©ÿÈr)=&7¥Ÿ²nİs|gKjŸõCÀ~¦ßßâO+aöÌ»9Âs6†‰öü±¶PuA×°9÷(İµCLÂã{YÌŒ‘.ğnN½q•]Ëo3J’nQŞ€%M‹r¯GËû…nÏ$Ö^¾Sè’Æo<gøWˆS ÷öH:İ}ìµÖÏK.p–Dâ2Y£{a@‚½#8™bMqÇ˜tVÄÆ5‚’…~ó‹öÆlì`uìóÎ,–K—ıéq2(—±k¨HÊ‹×L6€?3†Œ39&pâ²Ô”Üœ;IpìòÈ˜ \üpI~âŒ‡—x¿8¼ùåL¡Âñ ê• ôÍƒœN ÉÑ‰âöL¥(¥:h +1HL6àhWˆ?A‹«:ÂÁOÍ,°eJÔ˜ÆXRúª (]œ¹ë,ı’À½ŸV)ª®$‡åÈ²wíµ^Æsv8(b?Ğ«5ÖØKÌ$Z…_94I¦}nòIƒ¨'50ö>˜U/Th83”<T”A8Õ(«kküæh·)8–¦9ÛWwM`ÁÆg˜Z ¯
+ÛnÃTş!uƒ}}Í¸Áôã|g-ï‹“S;—»Øf²¤ãXåÁ’uÎˆM0}°cO 7#óHVÁ84 æ="L€¤4¨E…éF‚šuˆø9(B¥^ nØkfx2”ùz©»F©’š-Â­Y¼«¶LPê§-š%d%r²‚“¯Ïe<¹ŞÍªÃÀhMğ{cKÿÂ‘Œ›¹`$bVšƒ +¤vÃ§]æe¬ÌÔcïĞ‡ª»,ãØ§î:¼‚o„£„8 NÈÍä«HŞ ÷Õ£ú8«5ğ	Ì¬ êk”3¼Ï®]+ »ã< Ç‰´ZgD™S>#>S‰†¾ê?€`!}Áç:töÂBêİï
+
+®75z€À€âq;îJœ”B[krÙ&J,¯Òv‹gˆÀ.áŠº,Àe:ó‚ûaºº6éÈ›Ø°>’–Ä ÔğuZL,;¡+EÇ ó’<yÄf´_´£|;ø©á8ç¬)§
+âx•x’ÍqäÈhaSˆ†g–•¡v—ıƒÏßÃŸnœû	ªÖrj`0F¢ş^3ŒïÇ`C/É?¸K(êcp Lzõ÷¨!’×:óF^ç˜]}– ÇW°§@Ğ=nÓZwÀÓN;:ù¡ñ¢÷vó8W?té„ñL«Ş±Ü£y8StsõÀ$ –c˜°“b²ŠAˆ ©[“>DuTqxñ÷¥ƒ]æXs ŒÍ´Š Úè½a­Ç—ªñ,7¿ÍĞ2Ç¸UsY¾­•3ï7h5ƒì&ûç|ßzªÅDA‡ş‰õúÔó8ğó7)Pø/Ò¨şD…ÜÃÉdøYMÂ©z7Ş¨h¤oø¸«5½ÖíÜı	Üõ ÜæéÔ	$E“uÕŸD“úMoî¦V—×xpå·z®õ=UòfĞ¿¢Ñ5j\ˆÇqÇÈ¨ÂG£Ûûa„ËGÑh0|¸ÆÕ¤Fæ0º¦}^×é‰³_³FĞ^Dnsõ`–ÑËhô~A2îê©[Æ˜©£ég®ù>š`	Ú@á’Ç}<ÃşWœÆ÷w“ĞÌ¥ÉEsÛê>lŸÈQ-pŞ¥xÛN¦pˆEa…‚…"S>¡Š€z²Fp›š‰ZËfŠ0ÖúŞª!°m¦Ç ^à¶æÉ¨o—B ÜßÌ¬…UšÉeWó×µŒ?NÁÕ(é‚,]§\Aò–3pYYª6ŠóŞJÊ´°‡òÄ¹UshÏbÎu“O
+d‰EÂ–¶ˆ˜E\Ç½¶yÌöÍB`8¯Ş4­`››~YŸ @KYn7Â' ®•œ»tíÙ5+:­CÌ£5é;Ÿï§ñ?q%-š†ıAÊLF&J¿™Ò]ŠşXš7Wè)&İ­;äÒ¹ŠÄBûzwã‰šÜô‡CuÓÿˆ„øÎi(Éğ£kL–Ó2¸ùi€…H¹aOMîq«?„„HõşøsÏ ÄCi<$]ÿ¶ÿĞa[á–¡^8hphÓ ƒŞM¦¼MˆœœöZ¦±ŞR7wŸÂ°ğ Š×ØÇµ0ûL°»<ÓnBA)€£˜¢Ïİ)¦d0ÑTy
+ÂÃèC(×áQŠùMÂSÕGŞ»„LÚìSÿ³
+ˆ›Xñâ$­â7¶ö+ìMnjâk>	3¢	æãXõEÈÍl+†r‘ÿT„Ç®?âìÙ\½¼›L"†ïÕäap£®µ~° ™Ä;íW—ÿ‹«*á(÷‡ÿu$ƒ@±D#«ŸĞ%Ù6¢5YÂ/ ®O äh”Jœ2$(Îgª T ]µ9.çÔ&–y½ ³ááb ANŒA}‘3t{¤B€B±>t_|µ4!!Ô@Ç`	N‚Øtoö–ğb<Ñ×…ih›½êCmè¤sÆhÓkÀj²ÆœÓôoö®—œü“Oj†×HÒÖaep»ÊşË†7¼*ˆ7­·œ[»ãÂÚ4k®'nSñ@J79áá€t ‡€ônóBÓv)j^ı_êşAó¸%|ëd\ašæS¡o æŒ-ßÌZ*}òKÊõ…=BÏÙ•Pãf“]åĞÄ.êÚjƒuÉØµĞq±ÄÔg!]¤½!³¶f!NZ3°„™;âÌ!ú-Ó·†ìz5Áö=2aG…/ôaAuÆ½?Ó~›x¿7\\höîü·Ø›¼¬ï˜»n¯h1´W^TÖSzºà?aèˆ=2×~˜˜ÎÿÍôÂ:;z!™^hÕ…ïÁ×>37Ï÷Á¬:ôı¡xA› ‚–8‘Q” gÍËèacé5‚	,1³sp€Ç	{sÑPÓG{9C®ˆ	¸ï
+H†¸1®ôŠiÈŒñ¦O¼Äj*˜%ĞFòM£C‚#Â†ªI_Kjùmxª9/áì­J`.öiàhG_JmS`‹÷dÙ°C®U>Çÿİ^X8Şx¦nŠÇxŞRˆ8"èzÙæ„Bx3¬ßÒş8‰ÉãÓáÈÙKšoõğ×l0íÛ£1àº‚6ä´’G{´ş ß†}Ë‘JË–ĞrzİQªHànÀ?(¦À^^:© Ğs=ËoŒÅÈsG€S®ÅIO‘£â‘RãJÎÄ –fZböYìWz¤¬‡F¼`R'¸»§¤´kXôº6/3«•Ê“‚ô¤2ğ`±L4g¨N÷¬ïëë+nİâùæõ¸&7¡¥zc–£·Ó(nõæ¥nÔ©, Ù`*÷8FW·tŸµâ¾VFOÉY&°zM×WºûOb) º–v …†‹QĞp–ÀËâî¿. İQ)§IgRFô]ŠÌ‡‹Ú~±c…c·i…Ã¬Gë
+•o×³¤Ô~vIâyÇMÒØmêÍf»ø™ÓĞtÁˆ œ3µn#_*¦³ZŸU ^ù‡¥¾¦½_y5Öáî1B'8*IÅk¼ÕŠ÷*œ¾¨qôLÂY>Mì:v}^ÓµW6Ûî}½_A‰(ÑßF/„L×·áW9¤ÂÍ-äÎKÊ™BY©7/0‚frJÉŒg8ŸD÷âÃ™¹Ç{¦äb±=¨]7ù $¬VşÄÓıq‡ô¸Ô½J$œªİ½;8Y ·NæB9pÁ§ø›M"Óza¼_ÛeÛª´ZEÅ˜]²e„ÄßiãH¡uŠ¯½¾#i`iaúñÉô´ LıG^qåù¯¹BKÖj£y"ç~°ì¡ùçÂS%ğ~A‹.'ø/?àÌ VdˆÄ>NQåF«Üò`¼âÄ°µ?Ïr+ÿŒ©Ó™@vĞBââ3şä*
+w ’r¹—›ÑÇT0ÆÒf€¦5ØÅÀœx"%Œk¦şÜâÜçºWÉQlQ,1¥aqßµ+L¨›Ì\œãtáœª‰ÿÉ_ŒÿÁó²ü
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/eb/3aafb42141ed4cdcfe6e96965d63129d766881 squashfs-tools-patched/.git/objects/eb/3aafb42141ed4cdcfe6e96965d63129d766881
--- squashfs-tools/.git/objects/eb/3aafb42141ed4cdcfe6e96965d63129d766881	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/eb/3aafb42141ed4cdcfe6e96965d63129d766881	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,3 @@
+xmQ]kÂ0İsÅÁAI§›ö)h…éÓ`°¾ìiˆØ6a’B[ç>t¿}7I[-´irÏÉ=çÜd[$GşÍpˆy¹–é&©eİ
+™nwGït¼éYÖë“¬}„ZÍW‹B~ò²fóïšã.[×ë@%~x·‘Å>.ª„¬ÁeZdB¾;Ö¯…-&ôŸ%˜@„Ñ}˜FP÷èm„À!"¤6.ö¼ŒH´jŒY:ğö’ç¯¸ì1©Ôò,ä‡b"cJå›Xb6ƒç ¢n_®Û††0ı©ğ—°ák¤k0ºıáĞbúg¿¡›~ækwV«2%‹­j0jL§$ßÁ¡¹â\ƒ»Uİñõª§«äşU‹c¾ã¨ˆÕÓ,Íœ2^ÕmEåsA
+AŠÍI¯™hI|[ñNrƒUïÁN”®¹Iß¸VÑ!(H¦yj"€:÷/åÖ")ŒVAw'q†/*ÕÕ¿ Råi«¦t$Kê-y½+%ÄÄ:ZÿÅ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/ec/d0bb46de68e2edb47daa4e60398c204077b7e6 squashfs-tools-patched/.git/objects/ec/d0bb46de68e2edb47daa4e60398c204077b7e6
--- squashfs-tools/.git/objects/ec/d0bb46de68e2edb47daa4e60398c204077b7e6	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/ec/d0bb46de68e2edb47daa4e60398c204077b7e6	2022-01-01 15:09:15.669172591 +0800
@@ -0,0 +1,8 @@
+x­XûOI¾_í¿¢´‘Nàs CÂjÅju†˜€äÎ­rÑiÔ¶{ìQÆ3³==€7Úÿı¾êÇ¼bØhï¢È¸««ª«¾®W{§:?ÿñüo¯¢0YÉæwÓÍ‡Ó›ëipÓ}J”È&ñ¸×¥Í“ü·Bäd¿„9…Q,ó]®åöˆh¶‰rÂA›h½‰w´L·™’y.W¤¤XQšÄ;ÖT“Â’)Wi¶SÒt°<¤Ó““Ÿúøœ˜Ï3óù†ùî7QGÓb½‘Š~Î,áŸŞ¢£T­Š/¿8½Æ¤L¥k%¶lZ¨¤¤<õ£Pò‚viAK‘ÀºU”k-
+-)Ò$’ÕqªøÀmºŠÂÓ
+€¥Ho$i©¶9¥¡Y¼¿›Ó{™H%bº/q´¤q´”I.Y\ä”11ß ƒÅÎH\³Sg]§P,t”&$#¨Wô U5öYEªè@h6UQš1ã!ìÛQ,`‡ç=zÆßÊ­E‰9~“fpa•pêpÒBR‘Ë°ˆÍyÀ€~½İ|œÏhx÷‰~N&Ã»Ù§0ëMŠ]ù ­ªh›Å˜J$zLØâ£ÉÕD†—·ãÛÙ'öàúvv7šNéúã„†t?œÌn¯æãá„îç“ûÓ¢g
+Tà>+xS
+¡l›*I+©EçŞñO¸ÉÖÅ+Úˆ‰]Êè¶	DaÆ–çŸ×ÌçŠ8MÖÆM0#Z\à\PR’ê>=ª¢S£«q,^]eŸŞşD3	x$İÇb)é5M–=;CL_¦¹N“>}ÒÉé`0x=8;ù±OóéĞ»S¸\ó£TwËÄœMæ#”Ëëáx:¢“î«(YÆÅJÒÏ¹^EéÑæ—:i—ë]&¡¬N.ıªI!-Äs-t“.7IR©¤}4²*Y7ÙP0·[‘4©…¶²IÊ[Ö­UÖäøVFÉµ|j2…ÉVèå¦IÌ£u"ZögzÃuªÉÙ¶(ìÒeÛ{vËÛğmq£¤x*o+.?ÍFÁÇÉ»Ñ„ª¯õıÛ÷Áèîİíğ.Ë¯µ}$Ôl<ò,U÷•ŒQuªHÉ*r(ó×Aä£ä_/°j¸ÃT1©<ôj8æ\…İ7èˆ¥;ö/ıNBü;ìv}—ˆB®	y‘IµˆÓå$`‚\M¨ü2^¡#‹*OÅ”›(G.–Ú’+üµÛñTÓ}Â<0Rn;¿èv¹£½Ü`¸–™Zë]¤3®ç$…B±R¨›(¥:ç¤ê Í`İé$iPD+Öø}í6LàN”À`ş™9=ı‹n×¿Aã´XÄ2‰V;‚_•”×cÌXì´d#“ì%òI_tkÊ£$EæC#äÉÀÆòËPÔ3Ë Ó
+”ò@BÇ 0¨Äz›jËÀ›°†/šğé6ÍAARl’õ±8¤t_Ó0Ì%ë©ÎñY[òİùğœ'ĞÌœ0×'|eôĞkÍ‰F(Ï„ÊÍNí®èIhöˆ1`AcÚQ‚6§L_Í·»Š ÉAÏ‡F &d†:<¨ß¸…Ğ^b¿‹›®Ÿlìûã,ô½^tãÒhE=®!‡µ¥Ú“ûTÔ3(Ù€æóÖ^ı.Y'/Z*mÔ4´O··¹C·ÎwñÀ;}jEˆ?ÛF«t¨9'fÕRÛò`b-_pÃy`²êğ [”#%_‰»·*{ÚÇ÷VäAŒËƒˆ?YšGfŠroã’…‰®Äƒ¬ÔEî®#‡¡b^Å8aŠû)³.‘V…CÃVbÚØÑ¢CLe”	3Í.¤~”‚PTAFò` à[7UÅ¶4G~5–v¶â)p:¬í%æ>—s>Ü‘-SÀ·ï("Òˆ&ÙX›°MÖ`q=+Øbt}
+tÇü­ÑQ|9£¬–TyM^¬½])®»ájVÍ8vpÀ¾ıªÊ}>ûöìü?6Eq{%ó%ÆlnÌB¶¶€}ÎªvÖO§Ñ›ªŒ01
+Â¤S³BšL£s/{m¼²E÷y¯ñĞyxƒÚòfßÉÛ”´å™ƒw/t¿²y³Œ©è˜äm\~Ÿq)T„£6s(˜é–>8ş$¦0ßê]İÅ1¨¦özWP§E£Á#¼9»|5tùÅO”¦÷pwöOÑëÉğı‡Ñİ,¸œ__&Á»Ñõp>ÑéÛs†§­“|Qß»ál¸OWyà»Û	¬Y0½ı÷¨38/{8`ç«-1ÄV~.ÏwÃ£`<º£Ğ ßhˆLM¶Ä··Ê¶Y¯šÛ9|ê uádè[R+ Ôé,c›âûhèqıÙôU3´€Á´õN‡Ëï7ì®%×uønëƒßãĞÃ5ùa_å(—èÒ9^¸D¬ç®¯,¶îYeŞã²K³Z_şC?‹Ø.û«¤7ÇWÙîgã»›)êMs±™—aÚçk…Şï?œ3,Wynu9=æE‚ÜCŠsÅ®I0èmâè­ğN3_m$¬Ö³‡ÔîÀËš±‡Q÷²÷ÜÏ'UHûd»În¦Áp<şxeâŸ'¦­ñ³‘ˆMÃô)Uâ+zc¿ŒÑšı¾×«†N9º;üp&$*#XØìifå>qŒÉ¥F¶SOÉë¼©:¤šxÀ»®a¸iëªo—zß3¡ÃS;,1“½1«dnJBsÃX`{qÉÄnš_ğKŒdmˆáÖb?U×6â4ıRd—‚Ï¸¦Úg[: lïé4à’.Æ÷(	ùw"»0õSsSĞva´vûÌšGµÛ† Œ»Ñ£%—çš5ÎNÓÉñ.4o¸o/¦W›y1òÕäíÀœÛgÇã®jÌ}~õÉ6”=’¦°XC¦*8x¯£Ğ^HP^ĞB(Hu†?¢™‡Û‹<Å6Ìx Ü…´u1ŸØó9üÁÇİÌ£üzĞ@ÙØa`2Îš,4_-pÓ&q·:—ñ´û+¶ïĞAëÑ”dß26@›ÇõÙÔòñ\æ®i‹7L­ğ3«eqSÔÉº£{•ÒÒä£{6@W²Ó?‡ìôƒìt?dÕí”YÔ<¨˜d£‘jŞ5İ6Weo+i!Şˆ—³†ó%`¥AöÎÏ¾Û³RÑ¶’–ÍˆÛ2/©Ø2TŞ|*o¾•7ÿTÚJş*/©Ø‹J»ÚÖé'Ò+ûáæ¼Ş*
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/ec/daac796f09863cba5bbd50022c8ba1ccd40ec6 squashfs-tools-patched/.git/objects/ec/daac796f09863cba5bbd50022c8ba1ccd40ec6
--- squashfs-tools/.git/objects/ec/daac796f09863cba5bbd50022c8ba1ccd40ec6	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/ec/daac796f09863cba5bbd50022c8ba1ccd40ec6	2022-01-01 15:09:15.665172591 +0800
@@ -0,0 +1,11 @@
+xíZmsG¾¯èWtt%$À’—Š‘`	ÙT0ÒJ¢sT[+X`KË.·»Hæ^şû=İ3³/°€Ë‡|¸ªD–vzzúåéyğ‚:9yõí7yy¸G‡tëGÿXØÑ”lR¿Œ#»-£Ø™Õ‰S7"ügÓÔL½%ƒÙ<t¢ÈQèØ#
+|oÉœ2³ğ'¹æË“b*+ôêøø»*~ËÏùùJ~¾fê›©ëyîœ:Áb2uBú~®>ühäªá¤¾xlhî"Ø<&¡=cÇ¡ãPŒãg;tÎh,hhûqäFqè>,b‡Ü˜lô2yÁY0rÇKş¶ğGX0:;á,¢`,¼íŞÒ[ÇwBÛ£›Åƒç©ã?rxºÑœ?FSXâa)3®X†¾–®0¶c7ğÏÈqÁ>¤''Œğ7½ª2‹ ¤²³¨!s&¬@¾%y6ä0´õú¦jÈõeùi0‡
+S°„RÏ0'=8´ˆœñÂ“õ`ú¥=xw}; f÷~iözÍîàîÄñ4À¨óä(Vîlî¹PÆm?^Â&,ñûVïâ¦4ß´;íÁkpÕt[ı>]]÷¨I7ÍŞ }qÛiöèæ¶wsİoC}Xê3ƒÍ6¥1˜Í‚Ğ¡‘Û®ÅïàÉÒy#šÚO<:tÜ'Èf‹s–L”ßÌ™×µ½ÀŸˆš Z4pÎÈ“ÄUz] $„WÎ<=ue•¾şÌãĞgªQÁs_¿²ßQøUzß¤ãW'''µ“×ÇßVé¶ß4ê,tÄÕ¾ªÁúåŞŞ_]è-Fí›±qTŸîg¾›°¢g{ÎC{Q`	È^ã$t­qhOf[ø?\Òaòwl?xÎ™™†uÜ‰º~L‡îÈÒÃ{ü7GuÊHF¬¯Êb?ùq8rá‚8—jÖUöşµWR“£*¹gê‡eìDtNı¿İ6ûï®úÖU¯ùö}«;°ŞÜZırôÆ{¬Gu#dTÑó ÖÈù¸aj»{ÙúuÃäTHÃS‹(?h¶÷g{{¥A¯yÑ*ï({J#deHhÃ$.À“ùš¸¿W*íÃ`FÇ<ïãoş~•VÕ‚A”>UP¯jùàÎ0†ú°ÛxÍ,t~NÇ‚…KE¶‡·0…IK¡/BŸ½ÛşüV1ê©åÁaf{^0,‹ÇÄãò*Í9uo;
+øµ~m¬Û®rëÂ J8#£‹­¥,K‚,LÔÆ)”7"KÄ(Gk¶Ìš‹­¹,Ç&|ñ³~Zcâœ®š~KÙ»Õë]÷vjÈb'ˆQzieÅñJÇÄÂ^üŠßîöiŞ¤ña@^$l'1²fÙ…é‘Êè{ƒ4üqt¤Tà¨t>Î±pÇ9øˆN*ôÅ¹¡¥Ò }ß4/›ƒ¦Õoÿ½E§ì°RI…ñ*'ÖÎ“ÕÀaÆ+y?‰§Æ•ÀÔ£ø±H‘î}U0Ån)«T.§vH‡•Ä¦ÊWHñ™ºX”ŠÈ¡C»Wà‘\ë$h«FêƒÇ/³w™@§R•uÄJE¥ñ¸lÎÁ¦ô{p#áQÚ—å”opL ä „Uç}¿’"è“XkgÈÅ½»ò‹¼®ğ‹@kC²É[Ê0ÇHªFL•gföWU‰é~òU9·ùf0+oĞjƒ‘lh‰¯ìØ¢"÷Ÿì1Eiû4IÑ†<ÌL|(ê|ò^){'çbÃNï¦ç´j(CÀÊf¤şÍš[kdF…
+QáóÙ›NKëú
+ƒCIŒò;¶âœ3|«(d3ûz0GN,VWŸkÏ¤˜Pü¦T›êˆ–úAXCH+E®¢A¡şÀ¾¥<…©ì*³ç{Ağ¸˜+íËÙ©Sœ6×õ†WR¡.¾¶æqˆå2ÄxÅïUkƒE03Sù1ù]>§¸PTF§£{AFFğ*iæ‚ì¿Z…sªlÚí4ÅWE¬N-ÊT”¨fQü›t¢µ¥R	r&Á()ÿM³ß²ÚİëË–õ®Õ¼lõÊ‰-ªôBy¥ş`G’®¾@D!‹ã+®)İ>d™„éÖ'»i'	1CŒHí·x9wrLEU‹?ßÓ¿5ZD®:O”åx²¢¤³…;[¥˜Åø&ƒŠÖ_Ì Ç"6jˆ]á¼2œ–‹WRÛŞ&K÷µËvÏÜİ´N¥Š†òe3*Zä1èa)–¨‰%îñzPğÂ™T*Şc¾›œ',ÄkØOê8ÚĞJ>Ö|X¶8©AsUèNÇ´ó  'Ë@WÏşhÇ9	²ÚİŸ›ö¥õks0è	Ñ2È#ÿ†­£”·Mg‡q¼İÖa’"óë?}´ñÅ\»¬rÕî´¶A&t&; Š"›ôZoÿÈğ£
+åfÓáÃøğÅh+ı@tL§kP¤“éUÊÀ3å›ÌÒÕ‘FàVü
+;.ïøÍ	`“”ôƒÈYÖQƒmFS¹pèFÛh]nÔ&ºnÕ³üth¡wÆU4·Cd.®y!·¤f|K‡|ˆä`\VY!/ÄŸ•%ÌY	KÊ–œåíF “A°ó¦ˆŞ)	y#È$l”$9¼±ë?	«|ş\ê€Ò8Å‘îê–ô¸ÏşİûN»û“Bè:xsÃÅ›n´œy®ÿ¸#‹jª"›5>mƒÑŒ¹º×aŒ§ÅGòÑX…ïÙ'™’¶>Š›Âê”Ò‡ZB5Ğó0Œ¸Hu(Büá|™®SÍæÎ!%WVËÍ.g¹Šœ[Q‚\30ùHCläVùò·ã/uæÊ×*Y^Ê¨‘‹K¯Ü¾Ó1şá$V}’=IŠ§vwĞO«]:’ÏÒÙÌ)P	Å³[—\5>u<tîÙ¬z J'm­˜P·çsó›ÎO—­Ÿöieôâ]/-†şÈyÊ9¯ ŞtŠ Ï|?îy†Xñ÷lK{kªw¶ëŞÙ­¼·[{&)R¿óê¯1ó‰ÅàÕµñöŠ³û×?µÉ °¥-oRñç”y”u®Ú—íd×-.Ó†;PÆ$…vnß\|ÎVµİnİ‘3¶^,ıÅ•fò­ÿèÏ¾ªI”h¼ã‚+m|aÕ¥â,Ä	Çİõ~áæ*8© $wãÈÂ…™ÏÇ›•¦Š.4¹GQØTA®Í÷g]İgY?Wê%V™B.iw<,Æc'ü°!»³<Ò‚â~g’ ºÍ÷-«ÓêâÛÉ=²˜eñ¡O®5-«\¶=¹Ğ‘èêv‘0$éè!í•·TH‰aWZAø’txôïÌzˆNÌÄÚà«æ¬×¤Cßy¶ğGnDä`ÜénŞª;ôÙD5‰Ô¦(=[}ÊHÚ´97©Aø­8nˆ³s£zŠ½ÓHÑ_Ív| ÈuQ÷	†Ä¢Øğ„*­VP»®® TIÀˆÉÀ¥ÖÀe4,Ëq#‡íõìGİ“)^µ†î³µîÉwün˜p7ó=º?æ»4Y’İqF&;©)&Ê~ğ¡/}Ø¨¸(-+*•àÎé5oêxFP*á†Ã|Iên¯äqK/ŒG\ëóàÂ÷qwEv¸T“²MÂªº˜»|ñÇÔÃ Äİ;.ñqãûi5…ŸxNìà%‚°Ï¼;ˆèwìia©+Ppa‰ğFAÄTI¯ój',"®^Å _’àfœ0Ä;ô?u2zlsrÔ'DéìõU™Kˆá‰ÂÎèêÔ|w”­¾£¹¼„e9ÒÔ·oÜ–”ª‹M‘N°©;­>IŠC"ÁøŞtekôš­ñŒ‡ó{ÉhÁ•Ğë,ê–é&g"¤2Œ%Ë£jÃÈòğlüš
+®KªáˆñÍÉ£Ç?ÉºI?Ê
+4"—_Zè:¾
+Âş’R3j\'â-Æˆ”ˆÁbi7!ÁÀ.8ô³`b?„óÑë>^T„üÃ³Ã	~Ãë¼şøúA±{Ó)à˜*MÜ›20s ’m¬œ×jªÍ¹ÒMæVºÓeö’>50(y×T‘íAAqü6=Ö7'‰­NÍÂ¡±¾‰‰’EZ–fÎŒÏD,d­áÛ3§šúf*l(†ˆY'9»¥“?ä‡sÇœ{Ï‘ç¤2È¿hà3“>ÎíË5Ò·»õESº¤:†áï©êÛšk,E¡‚JéTk0Á[ŒuÎî¤)w±•Ì#€RIoªˆJ¤,¹¸7“!ë*#}®ÊsSŞ|óûµº@-±<Éé¦{ïÜ÷Ô-&Î¼Z2}(Ö; v™èÉ›KZ¨Î4—ÚÿŠ†=˜±Ê}=Å„Â‡²Ÿ¡ŠÖè%¿)'Ğ¹LÎ7Ôj—uºè8ÖIZÜ6Gß„€ÀÉäÖĞâèH¾&iWQKÈè‡"–käö$+ xæ'o‰·åõŒùÂVÑÓÔşÍWŠ\¼Á+#UBdq­¡ğıÄ§;¸MÈ=Úñóyf«¸À£INà	’g>éŒ´®Äı•LU¡½ñN*ğ)ö2^ØŞŞG¿f‚,º¦‹¤hê$£ÖrvÊ^×g×J:É#XrßgÚ8ÚÊæj^ùkë[#‚%Ğä|±f³BS#å¬¥5Úşh¥XF¸)·íĞ'#z¤’:6/ÏŸö]Jæm‘œäAJ^öô)JòVFyúÅxexƒ’â<÷†}ÂÉsİ)¹'!Û½’¹OÖoBØLL´ñ1——H»ˆ;kFâäU&H4jÍKÿMàà
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/ed/1784d6d11b589938b3c8f11d532cd7d51eae8e squashfs-tools-patched/.git/objects/ed/1784d6d11b589938b3c8f11d532cd7d51eae8e
--- squashfs-tools/.git/objects/ed/1784d6d11b589938b3c8f11d532cd7d51eae8e	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/ed/1784d6d11b589938b3c8f11d532cd7d51eae8e	2022-01-01 15:09:15.637172590 +0800
@@ -0,0 +1,6 @@
+xUÛnÚ@í3_1M¥tm¥D$•Rb*Tˆ‘R›*²ŒY7«Â:²×Q›(ÿŞÙ‹/Úò ö\ÎÎÌ9³,×ÉºççŞtl˜<mB/Ü\Ó(YÑvv§ÑxÇx´ÎW¶½÷èŠW4†À¿Ü'¸{ÎpîzßvrœJ(°>¥!î¿öÏÚÒL×­%µÛÉíô*vä‘ûÒ1B#˜Ÿˆ¯XŒ5cYŒSP(3Ïù?¾u {ºí’ÆÀ|ggã¢Ág*<J6)Í2ºòÙ%ÀO”ğL@Î3öƒÓD÷a
+6ãŸò8¦iTL†Ñ ÆeÚ¶ÍNr!­VãCKy2 …Å@t\ì–o)ğ”Š<åĞ•Ñ\Â±|“”0õóeILt9Ö X³©1Ê¼æ%Â_4ñ]M­>š&°;..€ôÁfG!"Ò¯ëòõ0öãÀ[¬UWPïÅ<c/>òs}5¿
+Ïs= ]«$PºÜÅÜM)jHÏÚbPÊFÓ÷¿Ä©q—i¦‘>CµòêÑ‚!µU·3¥I¤4¤½	[á‰®×I4Êyd]–‘‹
+#vœRªct¥u3¬ö"õE((dò{ €KÌÄûÂ%Ö½SXş4CwšG¨T#R¤Ô–ÁIïhÉ„\rÔ
+¥¯…$W*t^tU60I¢ÊÉxi—F™ŸgtÄÖ‚¦Ò mÿ¤å2õ[JñønĞ@¤W³,/¨?êC.i¥+SF5/¬ú¦‚ÑŒª¡µ+Ç,24¡ÛªöÏñæcGß!–°ÚÏñ“yà~Ù=4x™a¥d(ŸÀ¶JÊ‰¬¯˜›|£‚^—b¡FÌúªlK-l·,Zb—»d:ŞY
+C„&+©Æ`NÔš¬u½sc¶€(-XæN:ªf¢ÇÑ‚Ãš4\µ#Ev±ph°k½¨)}¡×Û+[6õÿÅà÷	¥¸ßö­”»%!œ¨ÒĞ³ÒÑbÌÅIüxœ†ÙOP·Î’LõÏ‚aÂQ[Á˜3AÊ¤–ÎÇHÕ@-”Ôg¥q­=u¶à]CÔÏ‰…ú‚•ÕoĞ?Hgju
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/ee/92f552ef59464c5a7157237b92d576b8f54749 squashfs-tools-patched/.git/objects/ee/92f552ef59464c5a7157237b92d576b8f54749
--- squashfs-tools/.git/objects/ee/92f552ef59464c5a7157237b92d576b8f54749	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/ee/92f552ef59464c5a7157237b92d576b8f54749	2022-01-01 15:09:15.633172589 +0800
@@ -0,0 +1,8 @@
+xÍX[oÛÆ>ÏúÓ8 E–•ôÛ1ÈN,TRInĞA‹+‹Eª$eÇuÜßŞ™ÙYr)Q©Û“‡c$¹;3;×ofy%WğãOÏøÏŞ>_í¨Y¨´½h4„ó8Psğ<ÚñNN{ïNNÇŞYã	®†±ÚŞ@–x­ß·Û{ú_/Y.“xox‡íÅ÷_!yEÉ¬¤ßÓ*m0>î>¾[çÂ8Hn·Ç~|­˜s¯||æÓT)"¶4!ûx)ö—*[ù3#Tw•ª,ƒû†µJ”¸ÒÈïVŠ|3*EôPºøïèÓh½&7
+—²cèïÊ½ÃFcù(¹7s•ú‘ğt÷¨’‚èxdÏÏ;ËÃÆj}…³¤¼IÂ úq˜;.¾/À<IÁ	ãBx	Cü9æÄÇ§O‰şJ©áe[K8Ä­üÿú.W %éÒœª‰¢+4Sr¯¼•çŸ÷ãüy²»åU¡
+û$`Üóú£şÔûõÕ˜ßƒ„´Î ˜|‡#OGG°ïÂK×Îå…Ş»lësŠú$>ëíéôuêØ1hY‚Œ”÷irÕ’“µkÈ ·‹0RP(‚ÜïtÜÂ’7ƒóÉYaJªòuƒCsµd¢Üğå‡0_ı|¶ ²Ç¸´¥#±4<ÿ«‹%0Z^˜chœB6ÃO.ü×D Ü::*‚Èq9W,¢Ì£}x*Laş¸0}-æ(İD³<Ï¬`.éøvw˜†‰‰¨+fÓÏ.®Ô…¾uŠ<€6¬Ó’‡}S2áÜ’öİKÚ6[÷{}âÛ%á7NyR¼pËN¯ÔÙnlĞ	KrĞ©ò?oëŠø–uñ°ÿ4üm`"4=nH)DÀæÅëåûTİ¼F`­¬%™Y’œñVI6ô34¥ÄÌÈuÜùNÇ…{²óÏ-Wxƒ]Ãq¹®xõÒßëôŞñŠH´7Æb$%ñW	c]Œ8@ö9ZõÛg™WÖ<e_!¾|§äÄÄ¶Ù óOÒí0$äW} :ü&/ÅFa/¢àIÊf„æTG»Ï59Sh
+Î†/»Ğt‡wÜèIŒnBş¡’ùµ+nÔégiº”ÖëcM´	ÙXÏ’À…gÚ*ÎĞB¬\0hnL@Ojä'êîN/UNªº]+Ì­ZØ­n]¸¥Ú±u\lõkğVåìLGŞ1õ¥ƒàsÃ½	fIœåÜûÂN	øó\
+°­9a¦cDPŸp~FgV(¤(şÕàĞ‚İúV5•€\†²…F3×Œ2³TƒoĞŒwªY×§	$‘©vu<°µo•½˜MèiÏ£*¾Î4‘ÊH)Yİ(9[$áLQòUÆQ@ŞèÒNuØC@¥iYdVfÚĞt5Hn	tq¤Œ’[¶/hM×öĞÿŒ3ë?–;#wßNîYx½Ğ‚½>²àC°úCYâq"Ú˜ÅeÖìŒ7Ví"ÇŒe9Ü x;(Ógf\¿çB°=lXíÙÀŞ+|UO!0ZXniJ[b±ÌÖÕL¨ıvõ²ö¥ƒÂ9ö+N«ÚY^®Ša¦TŠ*µ]ì‚–PĞ}ô	’±¾œdÔk¶ûHÑsK
+-`ÂZbKï’öĞ B~Ø,ÛêÛzZ¼õê(gi«fc¢Ìuo2+•æ¡ÊºDˆ7w¾¸O¦Şïìõ¬ıx’ã²Ü!/Öz‚½Ù¦™¨ß×*ÎC?²%<QqÎË“bÎãOqr÷—+™ìÊË:x‰¹·ëC¶1Âdœg}¶…^!yx±bÜÑ5ty10.Ô‚Ñü…ÙX­lvR¦æmçQTû¢ê>†ª3Hâk›ğ«–¡ÚÕªı[ü~%¹@"Õ¾‰çùXôã4!*Ê·]ƒ\Â‘1Ë›u„YîÇ3ŸÁ§Ó8@	Cü†ƒ¨Õ^Eáu\ªÉ¯r*E‹,7!ï™©Ø¢©!HÕŠsYB2°zÁŞVùNÃN°¤Á‰}£/È¼·ıÇ«Àdøh8ñğìâwÇï‡NË¹Aë¯(^ª–~£v‡ô‰äÙ>,•g€¥É2.ß6oue+VJ’ƒ~|Á¥F5L~âËÕ-œğW¼€Í)ûãëÙøtr>˜AÏd¥ff¬¤9	Ì}
+%nCÍğ7ï|ôËèİ‡‘×¾á ıpVZæÂb“øR·YÅ§‚b¨Í<QQ¦ğ·ªÛşãtÓŞP{j¬"ågJcWf}ÛÄµv…/ìY4öéel Õ)îM´Î*Åõ{æ+R»i¾¼<ò2x„IÀ¬ú4Ã%ÒóÍ@\¤K°<:f©…'O×J.Çt=–R1â\í{¹ã%ïª¯éñ8œˆägÇÌh\aoT|…^ÅÉŒl¢Ù„º%€IK‘€cv1goô“¶9u2=NÏŞ8”ÓcåG®ÓßNh†V[¤Ó-¢"å I%¤»§¾VqUc±;õËU"§e¶ÇªìÛ×ô‘¹Ïh®ä³dKçÿk}+ÚÖV¸ëğıSÖl~îã£ Š¤:cÿÖåO&ÑL*‰Vúw…_qUƒp–‡Iì§wäotdE1¼<ššCÏc{ÊTÀtŒo¾?Â\ß`CeÛß#W¦ÚF»:éË}\ä”ÖCûˆŒ!m$m´>ÛH[
+Â|\‡¡iÛµ…s(Á,£	dlÃ'SÖüIL–áÌ}„OA€›0Í×~Tâ€Ã<Î"„‰À¿ ¥†T
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/ef/c81ea35c1e85997dcdca69d7359edc75ed36b6 squashfs-tools-patched/.git/objects/ef/c81ea35c1e85997dcdca69d7359edc75ed36b6
--- squashfs-tools/.git/objects/ef/c81ea35c1e85997dcdca69d7359edc75ed36b6	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/ef/c81ea35c1e85997dcdca69d7359edc75ed36b6	2022-01-01 15:09:15.605172588 +0800
@@ -0,0 +1,8 @@
+x…VkoÚXİÏşÓ¬áÄ Û…Š¤ ¥…‚0Ù•²ZY}“Z56²Ú„òß;3÷M6Š°™;ïsf.OqúíNçò·‹3¿-ıÎÕ 	Ôë0~œôáşë\Aíîş‹Ã(.D¨†"³ÚÍf§Nÿ­ÑKšÁÌßÄéÆš­Ÿâ(€0]úQg–õ{”ñ:p“Y”¼4¾ß–„'û°ßOÊòFã¢ÇiĞ@±qq‚Ò»Ì'#'”9»Ås”pŞôaáMÿÌ‡ãéß,øÜ_ô½Á|>[V^ø¦ºI£ÎÜ7V“ßVäÑ›ğ
+~Ø°…ô`Õ…Lë,É«Ô&%»»Š/÷m˜	±÷$]úa˜‰</ùš¼²>(¹©làÅã8{JæàÙÁ®‹íRµX+ÏQÍÃ¡;X@­…è‘Ü›Í§3—ÏìCƒ?ıÏƒ9ŸAíˆ“sèØ–%…b‡'Ñ¯İ½ÎB‘¦Qüm,‚4É*y|§sğ\Æb#bFIqÙ†0
+
+ÛéğÙ3“m‚L³­-Z(4Ò5ë´±!:^Oe,i#B·È„¿dyšÆ°Î…¤.I(.1s.òu\ ÷QÒ¨2C¶¦CÒ»WŒšeé*‡}’¸,õFITÔNùÌ¦C~kpUè˜Ÿ{±.Oô+â¿.Oš$Š¡fê¼aÚR6*fâÑüQaËJTnDNÛ|õPÍ)~ÆÑ­E"¸N¢ósõno{„>ÙÔÿ%Hô/3!ì‚\î,ü¨B¡+3HÅaøÀ0GãrñÛ”›I]0ú”…*Å2}²jÊôäÑ‘¨Š§¶Wf û§¢(Æa¦Æ))¨i7=&²k K±V¯æHuæ{9Ì;¨STdÇ­êâöÚ~÷îÓd#²BÒJ+˜\KÇ‚òà58Õ†´”-%À ÈÔ$-£„¦MCƒ3D³ò„0r9."ÄÃ¡ç˜%×€wÄÊÏs‘‘›¢ë?,¦×¬A=kBğ¾PËÇˆ[(&şA»¢ş‹ù¸<
+‚nèÖQ^lˆrÌ­Àû§Áğ^¡XDïd½œÉ¬ª¤ê•IE)Úğ	.áZªœÒlñÉÃP%Yuá~p«s¯ÌĞÊJ«C«‘Ş›£é*W|ÔÇ..&Ö>´ˆA-Ã
+65“&ÜBNOq€±ê½´n8 ¹şŞ	Ú|¨b®à	·èDeM(5Å{ß=XdkÃp…»,‰¥6)ÖT£İ¢€®öé¬zjÚ,o
+x,ä§ÃÅs]È²­\Ûï5Œİ’¡$4ËÚßÆcÔP·ñşÍL§ªº¤*”;i”®İİ­20¸ìÒdúU+é'«­ÜZ2ˆ‡*hÑÀK+à°‹pÓ½ ~ş,_ˆÿ“ƒY‡+©.‘wÜ(kWêÂ¥2ıº?ÕUÈ§üä›¨É—N•¹8Ş-ï¦¥t­ª{«t…"äª~
+F+—¨ßgÕ‚½«{aŸz×ÚY¿ 0}@q
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/f1/31fc89e68fb444c13651b1ccf47e6e93a46c1a squashfs-tools-patched/.git/objects/f1/31fc89e68fb444c13651b1ccf47e6e93a46c1a
--- squashfs-tools/.git/objects/f1/31fc89e68fb444c13651b1ccf47e6e93a46c1a	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/f1/31fc89e68fb444c13651b1ccf47e6e93a46c1a	2022-01-01 15:10:59.989176882 +0800
@@ -0,0 +1,12 @@
+x}Ôy8Tkğ·ÈXÊµUSq‘.54¶Š†ÊJöcÌÌaŒÑœ±Œ½,!
+·ëAQˆ(7…Š4"Â¥’¥•’<xjHQ7Rºgj¦;–{Ï?çŸÏû=ïyŸïûc³(U=]#} ‹ÅàpªÖ{Ìğ¶ûñ ÃeEœ]¢iAõqå÷Îª'úqXäQµvµÙ	¸å¡GªÌj
+´B´`}‚ú†¤6A‚‰N¡úøQ@G†j‚£›şÕ¯R“A·mwüNsüF†7Øì¹W]½ßõ¬ÿ¾³¨’½yÊË9YD"³}˜şÉ@?ç¼]—í{*>(WÕ ›IÌ6pÉÕ)øt¤åãšKÓ4´“|S[ocœÀIdˆë
+¤"/?˜#¡¡mSú$cÏœÖª¼¨cò±øÿY ÆŞñ˜4fÚĞq(åÛÅ¹İ˜÷ÂLF ‹ÃLÜnÚ\hæ,ıèÖI±Â^~I°©u¾ƒ€¯y'k2s­_Õµ‰úSNt~¾Ø1£°XH”2-–WĞ>¿D¯l;'KHví~Ó  ´PŸ b0‹@áåëÌ¢Eb)úOtjD¥¬V[Èh!	Ó3–¤ƒuéå	¨ˆ¾şø}©İéãOe"Y¨™C_©}š
+Ÿò°Y½išºj&]T@àæ»-k²ÒĞí©½­Å>JæíğÅ‰l«*|Fæ+;ö…^¶­Â9‚«…¤]ÑÈI®©u·>Ñm
+"vı¾éêÉÖìÊŸA‰ìº}-wmù\¾|Cœ«‹#ŠÊPìXtXoX}:À¡*W¢»ÏjÍ[ñ'fŠÀäSSNä%ã+ÎÓ8#Ãı3¨/fµ£@DÛî¯“%bÚkI¯Ù¥òr_tA‡’`ˆÊ¯Wü$¦ZSÜ±aÓgéÂ²™ÄÛè8aEŒ#WÖqTnÒyù»›œ=VPJä°˜d¤TD*‹DcPü¿·–ƒÑ2–½ævqOxÏö¦HÚÒæiÿä`ÒûtÆ}ÃÆ_›Y<ÚkØ†Éşü/§ñ;ëEâ÷'3Å3¦Ëu©6tãÏ‰QÔøôÕı@Tl5ËİÔeŠ}öÌšãé¼[<õ"!„)ŞüM‡$^òJÃx¥‚Ä¿){×£<Û@ îéßÉi®ˆZ”†“[Õ©Xô JR`X’7‘?A(µ W`˜ì1#ó…s00<š–Ïbü³N›~wt\B–wWÁ·»Óâ\fşXXşY0r—²»´Q^%k[¶v•{yùJ7VŸM
+!±Ù,~Ú.9æÁv´Œ7w‚WÁ+V7­ı	a6“Åßa3]ßÆFÕÊó’Z¥¾’vÇÖ9ú
+gÄR”¥è½.ü–IÚInÁØ. dT°‘˜Ä¾\³¸ëUOÚIGepWÿ2ô{«)* ÙãÕ8…Y/«ãÈékpMøò­QŞR(m#’‘ñCb#ÿsù·÷Ì5Blã |ÑPƒĞ–rHe.FÚ	­îF%‚ôÓéR:×
+F…Œe%	‡Ÿ°ÃD8˜€Ğ÷µí÷?8u‚Òæ‡¦ƒFÑ\Æx¤0“/È ßÒVOÁ–¸åXPR ‰oÓB]ˆ@ÿq:ºˆ»=Ü•¤§¢æE-VìŒ
+¤ª)Fsç:=Äı‚™‰_µ›÷,®Á3şiâéëw¢M7Ìu›÷°Ì)oØe|Pƒêüš3ã:‡æ:âF•r˜RñÛn¸qíkË»Û-Û4Ç}¿²ÃSØ³b™aWV#¨,‹¥­{ìp™,PTÎÔ®n‹U)·¸Wd#%·mr>†ÀÈƒ‹Ğ«ÑÊˆ¶ÆÉª;‚¯Ïİ$&
+&oË«êr‰¶óòL™š‰Í—R×,>é=/ô†À$áë¯á­&øÂÇÜ&ÃÖcî5óñ÷Z#‡àòáÂËâ¨ÃE_;Ş»”x©ú:
+´TRìîßEËÆê¢›ê»^¯pSX<‹@ İSã€\e2^è~“gí?ÆÚš!$¢sw8òNFz½ı¶ÃôA¸’Wâ£²Îóîkàok=±7–®ŸhEÙ­ı:¹_P
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/f1/becfcef457d200acc7d53ee53880bd7925f27e squashfs-tools-patched/.git/objects/f1/becfcef457d200acc7d53ee53880bd7925f27e
--- squashfs-tools/.git/objects/f1/becfcef457d200acc7d53ee53880bd7925f27e	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/f1/becfcef457d200acc7d53ee53880bd7925f27e	2022-01-01 15:09:15.665172591 +0800
@@ -0,0 +1,11 @@
+xí\ßsÛ¸î«ıW`Æ/Rª8±óõÆ—L[¶5‘eW’/ç™Îp(	’x¡HI9Q;ıß» H‚w	®ßúâDÔî·àğ?4uı);}ÿá§Ÿÿrä,¼9_°ñ?»ãÛë±5şÚ}°nà¡ãñÒówoÙ6şsk‡«Eÿ/ıÍ.p–«ˆµfm ~ÿ·øû‹ø{ò>ş{ÿı ¬Vë:6ğ·ËØ¯ùàïa‚zìËãí·O	údå„løËÀ^3øï"àœ…ş"únü‚íü-›ÙøÜ	£À™n#ÎœˆÙŞüˆ€kî,vâÙÊ°hÅYÄƒuÈüEüáføÈn¸ÇÛeÛ©ëÌØÀ™q/äÂİ†èâa¸âs6İÅ×"‡q’»öØß»`Üø€=ó „Ïì´# ü€µìH¤0#Ûß¹6ä‘ÚåUÅš3Ç‹Ã¯üaP¨ïPlÊÙ6ä‹­Çƒ:`_û“ÛûÇ	ëŸØ×îhÔN.À8Zùğ-æÊYo\
+•Ø^´ƒ:ßõF—·àÒıÜô'O¢×ıÉ°7³ëûë²‡îhÒ¿|tGìáqôp?î36†Zâ ºNÙÀÖ~ÀÙœG¶ã†iÁŸ %CÈÎ³•ıÌ¡EgÜy†Ül6†¶–ë{Ë¸˜‰"ÎsÌó£û8@È+²Ğ"mÕ”öÓ/lÂ¡z8{pígoÙx+|ÏÎ€ÓŸı0ò½»ë²÷§'''oOÎŞÿÜaãnZœ”ÎVøİŞ¯ ıİá¡ì?k{ø¡Hbæ{@h{¶ba´E[¨˜Eà¯ÙÔY2îÍà6ºNA&òÄ‚¾Ë,ëóÓ¤gİ®z#öñ£øÜ¿±zÃ«~wxxäx3w;çì×0šC‡>^}:ä?€r{ö9‰Y.?9oÅßtäã7íÌììÔÈìüƒ‘ÙÉ¹åm×{¦ xDE¯gşAo¿õBgéÁ€uĞ§*¤ø•J){‰*¨šüÊ<&cü'‡úÉ*Ã¸2›¤r2L™´O¹z2Ÿ³Ó¸À™H°Ú#©¢,eÿVq^?>ôFÖçÁıå—VØaó‹§‹ëÇáe›ıûŸ‡ÙÇÖÙi‡I“ĞZÛKg£ øÍT¿Ønx`M]ö­}A8;?ç€cì{t4ÎÅ^[„Vä¬y„œ{œ›:ÿjè¿ìåš{Q´NÎÓš›ùëMÀC1‘ÔÉ_Èü]ÙÌ}áÚË†©{¾åÌú
+ÂüáÍrgàL-çói…¾Y1åêWşÓ]ÄC&bèÆŒm)gnEöÔåVÙÌUM0~ØQ@å¿)®ˆ—ÃÌ˜È#?Ø½*íO/Gr}ÿÛvSç?‡Ô°xÕYıáUïwóAÑ%ú£ÜÀPWÀ?øŠcfÈA³‘;:–ÂÒåüÜ÷  ÷W=ë¶×Å¡+¯‰.í6ÈH:µC.{µâ6(ô½Â+Pò/òß:HÇ4¿lâ¿7!á“‘.5›ÊŠé4åÈ ‡âĞÚ¸|…öt6³—4§±;ÚÆŞxcV»µe5DN]T7¥1Œç:Ş·òX€ùÓL¼à=ÿE\0÷GÉ`î³AãoD†1ÌqB˜Ä¢Ì(€¦ÔUï·W\æüù%ƒ‹±;Ê'coœNÕîFlª†0&“1Á%cÿ ,ËLÂÜi"^‡I.–EîV';ÌıQ.™»ãdÒø±IƒaL's‚Oæ 8¡Ìı©±#MÉñÓİ ?üò
+ã[¸[‹ùü%c\-”›µpzê!Œª‡1&i-(‚§µ0Rcbıˆhhšt£ŞÍ+.àË—ÍØ%š±7N²jw#‚UC“Ë¦òıİ%])O­ÆşbrdÉ`áˆ…*t=Ã y=xb»Xuæwc”ÚæáqnküÈ­Á0f·G­`VÒÛ¦‚[æ áÆBd½H‡ [ˆYÀ€î§æTG5G 4Fpº›ÊUÎÿõâŸ\z„u½fkÆîh5öÆ»hµ»Q­†0î Æ0•ıÓ…èõBUÑ½1¨n¡PFØš“Ú§<b0tß¼Nçp±,êLaÆşh÷0÷¿QÑ`÷s‚Üæ ì6©ì¨æ0Õ$×á¨ëX38ä„ÈEsªÃêT¥æ1Œåt_]µ7œŒÌw¯¨ÔE`C‚]qÇJ;Wuâƒ8›îØ9ÿİ4ÓûáÒ¼àW]If{|ªy†ˆˆè¾ò¬$»õNJ€.óõ¨{sÌ0c‡¡æM Æ“Üà…7VÙ™Îş÷îdR›Ø8·â~†&¬X'¼ç©Ëö·î@×	I«B>Û®èƒº€ı+]<Õ¬Äh#‹èÌ‹]>×”D7ĞúUO†Ó•Nkz5X}B&ŸI!Ë›9í³çù¿{“?×h³œ¨”‡ã3pj7>–È’#’pf?Š¼­} 'ÈÌ¬zm¶x”£Í0Ğ¢Mr†ÄOMàĞ¸­6ºy‹G@Mµğía<n«nòàPSm |	€ÛjCÛxÒ\]1Ãƒ ¦Ú øš·Õ†@_™ğ¨©6 şR†GÀmµ!DbJKâĞE#Èœò¢1sFZPDÚàÀˆ¡|_y$Èlo,Ş73ÄM5¯Mm!P™gQ)Ğ£»L@Í¼Ui*+,Qqñ¦ï©OW/îÂ‰5¡ÒÜø€õ wt$ÌZ­äü|»¶Ûì¯pCB¬éû‹–Ôu±{»#'±e<§só¢Ìgl–iEÌ³òá$+í½[Fƒûá%şŒ-s’ËªpO)ck|ú²—ÚÃíšxŞ.^/ÁzìàşşËãƒ<çÃl
+×¿j EÔÛøö~4Éå”İXˆÿƒºåê×äŞ€Æ©¼ôúHr P™KÁõñ]ûà KV>Ø7„[EÃôÁ¾!\¡(¦*õ¥ˆ(ŞnâË<ú²?Œ{YAaâİº`kˆ–ø¢ãEòœÌâÓÂ8jÎÀÑ86bh£¬ñe;ÓˆrÄC †¦1ÊÚQ¶3€hG<bhWxÜÖ4RY>âQÊv¦ùˆ‡@McÈ.•ß»ÂC”íL# šÆÙ%jÇÎÔÁL•$šZ˜¢fseºûV¦è%™$­Q›fCsNMâu‘3¨—¬“•™J½Y'ÍDMV%š	N7›¬Hõ&u¤şöS,&ÙGué1Õ Ù—JNeÀ:õX@V^FĞ +`Q½ÍZñíÈ¶J¾P×1“/cS,AĞE\­TğXaÄ_í!db0É:´mækIHwß+ë9ê5»Ô©´&êÒ
+Û—«µ
+
+µ¶·Ò¤y×ä+0¯"õT‘æ• ­p,êÑ¼{±Ê¸—øaÑ±p}šå×;ìmÉæ5W³Ö¼ëİ]>¤ûIb^Áªîî!„ˆ%§œ~Ò‹d²g×
+"¶:äı1** çB•¯Q!1AØ$bé.	•‡M"–o<P!1¹Ø$bé2M"–NS!)!Ù$jz6VîÜ%ÛƒT`L[6	Z:ïDD•f“ˆå3ZTHLy6‰(G€Üy** ªC›D,ïßS!ò´I(Q8¹ß^B‰Õ¦14|Ìfíı¥ßZcõŞæ.U¢‚Øë(±&«InÃUW\AÙ6"öa«KRX|mPØ
+­‰Şæ¥T˜LêÅ­‘A.Íşí²­îÉguSH^û`Í×³Í®%ncãúP®À;÷¼à×zR©%~¾…dEª1ã•QCh|ªÁ‹b3ÆIÖÔI¸ìGU T§?á§£lfÃTaÏáWª<&(CŸÍ}ñ“E+~ĞS¦‰ü/,B"EHÌrÚ’6BÔ!m\Öu´-"Éhã²˜¢mDã
+†¶/ÚÑ´qy¶§m‘‰š6ÎM±ÕFé$I[íÏr´eaŠÒ™Å{u:£x¹D-û§›>	•e¼tıƒ4ËÆi:ZVÆÂû7‰XÚªxCİ{§&1óoÏ¤Q:†UÄ+RÂPüVØ"ıç¿âˆAÌ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/f2/60ab42afd5a5d3479a665d74881d48308ec546 squashfs-tools-patched/.git/objects/f2/60ab42afd5a5d3479a665d74881d48308ec546
--- squashfs-tools/.git/objects/f2/60ab42afd5a5d3479a665d74881d48308ec546	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/f2/60ab42afd5a5d3479a665d74881d48308ec546	2022-01-01 15:09:15.653172590 +0800
@@ -0,0 +1,3 @@
+x­UÛnÚ@íó~Å(¼Øš’*’$ Ic©A‘qòÉZğÒ®0v¦¥ü{goö‚‚!myñzw|Î™³3Ã$Í'Ğé^^¼kğY–°Äq8¼¾¹Çw¤ï<cöiğlš®'ı%ğb˜'lùşë	!gÍòƒp£ ŠŸú!Ôü	Àc0Š>iö…Á•^\³©Àm÷±<ğŠı ~-^ìëp bKºıü8¾«×$””]%U‰-$½o”I%¤yFPŸAÇÖòé&Ñ¹CGëÅ}ş¡“«Ğ‡e>ÁÇ=æx?[ĞŸ<Ï>˜EÇİg¨Ğğb±ƒ|%(ÜÑîöz0G>ä’Q^ĞT»ĞTÔL Õ:T¦á5@{‰µ Í¿OŞQû
+LÒ[^€A£*)“Áñp%†¸8Eç[®A[æzjß¡EQbT·	¾+æPN
+cs(¬ö\a°tÅjÃjÆKmÌ¡Cã‡*è·¸P!}·mœo¾ÜCø_AXE&AÙ»uõPe¡W¥«@õêû€º¿fÆæTˆlz5†}˜Gù·'š®Ùn×+Â«„ªEõ¨4ÃÆ‡®¿!ÈÆÅ’ÑEÈh2øU0‡gñJî¸¢wJß´Xì©®›­Y¯æëÁñêşU?‹=h·ëi°,á3¤WÏ?:•º
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/f2/eae09e1441e30486867591ee3eb788d1a14816 squashfs-tools-patched/.git/objects/f2/eae09e1441e30486867591ee3eb788d1a14816
--- squashfs-tools/.git/objects/f2/eae09e1441e30486867591ee3eb788d1a14816	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/f2/eae09e1441e30486867591ee3eb788d1a14816	2022-01-01 15:09:15.629172589 +0800
@@ -0,0 +1,6 @@
+xíXëoÛÈïgıH)¿"Én“œ“ ²¤ÄD-Ù°ä»Ü©@K«3!ŠTIÊúÒ¿½3³Ë}P”âûX Æ](îÎûñãìŞFÉ-¼}ßúÛ_Ş¼Ë ?¼«Õğ×«pOÅÆãËöèÊïøíñøŒ7p5ŒEi£ö*Œ'Ñj*`çğğş¯“,Iü¦ÿ„?ïv¶S–"[£:ÿÍ	ãiò@[µ8XˆlL ]ãA»ß^¶;=x®Õ²<]Mrè’©8©ÕrGğ;ìòã2	ã\¤¸K.jOÚ×£‹ñU¯ñs¯´3¸èöÆÇãS4tYxãhÓFkûÆ´Ûõ_JÊÎÚÃ³ñQÍ˜~íÇùQ:>¦âÆ¤ÈœØf:ä­“ÚúÎ£wæ…ú¤öJD™(	U.­³²/Z¡[9±.Ù5Êâ”~+÷Qõ+OÃYñ¨M’8ËA9=¬ä™³øYøo‘Ì<)¤»ğî¤ÄÒòÉİ0Òüç Z	ä‘Â¼f>| ¯,ó šõ*ƒiÿ5‡É]ÿ.`^Ãeæaï£1–j˜C˜Á*Sc 	Øhı Œï~“îÂ_hJÕõ³+²	Æ!ˆóŞb™?–¯YÆbÅ¬b4:†	jÏa¥‰:EëÁU[1Ø/TK·IŸ±V¯ÒªgHE¾Jc°DÁÇ07™'ğİÈ!†íb>¼@
+¹]Ì§mbî“pŠÎEáÖ³ëÉfŞïÔ+ÆÈş¯ãÓ_G½ñĞÿñcC“hcÃ;Œ‡›^,ãáê–*Ëñø=Z)óıv™G…LĞ ¸f’ë‚3À¿-¶24HDù%Ö%êvzY½•úSÆ‚
+…‚Ñ¤¤–Tñ)w3.3i?ÈæH®(%·lûaµAÎƒÛÁ€,ëØx¤O&mr?áóÿGRSå æwvc+ÿF|PàÔ@<æŸS!È.ÚÀ2Â`8¸®ã]µ¬?Zâe0†ñï7-V¤"©l•éÜï¢7TZ§O9â¾,^³:ÌS”óÃ6$GrA}LÍ®£Ş×‘·s¼Sßş¹YçWÒ[/~´Aº‰äšuJzóÒ[Zz•›JPã‚š,Èş†uorÑâU]‰Er/H´•&{k-Wöã˜ism°Õ&q²Ví¸M^H$ ³Rh“8¯L,ÏÎ‚ìî¨ä-¯­¹©F$G™æÆZl»†XRT%U;å)år]H¥×™`'Êí¥×µ7¦õ^ÈFÍ
+£ŞubˆÊ­Ø©ö/EO­j c!‰¥ÒGálºátÄª€^V´$¨Ò*AVPyÖÖø¤¼°FvD'$x¼X¦"ËÅ?‡øYNqÄÚ©ÃáBEuâj9Ø¸äZ‰V%ğìşÜ:j¾m|şûûƒãF§yĞzû®sĞh~ızĞĞßkµnï³?è¿\û]N-ó¡ßİ‡Zã±`ßÇX“z’z6ğ­†:-Ì†?xÅ¶ŸëærÓT0¿jw…•ÖŞh°ÿâ°K‰ğ}ŸÍÖ‡-¬¿Idt0Æi8	œb–«Û(œ€oå`¿zy(òNE·ÁdnQtúO×ñ<Nb±¤õ9ûÕI*×ƒ.~ŒışeÓ³UY2Ñ>€á¨ÛïÎ.º‡yİó‡â_+çaù1°Èè¨Å0öh*Ü‡+‰ ŠÄs‰¼>ôe’ÕKëcâ½_DÎzCå|£²|tÅŒ=yä`Ü¹ˆúıbràh/Q¸@§Jf[¢°hÚ÷A·FÖìô:2MŸîÂ,OÒ§!š°6h`ÑÆ\ˆe{:=]Íf"=³$EÅ¶ ©©<¢Õ[ÙÚ3<vo±÷<Á£”Â´M»S4*ÀTVæ”	ê®‹'—³L(Vn]±:îŒ’Î*M±Š¢Ë| Ù¬_ßô‰+Kú'ÜÔ¥.óıç÷U<Ætê<“±¤ìËVœ°©Pœ™aw1¦Ş5+™3êO^O«Ì$§jR@&‰æ˜u)ÛóçÚ"&“©õğéNš+!fªÄkOQáj¡‹ó Ÿa1.¢…oúj.† uÄ4d­sä>wO;O“Hp¨Ô>:;Z,OTp•BÀ×N—yúÁÆ‰x>¡â7“ß‡i£—,YæÔã§Q2™Ë¤;\Ñª$´´àÏÂ$Ü4ˆd­c¯[…A°;QøˆEˆ¬\šÒo}VÑ‹µÃ· \ûH¼!s,c„M&‡KS9]X¯§ú~A79ƒ5
+ÕeI§Z…‡ÎÒR8­öÔ+±¶c¬tDØ2/±•[¨T¥­ÌV·&%Ul¥­OZ\”'Sÿ)[TÉ­ëÔRÖbÂi.ôò!`™†÷ˆÁ/l‚,~(DĞ¾²„€–ö‹››]~U`¦€îù2¿¿^\éXØ¤Å±Ö,RŠÑ–gôÃ]	Ïc1È
+¯anŸ°ëtËÓ ò‚@Ó~ú¤ÏßtÜ¤²¡?Ş‡M›–IpPÁOwG²ÃâL¤9ÄßÕğr)Tâ¢…· ¯ Ş,4ê¹çq#©‘º*ªÒøªd0R%™yÇÍ -$3>•ı{P¢¬{{R®>Õ„3ğ,5c#t»	q¶*Ìeuhaf‡çĞ¶Öa‚=ºS¤,àPKÕ%™Ò>s½•jEòØÄÑ‰eqÁ?uáÔËU&9qâ &È×8ô]…8Ã•½=é<Ö™¼•ì&üvH¤ªYPLõ%;V-¡ğó›<fIv§|+­ß"ÃP6ÊÔc™Ûîî-•Ç\Xg¦«á Ã`^ºíÈèÏ%Í—Ú”ó²h7Ò8·b¨ÏÚ<(îÚ¨X—Giç"˜Qà½RâÒ>x²3T±-¦Æ,b™“lîgeX?ŞÉìÄ	ì9 ävÕv#/+aNbXÑ	ªLô1İ*“QŠ×0ÍH ¬ê.°ZŠŞ0"üÏÃB”ş¨â/ÂNeú b0c âÁÄ€™ê;)¦©²›À¼pÍº8øçğÊàÇ¡éEö¸ _t Kæ}¯Ñu8¢]%É£Òz4ÄL
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/f3/5fc649caa663f20768b1bc6a979d59b26f733a squashfs-tools-patched/.git/objects/f3/5fc649caa663f20768b1bc6a979d59b26f733a
--- squashfs-tools/.git/objects/f3/5fc649caa663f20768b1bc6a979d59b26f733a	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/f3/5fc649caa663f20768b1bc6a979d59b26f733a	2022-01-01 15:09:40.213173601 +0800
@@ -0,0 +1,2 @@
+x•KB!E³
+æFÓÂûô%Æ¸(E›@H:põ²§7çœË­V·ı4ºˆõä(LIB	~a«Ï¼¯.à“	ïñjİvıH¿µ·¢_epÏ´\¹ÕûìNÜÁA`Ï@ f®óoÈÿ¦‰’[óø~4ì
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/f4/ec1a30cb9ce532777c2e8191825c7f6d170d7f squashfs-tools-patched/.git/objects/f4/ec1a30cb9ce532777c2e8191825c7f6d170d7f
--- squashfs-tools/.git/objects/f4/ec1a30cb9ce532777c2e8191825c7f6d170d7f	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/f4/ec1a30cb9ce532777c2e8191825c7f6d170d7f	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1,2 @@
+x…UmOÛ0ŞçüŠ•PÂKnšDG™ +[µA«Ä¾Umê¨iÜ9°¡ı÷İÙNbwí&!ÑäŞ{î¹Ë,3èœœ¾::‚Q©.*ÖNV« hñ<ÉÊ9ƒXÍ/ÒçöbÇ}I¾eš2¹ö¾İ>Â¿¾X.E~t‘e"Ñ3!2è×Aİn_²©báİ0Wo:0Ó©bş‹EÁK ˆ¼P`×<¿ÄDd‡œ¼GBØDÁx^z€“£<{•abRÀëÃî.ØgS¨ç$0	%S¥ÌAÉ’Q†+ÉXÑ//Î	sl!$va/êv¯ù\sã´ óØ¡‹¿ƒàQğ¹G )®ÙÒùô³s1aİãÍb¦b…cX†Ã˜ı(Y®ø4Ã™—°Wh£ÈÄ<`2ócsÆaÎUèŒEa  G_re^8|iŠVÛJŠ„›Ûq#zL~ä‰Âlé4+4ÿ-ÎY
+“›Ñdğ½?ßG71:¤²/P»=ˆ'£/” Åò9O‰IRÕ»·—Ÿ˜»UÃÈ(0xµ’Q+Ş>¾@ì‡`	Âö¨©³yçÚ+¢d ”g5ê¥;y4jjƒÏßñİ×[æUV‹ñTVãÊ:EÎÜ”6®Va–ÆƒCmˆ"‚ˆ²áuAë½iaUĞk™Ñ@j·ÌƒØhf‚»FÕFÙµİ–åÑ ìè%¥¨Mã’á‰ydUƒª}À™‘â0tÿv½¥¢Ÿh¡R(o\ºŠ.€šÙÒMÅ¶j±‘4ˆí9ó¤·“üj6-øÃó{ÉñBÚmèê v½\¶K;pÏd:Ejb\ÖÔÚóÄiæäZÄ:ˆôñ·»»²ÕÅD:„NqÏÎUğ4ZKÔ)İ­fL§2¬oc3×fŸP£z¥*Ùº_!½Qöbm›ö?Õ«¿›´‹à<Ãù5”£òõŞ¡ÍPTAªgïl8µg”i­ŞŞ¸C7hØ´]›…ÜøÕ rÏÕ¢¿`Éƒíü0¶1S÷7À€$Ğ-†çÿo› «…OÎ]<'l¥¸È­·–q}®ÿ Û·¥à
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/f5/a93fef93b405562e3946492d5a855aea664e4f squashfs-tools-patched/.git/objects/f5/a93fef93b405562e3946492d5a855aea664e4f
--- squashfs-tools/.git/objects/f5/a93fef93b405562e3946492d5a855aea664e4f	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/f5/a93fef93b405562e3946492d5a855aea664e4f	2022-01-01 15:09:15.641172590 +0800
@@ -0,0 +1,8 @@
+xíZûsÛ¸î¯Ö_±õM;”-[;ÉÅv<•e9aO¯Ñ#n’f44YS¤¤ìSr×¿½ß E½årÍİu¢ñÈ",‹İoÀëßP±ôäù“¿ä÷2´Gî‡±E\ç†Bg<q¡#ôX“‰ĞÎ]*şd8·£ˆ;K¥BáÉ¾RÓ·dÒëïÜ9ùxó;<‡ÓÃpz®ÇwGNH˜!°‚áç0‚B=X8¥™?%Ûò('Œçf	âyˆ,o÷ûgˆ±M½(	ŠD0ÉÊ‡—ÕD¢G¾,—ZÓ×±©æØÂY!MøM8Âofrä3ÓÑÌÈÁW>&±"Ç÷NI8˜* {„x¦Òa1QÓÌØã)+â•äOxh¬ÏÈµÀe<úpƒ8æ«„Èkù,p’Xòƒãºt£D2Åpêæ2¢k³ûªÙëR¹ñ†®Ëív¹Ñ}sŠŞÑÈG«¸Š–ÜU¬—™„ÀË‹f¼ˆzµ]y…1å³fvßğ:®Ìn£ÚéĞU³Mej•Û]³Ò«•Ûrl«×n5;ÕCê@`ÌdJæäÍSåö‚"²7Œ¥ğ»‚Sw@#ë^`÷máÜƒO‹lè[,æ5“0Õåu}ïV.œÍ•í”œ!y~”ƒB;PªÈ—+aæ·}¾å92=û0GOSWÀµ\Ë99°3e*GG…]øaä{9ª—©P*‹Å£Â3êuÊÜ1ŸÉ(ãˆ¡5u#º·Ü©€âCÂ³}¨p~ äÂJ]œ›Fçx¶;:£ãÎS¯ØXùM&Ÿ§Ê?_ĞÈb"ßW†lûã	ô÷Æqhvˆ‘CğAı·ıæUæ;6 !ñ/üw<Ÿq“ğ`e˜\7¼­™ıZ…–Ş´¨°ø¦uA¥97]ëš7ü1UKÅBÂ§V8†Äš(Æ`T×"Z¥¯z/Ñ®µÖ¿o]è÷˜Y/ğÚl•Rrr<'º:)=á†"™Ñl˜İ—=ó2ó]¼äXŞ»‡‡yõWñÇcßË×g×7ğÂÃÑîœ6w«½­—å×¥ÚÉÍªjË¹CÂB§û²_íwªÕªí6Ìmåc¯ÚÕN¯ÖÍ~ú¾P8*ŠÏkÙ¥ñõê¥Ù«_õjµ-Æ?+`|Æv­0¤ŠéÕÅØf(ÖøZ« Ñ&ÓôÔË\êzóRDçƒH5Tê³wçù9d>f$¼Ú'¹4ƒaû^ÑÅ,‚öí^­õL/zz¿óAd	,ìûÜdğW6‡'n3d~ò‡ÃPDF!KÉ`{'ˆ¦€ùÿ,Ow¨¿é÷?4š×¾Yo•ŒùÚÈ\XCÔé^Ö«ÀÔK£-¬AÖ¸÷Aš×£’äU1‡½IàÛìt,•,(|ä5 s$Ët®@	ïY¬]xEôbµù4“&€UÈŞc1¶'3)–‡ö’9%ÀS	©H!*AÑşÙ6§ºÈ°âeqàŠ™SCM:ıæ§X”ù¢ZVıJAiâ,j½48G‹<®™şç.k(İQMv$DS¡ŠdÖÚµç‰‡–:Ò)Ç[¤Û´BÍå3O/^@ÚÕr])¾ºYÒı!#5¯”9#‹ÚódòåÁ•^;=8Vdl¢¦#uBÕÆå"!µWØs98Ş/‰-fãu¹f^^õ•®ÙlÌ¯âŒ
+ôóÏÉ¢bmÍJ[ •À”"’ğÿ"<'¾ mVõ´ü¥ÊÇ¢cMgY¯`n²F¼•¼ÚÄÌöø)1"¹+ä K‘°#18Éì, ²"Ò¤Ò¤Ÿc6ÁÚ4f6§ÑFĞDÛ
+j>K¤Œu¸8¶~’~%uO#±‚•i¨\Zb%±XDË¢a&‹Z‚Çk¦²Ò”ÔŒ?”«=æ:§¤ô1•kPRùÙW*Ë§°2Ñò´a(=YÑc†üEÜú|l•[0GW)c¯Js¥œµMHrßp–Aç€³±¡şP»¤oÛÅ8ŞI£-k¸Æá¬n“ñM¼¥ï1 K4N•©Æ	Ø§ÑYà§qYO¸	ªßVÿÕ­¶H¤#ÂïV³İE>9ˆÓJÈuŒjEˆ¼hZCêÈ!)kÂãØöSŸO"ççüPÒAUƒŸ¶¤Ã<ºÈÓİl¡óÎRK{Ä;ar ö•¨:=™7ÁÀï {iEÁ™Ù?N‘p9–GõçòT ÿä0C—¼íù±cKs±ÔË`áånä!ñ'ç”Éï„ø—[vrÒà<ëä¤¢“(ÚÓ	´fÄrÙ<`Q1İ
+çàçq2RT¥ ZífË¼ä`tb^†ïŞ£Kfç#fÃLÚ’ïONî.›#KT¶Ø\r«{vğŠ'
+×4×œ¨â{‘ø)ÚÜ$64–İ[¾x4^C¹1_YaÄ†µnâºÙ£+ä¶"X3¸êêVp‡à ;±¾Ş,/>„@Ø—úCv|,£,å—Ş¼+¼gUÈì°0_—Û&ªMR¢"ˆ¾Kh½G/®<Ã”§øwFOñoŸRCš¼?¼Ğçu·ß312ÕVx8u_##|!Ãÿ£’Q¤³32¤•!Ü.g™£ÔˆâÊYöh],õ+­ïW«dO	uæŞóƒ1¦:®æ8Ú0¶µÅØã•±¥%Î¬ô(–¾WrO­óé\jÈk…€Æ›0
+”ànƒ»{dıˆö²µİ‹îñ.Æ-,íYŠl³Y[$‹Æß×û¡÷¿ßm÷ª’
+{””ÕœÃ%¶¥ö:V-™êıÏÍU0KE’wÂ¢½ËÛ~½ZïËšŠÜ]bDeFÔ´=^€®¬ ı¹:—XÿÁ93 -Ô¡ü™r„šÿ±`™óxèªöQ„m^aÚfû8ù¸üJf'‰>4…ù^ô®ô*v ^kV¡¨%	k#Ø[€S«¸3Àz:›E™£¿ÇcxM±ÿƒ0â×x›™‹•K ™U]S–»#Á5uYÚXÛPnã’=¼ÚòhãËIûNQMàBïï<[ÈJp\ÃóSTÉèçùLEÎ~êU)P‹Ø­ìJß¾Úå7rîˆR…ªØ¿.ywå°cŞŸ}p&g‘Ô7UE7ôÇ‚Ø{ÍdáààØ›g'†ÁûÒ¡Cv™Ün³\F(hRŒpE‡!o'ñ÷t Şp6ó-€x,€ĞeZRlváŸ ô ˆ;P-š¬&EUƒDê„7M±•8³¶õ`è2;NvvÔïV´Ê‘r`¥£ììâªÉÛşe¹[Ö(Á¶ªk±ı‚©Øª—9úĞ%ÈÀ€—ÙIpœ í¿0ÿ[øÑGe)op½ñ!Š29Ç»g!uä¹ÃUægİÂ%¯EÙ54_E¾YíŸØjÕ!TÚvã7Ú‚ãÇovÌ'	8‚ÔaÄz;æ0z7>/|ö®~£é>ûğ{Z-—b÷/¯7Ü[â¾# bÚP‘Ïğøx_æHÂø²ÇĞ	p,æñAìgj_âÅ÷Ÿã,(.@<ç°.å¹şJÚ~O.=Ş††×—ÑŠ[/e´o ¨-{W|Ï0’ÏëØî]	Ïº©€Ÿ[«æVs—E~ÿ×Rn	¤?k}ıW‰6RYİW3äÍ%£úËËƒkT·3‚èVšéÇAj	†|­éËÑ	j6G§ãoèW65|,¢õvy†B'\Òã.êñm 5;,Õ5å‹’ı½8*‡ó¹åëVÂ²GI­œSX×·ï¤+Úò_ÇÂšÙ#aß±ûBş¯¯6Á¡€;g¸y~€Û>êú™œ[_ş‹‰åÑ|~€•¡±Ëv4çï„ş6PÿöS/tn=p„ÎqÌpS‘¬}êk=€ìo@EÖ9™äõëç)¾ÇiÉ1ÛÕl´aQ¥íºVºmœuãLYæˆOÓùÚ
+óg-Ös×¶ò*œÒ.x´/õg_'±ıı\M\¬Ki9¾	ø>,~Ùl§¨‘áZ*jòJ,ßÕ•†[»î`mŠâhçQç“ì=oó#Ÿåƒ2¾1°ÕgmAmÛÁK…7¾‡¹İXA®ı™ı'Ÿ×róyıÉa‘¼Ø¶ÍY£\,¯EİGùÒ“Â}E&í‰5áE÷óŸ,l84üb_¬cÆ<#_3ÆUZyx¾ó:ÿã{ÉÈùp%-T^»—ª-AvQOèLÖYæHÍOsªRŸPğK²¾7÷™¨-­egÇ…°b/Ÿ'ëÄ'`zÁ{üiËÿĞ."¤
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/f6/143f837ce89903f72ee6f7974cd580480edbd5 squashfs-tools-patched/.git/objects/f6/143f837ce89903f72ee6f7974cd580480edbd5
--- squashfs-tools/.git/objects/f6/143f837ce89903f72ee6f7974cd580480edbd5	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/f6/143f837ce89903f72ee6f7974cd580480edbd5	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1,33 @@
+xÕ]ûSÇ–ŞŸıWtîVQ’Ä`ÇqÅ	·.cgw/ë¢‚l,Q’°;ùß÷ûÎ£3#!ß›»WÒÌéÓç}NŸîÎ¯Ççááƒ¿ı—¯{áÛO£õ‹°¶†Oá`ts;—·£‹Ùp<šŞÛ|ğàÉÚÆæÚÃğ]8øu<	Ïûï¯Çïñíùíùõğ"ÆïúÃQè}}ïŞ¿G×·ƒ*üe}ıkü÷í§ÉÅúÕ_7vnn·'W¼•İûöÓnu1Tå!O ÕåpT…GÇ‡İğ9/C‡Ÿ~ø!<è†I5»ŒÂÉßÎö^¼8~qv¸wø4ülàÑ«Ã³ıãg»{/Îvñóäìpû?ÂÃÍ@îœ¼|±·}î½áäÓödïãÙÁh8ëìè—Ğ»éŞû|/È=½³r³¶58ï>ÅE|Ú_ªÉÉ¬?™=ï_¼=™Mªş»ƒÑ ú@³¥;
+8EúH†gx]Õ1Äk/Ç
+) ‡ıE!äìOª*ã`5€›ëëñEèõùKY:Kg,—W3$,·šÇà‚!m/w¡Ô c¨,eDµ³”OÊ?×ê !«¯{÷^Œf…«fJHÆÁğSÕà$¢Zôjà…iRn7\À{fbf–‚c§§k	­à9Íp¾÷sŒ¯…²Œ,0ì(•—@>wNXÃ\K9½t˜*ˆkeÔ„-º®ÆÿA¹på%¬8èå˜sˆd¦7Ä©Xõ®Xz$¦ ¥;Gb8gp×êØ¿½¾ÜûÜp*ÑöbB‡‡ıqOB“Å€Ãÿ<Û~öìx§óÖ¼¦PˆƒÇ^ó¢şªëişh%àğbçeèuÍØÅO:æ"ŞÔãËÎËn×‘Í‹OÓY†@zò¢šº5B0×w{(­áá&¬„Ñe<U_ÁŒÄ/Ÿ€ŸüF©I¯Å0u0R}ù½(@~GLÛƒóõ£ÛwŠfêÒ&—H'¡`Ãğ=ÃKû4ïßOF·0œ_‘ó¬ÖæßÂı·`’”¼oÊğü
+ş?Ü‰‰ZãsÆ]É8\Äb6 ÉfºYNX2IÅ–ŒŠª#³‚0Skçïáf]Ñ#3ŞZ4WHÉ±xü¨‡à`–)™ÖDÃ€ÃYfÕ»Ğ»Ä'¨\F 1Å²á§ÇÕ»›ÙošpöÁ×¶~êOõ’
+şœÃ­¬`haõö<ğiR'«sªúé¨kt×6t	—³áèÖ´Åø¤¡ä®¹ˆÂû‡ëAÚÅx2©.f×¿…ãÉÛj>gWÊ©å£©x´şàÛïÂ³ñøFülúvxs3ıÚ
+Œ©óˆG>}ªA7ñ¬Ô^¦„ÇtP÷VDLõP·ıbç§ƒ_ö\õÒH”JÖò€«“(©*ÓuKz¡;¿İÄk¾ŠšãèÎQy½MdÌÜ¿ï—U3ú“Ñf±3Š fM.”™öûÔYÜH6ï+$ÓàV§úµÈ¢S,Ô' Kv­Å'ƒşŸ4vü³”^Y}S¯ºÒMGJ,‹Q	¯¶¤”x­˜^L›’JíÏúL`÷…\˜ ©Q¿Æ¨oa¶ƒAÎ²PuŠbby¦Pö&Õ”1WùQ·É…(QKM;JUUO-,95|p¦7?‡pf3“éëyVG¯mÕR`™mç³Şûæğ)«Ô…À%Ï¨¯ÎĞ9°°Æ¼¸ª.Ş†áŒËDuÇdoºXÛß>x¦^d\ÌøÖéB6Bx9vcE¤´úéEÕ¼¾«Ü<Ïß bş‚ÿÇ“ïw~¼½Ü
++´7½²*äì”@)Ë –y)ËÅñÛi{çÇñøZ‘„óø‘Ôqús‡t$ÍàY?D:İÕlD·Ë²cGİêñüâÊê~ı’0Ne}¡W×OªYgv5e7]Ô¿@¦ú†¥gµU>ı‚¬*ìBÒnu¨ãj}ø¾Ú‡,([¹Í$¡ì-°›¤0¾@ªÌg®ÇVÃÕğ×+Eè2<ùD)*L0äOÍGe\Üçğ@HáúàÃ³ñ‡İşL	ÿ! #É`~Âà(‘¢É`*zéÌDû¤à³ÑqÑÇÊà-zƒÎöHfı`*ßv¥aA‘ï|&…H“¸ˆ´ÌTi‚íbù¶Ô¹Ì‡Åòm©	rŞóòe¨Ï¹ğaL~YMg'Ã_G}´pªşh0„V›U¡7ÃM~šjœe€8ƒqSõĞUD4ôµhê”+5T98.yÆ¶ø"ıûŒZë tI½½˜…3Äj$¢Y%}%VÔ'eF¥qï êg:‹VÇÅBo:XŠé\Ù¥ÉLk[Ä¤.±½5€f%–C¯­‘Ş9t´k[œ@‚4Ø¨©¢FÕ´¬°èÊJ —wk…PQê:¹‹ È7Q3o«Ót– ÔÂC!@+½÷ıë[£V&&£!Qoİ€ÕèUœSePŠ4¯œ{Ğ1Ä¿£;àK€Îy7|ÿ}è<	½/ä
+¹ù¼š”ò'W¬:2®„¼ËáD„dÊ•wıé[røñ‰0yo•:b¾WNèÉÑT‘è[X	¤ÃÚ"AÕ},XfŸ£y!Á#êùka#†{#	KÛNS“+TZ¯høng{®â?ê×Õ„—°……,ë–4NUãÃÍ¦"Ñ†ÉiºÕ>~DEæD›5ĞGVDuE‰ÛiÑAáúOCYˆ‰WG'¯??~ñro—SÔF«Ù‚ûÎ†š­4³ĞÄ¢ÿÍº*%?n¢¯%*½cŠhLî‡ièÜ(t°Û”\Í‹Ô
+™ d"XÂvİNŞVÕc!#j+úÕ$ø,lªíl·„ß°s5Ññ%îa˜-©ú=gäog­âˆdç$§•‡Õÿ‹,GØŸò©>E¤'”íK€Z¤ÆJÌÊÀç“ñM5™«"?()OµƒğYìÃ›™“´•võŠMKaeŞN‘ó;sTV{£'ælÌëz»„Oş{8ÛÍ&ÃóÛzÒ5Bû~÷ŸÁO†œ¢h‹X‹ØwµùWftI®…XL.(W'¹EÅÔ>º}ÇFV’Rz½÷s6Šä6‹É5Eş“‡ey¹û†„ZE \iš´'SOÊSK=•fºØëQ›KÂ>Y_‰™ÅˆoÑ<eHÏŞû.kCx'Iìv:ó˜Ç¤¥ş¸úÀ¬UæÿÒ¬¯‹º…ÎY9¿Ë‰rÛTVª×%gr¤‚(†¤LR\n©5%Ä&âW¢ÊL*ü³4BR‰$Şä­Q’
+G“÷jwø+jıiGBN.c¹P—³\Ëíõ:Òä©Æ&l¿©W[·MõŠ(„{›5¹Õ&4!Š}E)*ğş;ıFS~Ç±´x°mî£SÍq`7UésÚ‡eÊ¥VØ8:]ç¨ÄÂok€ãËËi5+E;“Ö“4A¦é«´¢à;vİ4É«;/v¦íªô»tijoèòH‹sÆ”D®ºQ®rCñGÀ’~gR¦%‚Kæ;KYX÷¥2c%Ñ+'Işˆ©ê1µ[­M6Ì ¢¤3³ÿ±ÄßHPñ|ëÍcåêEW}ìQÕŒ%^p)ŠC2g—ıür…Ñ–|ÕéD_™5Æğª>õKÛ5ífĞO1·¶{É}¹8ë’–µ’ÔëÄ)²hâÅ Å• ,³J™ ac‰Š¡C{y•¢Å™øyõqVMFıëFÀÙÎ!ÔC-tüª*i‡ş.*K
+
+"G@¡}J9y«Í.şœâÉBwGŸ&¨¶ğñGì\<ïc]8hB6Ó ƒ‘6eó_ ogÙ%Bgq†Â<’àeQi%N¬Â¡sÅKXô´™j_âb¼á&”l2(g°‰ˆÙÈŠF-@Ì«q¨KÄ}6w—ÌºİbqrŠ BÅÆC>½ÒrêŒ4öœ–DöâŒ]–áˆ&Hndß&NzÔ&ˆjN¤ĞŠ&„ÛÑmOìäŒö«áŞ·)®Ç£_vO7¾±•ZMMœgğHŠj‘ä(>PĞñ)º(–
+íƒû1 åÁH¦ëujXœ–!†‰r,ŠA3ÂíÚÖa5»v­5@2R¹ÖÚ Hm°hR$jIëêö6”tŞ§ááèæx6à´šèšøŒ\´/ĞÂxó:övŞ¨Ò‰„†_ÊgG
+óMd×X©‚£Â›Œ\Œ™·ÜÀä¿ùH’×‚Ü<´yhñ÷ßM‚ä-Št%ôóÆúZ›ã–Ğæ¿ g¤lÎ$©6’­FôsË {S=›sÕ£º7±KAÇÊ­ªMbò+å˜º¾ÂîáÙÎ¤âÎÄŠ±Æ^Â´‡¨Ç©E"å)Õ¨«vOÌ§ZgÁ9o¾D°ÊM~¸Â^XİºŸâsÕçW©xØHè.–;±Vˆl1&iªp¾‡y‚k—Lés£4E›bc¢K`ÿgŒj¾K;ª“®Œ²(Ã~b‹³©ü ˜¹}™®T
+yê©!Ç«ÅFÆ@x¶ƒ†bÏºÚ×4/›Êœ;Õš
+¿’9ZÒİl^ÃcEğY¸ÙñØ#ã¡N§Ş/ã@ŠŸ@rM5¨sI9ÉQWÓb`°Aç"9™.ço‰z«”ıóx.†u!P5.¤©ÖŠ©
+M¨&5dXR*±ª0KÊ†±ÖŞ ;ª€új¸aQYÌDå§ÏöQ»öÇ8è¤oGõ‡Š»zZ™C‹£_ÄƒS"‡me…[hİqÉ8:}Àf¡TåôJl-¬e£2ŞT"WË¤G÷EÇİÑa‹:Ø×sFÚAi®ßÑfQRà…<ÓCeíé‡zjí°Ö¾ÊKœ¶L{~ÙfNDçWïrĞ†#&ºPåšƒÛ*›^ö¥˜ãLbÅ™ôœ‹$v8[•œAfæòCYĞµGÇ§ĞŠD-+u³;í¸êÖÒ\…J“£˜Á}Òê}š©D—Í©ïÈzÔU"½›Ôê†İF§RiIÜ4™©„á6¥$ŠL=õ9ë‡$Brœß3¯o¨”xØ'ÓÉÖ¶#eI™Èå”+$[{ÀÀl¶©«$Y¦D-óÃ}ß¨‘zœ‹\ÿig)´±kÎXÆHXl³5Úhr'Ş¤½‹É…7T¡AëåÄ–„ÜÎ¯c<¾êA­z/.3ìkgˆí›)Db†A²'²_ã±Ûµ°¬#QiLû©Ë6óä¸”Ô¨ 9ë}ÕŒ´ÕìÖA]€ymê¿TQ«2‹ùs`¼'çt¨ÏC€qğ—v30ÚûÉí¹5îÎ0)P7ŒúJÖÜ·„d¾ÛÚú¿ÕSßPeó¿¶«’Ç–ÅÛ8eŠÂö‚z‰šºE§!åiŸ§´Ó0¸«{Hê¸SšIY0îaóİ@$E2=¦nd¸âáÏ<x˜§–Úo?*çPs_i£ ¥ØÌı.{3·Óõ[–íA4yŸui“^“fh²‚¥QĞ=±ÍQÚ‚høıw3;¿Àµ±‡©ì Cclû9W_\j#«(ßqéĞdÄWlªµ^æ#j’Xm°yÃ¯P V×¶â³f[h{ N£U^I•æŸ“Ótí
+%Ó‡œn‹WM¢íŒhËÃxKÏ7Nmæ2zÔ&‡`ì4Ó?ÎóC¤R“,g–‹¢á%œJÕbO}é³BïõI¡•ÒŸ]õıáÖ0œêóB° ŒİWM…éí;7
+­ÔË¼úö|ªQ°â›J€AÿËÅƒlÑÔË—äe"0n¨Òt)P¶nÎÜTéh>Ú	›ZLqpg+s¬îéO+ÊCˆ"J	Q…ã·F“9#ã:E®ù	Z…+İÁNâ"¦Fq)|yìhı­ÖÕˆ%1A)ÊxÀ+Üdñn¾Õ‡y@ÍÒfüçYº÷ŒÆ_e–§bM›fØ'mËÑ
+UØ÷¸–r½°“§Ù†*õ4Oáj\‘şO’š—ÖeĞÙÌL(şŠ{^§¾½ÎN¼ñi‘âx¶ˆı
+>Êr^êòÌäêËÊmL¶¯ıƒh9ŠJíG?·-MI©ç¦ ÍA¶‹Œâ„spk<ÙxÈSçòEaÓ8:§—¾^
+îNÃ—²Œàú/‚ùıÆL94¨ô„1x±ÁÏ±—Ä/uzL,q·Pabè{0/ôáÄŠ€˜`¾‹Öœb>Ó¥(6O3”ÅŠ‡8±Á‹GÕåRJ&IÉ?ùï9K¡Á–qç®œœÄ§4-›t:y-@Ãï³2®¹ê:uëòİ,ïœe‡˜Ä^›§­–[ñğT:Á×cÛ>Î)!ÀÜºğ³tW`İf«06c$ñª5V:?gÉÄV`ŸÔ}pò¯ó—µq›sÙ"O]s±¼5ªøş2ß¼Ñ•õ!r{:IšŸ³ímO”Eå*+=õkúÎbq¾ë]”Eñ	4ö—¹üvx7±²œq()h2İ¾å¨Ø*P»ìy_ZØ(IĞBó¯Ş*/z;-:QÑˆwëÎP»›…§U™nYG‰ˆ_ÄóÌ¶<9eSc±TKX!«F¾:QQŸmÃ±p$ä†û7*æ2ryô†ü£‡ùúÈ²åeğ ºìß^ÏœÜŒæ'ÃÛ|pB¼öí«Ùå“gÃwÃÙôôæ¼Ï8=²ó`?÷äç¾ş|Â+û;á4P›‰Ïõß•ÏÄÇÃY5  |±4À§ô\«¹xs¡­¸$ºX‚¨/X\¹®F©¶²k7éı)Ú,h 8Í6mSÃğ0Lø5¾=£Wz2‹>0·=Ä>ªÍ(Ï§ ±-%»0}DïH_‡ß±cï·ò;˜nãµ<ó$i^Èø!lj¦º‚Ê&Ë–S5cI@Ø:ÃSDÈêë.Šïú¸‹'XRé%ŞÃH><Å ãú"ÒØÄ´“ÆÑ˜ë1´xÚ ¤ÙP>‡÷—@qÁJÚÅüh ¯´ )d:Pú0e²Ş¸ÁW‘Z.£¥Öbª\3Ñ‹%ğ ìÈå2åè–à…‘xˆ"XÆÒØ¿|¾‰_ò‚0·ˆdŠöd˜î…o`ıa0z…èlº¢J> +ÏlËÿâª?ÁN<)1"í.c´çÛ–)œ×¼ğOö?lé¶z_Óï²‡¯%îoFÙçÌ}*9EbùT\–ÑµCitEß®ÄÜU¼µ§¢®yqÓ[]ÿ‰–¿Ïk[İdyAq4–¸-¢Â+nø¨.gùÿfàóuØÉ3§{»ğÕnÆåÖVè<Æ#•v~ä:Œ­LHÖb@úX·êÁä´8N4o&9 õp?Íè¦bNåoÉ³NFL»7k­‘âõü's°QM6ã# ñÍ1ipho“$¨vùH8Š˜DšëÖ5ÄÜG+´e§´3äîÕ
+m¸³7GÙÛDî„ŞGŒsØÄ3[.µ…Òõ{gI\û´â®UFJªvCš:ò–!+45cÊÖªÚÖpDÙÕI·Iy|Å\³HkØKïßŠãİPbù¢…(cÄÒ­7ÛGi<}Ê"C½#GÕ CTv#Ïáš{ap éò5f¦X³uû¼ ó€Ø+­H^9	+~>¶Êxñ<ª+ İÊ—imYP¿n9SÌ¡¹RÀR„?ÄÌŒo¨Öå‚Û—x”â'ñQCwÉó6„ûe<È ±V–Ç›Ä¤¸ÜÓj1Áë²$«÷0ONÊQqè¢Lªd2§/4ƒõÛbsÅ‰ p™¡•–¾Må#2)",ƒÅípÉ	(§;WrĞöìV>rw’kª>Š¨7E…±ŒZ2I£XXğuS¤RÀ¬p"
+¬)®;ÚêƒIEÍDï‰PÓLl„-Ûa]èKXŸ0M)‡ô%=ÉÛ9[Î#§KP’JZEæÊöÕK­ºò™Z.YŒ[L[ó¡Y±¢Õü-…ZWö 6›,T²¸”* µÓC¶ñ7#êœéP“®D>]ZL.'2÷¥Éç3¹ÍB©´ö;’zôFbÆ)È`nI1ñ1MÓL–[5’c)º—MÆ\o< §êëÇŠB¶[„®Ş†Í—Kuz‘T*RC„q‰grøV'ë·Ø†µ­ãEY€ğ1ë|'¾ÇÓDI2ÉIJJùjÆ×¸1c"ÏÈJçcHM9ÈİÑC
+QµÎ`Ià®ÂÅËñs>Y¹*«eÄ™h2µM=»ÍÈW»³„]8‰:‹úÁ\Y#
+Ş8ƒ>İÆşx®/êªéëñ¹S•¼¯EÅø¸£C4!›pş‚„æ²ùû×ğ ¯IH¯ğ!55$nAÎ­Ïr0İòÙ¹Ìòtä	„‰ëİsqfú
+¿É ?-C¬bâ¾ÜàÉYŒEß†°í("Ú+İ@3A&V“vH¥F¹šnêòˆšiì*».·R3	}÷´4Ö×xèµT37pˆm>µèé´˜
+ªá´š+O¥ Î“:rú.}Œºîà8£XV«¨:àbÍî±¥u£×X%ÖÖ>Ë/ŠòóÎ‚®õÊzÛï™»}øe"’ÔEkW-:»tSİ/7÷øm%á¥ÅÆJ¾Vˆûf¶i§ß×+ÀïJ$ÆÇEm™ââ‰9»¯UĞï]»®îewC.BÖ`íNà¤‹E QdKlÏ±ÛíÑ@ÿ¨wÎª­­r€·3cÇN/†¯1UÌ«æ»KCo|;ÃïËj¢P´@,Î±	˜¿4ƒ·Ë=ÜF×D\Ç¥u'Ìw¾òÄÛ
+@f¾€:un#4pİyb«M*˜	NN‹øs¼hL%³áE÷€Fë ¶îÖ÷¡úx¯ƒ[-Ï¤¡³’¦Àò¯&ÿîãc˜[½X¨Ëùâ¢:)„´3ÖcíxÆğÁby*ÄÆ;0îRE#ktÛ<$ºD5Âƒğ¬íÌ˜“§…Nnng'UõöåûÏ*?}“‰‹ÍV¤;è5_\+'Z
+±€Ê&kö¨+îÉ‘"®¾AÙd;ËÊµ‹ˆÚ‰Ì!"eÚÚHkùvú(E•‰ŸéòDÄ=ïT!ğ÷lvú×%¦“‡Ç••£—<õ^R'iJ—ç¶PÛ#ŠfÆ^@©¥T÷{q`Dšonû'%Ñäïìàï·ÈßİYáŸhIöÃe»@63Ëæj?jï^®ËäĞ/Êœ1-Bœü•"*ïıo$Ä…9‰÷³ã›jÔìÁC¬HÍyŒ¨§¤š,QWI~¹’Rå(	/ZÊ±”zİ¬f„w©èËc!]!,µÎ›oG‹ ¼ñÒMÉ*İ1’œy.ù’`É¦ğ¥%&ÒœrÃQÊåeL5ÒWÓkbÏ¬S™GÍ9/4VŒs^™0‘XÆ?}ì/+>ì¿O~ÁkbğÇ¹4”¤ˆÑr–X’HT®ÈLÃÇ9Ïè–e¥\Û ñÎR– uq%ñœ½R„›O @Äõi³µÌM[ ^ü—ÙˆnGSíu©pÃòÈ©rÀD«æ]ŞÂŒ\âux$êòRût–ÚH~	ş2[Ó%]éñ­Úô³•Íg—îg—D5ñíi®/}¿Eüí\å	Y~IkÅÉÓq…®®äY¯ªFm‘Åß ‹Ãœìíı|¶w„÷ÃPÜªmï-!{J1†"«8Iª¡¢«M‚áıÙÃsŒ”¼Š©imGÏ_½<Û;Ş'_Ò#j‰.Šk)ò ’¿D£ÚØQbbàyjWª˜*ÈÔ,÷gŒ™Şt
+{ãHmÑ XĞdcª‘X×(j]ë^H-œBÓìÁ£•!!íOjM±ñ½MN6¬Ë2JrIÂÃã¦øS¼9…ı¦± ï¼Ä^á
+«ˆ9ãémìsÎÏbÜüDˆbsÂgP~’”èÖ” [?bËŸ‹ØpÃª xÛ‰w]£ú@{U”)Wù‰ˆä4µëÜrZœwÄÇâ9\¥„”jI”MP–F
+Øèd%Ù á9×Eo­¾r$hü&í".ÅYu+´ARÕd®{…\h;d¾)ÈİvD8ï¦O~Å%½¼BÒIR+«›Wiz—m7±QK}§8©:k^’Îšc×^ú–8ñ~ß]¬U«R¡Ùèa™Ê—êÅC"óŠÓúùPe¦V­¦%‹WĞ~6Ó&â)Ì¬¾M*®Òğ‘Ø¼¯8Zü³äñ¿Q4D-
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/f6/286299ae50763f5acc77f0ba711a3505484c57 squashfs-tools-patched/.git/objects/f6/286299ae50763f5acc77f0ba711a3505484c57
--- squashfs-tools/.git/objects/f6/286299ae50763f5acc77f0ba711a3505484c57	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/f6/286299ae50763f5acc77f0ba711a3505484c57	2022-01-01 15:09:40.213173601 +0800
@@ -0,0 +1,4 @@
+x+)JMU033c040031Q0¯Ê©ÊMÔKfà•ig)©~xÕõÃÄI¥îà3€ªq,ÊtÊ,qÎOI-ÒË`8wGbêí’Ÿ•³n,°S–fÈ?>áÍ&¨B ª ù0•=iv¹,	‰Zj¯"ÿÌÎx|%yòë•P•yş¥%Á%E©‰¹Å@Ûçh`ù0éû÷ŠˆÃ"aÏ•Ê°*Í`È\ıyºÀŸÀ½Yş,ÿüVîs›wªÔ'Ê×èB³fcuÍ	UÙ.‹ïù–c¶l3’
+—Ôd°W’ê)„Ç–¯ì7*ø’9ÍÃŠ³²òª4…e¿‚³§×fÍ½d]>qŞEçúcKea
+Só`şuÕn-í©¸Îii'~Æ¤œ÷ÕY]˜ªÌ’Ô¢Ä˜Jm±‚›“¢ƒ&-š_U}iªÓ¯EÓjë *}³SÓ2sRêÊ‹šX›Ïm}'øb
+g¨KœäÊ}×¡jò‹J“rR~Íì7Ø}cÕM—½K…œyjÜ,Çã g—Ô´b šO	«Ö_]zÙ}VZlI‡¬‡AßQ7¨IA‰yéğøZ—?İıNô‡1Ë¸ßú-ëÂı`{¨ºğÌ¼”ür`”‹Ù$ß_{³[!Å”íŞ&eã³"z‡] Ê@i)¤æ^ÌÖ×¦ï'XÆò%rå.›·æë>¨š²ŠÊ‚Ôbÿœ ºº§ÕŸÚ6-Ù›ÑŞ£c²XşÉı¦¸2 ³ 
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/f6/62c0e61779d3b1d1a211f221bab2dcd316c118 squashfs-tools-patched/.git/objects/f6/62c0e61779d3b1d1a211f221bab2dcd316c118
--- squashfs-tools/.git/objects/f6/62c0e61779d3b1d1a211f221bab2dcd316c118	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/f6/62c0e61779d3b1d1a211f221bab2dcd316c118	2022-01-01 15:09:15.625172589 +0800
@@ -0,0 +1,3 @@
+xKÊÉOR020bĞ×WpÊÌ)JM5ÖËàâRÎLËKIMSˆwòô	ru5÷àRŠdæ¥¢
+r)—‚U:…Äû9úº8:»ÂU"*ø9…M†âáìïäo²//9§4%UA	ê
+½%LAßÄÌ<ÌN43RóR2Ó¸ mÅ=ì
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/f6/972e6a7cd5a3ae4fa9dad04655792960f069e7 squashfs-tools-patched/.git/objects/f6/972e6a7cd5a3ae4fa9dad04655792960f069e7
--- squashfs-tools/.git/objects/f6/972e6a7cd5a3ae4fa9dad04655792960f069e7	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/f6/972e6a7cd5a3ae4fa9dad04655792960f069e7	2022-01-01 15:10:24.005175402 +0800
@@ -0,0 +1,4 @@
+x}Ôy8Tkğ·ÈXÊµUSq%İ4dhÊ´h´!É^fcfƒÑ9#Æ^Œ¢”º]Š’²å¦P‘FD¸´YÚĞ"O<¥¨{Ié©3İ±<÷üsşù¼ßó÷ù¾?>Âbéšš¬4&d²9…¢k»Åšf¿“šİçd¨9$ØQ³Ëh§ì^ç¦{´‹BÆ][»õ@TV³¿ü uE¶A¨jF×[–Ø„'ØA\Û×Ÿ¢ä§œ<ã´³7˜Ü‹à/~ü57´õíhË|ÀŠİ©[õôº<În?CÈßš¥=[†#ˆÉ÷å.g³Œt­‰ ^şTşµZQtj­0ŞÀÀ=Ó(ûŸıŸ\å]Õëš:k…¸aBL˜…í	fc/_”b¡aí“º\ãNŸ2(½ —aõ)ïÿY ƒÚÎÁØc¼¢…sOÒ·uÓk3ÛH¤xAEy|ŸZŞÚMùÑm²«fÉõ!Twöd¿-ÈpêBÿ²«CÕ']IÄ³gåá… X´¦ÚÌ.á|~IœÛtN•~Ø£íMN8a¾AŒ
+
+bI>JğsC8Qd–Ù§ıè¤ù‹–ìY9•„õô&È¥êxdñĞABä‹®øíÉm¸ôdó°,\/àÎ5<ÅFOzÚÍ7eÏ;.+`pãıª…æiÇˆ÷“;ó|µx—³qáF‘ÙVYÄ˜ÊM$=î¹iº½Æ9º‡¢CÎ˜‰ÉU7ÿáÚeGnøİøÊ‰ÆôÒŸ0 ’‰lî¹u5s±ˆ¸é™zñ2¡>RL¦0deh˜vÎÙgÚ«7äX–%Î7Ù¾mA_ó'æÉÀÃ'G\™3çärı½]c„/Ö•o§€0ˆ±ßY¥Ê 5½®„Rúø…Îêj_LpÀE÷C(Ì–Ô+~˜T¾TŞ¹Æø³r}ÖXÂ-¢PÚGË¨¹U\±şÙÍuns´’¥—$á1±R1ØÄ	`~o­€d`©zu×…-kë¢83ë”=ñÏOæ0àq_ú…öYÛ<ZK©YC‹MÿüçH:ëIú“F»ìÛê1Ó¾şçĞ[Âàè•S@”¬6Ï4n¥’ÛÛm^n›åÏÎŸ&…(+ØGR aFÂKqa¸£ØEi¯Ü‘7Eï;´ÇT=ıûã!µ¥s¢§£¨ÍkÑÌy­ˆ„ù0$‹Zä,{©|ÜA#Í-rAİìqLrÖÇFßTPßÑğk;Ojp+ÚøXZşY(v—Ò[	Şù4V·{{û)×–çÆÊ&…B|>"IÛ ÆsiäÇ¨øˆ†Ä%ryzÔÊŸåóÉ¾è+¸f(9ºR]œØ¨ô@†Í«' ˜iœ–KÒVâvºøÏRtP\E²Ÿ#lTğ±˜„™ÖÂkeOî'@T(Wş²ğ·TVÀ µÃ»v„´DÕÈYğ¢Æãà—oµê›¤oƒ‰ˆıcì¥ßŞİ¨j/è}zSÒ‰k'ÚjµèÊOGu¸¢m(!t -Q:ü¤f !PF?TŞ¿÷ÑµÖ?¤¾^#èFI3%‚	hMÕ,rş®ŒMNZÌ½òk—pø#ÎÈs·z[Muy³ó4[¢ƒÙ‹4_Çˆ&:SÌıB‹Ÿ·YÜ.¬ñŠšpêÚíê²‰næ¹fõZ,¯öŞªÀ•õ©Â–‰‚¹şöBO)~Íõ]"‡é†‡²î´©ÖMpß¯lïùŒ\sjøeú¶şlBšÍÌÆ-;¦pËyˆ/hê=ã–7FÄéÛÜÍ±SR[3<Ã ÿA…ÍsøÕÛÒÈ{/ËÃºëB®MÜ$eà“·áUy±BS®:O¥bhÅÅäÅİÓOøL
+ıa0LÿúkD£‚íücQç>Ûóİ“ñ÷Zc‡àş±àe^ô¾œî¯Íï,İó½uıƒq-%¥,‡{wˆªq&ÄºêàÖ¾9»4º§#08î¥ï´-³<¿û†Ø6p@4²:EJdçnoÔí”ãÕ;zG]<…ù¯äßªºMv0¸§O»eğÄ!ÂR¹z¬»‘°cïÀ’¾¹d`z
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/f7/118219a1d13a5b0b4b109ed9a30a616c80d31a squashfs-tools-patched/.git/objects/f7/118219a1d13a5b0b4b109ed9a30a616c80d31a
--- squashfs-tools/.git/objects/f7/118219a1d13a5b0b4b109ed9a30a616c80d31a	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/f7/118219a1d13a5b0b4b109ed9a30a616c80d31a	2022-01-01 15:09:15.605172588 +0800
@@ -0,0 +1,4 @@
+x¥“KoÚ@Ç{ŞO1
+âb /„Ú	NK±eÌ%Ëq±jïZûˆJ>}g±)"õPËZK;³3;¿ÿßi%Rx7x3r`ùZ'ÓÉ³á\–Ï«¼…_Ó	ôïî¿ßÂCYi”@	"GÉŞÇS×¾ŸØâ‡$/•xaI«2ƒ\ÔIÉÁ1Ö+cqlKRï>şÆz´Ur¼Ø¥dU&G¸GÑ®A5ÜŞ06rX{½ø+êo’ìçº|ÅÏ`Áí
+ df? .”¼1òD'‡ÈùE§°ot{Şü©JlD†g¢n$*…9(-1©éLˆÚH–C{vıûûæÇÅÿqß‚^úa¼x
+6Qìùö”m1!œŠYTëU§Ãù ıLp¥án§št vüÈM£`³àzòœã·_N©µ¢âÊ‘êÙÇaô/Ú;€ı?é“úY·»D§Ê¾ÉA´cR+l—óOşV`>‹fvâ9YĞ*p®ĞÊ[í‰¬°rIU‰,Ñ¥à×’7OëMøaäÍ©¤áÊ4šŒR”•µÀéÉ8b®€z ¤$©²>hgKMQĞÏui†V¿~«¿åw0€ÓÁ¯:Äº…@Z;ôçeÁ~ÑË-X
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/f8/5efd1e7cca063d45a5d7bdc65d814cef365cbb squashfs-tools-patched/.git/objects/f8/5efd1e7cca063d45a5d7bdc65d814cef365cbb
--- squashfs-tools/.git/objects/f8/5efd1e7cca063d45a5d7bdc65d814cef365cbb	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/f8/5efd1e7cca063d45a5d7bdc65d814cef365cbb	2022-01-01 15:09:15.669172591 +0800
@@ -0,0 +1,4 @@
+xuR]oÚ@ì3¿b¤¼$!ú¡Šªª…‚D€ÚFOÑa¯ñ©Ç{w&õ¿ïIS5’eénwæffw£Ìƒşğã»Yèœ
+¬æÉU”LÆÉÃt>^<L:'|-5ı§ryŞÁ9n,	Op¿jáÊÂ¡Š\ã<íz@ZJşJ¹-UƒÌì*KÎQFæ0Z5ç/[fS5–A§Ù®úƒa7üß‡Ú²”JÉ
+3SoK²øR=]|;ªè»íÕ?¿¸Z•5[+vANa‰àLá…¥S#šåÒy+75[’Bç—Æ†w&—EîjÊÂ—Ovç`Šöğ}¾ÂwÒd…Â²Ş(™a&3Ò\8TáÒ•ì{Ó´ˆqĞ4`l˜Xxiô$™ŞbOÖñWİ@a,N…R-LÏX_Åñ?÷öŞğûb+‡Ôíó¥©ØBÉ”lê‘ãÄ†P;*jÕ¾Çà~šN«Ñ|û(£yºq³/WiOOTrW)ÉÆ8L+´o8“ øî6¾™0$ºÎ¦é:8OÓùm’`¼ˆaÅéôf5‹b,Wñr‘ÜòÆ$œ
+ÛogŠ‚ÉvÆròB*w4¾æI:V§r”bO<ÑŒäµ	Ş¼*(kÍ¿ÍŞÊèmk“›y[‹3‚, ïâÑJ^oZ®Wsğ—Qvñá3RâxK%2Â’:`‡Ã~×Æy£»¸‹Ğ¿ƒaÿS«$:Ú©õq¡¤.L¯dşËN‡~óÌ5öFæàÑŠ¢¶~z6zU«+^©C)+…Åù?RKÿŒ<!ÍKŞùB§Tü
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/f8/5fe606e0ebac7b52eb560976038eeaaff0db1c squashfs-tools-patched/.git/objects/f8/5fe606e0ebac7b52eb560976038eeaaff0db1c
--- squashfs-tools/.git/objects/f8/5fe606e0ebac7b52eb560976038eeaaff0db1c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/f8/5fe606e0ebac7b52eb560976038eeaaff0db1c	2022-01-01 15:09:15.661172591 +0800
@@ -0,0 +1,15 @@
+xµZkSÛHİ¯ö¯è8bÀ$35•!a—d ¡–<Ö@Í¦’%Km[[òJ2„Éşö=çŞnY²a¶jS”cuß¾ïW_¹?Nûfoï‡ÿew«i¶ÌËÌ…5Éÿ5òÑ 7ƒxló›¼°“cÎGqnğ˜Q<oL˜N¦™ÍsœŒLšŒoˆ§r
+‚9Şd8T˜v¸iw»O;øÜëÊçcùüpïGñxOÍi:lfMuáo£4îÌ¾8¼ÂÒ4K‡Y0!kƒÌZ“§ƒâ:Èì¾¹Ig&pÅy‘ÅıÄ‹$Ñnš‘à$âÁ×fI‚ÅÈšÂf“Ü¤yxõöÂ¼²‰Í‚±y?ëãĞœÆ¡MrËãAn¦\ÌGĞAÿFN“‡3Çƒ9N8(â4Ù76úÌ\Ù,Ç³yÜ!Š43í  «™I§Ü7fS”°;·È;+2q"äGé"Œ€B]C¦oÍ,·ƒÙXèAæ×“ó×ï.ÎÍáÛæ×Ã^ïğíù‡} £»öÊ*ªx2ÇÊÌ‚¤¸NÈñ›£ŞË×8røâäôäü%8>9{tvfßõÌ¡yØ;?yyqzØ3ï/zïßÁ{Î ˆO·ëÔ€l’fÖD¶âqîÿ Kæàn™QpeaÑĞÆWà-€NÉ™;fÒÆi21oq³oâIÒ¢c®³R¤‚«fGŸ›²c~|jÎ-ÔcÍûqZ³mÎf<ûä	|úEšiÒ1oM÷ñŞŞŞöŞ“îOsqvèÅ™æv¥;!Ğî6›ã$Ï"w¿vF•…a6­/Ìxòâ´6“b\_²Y–,@1&’aÈÆqaí&ß-n¦6_^¾â¢¾’Ks1ZNŞQ«²~Òl§¶$ABé²Ñ|ÙAœXsŞ»82{åãñáéÙ‘é6›ö+b$ç’€.™xÚá(ÈÌ¿&ÁÄvŒ>“©@¶§A–ÛË1o:àÍÍıfÊ˜……QV/#{e¶¶Ü‘™çæíÅéé~Î8r—¼¸S!B¿ÀFW#„—¡-.™;ÓÄ&…c¡2,{n·øHö7›¿7*Aµ¨×È‰¶- øŸ›İÍf£¡(Ì£Gh×ÅıÅSä”Y_7W>u—•¬ T”D³i[wnø¾<S‡÷ã-³Åfó¬}k6›Z€£È)ñ…4ëI¸Ì!/"]õë@rä–÷N´ã4²yˆ\os	ã°	
+W$³ì.3ˆ¢K= +îàÍÜ¡
+½DzÇÛJEóÖÆc]¨X“40,C—‰©<‚ëâ‘­û3¢éxĞv¢Áè™›®ÒğkfªiØÎãÛtP—†îŞh,#ÀbãÍÑ›Ë£^ï]¯-T¾íòš«3{"ÛŸ/€,·¤Şå¬‰Í3g>‡É÷Ñ#z/ØnÃÉÔ‰¥ûãÏ;D¨ÎÆo›ôø.O4úè:¾Pq8üÏë˜U»LûP›Ä^áa—İ0õÖ¹Î%vêk`TD•ªZå«c@ñ‘ÙÛDNViùR¨,èZO“W1ÏÖ4^'î¥Şö—òªS|ì~–ÀÀó7(oaÆ6@˜ÅHÄ-sŠ\³)I”>ãl¶ÌD‰Jr SÀÜ§éKK(™>½=úfì8·%›(á3$bƒ˜CBjŒQÜKVó[xUÄ·3*™ ¤+‘Làó¥àØGU]oÍ*›P¦ıŠzKş&Añ¥â<l7Åâ˜Ş4U?©ª·¦´ÓÛÔä³şvCE
+‡DbGfbƒ„©K›m6¤´&•ŒÜVê‡y0@c·KY¬vœ^wŸåÕ
+à‚D¬RMf9ú?ŠÌÖÖõ«Ùˆ6(Z=¿1qKªnO¨’ì¢"`»íÁÿ'Î?ş#«¼§8‘¢6¡³û9Í²?:.Ÿ+½Æw½ã6ÿh4æ>ÜhH¢¼<;G¿Ûn­áf4æ=èF5ˆGŞ•Zd+AË_Úz§…Z!ÿ•ä\IöÿÑ?O€eîd˜¤lØÌZşàSRb¨{0âŒ˜]°Á
+;™gUñÿZ¤‡Â0•‰Û››®ÓuIæ^‚ãb5°üÊ«Àu¨ÏhêbŞt fgE)J^§*ó\dÊ« Õ,r>ĞF`"qs¶XfäÁÿÂÔ\eæ¤\‰³zÄK¨å¸xT"ÿÚÊU.Óô'Ü•Á®¹MšQŞwŒ"\™ôûdC|ÊeÎ["Ğ×ô~Î]œÒ5*QW	OŸ KïK<¯JûŠª±§àa©nÔÕì=äQ7÷B§¾š÷9îîƒs¼
+‰ûg®JfZäJŸ—+Ù¥Í‚k¶õğ~sŞlÇIÄTæ$Nl§p%ˆCox|1d»íoZLPƒòÉD©Í“_Mà£¸d{P"I“Â%bql²VË¥¸ÖgûöûRÙ]ºâ­–f»ì­ËräıŸd…(‹÷ŸìS½4Ş"õµÒ§ÖL0‡ò&)m¤]-THÉR,1°Y½¥÷»*´/½wÈª—HeÁ7ò­¹Fw©8Çxíˆ”V².=¹“uİƒ±œ}ôr_xôè3»AÖQÆÆÂ¶xe¨Y†©Ü«íWêU¿®&æ-|è5KÊÒ	0§„â©Dƒ’à}†Km]g}´²şÜl£·ÿêe¨u¢3i£È„»¼2.>­˜Í +ùJåDÀí_$R~@^ö…—+Òò‹–q,¦¸$+b¿+İá8Í½¼¸<HIÕµ³ó_0¼<>9=zûNÖUALÛNo{
+_ÓMˆ*V´Y±/ON/zG8uÚiÜníöãd7¡Â¶ôs;Äw)6èf'˜Åâ2¥#Mõ#ğ¿§è±&räãK­Û¥uU?ã>¾,pm©†¶¢¯]¥1êm9
+¸Ë×Ä¿Ôö­_e:½1—ÇÛÚ-³%÷Fhº†{gµKc³!Út à½¼y	9¨³‚Å#PœN!ã*ùŠ€â,¢r¼]	Ä8ñ½úuÃ¬èiÄlá£—yËcBv&Ç·2F12íß6Ã³$‡	ŠÉM‚ßP?Ğ~vÌ$Fì¾¦§'â9ì:ÈEæWòY}Üëv?cd3t_÷êpŠñû`œ^›<Xi•Ô÷æÙ|‹9ËãÙBÇ=Dç35°,Cdù ‰r,®Pœ(µ)­êÛßC lËˆHY1š7yİA›ƒÿÈà"ÑÂÌ>°Ód÷'Ã|  x Œ"=¯¹³ó)FĞ9aqõò{à×€Š³Ğ65-#°ÇšÃİêU¬‡ÔPyè}ó Î…^©9A¤vÜÅr¿,²Ê{Ş§O~6A8N'‘2Ğ‚rzÁE?ĞÑ+Œ˜ğ .¸ä$î6º®ÓJæ¦9Ï^‰®šºß¦èB¾Qb«'WÁ˜ñg\ğJ«l{ˆF/	-ğê.)æ,ò©ÅÎ«3H~”Œ+SlˆÄ¢•€UgJG¾3k¡YKÍÚÓ§¹û ’uõÖu¼{‚ÓÒQÕGy[—  zQÖs"f‚áÙµªôÿ-Ç» pÔÆ«¨ßÁTÀG·÷MåñûéùëŞ»‹W¯õª!û]ÙvÕ²Ç×Ş(ˆj¼UÒŒÌ—+L´„4‘îNÖ¢N|åœû`VÂ«0K¼¨6W“Ğ_K)¥a; µ~¡Çwˆ@*BN­V'çÈÔƒ]—éÀªÁl\|‡ò¸râjÔ’‘†¨˜‹£€%7uÆ¥Db_QòFƒL!A.šW·CÙ^òğµ™áŸ¸µ¤i¸·ähü_ºò’/3féÌÕ¿|uoÆy•oœ"´4‰¯UÕ˜Ë1õ7Ì_éÂVá/-ó³i1÷!Ş"-·gqOºZÏá‚_«ë©GÀPb0‘/t@èÇu•6óíğı(IÙ)©°j8å¯ ÈPóüh ˆJÊ5ÿh|k€uüÁBZvL÷ë`€LÏLà¹{#ya1‹Àëá!£
+ËIuÇ“)X¥‚;¬Kxes%^î¬Æ{‡×Fw;õÄmC2ÔÙ—#¢«†ºŠ<m¿Í’/&ğM¼ı:Å˜IY8ä‡Ğâš³øúxÕ¥¬‹¤<ËwÚÄ[ºİêêÓ¸OùYÒï¼~jÈDº9sRŒË¹JÌ•‚±"ú[”Dd.ä ë÷J£÷“#¯´²Ó×I›!ü,Ÿ¼$ÌŠ ïo£ıcÖã?=¿¬ÀOøBoZÜå²î]SO°¥úóÙtšf´ä‚µP<Uò
+m]ìVÅM™€á¥?áŸú¾C÷†(êËÕ}Sƒ¼8)Òñ¸­½jÇìuy&bëZo^°ÈsÏLcrÃ¯¦İŞ;=5Ï™'ÈœÛxûTÊ !A.qFŠ·„Ne€é[Ø Ï¯#ôÒ×¤)ï"§×è…oÁÎdsºk(<oL¯/ñLÎ§äŞ
+Ê›ï¾x†Fx%éuÂ&8£ÜÅ*Ğ6H¯U]J¶½.yÎé’_¿«ËW Z©Kœ¾·.‡Y:›š­aF’¢Êa&ªôH JÙU: o³Kü¿R•¯”µïªçoã>~W İÇÏÍÙåÉñ‹Ó¿“_Õn 
+öòuoLÓoì—“`š¨ª`½£WUll®Qö¡B¥YñV›ãikà[ï5ØõƒnÉ %KÂh ı’º·:µÀ@©´¤˜F¹Ë©>Ì_Så,ÂÎe2p×!9íò¢º4G-È_b´Åñ ¹NM¸l\{Ç©k2VéToß‚ãh³!o+++~ÈÆ_×`_n2è]À¾×·ódŸû`!q#1£N¢›p)ÙùTxô	%õeİ
+6¹X¿¦M†ÎnÅşù#ƒùg‡ı6ÍÉ‘VO8¨ˆ…9uuXÂ«‚Î•¼ÆĞ4ªÑDÉ®>qô ë±,ù­†ÙšfÚUÌzLO<Œ8nÎşqqxöúøìò¼wøòxä·H2åŠf“éw~ñ¢ãGãRjb2ÉAîò}¸Øwé!mdM?ŞÖ7ĞÏM}tË°ñãĞ6TG“A>SÅ ½NúPàZ¾‹á	nÓÂlG_jëÜZ‚Šq8ï²|5^şâ~ïÒòèüU•]Ğ\=ÎÜ+?%Q®ğ­D ’p+YÂ¹à@5Á8 Ëy J‹ûV…ûù)MNúF¶º*µnşÃ´üæ¼O	mù "¯%IjNÒ”hhÎ½ú‘PÑ‚—Mw•uĞ»D–€¡XÜû6ªV0åêµ•7ëìø!ğ·æC¹-:ªän‚·{Íÿ›éŠÅ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/f9/5a753b1809d6a68baf40834a27c6cd4582a80f squashfs-tools-patched/.git/objects/f9/5a753b1809d6a68baf40834a27c6cd4582a80f
--- squashfs-tools/.git/objects/f9/5a753b1809d6a68baf40834a27c6cd4582a80f	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/f9/5a753b1809d6a68baf40834a27c6cd4582a80f	2022-01-01 15:09:15.637172590 +0800
@@ -0,0 +1,13 @@
+x­Y{oÛF¿¿õ)¦Î%I•7pjÇ€c+=!OÄŠ«¤´’x–H¤âs|÷›Ç¾HÑòwZK»;³óüÍì(^f1=;üí§6´Şş¹Š®TQö&-úÑz½L&Q™d)Ì²Şşşî.Ô$›ª¼ÕºZ$Ì’¥‚Û<)K•B”NašeÄ›RM¡Ì`½‰‘L³U”¤ßÁhŒ>F_—Ù×ÇY­£¼„l&·\^¼ÃŞà9ƒ~ÿçnÿ¨Ûÿ9lµjµ$éd¹™*8)Êi’õ§Õ¥e××ò$Óš;¸GªŠ&½Å^«5ÉRÔw²ˆrhßœGiùIEÓwª(¢¹‚—°‡Kf%ä¸IºŞ”¬ùŞñ6åohÕ@JFRmÊ]ÄgËe†o¢ô¬Ô*ËïğêV‘ü©Æ%¼»#i_£'‚×£·Ch“S:ğ5K¦ĞFeÔ}’ş„­{h$3è+¼|	ı •+7y
+ıcü¦?ÏHá@x›kCë{«•¤şõgéô|¡&7ÿ ÷æšÀSA„wb‡$!~ü<ÙÎ[J‹#ÿ/ª³ÃÕİŠÑ¨ü#âTM`Y;l hõ'Élªf0¦|ŞÏ_µàB’*¸¥¯6³™Ê/É·ÁœœÀfNy·VDƒÉ¹™”€$|ªu¾Q2ŒÒsŒ°8šÜ€ûH‘ !E†¦o›´Hæ)æ6çŠ0¹®\úå¸õ4{ŒQŠâO!z­Ö9&•šâ¡,ş—š”3Uy·Û1‹ØRå
+Ú,°æís3°ßBaGbjZÜ»§"%/¢a–¡uxŒTì¸óª-C¢×YÁvÿ4¼üüöjüáêÛ22ÌÇÆş¨ú•N“YÍ]>_?Ï.œÇ>lJ‘„ò\V5Ç|lÏ]ßØD‚77‘±?"Ú•Ã<Ïò@ğÌ˜ÑÇ¸•@bjU¬‰dÈAxJA²T©şv`ï”ş{l†G	{Ïfd&ªÏ4D$©X]‚ÁQ¾Šày!òaiúMÁ¦PPŞfğlĞ“A¸Ts•TdX3ëç‡ş&­º•ñ£‡ªâ¿f˜ œç£_ÉˆÿHæ‹ânO³ôÇR…a~ú}Åf½ÎòëHG¸`£“Äˆû<JËç‡„îÄÌ0ÊQ²ÕïÏƒªXÑ€©Ÿ5Æ'C0ñt«$ ÙÁüO Øˆ)ZŠ×›å’P£6í–ë+ÚÓ\0xn£¤~¸Ä‹àĞôŞëU.T® ëuš!kRPRšmŒnf::¦CôPd0•†n“å’¹İ±YÀj/²À»(¿QyHô>K¨ì£¬­öŒÊ†ìß u’n),Ï]_–Xw1ôñÿÇ¬xRşX@£½`pØ=êc÷RªB#è&/c’-tP²7«ö^çÙZaä¨âšaãã§‡Ÿ®FÃËñåè÷!&/ÊA\ĞŠü¹Ü®ô(CĞ?’9‰®éÙ,à	á+ÅİCrÑ·tÆCñÚ?Ï•uTRÆ?hü{ÜXfé0æå‚ä˜Jİ&·ûˆàÃá›ñğı£ğYTbVªåRÔ{Í´—Ã+½O:tc¨A\3ûá¥f+êZ¬®+|•e'óí(hoƒB	…Ô÷ú¢.MDØ<
+YÆïd.ıHTú¤«uÁÀĞä¢–¢
+SRG:éøƒ+N¶³0ul¤%C»¥0Üåğzs‹£¸˜æ,äv>Kê‰Ÿ9Öµ‡ÿ‚Ó?†ƒìÿ<}*Ëá:îÄB(AºK¹ı¸Z
+&]sk~lĞƒû0úÿ~ıÚÄx(ÆØjN’ì:AhI#'<E¯ë
+bL¢R¶6J¨e¡8Ô=*FèJ$íâ%=ECnÔ<(M4ø=šm±§1ô6)Œ­+SÁèÒ”55îÕŞzQô€„’à*¤:xd¤ğé¿¡¥!zí@mçs¶ş¦d3†(ÿ9
+¾}sæ–ûôò£şh.À&­«ÌIeÔ¶µûyyÿme&½bk-ÊK©‘˜™®f|´Øìsáè¹•¸”ìğãô‡¤]µ•%Pq„ÅVYƒ…»@T´"Äùõ…‰¡®XûWU¾ß¬h½Ø–˜"´@o#š0)¡j]©G^€rŒPµô”î]$šDù€'zWtÙÜ6Cr·‰Ôp ¨VR«‰ÕSÖÚ­nO4c’RGõCŞk—Vt	Å|Qü‡dğxêû¤×¯g´iSH÷5ã˜ædË(ŞÆC‚T™Öd©øˆ¢‚²U}Ø«ÀÉ¸í"Üß—öh‡Ã)ÅáÆÂĞ3©æäÑÚP±µ„^“kì(ìœ]4·ªšÒ÷¬<N5T`£(.Øj»lâ¸6T6„ù”ÕÔn?ªÓ•¶Éšá€àYu\Ä´>ºIoîúg÷h0öôK÷ìïq3€à´õn§<1¥àÚUÈFô¼7
+ü¿ÚŸĞ^r9<0¿6¿Ì!IÏ¾F	B@MÒ‰Ú>š Ö'ÑÃ¤1ÚÈi[K€$•$¥I©qU»qš1s#¬1¦ˆˆÍÈ=VwÑœÂÛ:F†½¢Zit¬Î7ö™yÑa>ë,”Ç¥ËLarj¶%7I ï‚jÑ7à+åJ¤6‡~5#‡J91QH¬öƒÑ#µ™F§oğQ*íÀ~’ZÃød6‰Î¤t¬>Hë[U{Oz0RÉášÁbeæ 8…°CZğÀ„Cç hƒ6ùûôt¯CÏ<Ëš[2ÎFˆı‹ñpc¾JŸ¸+lLLw)@­î†Ş˜ˆúÙ†m/ˆu7*
+£%ø‘ÉJÛÙÃ„·cJû.Ñªmy¼<.ÃŠa](İ[ÁŸYÑ«”±¯ÑstÏb6«YpD*Æ´²SØ£\vOÈéÖTN½O©Ğí"´¯yøÔõcû˜Bøìf³.…½ÛkFü¨ªç¨•œüAåÙ“TÓ)Ñ`†ˆûÜ.h’TÙ7`BØt'×aó:!M¹ì˜ÒpÏx­!ÄR^8Z4«y]Ä–İÈb¤¦ 10_/ZÍàâ‰,Gn(VHê8›‘…|\Å1Ùÿ)DGlš‡—Klv‘¹•cngjSĞiív&¶áø—’º"´É_şÓFÆO^†¡û¶ŠÓ½–À;\ëÙŒ¿ú5ëĞæØİîÔ,îÒP“Ê {€Ó-%oVgù‘ÍŸÁG¸rı×øWG3ì–I¸Lz°4ğË¤27‹şÌpW!â	ŸnPä'Õól}—#Ì•ø$	áàÅ‹]ú‘ÕÿiÀıìŠe‹ñ—bD+‚S“¡‚ùz
+ÏƒÄ÷»„ùL?¨ş‚@ì,§jÂ?%öè\c€Qp~1×ÙÉWG†k•ÎTÓ€x€ÜËc'¢9„¶\lîŸíOºÄ
+ÓŞş*‹º¢*¾²§0pÚi1Ñâ6~jFDmZA¬FµYVU¤óeÑÈ*"?˜1 ¾{
+j)´ĞæZ×±Ì&Ë¬PFv¥^F¼ò@ø>½òGp^\õû_Ğ0÷X¦¾“<2ÖÆ%|`¢§ä9-6àœÏÍVÂšHçÑ ú@Ôq
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/f9/f3eb6971058245fb16c057ce548efc7832b124 squashfs-tools-patched/.git/objects/f9/f3eb6971058245fb16c057ce548efc7832b124
--- squashfs-tools/.git/objects/f9/f3eb6971058245fb16c057ce548efc7832b124	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/f9/f3eb6971058245fb16c057ce548efc7832b124	2022-01-01 15:09:15.633172589 +0800
@@ -0,0 +1,8 @@
+xí[koã¶½Ÿı+¸º÷ÃnÑÚÙ8È¦As[~D­‚-·Ã€!K´­®,
+zl’ıõR´^–GRÑ.`³¡(òğÌp8Ã™I6èãÕõ§›ÿüÍ!.Ùz¨‡¿b“ØØAsÏ×‚d‡ü‰5£ŸĞD=à;¡c–ã U²ª}QwM-ìÜırõÿF!àC3ÕÃ:êú†©3àÑ€8ÕC¿cÇ5ˆ…®› óÃ¨7E“©‚ú=IÇT*ÙPyûHøÃ°Ú—èıÓÍõ$Ë%@±cÛ¦¡© èâéâãE»ÑÃ»3P:öğÆß-ïÆıù¼3ì#eo¸şYÄC*úªš†ê¼Ñ›H!hÃ{´™ÍÕâ»†µC“qç·ş’ïbäí1ê?ÙÄñĞ˜ƒ ª¥#úãøVÔ!*1(ÔÚ¢HÉM !4£&QéøHS-äÚX3¶ÏÀZ#ÖÖØù `ªÆÇ=¶è@VH2ê»yF:ˆÆ^Q®l ¦t¤G²¦aø0A?©ÛÄ·HTÊãMc“R¾D%™¸®±¹ÔöÄĞ°‹¶0vR0ÕÉf)-h†M¬ºX@ï7ğK§Ò½h8"2ˆÌnjÄã5B¦]®².ŞÖqõÃ³<›Ê¨cšäQÆ,6°²¶±¥cK3`èremæš¶¦Nƒz
+$ñêÑTSV½=­eùN3›ø	7fsñÎÑX±ñN $üï=˜ÍİİÅÖÁÉ”RlÌngŞG¯Ç1bÖ2m¬GÆÆQWÖbê{¶ï­{†ƒ„£±$€%ËÃÎëx­‚fŠêì0Ç	Å>!E+rùQy™…´³ˆƒ×Ó¡âFªHsëôzˆ	³€Z1É ÖmÔ~F­é%jõ`•H“ö¥ÀŠ“^¿»åµ8Ì§£>wÅ9 ß ‡Z¨¢'€ÇJ\BB³¹
+ş­2Fà˜I±q|aîéíSs½ãÃ2¡ÀPËïõñgÔÒ‘Àésj¹¯»s±}y·q5êõ™9²0Pöò¨+”¬I“ß ?øË/éÎÁ+ô;6Û—M&‚„Ã‹;İà¥GÃrmBLÖ<°nîøUÿªÚÇfî›Gˆz¼	”Tßã¾oè…èíØ ŠšÍşUdBtıûìzøpŸEôD¦=Ä [©}sÍÿ¦Ï&÷\}¢ñ½[A»]-i´2¿Tj»°ªˆíİN¦à~¾¥Ï]eÖÄ5ß²õÍ­»ÀFã]4ïŸáµƒ°YÖg‘¯;J}ê+3¥}"C?Ë_‡\òi¼Ä _}üõRŸ­§}öúlŸ=\æømRƒdøîÄH¯÷İñá³ı7€/şÿ}|ıæ¿i\ùG‚I‘¿Ñi…nQÿá=ÛøÖÅ¶÷æÔƒÁKûÕJÎóí	åŸíÀÃ<¥¬s¶ÊãÎ3‚.vã9íò7¾l¤ò>d\HöÔÙŸğ¬ìïÇ°·NíÏã›òØ^=¶O†tÿ³8ZôúP9æíézÖJseöT¦³qGYZ&»KIæ›Ş *-à;Lây6€±ä|TYŸˆh.VuÅ_×Ÿo®ƒñZ>XX%NeN0¬ÖrGIu…ÊnºN–Ç½T³^0ê(<i	¥±<šöÒµ1ÙÅÙƒ¬L×hùiG2ÛIMUFÄŒOİb"‰!‡uâ){VóidGÏ·ì'H¸h"ô}g?©İú§oêeñnÄÉ–=Èjßr¨ï4‡Zep˜¸œ`–pqøÍlõ·ßm<ø¦(œ†Ştƒ|zémAÁG±T-ód»é·à†Ù:‚/Õùñ[ãÉç¿x
+™ˆÅe2ØDN<dOôi<ÓÉÉÇ”5pÅo-K€¾›/’zVF›H¶b¡9‘l½…^öéûËt'=øRIÃgp¾„ úWóLFÆ¼&,â5ˆgƒ… , Ì†ñm$Ìád7
+÷=¼U}Ó[Ãa<I§kAó9ñ³ÃôFc>]ÌÄş]sÅI4Ûúá©Ìƒ@}£ãİº‰×@î3;R(FŞ&ÄÉÁv°ë#
+—œåáFç•’7W´;û¯™Mµ@m±Î=¬;Í@ƒ¯ÒTJ&}«&G”l&¹Ó7S­©&Î™ÀLÃi®"X±Ììdu¯Ü,å¢eë¨Ğnò°ãÚ$Ú^Vîü–çÌ_xp@NëœY-W àš¡ÒBÓB-¦ .ëÀ¸¯dVH»&Wu€ŒUÃÊ(×àK[—¼ê]Çß9Ã¿d)”²’‚i×Ã¦½¬§`‚^©¡«z(]mêÁ),×òîÅj–w¯º{q&¿ºKJ‡(ksqŒ²Ç(;³	Œ²ÓyÕœæÇi¬zÚ~`À½2§ä4–’<uòXnC á'QbÀ à›UeF6‹ÜÅÒuTKÛWX0À*øÇ5Mz­+¼Â¾°Ğ_üø™©@¡‡:¥|ts¿®æ(Àj×]‚-~Íãø/K˜;›•;å,¬à¦ÇYÑ«ÜÒ´ÜâÈDzY¶Àø’ÁÜÎ.¿‘H0+z'U«"L'[”BcN°¡`p»{÷ÕdÕ~50;Å¬Ìr&ÖÁPª2¼Ş-r´èj(Ü ÆÏP(Ï%Dá¤*#Mğã=˜’Y‹ÅÀªNÙ²;kWƒıp zøÀ•ô¯Ø)ù ±„ZG¼zØ)ªjSY€V•™×¯*¬=nï¿Ã‘:¼Ê–*76~úfØğ·?Õ
+‡ÆF0 ¬ÜÒÓ••-ÕKa…IV×ßn+¸4N%6°)­‡NT‰O0[Ï0+ÏX*›Ó©æï¸$öÁôõa€íÙADd½»ğG9ûŠ½³P`²lä™z(=.í[zÔ¿aˆCgS£ÁO‘‚£ş“¿ zÀ{
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/fa/ac2e6e8d99469f4812f2335655b6ae5a895546 squashfs-tools-patched/.git/objects/fa/ac2e6e8d99469f4812f2335655b6ae5a895546
--- squashfs-tools/.git/objects/fa/ac2e6e8d99469f4812f2335655b6ae5a895546	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/fa/ac2e6e8d99469f4812f2335655b6ae5a895546	2022-01-01 15:09:15.605172588 +0800
@@ -0,0 +1,5 @@
+xíXÛnã6í³¾b¢ö!Yl¥$NÓ]£.`[²k¬o°”îfÀ (Úf#‰‚.¹ì×w¨‹eÇë8Q´„"gÎÎ‡dO8ğËÙÅÇ~„§‘ˆÅ"ƒİ1O„,+I].`‰¿M Ç=?Ã˜ø¬¥¿ùä*áŠ=SBoÉ’Áä>`Që·‹ß•gñúÍHÂ\è¤Üs3Ü÷Ğ‘Oø“E1\j§§óîOl0Ÿ
+vÚíYß¾š ~æAã>\@W±@†í0ô8%	¢¨púpzvÚP”n¯ß*)#ãÜÏ`NºTF¦eµû&Ø+ş"wÄã.øä–-pŞØœŒn"ÍÂ"'iÌƒ%ŒGíOæû
+)$+æC(¢FPáû$pAşFiP9T­
+ô¬3¬!U«,ªÖµH’ âQ¾xDÒT¾L1»2‡÷+È8Ášcåë<‚‹3Ë†$UŸ`ıÓè(;J®pöX`Ä=Ö¬@ªÖÚ°Z+Û‰W+ïª5qÌ¬"]	NY¼=+}ŸÂ:aë03æ13üãÊ™\1'—]ÀlÁÔ…“+·Ã–<(7~Og“)´=OÜOY„‹g°.(ÇÙË-ÙX”Îå>”›Tu³{((ñ¦$YÉşîtÚ¢Æ˜2³º­ˆfMåhĞP:Ærœ¨ĞjU«k'Y’f²Ó¶L¸ŠÙ|ÔëVDÖ½Y.æCîD$Ú¢šYLÒ$L“¹Á#PË2l‚„E>s9
+Á3f6‰–¬ÀYÏz‡”ìØËç9*‡Y–ˆØ<ßÉrºU*rkd“Ç"€O,èŸ ÷¿€>9İÀõ77ÎÕ¬96ÌÎU?oÏ»“±5šÅ×¨Óµ°y~=tŠ©“è[À#;¯\‚ZW{ÖîÚ9òõ—"N6\? {¨ gAwA-ø6{‡;V·qŞrb*µ3[~9ù4,“SF“ë¾á`ü	ıQvnŸ:çCpË¢€ysÍÃj ÔFEséò¢uÏƒ8ÂË,PÈ\oYŒ÷„¥Y¼b^‰ƒ'Ga‚-’&ÅGšr7C®CKlÒ°øø_‘Y/º8uâÇ8a~µ3;uøJysĞøpY$ş-ŸŠûÒ|‚.Ò¤©ÒæMŠW¢ïF™ğªŠrd-ó°úæ'K]í=Ã‚Vš½)xîæğ®æ}Çè©¶eè/Òİ5—ı41øw4×Ïu÷ë µ×}ª½ókoÿë^ıEÔLİ1Rİ(RˆË¯ãbûÄ¸~cyHü''ÃsâáÊ—li2è¡ë$!kÆ,LŞ:?İ¿¯Nò¡~’}”í±ª]İÙsA”ßù|ç1¹qËİc±–Ùü`‰4¢,{ı*Š5¹šuÍ–¦İüúM¾³5yå3ñ™¸iU¾6ûv=Wu<­$bÄ¯µx²k5Ë§­5w¬±¦íˆ®êbe·ÛÂ³İÜs”ÔŠ¾µâşAâšYò‰ÁjUî)éZ‹¯OÌ vTéúê¨7¥Ô)½ÂçÆÿÄõÕ„µÏ—xÏL¥Ú*—KOñ?åo)~
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/fb/b98b84e6775413b04620e8368aa29e55fee6ac squashfs-tools-patched/.git/objects/fb/b98b84e6775413b04620e8368aa29e55fee6ac
--- squashfs-tools/.git/objects/fb/b98b84e6775413b04620e8368aa29e55fee6ac	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/fb/b98b84e6775413b04620e8368aa29e55fee6ac	2022-01-01 15:09:15.609172588 +0800
@@ -0,0 +1,3 @@
+xmQKÃ0…}õşŠ8ú°
+fLƒÁÚlÕÄ”¥>(ƒ¶£iÚô×›ºŠİ&äáæ»ç\î=™­3t7]°g)Ò ‰¤ñãÃr
+É–oĞÑäXi Ñ`#óÆ‡ÒG;@èfE8K¶k!$‹$K‡’‡÷¸“x|GÛR=5Æâ:{ëä¤X[ç}³7D¦*Î	kY©VúÄXªuu„æmd¬úæ­h>´*‡,}u¤øì÷ÿt8Ùğ³~÷ƒ+Såv_h4ÂxâI’I¸7¶À¥zxæ…‹î:ôq—n„KJ~ë;E?nœÿ_É7£{p
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/fb/d257016a8240c409e376a2ce30c75b41f5a6bd squashfs-tools-patched/.git/objects/fb/d257016a8240c409e376a2ce30c75b41f5a6bd
--- squashfs-tools/.git/objects/fb/d257016a8240c409e376a2ce30c75b41f5a6bd	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/fb/d257016a8240c409e376a2ce30c75b41f5a6bd	2022-01-01 15:09:15.621172589 +0800
@@ -0,0 +1 @@
+xµ»‚0†û'¸€! ²˜:jâ`bDgBË!`!¥5^â»‹7Âàêúı—•Ï›\üİfŸë#sx]2,/uŠ`D*õ³³“=Öu[ÚÃLÏ»·áa-”7…0ã/—‚W)JJ#ÍVE©PšÁE!ŒÒD%6|&MqE‹Ü€D¥¥ J»‡°'”Ê|Mb¦³å¶jl˜Xsrÿ-_à¿åã—ü°go:
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/fb/ef6837f86997a26f32cb64eb1fd6a145b409e6 squashfs-tools-patched/.git/objects/fb/ef6837f86997a26f32cb64eb1fd6a145b409e6
--- squashfs-tools/.git/objects/fb/ef6837f86997a26f32cb64eb1fd6a145b409e6	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/fb/ef6837f86997a26f32cb64eb1fd6a145b409e6	2022-01-01 15:09:15.593172588 +0800
@@ -0,0 +1,6 @@
+x•TKOÛ@îyÅˆ
+–Ä}¤jªJUÅRD†FêÅZÛ“x…³¼›¤¤â¿³»~Ô)µ9Åó½f&Ç¹ˆ¡ï>¼9q`°;g9gày`¾A0%şéé'¯ß÷|>C°\ÑM.6úéjç,T,)ãàœÒcsâ¢hğ3:&ãè‚ôtqÜ«¢åÍ‚Ëw~C¹Ç‘®œMg¡U“ò”Í­¯¡?ÇOòuŠğeËx*¶ò8ûªE¹DPCR¥L”@íVA7+ÔšBˆßk>åôÍ£g‡SšlºªX'Šü& ÕÏú¸øvy6CFyšãĞPmW f+àÌõvËªméF¡İı`©ÍF‚—Y‡
+ÎêhHf×(!àæŠ¦+ä-Ô…Äh Éh§K¬ùÓµú?er!±å¯İÌ¢
+¤©„%ıuèH¶CWì	˜©ŞJ0µ#ˆ”îS_…í×Ú]k]ËÍ;«“RE]«ŠXÇ*g[0ëa»üfß3,ÇÍöO7!âİ8àêã{½c!]‡;ƒƒ(Ø‚ñz‹vŠï¨&È*ÛßVêÜBf€“
+x¨ôò–íS3ÿ›Ó
+B¼oèÒÜJ}fËC¢OÆtÓbµo§UF:QáçzY‰Ê“z©¼û‡jJ;¿®u„×ĞëÉ÷ú`«]½<|ÃiG7Åì«Â«÷ËHä’
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/fd/ef14581018edf602c3a9be320e827266cc258c squashfs-tools-patched/.git/objects/fd/ef14581018edf602c3a9be320e827266cc258c
--- squashfs-tools/.git/objects/fd/ef14581018edf602c3a9be320e827266cc258c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/fd/ef14581018edf602c3a9be320e827266cc258c	2022-01-01 15:09:15.617172589 +0800
@@ -0,0 +1,3 @@
+xu“ÉNã@†çì§(”‡!‹Çh„8ÓÛ¼ ‘K+vÒ’§y‘ˆwŸrâ=p±åZşêÿëòkœ¼Ât¢ııuyWÁ~Ç³ß[¸¸T”‘ˆäšGÀ˜I‡º,xy">{PF’Ÿ&š–Ğ’ù|V~ì¥c°ĞrƒùŒY>mêŞ7*ÇZ(d&6’¯!NäFñ8ã?–™c…\‹¨~5“o÷yÛW~´ÂoÛUzR_NŸê½IS½íÉ¶IÚÌRQãİ_2—2ôÄt­Ä…¹
+‹ÈaŸ)¼%ÿv"æ)¬Éó²b·C¹ƒÃãÔ¨ º¢½3áŒoU€ßdÏÄû±…1œ¤kß`
+7çªIUœ•¡ù…eæ[KÒú3Ü	´ĞK‰¨¤’ãÕÖ ¢$…Ñd¯ÒÊ·+	Üßv÷Î\`‰/>ğ>+›íÆnS	åuøì§Ë½ìNuq(ï?´@Z¸ÿm˜>‚:w"„İÁˆçQÔi?EÃ€.âPïÔY?gzfİ5wg\§ÀrlPµ~ËÂ°0øgPmxæƒõLj1½“ö,—>ªïcø,àošò¬ˆs7€Ñk‘ÚÆÎn`2†”çE*ÛÒkøÂÃ1ı„hI
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/fe/67e4f5a168562dd7b4eabcca350f28d01e9613 squashfs-tools-patched/.git/objects/fe/67e4f5a168562dd7b4eabcca350f28d01e9613
--- squashfs-tools/.git/objects/fe/67e4f5a168562dd7b4eabcca350f28d01e9613	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/fe/67e4f5a168562dd7b4eabcca350f28d01e9613	2022-01-01 15:09:15.629172589 +0800
@@ -0,0 +1,11 @@
+xÅZ}OÛVşÎ§8[¥Î!¥¤«*hû(„P¢@	ÛÔ!™ä¦X86‹Z†ºÏ¾ór¯}¯í$ô™´§B‚ØçıåwÏ=éu_Ã›×ÍWÿÙÙãîË›ZíYMÂåTÁ÷/_îd?İx>£C5K^Ş|¿¨;DAh:aOˆªùs•Üù…úÇ§AotŞéöà‘,™MÕ;£ãqg8ì|·j Iê§Á&q”¤ğs?JÛ-¸=ö“›Ö(øSÁ;hÂÛ·ĞÜİGÚ²„6>]!ãt9'1‡ÁBMÒƒ‡T%(ŒÅ¬g0¤¯Hã
+RÜvì{#Ô¶…ıë%ØZm-@…‰ú6íĞ3Mƒò=[ÏÿOƒ¢­\™4Û%¯ùºÎYÛŒevˆ~ëŸÃjgÿMc›¯ÅTıgXªA¤àâ¸7ìa¹öÆ‡ıa¯{1æò=øxÑ}£á-Ipeè´§¦ôÖ‘Ré9Q~[pkpƒÎuQ«ÔjD–sln:’Ì~ÙYÊ› a5ç
+BéIMÈ]"„¦D©HuµìWãÂJ{[g³Y¢RÛŞı
+di¯ö¸]–àx…âLÁJìº?ÜÑT-»{{îg¯¾‡îo0-Şnıı=Y¦¿øáRQÔk_kµû8˜‚Ë··w´Pêâ&Hº¡Ÿ$5ÑŸè¥ÇR9ü—à×:q”JùT„İ“ßúÑ¯èOüY¬ğPŠ-ø—û€Œ£n%¹Fó.½‹ã³Ãşà¼äew¡üTyÙÑİı¤2{‘¡½Rwéô`9›©ÅšÅ|‡zÀÌ)şÿË‰Šª™:³T-$tZO‚
+†*Q‹{šgi¥T—õáSV`é*’ŠØ¾iıÈ€ÌÀsÂ©İİ¨Q{¸YáÈ}©×ÑJ* Rì*A‹à=Übœ°øâÅi¼˜û!Æ˜[1{ô`¡Òå"‚Ş¸úKç¤Ø~°úÊ¬c;(ïì	•y¤>w&a0‘LR1ø®‘Má ë¥¤¿Ã3?‡JæwØK‰âLfòh|ö“ˆ\YíÔ!hV…¾}À¡iG?¤0¹ñ£O
+‚Tü§æ¦:êö¾ÀV”'ÏËP“@´QVUGt¦Æ3Í]ç~–æ!XáÅßm·ÌóŞøìç‹³£Aop6üÈmX‰™½ù]ú@@Ïˆ„NàÀP[Û°ı(H½şHı±TQøa?¥ØÃsØJø·ôÙ°zö“[úÌ¨iØIìdÓ÷k† ŞæçFl‚FC|çX\WHxëMùuRxg£ÜPM—%ˆxÛMÖ«ËYjqÍvwì×K05T¡ò%®¤Ãz(<ßÊªÃ±ü¬]¢fİ”Oæ\:èaë."®ÓSµ8Qî³6?s .Uó;U‡ó½½ÿ:T—ZÜåîÕüæSóŠâ—KF&æ}R»2foƒ„èDÒyLø;è$zFdëªN3ù›zŒ†€üh¦WåA=@?²nAĞÖ2¨ˆš¯xNã´FMÅö­âŸÄıßˆñS£“G7÷š]ÆòÛºJµWE£åT+ÜO+K	…1¶X»¦0‡:CU™l:µH…c*&÷‰]*dòµÓ”è.µ@Ñæ¦±¹"Š¨°:°­Z@¤ËòA¥'1IÊ£¾­)Î<~4Q‰S\¡ŠN‚yRwòqx‡¨†ˆ}Ö¾ÅP !O`Ò°a{Ú¤$Eßü96]&¶aŒjˆ˜”z¢²sƒ`‚ì¨ÙEÔ@Ü+LdA$Hì‘Pœ=¦üÖá¿xÎÓKT\<„ë°'×qÃÉrA>]óHĞ†ÚJiD":Âª–´NĞX›ã9[…Í©@‘ZüæÄ<fÜ^"NçRåoË¬BGÿ‰ü|Ne× s5^Ã\`¨X¥äÆc(¹[P²ùR*úâÓ°üàÃa‰ÑÙÈjù²E'õî—#ıb€•«~¯çD.©].sIğeFˆbŞ~ÂcK¨Qı+¨Òe”ñaIéa’fh]úâÌ¥Zôr”Ún”ÌõP¢$.F©’¦2JíµQjcÓH¿oˆ‰Ù%VUˆR»2Jz‰CÃ%şXU(÷İ¬	L¬³ Q-qWXÉŸY0ƒ2ÎÑu¬ºz%@È@³êæ÷—4œÇ	ÅÌè&ª¼”*‡V§|ıÎ†ª0>Œª‘i-
+©¥­’®ÊÀç› Tàé
+Ìq´ ­XÒ†p…œ™”Qz4¨d)£4LLâeD‹lß@±ÂhÅüKH¦<OJåF,×8ßß
+7.d6½~h’ìí„1b¹Xà=A€¹"”Fê46c‚1L½;ÔC` …\^ñ£ıH`t,•Û©Î×häbHŠÉ1#'ñrX2Ã§*Lırô½Å¼æ²ssòº´Ó)‚-t’Ê¢dY¦-*¸åÚ)Ç&vÚê‰lìÓ_âI›	óŠ/±¢˜‘7U‰••7X­ #Á§Ú#í›YÈ¨@ƒéà zÛÛR¥tÍçDĞË22ÓÉ]~J‹DêÖ<Î¯ğ^`ÁA[9ƒ`şñ›”µ+ima8œ²á97qùÇ¶+LOÆÒÇ¥=Øª{æár>pÆD™
+ùl,jt[.Ïe¢˜g24xãôTëÿsN²fM§è¦"{$s'$KY;sî|ªí'è±e#‡%\fÅÆÑ§˜æG$©+>Ë,Á©¥rOœ-òôvX#o²¼6ª>Aœ¾'ÃH9Š¼Ì†°zz¡ÅDËy_¿Ú´Ë".Üé˜{nshç¥‘’-t‘6ÓqOÛp$fpÇC‚¤µåšñÆ «a©ØeÇ"	ºí\€–M.É6‰)è)A»/Ê”–Ú·´Ä÷
+“ªS@İÚh8ñf„. 3ßØ×2©Ü}*Öh™&.:Æ…;BœT+v»V…£™Vì¿0*/¯¼Ü¤·|‹_¨/”G#ÑÙtãu7çÚ}º$ºÛ6©²J}|Šàà`«sÿ×şä6Û„…t[^kN&­yÂ.|ßf‚nçŞBÚ«QD(ïkâPA^¡Ï^ıUä\öqWæ!©·5z+X3.‡úùÚj¤Ò®†'?¥2·=[€á†­‰–#ÇÖ|œ½Áq@¿ªªÁJd“/{¨àğ¿ÜZÍ•Ë@È?o¿®.­èƒè“|ÙÀ¡"½N‰–äsŸWšÂ_î|«%ÌôCŠÒÉÚ$ÿNî
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/fe/ca07b7c22e0d53d657c36028bc5609210bb900 squashfs-tools-patched/.git/objects/fe/ca07b7c22e0d53d657c36028bc5609210bb900
--- squashfs-tools/.git/objects/fe/ca07b7c22e0d53d657c36028bc5609210bb900	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/fe/ca07b7c22e0d53d657c36028bc5609210bb900	2022-01-01 15:09:40.209173600 +0800
@@ -0,0 +1,2 @@
+x+)JMU0425c040031Q0¯r*MÓKfyşåÑN%ÑcËv9¶M¬vcº¦ğoŠ’†£{Ûçœº³/ªXlÉ£)'î+ÇúÌDVb4¦WüÁ\uº\›ä,gàé‘bWã\”TR8M[Gã‚kÒóºgïœ×äÜêsEIÃÍsU¬Sÿó¸G`zÙôka¸·ÌœT 1³\Î:pò{@ş±ñ·jË«ócÛ®¡ªÉ`øı>ÃüGæôEùF§S^Ë_[èº…ó\MpIQjb.Ğ¤6e­Åò¿9¦Çœ8­uøûÆ_m}mpUa©EÅ™ùyzÛ_+‡z|óššSÆ©qé)Ëé)ëPe99ù ¯™vU¥òíwûí°²åÁË…šm¾å0¯A”d0ügË<uãz–Ñ¦Ó·'ÜL.—ºãy§‰(8%gd–¥2˜2‹–™Z·¿›Å=ÿ½ûB«Y“Z¦GCíqJÎ²‚äœ§©3J>ir+ù}·{®•è¿CÈ*2Œ®lŞ95æ>Cª”¿£ì«tå%0E‰@#âB2#u·+o—>~"Y÷/gªªå=$®_xf–¿Uiu¿ùNÇWwÎ!X˜Í{ğœsG{áölI¿Êİh[¸\Ù¡ÄÓÑÌ¨ˆÛïEôñ­VÕÊ;Ûz…7¼û²­ªÈ¹ äg`Ğ·l8¬õòÈ…m÷?nŞìô9.aæ¨"Ÿ*·Ì¼ A&_>Ì[ÚÔı°.B`WÛ#ù‰…%E¨j2¢ç¼şûÿ‰ô?íºwóEYı­aDQã[4iËœëÙš¾K‹(ÿ^x©ïnÉùßÑUe0èÔ¹éFªlJÎ°MÎ]~îì“ƒpU‰Å wÏw,~şØhî§MçõÍì1œ_zlj6\Mn¢K*(QÜ¨Û8ÑoÉÇ.oé“Uez~SšÜŞ )Ê`˜qvß”)Sïúlş“ıB.ƒmòÏ!—¹æL²Ò™»î.óüpı“gÖ\æ|öBâöÿ³hŠ2öï©ÕcÚ¸ûÊ‰P§²wU©×Â¼‘ùd&MbZ*ØZ3£«šuÙÕ3™bíg'ùıDS”Á3ïİq›E^ë„¶İ\È¨rK±ê$©úTå&bØÏ7=kÛÌIºK_ıkùôğÉ²ù;Uõ*BK2sä®f„~³\wD]ï§ğÏ·Ø¿ïÚ’Ì€)Å@çøßÍÜpõÀ”Êº)™û„î}^¾vN3š¢†ÊO+"l]xç¸Ó/Í×³ÁU¤ãCêëù#72
+lU.Ş<uõÊ]¢ õ¯æ
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/ff/0669cad8d76a32b2cbdb90d963771b95b8e789 squashfs-tools-patched/.git/objects/ff/0669cad8d76a32b2cbdb90d963771b95b8e789
--- squashfs-tools/.git/objects/ff/0669cad8d76a32b2cbdb90d963771b95b8e789	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/ff/0669cad8d76a32b2cbdb90d963771b95b8e789	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1,2 @@
+xuP[kƒ0Şs~Å_T°uuƒAW+˜*ôaÍÑÒ¼ûõ‹—KëS’ó]OR©Sx~z}X»°•Rg«xP<ë²ÖOX-´‚¼QY©ÈÆ÷_<?ğ²/t	1k¥nIÜ¤RdÀõ™	îšKäŠcI²‹(É6£]òM,3
+o#Q™l8Â{UsÃZ>iµààÒnègWâ“úÃy1Ú}•ˆöÈcœ—XUëù?ûC°™|X‡¬,0f‡İ§Á—#¿›1*?E±¨4Ø]%±PVhJNŸAçéÌ×uæ¤Áì²¤¡]½ÿ‰W–Ü.ÕİLGÅEnJçÌ¶4
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/objects/ff/79802bc6238ea11b4ebdafce285fc1d7fff518 squashfs-tools-patched/.git/objects/ff/79802bc6238ea11b4ebdafce285fc1d7fff518
--- squashfs-tools/.git/objects/ff/79802bc6238ea11b4ebdafce285fc1d7fff518	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/objects/ff/79802bc6238ea11b4ebdafce285fc1d7fff518	2022-01-01 15:09:15.597172588 +0800
@@ -0,0 +1,7 @@
+xUÛNÛ@í³¿bJ_çB¸ªR „ÊJ”ÀKŠgÆÙ¢ş½3;»ŞM‚*¢ìÙİ™sÎ\v’É	lïîíÙ`Ñ©Š(®:1´Û _Òü’B>á2DEü>o»ÛıŞŞÚjoïÀïeƒè9“Ïø6˜O²4†©|ŠÒ‚MÏû–æq6Ÿ
+Øèt6ñ»¿èqçaÃYØ_œŠXNÅªÕàÁÍŞh(J-‹±¶úà'–yYAú/ÌZÊ^Hùæ£ªÑ©~âÅ›0¯v¶!I3æSñ²d&™Œñhm?ù[	9¯NæI"
+Ş]¦1®ÀšGhXYJ’RT+¶yE…ŒEYŠ)¯†ˆ>Ã°Dôï•ûpáZ<ÍŞ+24d6…‡0kN×òÌ®]F³ÛšíİWb(è!ŒşŒ¯ÎÉHM]~]ÁjÒüÄ:‡ÃCğO£½Õ@G T”Æg…¾¥å(Ö (Ö
+Çz¹ŞÄ'¤&$¦µ¢š¹eôîa‚kÚ.¼½-…ıº×RÀªb!`\
+EN:l.¡¹˜¤ØÛ…y>‹âGÂ7š‰_ã_¢º©µ’Z‹·cUÙ³xÎgcÃÉ!‹£c•UTTW&{Ü
+†QrdéÏZ.Üt1¬Êidıêaß(IB+p8¼/û—ŸJâ§k¡N¬Mª
+=_ûnSGB<^K¿nmpThh=krªÔu­3™WMÉ–†®%Ëœ©qY+©Ó5‚/nMRÎxh44oÕ	nXo(‰ûA¡š0¬½îÖéŞ5r°NÔô£ãCO[Ÿky ë«Y;¢­4LT“¨¸Ô5LÕ°¹åvPÏw¦¨xdÑYäb®›wƒ•½åÔZÔ¤PsÎ¨ÏÂ|ÄËeÆ»VûèFõWoØ;Iš‹©«£M™ŠšáuÔ‹²Ø™.¦%|Í±ë‘üÔ³”³ƒ¡-~›!ûÄ9£¿ôû(sŒSú”½Ñ@¢	_	¼ÔÔD§§z(á’IæàC+sL~ÊÇœ×wÇRv …Ÿö®Ä×fÓ7›öĞã‘Ü¦wê)ƒbı:1£Í0iÙıÜ<ÓšjâÓZ}qÂÑÊ-`0­¨³ãğ‚¼:mb#ëõB1{95ë‚ƒ_“o­cãŠ¡$`vøNÆàÿ«e¹.4,®ïİûUÉØû
\ No newline at end of file
diff --color --strip-trailing-cr -NBbaur squashfs-tools/.git/refs/heads/master squashfs-tools-patched/.git/refs/heads/master
--- squashfs-tools/.git/refs/heads/master	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/.git/refs/heads/master	2022-01-01 15:10:59.989176882 +0800
@@ -0,0 +1 @@
+5ef72270f72986e27fbe07a7a34c5ab685d83d18
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LICENSE squashfs-tools-patched/LICENSE
--- squashfs-tools/LICENSE	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LICENSE	2022-01-01 15:08:47.861171447 +0800
@@ -0,0 +1,339 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/7zC.txt squashfs-tools-patched/LZMA/lzma465/7zC.txt
--- squashfs-tools/LZMA/lzma465/7zC.txt	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/7zC.txt	2022-01-01 15:08:47.861171447 +0800
@@ -0,0 +1,194 @@
+7z ANSI-C Decoder 4.62
+----------------------
+
+7z ANSI-C provides 7z/LZMA decoding.
+7z ANSI-C version is simplified version ported from C++ code.
+
+LZMA is default and general compression method of 7z format
+in 7-Zip compression program (www.7-zip.org). LZMA provides high 
+compression ratio and very fast decompression.
+
+
+LICENSE
+-------
+
+7z ANSI-C Decoder is part of the LZMA SDK.
+LZMA SDK is written and placed in the public domain by Igor Pavlov.
+
+Files
+---------------------
+
+7zDecode.*   - Low level 7z decoding
+7zExtract.*  - High level 7z decoding
+7zHeader.*   - .7z format constants
+7zIn.*       - .7z archive opening
+7zItem.*     - .7z structures
+7zMain.c     - Test application
+
+
+How To Use
+----------
+
+You must download 7-Zip program from www.7-zip.org.
+
+You can create .7z archive with 7z.exe or 7za.exe:
+
+  7za.exe a archive.7z *.htm -r -mx -m0fb=255
+
+If you have big number of files in archive, and you need fast extracting, 
+you can use partly-solid archives:
+  
+  7za.exe a archive.7z *.htm -ms=512K -r -mx -m0fb=255 -m0d=512K
+
+In that example 7-Zip will use 512KB solid blocks. So it needs to decompress only 
+512KB for extracting one file from such archive.
+
+
+Limitations of current version of 7z ANSI-C Decoder
+---------------------------------------------------
+
+ - It reads only "FileName", "Size", "LastWriteTime" and "CRC" information for each file in archive.
+ - It supports only LZMA and Copy (no compression) methods with BCJ or BCJ2 filters.
+ - It converts original UTF-16 Unicode file names to UTF-8 Unicode file names.
+ 
+These limitations will be fixed in future versions.
+
+
+Using 7z ANSI-C Decoder Test application:
+-----------------------------------------
+
+Usage: 7zDec <command> <archive_name>
+
+<Command>:
+  e: Extract files from archive
+  l: List contents of archive
+  t: Test integrity of archive
+
+Example: 
+
+  7zDec l archive.7z
+
+lists contents of archive.7z
+
+  7zDec e archive.7z
+
+extracts files from archive.7z to current folder.
+
+
+How to use .7z Decoder
+----------------------
+
+Memory allocation
+~~~~~~~~~~~~~~~~~
+
+7z Decoder uses two memory pools:
+1) Temporary pool
+2) Main pool
+Such scheme can allow you to avoid fragmentation of allocated blocks.
+
+
+Steps for using 7z decoder
+--------------------------
+
+Use code at 7zMain.c as example.
+
+1) Declare variables:
+  inStream                 /* implements ILookInStream interface */
+  CSzArEx db;              /* 7z archive database structure */
+  ISzAlloc allocImp;       /* memory functions for main pool */
+  ISzAlloc allocTempImp;   /* memory functions for temporary pool */
+
+2) call CrcGenerateTable(); function to initialize CRC structures.
+
+3) call SzArEx_Init(&db); function to initialize db structures.
+
+4) call SzArEx_Open(&db, inStream, &allocMain, &allocTemp) to open archive
+
+This function opens archive "inStream" and reads headers to "db".
+All items in "db" will be allocated with "allocMain" functions.
+SzArEx_Open function allocates and frees temporary structures by "allocTemp" functions.
+
+5) List items or Extract items
+
+  Listing code:
+  ~~~~~~~~~~~~~
+    {
+      UInt32 i;
+      for (i = 0; i < db.db.NumFiles; i++)
+      {
+        CFileItem *f = db.db.Files + i;
+        printf("%10d  %s\n", (int)f->Size, f->Name);
+      }
+    }
+
+  Extracting code:
+  ~~~~~~~~~~~~~~~~
+
+  SZ_RESULT SzAr_Extract(
+    CArchiveDatabaseEx *db,
+    ILookInStream *inStream, 
+    UInt32 fileIndex,         /* index of file */
+    UInt32 *blockIndex,       /* index of solid block */
+    Byte **outBuffer,         /* pointer to pointer to output buffer (allocated with allocMain) */
+    size_t *outBufferSize,    /* buffer size for output buffer */
+    size_t *offset,           /* offset of stream for required file in *outBuffer */
+    size_t *outSizeProcessed, /* size of file in *outBuffer */
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp);
+
+  If you need to decompress more than one file, you can send these values from previous call:
+    blockIndex, 
+    outBuffer, 
+    outBufferSize,
+  You can consider "outBuffer" as cache of solid block. If your archive is solid, 
+  it will increase decompression speed.
+
+  After decompressing you must free "outBuffer":
+  allocImp.Free(outBuffer);
+
+6) call SzArEx_Free(&db, allocImp.Free) to free allocated items in "db".
+
+
+
+
+Memory requirements for .7z decoding 
+------------------------------------
+
+Memory usage for Archive opening:
+  - Temporary pool:
+     - Memory for uncompressed .7z headers
+     - some other temporary blocks
+  - Main pool:
+     - Memory for database: 
+       Estimated size of one file structures in solid archive:
+         - Size (4 or 8 Bytes)
+         - CRC32 (4 bytes)
+         - LastWriteTime (8 bytes)
+         - Some file information (4 bytes)
+         - File Name (variable length) + pointer + allocation structures
+
+Memory usage for archive Decompressing:
+  - Temporary pool:
+     - Memory for LZMA decompressing structures
+  - Main pool:
+     - Memory for decompressed solid block
+     - Memory for temprorary buffers, if BCJ2 fileter is used. Usually these 
+       temprorary buffers can be about 15% of solid block size. 
+  
+
+7z Decoder doesn't allocate memory for compressed blocks. 
+Instead of this, you must allocate buffer with desired 
+size before calling 7z Decoder. Use 7zMain.c as example.
+
+
+Defines
+-------
+
+_SZ_ALLOC_DEBUG   - define it if you want to debug alloc/free operations to stderr.
+
+
+---
+
+http://www.7-zip.org
+http://www.7-zip.org/sdk.html
+http://www.7-zip.org/support.html
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/7zFormat.txt squashfs-tools-patched/LZMA/lzma465/7zFormat.txt
--- squashfs-tools/LZMA/lzma465/7zFormat.txt	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/7zFormat.txt	2022-01-01 15:08:47.861171447 +0800
@@ -0,0 +1,471 @@
+7z Format description (2.30 Beta 25)
+-----------------------------------
+
+This file contains description of 7z archive format. 
+7z archive can contain files compressed with any method.
+See "Methods.txt" for description for defined compressing methods.
+
+
+Format structure Overview
+-------------------------
+
+Some fields can be optional.
+
+Archive structure
+~~~~~~~~~~~~~~~~~  
+SignatureHeader
+[PackedStreams]
+[PackedStreamsForHeaders]
+[
+  Header 
+  or 
+  {
+    Packed Header
+    HeaderInfo
+  }
+]
+
+
+
+Header structure
+~~~~~~~~~~~~~~~~  
+{
+  ArchiveProperties
+  AdditionalStreams
+  {
+    PackInfo
+    {
+      PackPos
+      NumPackStreams
+      Sizes[NumPackStreams]
+      CRCs[NumPackStreams]
+    }
+    CodersInfo
+    {
+      NumFolders
+      Folders[NumFolders]
+      {
+        NumCoders
+        CodersInfo[NumCoders]
+        {
+          ID
+          NumInStreams;
+          NumOutStreams;
+          PropertiesSize
+          Properties[PropertiesSize]
+        }
+        NumBindPairs
+        BindPairsInfo[NumBindPairs]
+        {
+          InIndex;
+          OutIndex;
+        }
+        PackedIndices
+      }
+      UnPackSize[Folders][Folders.NumOutstreams]
+      CRCs[NumFolders]
+    }
+    SubStreamsInfo
+    {
+      NumUnPackStreamsInFolders[NumFolders];
+      UnPackSizes[]
+      CRCs[]
+    }
+  }
+  MainStreamsInfo
+  {
+    (Same as in AdditionalStreams)
+  }
+  FilesInfo
+  {
+    NumFiles
+    Properties[]
+    {
+      ID
+      Size
+      Data
+    }
+  }
+}
+
+HeaderInfo structure
+~~~~~~~~~~~~~~~~~~~~
+{
+  (Same as in AdditionalStreams)
+}
+
+
+
+Notes about Notation and encoding
+---------------------------------
+
+7z uses little endian encoding.
+
+7z archive format has optional headers that are marked as
+[]
+Header
+[]
+
+REAL_UINT64 means real UINT64.
+
+UINT64 means real UINT64 encoded with the following scheme:
+
+  Size of encoding sequence depends from first byte:
+  First_Byte  Extra_Bytes        Value
+  (binary)   
+  0xxxxxxx               : ( xxxxxxx           )
+  10xxxxxx    BYTE y[1]  : (  xxxxxx << (8 * 1)) + y
+  110xxxxx    BYTE y[2]  : (   xxxxx << (8 * 2)) + y
+  ...
+  1111110x    BYTE y[6]  : (       x << (8 * 6)) + y
+  11111110    BYTE y[7]  :                         y
+  11111111    BYTE y[8]  :                         y
+
+
+
+Property IDs
+------------
+
+0x00 = kEnd,
+
+0x01 = kHeader,
+
+0x02 = kArchiveProperties,
+    
+0x03 = kAdditionalStreamsInfo,
+0x04 = kMainStreamsInfo,
+0x05 = kFilesInfo,
+    
+0x06 = kPackInfo,
+0x07 = kUnPackInfo,
+0x08 = kSubStreamsInfo,
+
+0x09 = kSize,
+0x0A = kCRC,
+
+0x0B = kFolder,
+
+0x0C = kCodersUnPackSize,
+0x0D = kNumUnPackStream,
+
+0x0E = kEmptyStream,
+0x0F = kEmptyFile,
+0x10 = kAnti,
+
+0x11 = kName,
+0x12 = kCreationTime,
+0x13 = kLastAccessTime,
+0x14 = kLastWriteTime,
+0x15 = kWinAttributes,
+0x16 = kComment,
+
+0x17 = kEncodedHeader,
+
+
+7z format headers
+-----------------
+
+SignatureHeader
+~~~~~~~~~~~~~~~
+  BYTE kSignature[6] = {'7', 'z', 0xBC, 0xAF, 0x27, 0x1C};
+
+  ArchiveVersion
+  {
+    BYTE Major;   // now = 0
+    BYTE Minor;   // now = 2
+  };
+
+  UINT32 StartHeaderCRC;
+
+  StartHeader
+  {
+    REAL_UINT64 NextHeaderOffset
+    REAL_UINT64 NextHeaderSize
+    UINT32 NextHeaderCRC
+  }
+
+
+...........................
+
+
+ArchiveProperties
+~~~~~~~~~~~~~~~~~
+BYTE NID::kArchiveProperties (0x02)
+for (;;)
+{
+  BYTE PropertyType;
+  if (aType == 0)
+    break;
+  UINT64 PropertySize;
+  BYTE PropertyData[PropertySize];
+}
+
+
+Digests (NumStreams)
+~~~~~~~~~~~~~~~~~~~~~
+  BYTE AllAreDefined
+  if (AllAreDefined == 0)
+  {
+    for(NumStreams)
+      BIT Defined
+  }
+  UINT32 CRCs[NumDefined]
+
+
+PackInfo
+~~~~~~~~~~~~
+  BYTE NID::kPackInfo  (0x06)
+  UINT64 PackPos
+  UINT64 NumPackStreams
+
+  []
+  BYTE NID::kSize    (0x09)
+  UINT64 PackSizes[NumPackStreams]
+  []
+
+  []
+  BYTE NID::kCRC      (0x0A)
+  PackStreamDigests[NumPackStreams]
+  []
+
+  BYTE NID::kEnd
+
+
+Folder
+~~~~~~
+  UINT64 NumCoders;
+  for (NumCoders)
+  {
+    BYTE 
+    {
+      0:3 DecompressionMethod.IDSize
+      4:
+        0 - IsSimple
+        1 - Is not simple
+      5:
+        0 - No Attributes
+        1 - There Are Attributes
+      7:
+        0 - Last Method in Alternative_Method_List
+        1 - There are more alternative methods
+    } 
+    BYTE DecompressionMethod.ID[DecompressionMethod.IDSize]
+    if (!IsSimple)
+    {
+      UINT64 NumInStreams;
+      UINT64 NumOutStreams;
+    }
+    if (DecompressionMethod[0] != 0)
+    {
+      UINT64 PropertiesSize
+      BYTE Properties[PropertiesSize]
+    }
+  }
+    
+  NumBindPairs = NumOutStreamsTotal - 1;
+
+  for (NumBindPairs)
+  {
+    UINT64 InIndex;
+    UINT64 OutIndex;
+  }
+
+  NumPackedStreams = NumInStreamsTotal - NumBindPairs;
+  if (NumPackedStreams > 1)
+    for(NumPackedStreams)
+    {
+      UINT64 Index;
+    };
+
+
+
+
+Coders Info
+~~~~~~~~~~~
+
+  BYTE NID::kUnPackInfo  (0x07)
+
+
+  BYTE NID::kFolder  (0x0B)
+  UINT64 NumFolders
+  BYTE External
+  switch(External)
+  {
+    case 0:
+      Folders[NumFolders]
+    case 1:
+      UINT64 DataStreamIndex
+  }
+
+
+  BYTE ID::kCodersUnPackSize  (0x0C)
+  for(Folders)
+    for(Folder.NumOutStreams)
+     UINT64 UnPackSize;
+
+
+  []
+  BYTE NID::kCRC   (0x0A)
+  UnPackDigests[NumFolders]
+  []
+
+  
+
+  BYTE NID::kEnd
+
+
+
+SubStreams Info
+~~~~~~~~~~~~~~
+  BYTE NID::kSubStreamsInfo; (0x08)
+
+  []
+  BYTE NID::kNumUnPackStream; (0x0D)
+  UINT64 NumUnPackStreamsInFolders[NumFolders];
+  []
+
+
+  []
+  BYTE NID::kSize  (0x09)
+  UINT64 UnPackSizes[]
+  []
+
+
+  []
+  BYTE NID::kCRC  (0x0A)
+  Digests[Number of streams with unknown CRC]
+  []
+
+  
+  BYTE NID::kEnd
+
+
+Streams Info
+~~~~~~~~~~~~
+
+  []
+  PackInfo
+  []
+
+
+  []
+  CodersInfo
+  []
+
+
+  []
+  SubStreamsInfo
+  []
+
+  BYTE NID::kEnd
+
+
+FilesInfo
+~~~~~~~~~
+  BYTE NID::kFilesInfo;  (0x05)
+  UINT64 NumFiles
+
+  for (;;)
+  {
+    BYTE PropertyType;
+    if (aType == 0)
+      break;
+
+    UINT64 Size;
+
+    switch(PropertyType)
+    {
+      kEmptyStream:   (0x0E)
+        for(NumFiles)
+          BIT IsEmptyStream
+
+      kEmptyFile:     (0x0F)
+        for(EmptyStreams)
+          BIT IsEmptyFile
+
+      kAnti:          (0x10)
+        for(EmptyStreams)
+          BIT IsAntiFile
+      
+      case kCreationTime:   (0x12)
+      case kLastAccessTime: (0x13)
+      case kLastWriteTime:  (0x14)
+        BYTE AllAreDefined
+        if (AllAreDefined == 0)
+        {
+          for(NumFiles)
+            BIT TimeDefined
+        }
+        BYTE External;
+        if(External != 0)
+          UINT64 DataIndex
+        []
+        for(Definded Items)
+          UINT32 Time
+        []
+      
+      kNames:     (0x11)
+        BYTE External;
+        if(External != 0)
+          UINT64 DataIndex
+        []
+        for(Files)
+        {
+          wchar_t Names[NameSize];
+          wchar_t 0;
+        }
+        []
+
+      kAttributes:  (0x15)
+        BYTE AllAreDefined
+        if (AllAreDefined == 0)
+        {
+          for(NumFiles)
+            BIT AttributesAreDefined
+        }
+        BYTE External;
+        if(External != 0)
+          UINT64 DataIndex
+        []
+        for(Definded Attributes)
+          UINT32 Attributes
+        []
+    }
+  }
+
+
+Header
+~~~~~~
+  BYTE NID::kHeader (0x01)
+
+  []
+  ArchiveProperties
+  []
+
+  []
+  BYTE NID::kAdditionalStreamsInfo; (0x03)
+  StreamsInfo
+  []
+
+  []
+  BYTE NID::kMainStreamsInfo;    (0x04)
+  StreamsInfo
+  []
+
+  []
+  FilesInfo
+  []
+
+  BYTE NID::kEnd
+
+
+HeaderInfo
+~~~~~~~~~~
+  []
+  BYTE NID::kEncodedHeader; (0x17)
+  StreamsInfo for Encoded Header
+  []
+
+
+---
+End of document
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/7zBuf2.c squashfs-tools-patched/LZMA/lzma465/C/7zBuf2.c
--- squashfs-tools/LZMA/lzma465/C/7zBuf2.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/7zBuf2.c	2022-01-01 15:08:47.861171447 +0800
@@ -0,0 +1,45 @@
+/* 7zBuf2.c -- Byte Buffer
+2008-10-04 : Igor Pavlov : Public domain */
+
+#include <string.h>
+#include "7zBuf.h"
+
+void DynBuf_Construct(CDynBuf *p)
+{
+  p->data = 0;
+  p->size = 0;
+  p->pos = 0;
+}
+
+void DynBuf_SeekToBeg(CDynBuf *p)
+{
+  p->pos = 0;
+}
+
+int DynBuf_Write(CDynBuf *p, const Byte *buf, size_t size, ISzAlloc *alloc)
+{
+  if (size > p->size - p->pos)
+  {
+    size_t newSize = p->pos + size;
+    Byte *data;
+    newSize += newSize / 4;
+    data = (Byte *)alloc->Alloc(alloc, newSize);
+    if (data == 0)
+      return 0;
+    p->size = newSize;
+    memcpy(data, p->data, p->pos);
+    alloc->Free(alloc, p->data);
+    p->data = data;
+  }
+  memcpy(p->data + p->pos, buf, size);
+  p->pos += size;
+  return 1;
+}
+
+void DynBuf_Free(CDynBuf *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->data);
+  p->data = 0;
+  p->size = 0;
+  p->pos = 0;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/7zBuf.c squashfs-tools-patched/LZMA/lzma465/C/7zBuf.c
--- squashfs-tools/LZMA/lzma465/C/7zBuf.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/7zBuf.c	2022-01-01 15:08:47.861171447 +0800
@@ -0,0 +1,36 @@
+/* 7zBuf.c -- Byte Buffer
+2008-03-28
+Igor Pavlov
+Public domain */
+
+#include "7zBuf.h"
+
+void Buf_Init(CBuf *p)
+{
+  p->data = 0;
+  p->size = 0;
+}
+
+int Buf_Create(CBuf *p, size_t size, ISzAlloc *alloc)
+{
+  p->size = 0;
+  if (size == 0)
+  {
+    p->data = 0;
+    return 1;
+  }
+  p->data = (Byte *)alloc->Alloc(alloc, size);
+  if (p->data != 0)
+  {
+    p->size = size;
+    return 1;
+  }
+  return 0;
+}
+
+void Buf_Free(CBuf *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->data);
+  p->data = 0;
+  p->size = 0;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/7zBuf.h squashfs-tools-patched/LZMA/lzma465/C/7zBuf.h
--- squashfs-tools/LZMA/lzma465/C/7zBuf.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/7zBuf.h	2022-01-01 15:08:47.861171447 +0800
@@ -0,0 +1,31 @@
+/* 7zBuf.h -- Byte Buffer
+2008-10-04 : Igor Pavlov : Public domain */
+
+#ifndef __7Z_BUF_H
+#define __7Z_BUF_H
+
+#include "Types.h"
+
+typedef struct
+{
+  Byte *data;
+  size_t size;
+} CBuf;
+
+void Buf_Init(CBuf *p);
+int Buf_Create(CBuf *p, size_t size, ISzAlloc *alloc);
+void Buf_Free(CBuf *p, ISzAlloc *alloc);
+
+typedef struct
+{
+  Byte *data;
+  size_t size;
+  size_t pos;
+} CDynBuf;
+
+void DynBuf_Construct(CDynBuf *p);
+void DynBuf_SeekToBeg(CDynBuf *p);
+int DynBuf_Write(CDynBuf *p, const Byte *buf, size_t size, ISzAlloc *alloc);
+void DynBuf_Free(CDynBuf *p, ISzAlloc *alloc);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/7zCrc.c squashfs-tools-patched/LZMA/lzma465/C/7zCrc.c
--- squashfs-tools/LZMA/lzma465/C/7zCrc.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/7zCrc.c	2022-01-01 15:08:47.861171447 +0800
@@ -0,0 +1,35 @@
+/* 7zCrc.c -- CRC32 calculation
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#include "7zCrc.h"
+
+#define kCrcPoly 0xEDB88320
+UInt32 g_CrcTable[256];
+
+void MY_FAST_CALL CrcGenerateTable(void)
+{
+  UInt32 i;
+  for (i = 0; i < 256; i++)
+  {
+    UInt32 r = i;
+    int j;
+    for (j = 0; j < 8; j++)
+      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
+    g_CrcTable[i] = r;
+  }
+}
+
+UInt32 MY_FAST_CALL CrcUpdate(UInt32 v, const void *data, size_t size)
+{
+  const Byte *p = (const Byte *)data;
+  for (; size > 0 ; size--, p++)
+    v = CRC_UPDATE_BYTE(v, *p);
+  return v;
+}
+
+UInt32 MY_FAST_CALL CrcCalc(const void *data, size_t size)
+{
+  return CrcUpdate(CRC_INIT_VAL, data, size) ^ 0xFFFFFFFF;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/7zCrc.h squashfs-tools-patched/LZMA/lzma465/C/7zCrc.h
--- squashfs-tools/LZMA/lzma465/C/7zCrc.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/7zCrc.h	2022-01-01 15:08:47.861171447 +0800
@@ -0,0 +1,24 @@
+/* 7zCrc.h -- CRC32 calculation
+2008-03-13
+Igor Pavlov
+Public domain */
+
+#ifndef __7Z_CRC_H
+#define __7Z_CRC_H
+
+#include <stddef.h>
+
+#include "Types.h"
+
+extern UInt32 g_CrcTable[];
+
+void MY_FAST_CALL CrcGenerateTable(void);
+
+#define CRC_INIT_VAL 0xFFFFFFFF
+#define CRC_GET_DIGEST(crc) ((crc) ^ 0xFFFFFFFF)
+#define CRC_UPDATE_BYTE(crc, b) (g_CrcTable[((crc) ^ (b)) & 0xFF] ^ ((crc) >> 8))
+
+UInt32 MY_FAST_CALL CrcUpdate(UInt32 crc, const void *data, size_t size);
+UInt32 MY_FAST_CALL CrcCalc(const void *data, size_t size);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/7zFile.c squashfs-tools-patched/LZMA/lzma465/C/7zFile.c
--- squashfs-tools/LZMA/lzma465/C/7zFile.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/7zFile.c	2022-01-01 15:08:47.861171447 +0800
@@ -0,0 +1,263 @@
+/* 7zFile.c -- File IO
+2008-11-22 : Igor Pavlov : Public domain */
+
+#include "7zFile.h"
+
+#ifndef USE_WINDOWS_FILE
+
+#include <errno.h>
+
+#endif
+
+#ifdef USE_WINDOWS_FILE
+
+/*
+   ReadFile and WriteFile functions in Windows have BUG:
+   If you Read or Write 64MB or more (probably min_failure_size = 64MB - 32KB + 1)
+   from/to Network file, it returns ERROR_NO_SYSTEM_RESOURCES
+   (Insufficient system resources exist to complete the requested service).
+   Probably in some version of Windows there are problems with other sizes:
+   for 32 MB (maybe also for 16 MB).
+   And message can be "Network connection was lost"
+*/
+
+#define kChunkSizeMax (1 << 22)
+
+#endif
+
+void File_Construct(CSzFile *p)
+{
+  #ifdef USE_WINDOWS_FILE
+  p->handle = INVALID_HANDLE_VALUE;
+  #else
+  p->file = NULL;
+  #endif
+}
+
+static WRes File_Open(CSzFile *p, const char *name, int writeMode)
+{
+  #ifdef USE_WINDOWS_FILE
+  p->handle = CreateFileA(name,
+      writeMode ? GENERIC_WRITE : GENERIC_READ,
+      FILE_SHARE_READ, NULL,
+      writeMode ? CREATE_ALWAYS : OPEN_EXISTING,
+      FILE_ATTRIBUTE_NORMAL, NULL);
+  return (p->handle != INVALID_HANDLE_VALUE) ? 0 : GetLastError();
+  #else
+  p->file = fopen(name, writeMode ? "wb+" : "rb");
+  return (p->file != 0) ? 0 : errno;
+  #endif
+}
+
+WRes InFile_Open(CSzFile *p, const char *name) { return File_Open(p, name, 0); }
+WRes OutFile_Open(CSzFile *p, const char *name) { return File_Open(p, name, 1); }
+
+WRes File_Close(CSzFile *p)
+{
+  #ifdef USE_WINDOWS_FILE
+  if (p->handle != INVALID_HANDLE_VALUE)
+  {
+    if (!CloseHandle(p->handle))
+      return GetLastError();
+    p->handle = INVALID_HANDLE_VALUE;
+  }
+  #else
+  if (p->file != NULL)
+  {
+    int res = fclose(p->file);
+    if (res != 0)
+      return res;
+    p->file = NULL;
+  }
+  #endif
+  return 0;
+}
+
+WRes File_Read(CSzFile *p, void *data, size_t *size)
+{
+  size_t originalSize = *size;
+  if (originalSize == 0)
+    return 0;
+
+  #ifdef USE_WINDOWS_FILE
+
+  *size = 0;
+  do
+  {
+    DWORD curSize = (originalSize > kChunkSizeMax) ? kChunkSizeMax : (DWORD)originalSize;
+    DWORD processed = 0;
+    BOOL res = ReadFile(p->handle, data, curSize, &processed, NULL);
+    data = (void *)((Byte *)data + processed);
+    originalSize -= processed;
+    *size += processed;
+    if (!res)
+      return GetLastError();
+    if (processed == 0)
+      break;
+  }
+  while (originalSize > 0);
+  return 0;
+
+  #else
+  
+  *size = fread(data, 1, originalSize, p->file);
+  if (*size == originalSize)
+    return 0;
+  return ferror(p->file);
+  
+  #endif
+}
+
+WRes File_Write(CSzFile *p, const void *data, size_t *size)
+{
+  size_t originalSize = *size;
+  if (originalSize == 0)
+    return 0;
+  
+  #ifdef USE_WINDOWS_FILE
+
+  *size = 0;
+  do
+  {
+    DWORD curSize = (originalSize > kChunkSizeMax) ? kChunkSizeMax : (DWORD)originalSize;
+    DWORD processed = 0;
+    BOOL res = WriteFile(p->handle, data, curSize, &processed, NULL);
+    data = (void *)((Byte *)data + processed);
+    originalSize -= processed;
+    *size += processed;
+    if (!res)
+      return GetLastError();
+    if (processed == 0)
+      break;
+  }
+  while (originalSize > 0);
+  return 0;
+
+  #else
+
+  *size = fwrite(data, 1, originalSize, p->file);
+  if (*size == originalSize)
+    return 0;
+  return ferror(p->file);
+  
+  #endif
+}
+
+WRes File_Seek(CSzFile *p, Int64 *pos, ESzSeek origin)
+{
+  #ifdef USE_WINDOWS_FILE
+
+  LARGE_INTEGER value;
+  DWORD moveMethod;
+  value.LowPart = (DWORD)*pos;
+  value.HighPart = (LONG)((UInt64)*pos >> 16 >> 16); /* for case when UInt64 is 32-bit only */
+  switch (origin)
+  {
+    case SZ_SEEK_SET: moveMethod = FILE_BEGIN; break;
+    case SZ_SEEK_CUR: moveMethod = FILE_CURRENT; break;
+    case SZ_SEEK_END: moveMethod = FILE_END; break;
+    default: return ERROR_INVALID_PARAMETER;
+  }
+  value.LowPart = SetFilePointer(p->handle, value.LowPart, &value.HighPart, moveMethod);
+  if (value.LowPart == 0xFFFFFFFF)
+  {
+    WRes res = GetLastError();
+    if (res != NO_ERROR)
+      return res;
+  }
+  *pos = ((Int64)value.HighPart << 32) | value.LowPart;
+  return 0;
+
+  #else
+  
+  int moveMethod;
+  int res;
+  switch (origin)
+  {
+    case SZ_SEEK_SET: moveMethod = SEEK_SET; break;
+    case SZ_SEEK_CUR: moveMethod = SEEK_CUR; break;
+    case SZ_SEEK_END: moveMethod = SEEK_END; break;
+    default: return 1;
+  }
+  res = fseek(p->file, (long)*pos, moveMethod);
+  *pos = ftell(p->file);
+  return res;
+  
+  #endif
+}
+
+WRes File_GetLength(CSzFile *p, UInt64 *length)
+{
+  #ifdef USE_WINDOWS_FILE
+  
+  DWORD sizeHigh;
+  DWORD sizeLow = GetFileSize(p->handle, &sizeHigh);
+  if (sizeLow == 0xFFFFFFFF)
+  {
+    DWORD res = GetLastError();
+    if (res != NO_ERROR)
+      return res;
+  }
+  *length = (((UInt64)sizeHigh) << 32) + sizeLow;
+  return 0;
+  
+  #else
+  
+  long pos = ftell(p->file);
+  int res = fseek(p->file, 0, SEEK_END);
+  *length = ftell(p->file);
+  fseek(p->file, pos, SEEK_SET);
+  return res;
+  
+  #endif
+}
+
+
+/* ---------- FileSeqInStream ---------- */
+
+static SRes FileSeqInStream_Read(void *pp, void *buf, size_t *size)
+{
+  CFileSeqInStream *p = (CFileSeqInStream *)pp;
+  return File_Read(&p->file, buf, size) == 0 ? SZ_OK : SZ_ERROR_READ;
+}
+
+void FileSeqInStream_CreateVTable(CFileSeqInStream *p)
+{
+  p->s.Read = FileSeqInStream_Read;
+}
+
+
+/* ---------- FileInStream ---------- */
+
+static SRes FileInStream_Read(void *pp, void *buf, size_t *size)
+{
+  CFileInStream *p = (CFileInStream *)pp;
+  return (File_Read(&p->file, buf, size) == 0) ? SZ_OK : SZ_ERROR_READ;
+}
+
+static SRes FileInStream_Seek(void *pp, Int64 *pos, ESzSeek origin)
+{
+  CFileInStream *p = (CFileInStream *)pp;
+  return File_Seek(&p->file, pos, origin);
+}
+
+void FileInStream_CreateVTable(CFileInStream *p)
+{
+  p->s.Read = FileInStream_Read;
+  p->s.Seek = FileInStream_Seek;
+}
+
+
+/* ---------- FileOutStream ---------- */
+
+static size_t FileOutStream_Write(void *pp, const void *data, size_t size)
+{
+  CFileOutStream *p = (CFileOutStream *)pp;
+  File_Write(&p->file, data, &size);
+  return size;
+}
+
+void FileOutStream_CreateVTable(CFileOutStream *p)
+{
+  p->s.Write = FileOutStream_Write;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/7zFile.h squashfs-tools-patched/LZMA/lzma465/C/7zFile.h
--- squashfs-tools/LZMA/lzma465/C/7zFile.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/7zFile.h	2022-01-01 15:08:47.861171447 +0800
@@ -0,0 +1,74 @@
+/* 7zFile.h -- File IO
+2008-11-22 : Igor Pavlov : Public domain */
+
+#ifndef __7Z_FILE_H
+#define __7Z_FILE_H
+
+#ifdef _WIN32
+#define USE_WINDOWS_FILE
+#endif
+
+#ifdef USE_WINDOWS_FILE
+#include <windows.h>
+#else
+#include <stdio.h>
+#endif
+
+#include "Types.h"
+
+
+/* ---------- File ---------- */
+
+typedef struct
+{
+  #ifdef USE_WINDOWS_FILE
+  HANDLE handle;
+  #else
+  FILE *file;
+  #endif
+} CSzFile;
+
+void File_Construct(CSzFile *p);
+WRes InFile_Open(CSzFile *p, const char *name);
+WRes OutFile_Open(CSzFile *p, const char *name);
+WRes File_Close(CSzFile *p);
+
+/* reads max(*size, remain file's size) bytes */
+WRes File_Read(CSzFile *p, void *data, size_t *size);
+
+/* writes *size bytes */
+WRes File_Write(CSzFile *p, const void *data, size_t *size);
+
+WRes File_Seek(CSzFile *p, Int64 *pos, ESzSeek origin);
+WRes File_GetLength(CSzFile *p, UInt64 *length);
+
+
+/* ---------- FileInStream ---------- */
+
+typedef struct
+{
+  ISeqInStream s;
+  CSzFile file;
+} CFileSeqInStream;
+
+void FileSeqInStream_CreateVTable(CFileSeqInStream *p);
+
+
+typedef struct
+{
+  ISeekInStream s;
+  CSzFile file;
+} CFileInStream;
+
+void FileInStream_CreateVTable(CFileInStream *p);
+
+
+typedef struct
+{
+  ISeqOutStream s;
+  CSzFile file;
+} CFileOutStream;
+
+void FileOutStream_CreateVTable(CFileOutStream *p);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/7zStream.c squashfs-tools-patched/LZMA/lzma465/C/7zStream.c
--- squashfs-tools/LZMA/lzma465/C/7zStream.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/7zStream.c	2022-01-01 15:08:47.861171447 +0800
@@ -0,0 +1,169 @@
+/* 7zStream.c -- 7z Stream functions
+2008-11-23 : Igor Pavlov : Public domain */
+
+#include <string.h>
+
+#include "Types.h"
+
+SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType)
+{
+  while (size != 0)
+  {
+    size_t processed = size;
+    RINOK(stream->Read(stream, buf, &processed));
+    if (processed == 0)
+      return errorType;
+    buf = (void *)((Byte *)buf + processed);
+    size -= processed;
+  }
+  return SZ_OK;
+}
+
+SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size)
+{
+  return SeqInStream_Read2(stream, buf, size, SZ_ERROR_INPUT_EOF);
+}
+
+SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf)
+{
+  size_t processed = 1;
+  RINOK(stream->Read(stream, buf, &processed));
+  return (processed == 1) ? SZ_OK : SZ_ERROR_INPUT_EOF;
+}
+
+SRes LookInStream_SeekTo(ILookInStream *stream, UInt64 offset)
+{
+  Int64 t = offset;
+  return stream->Seek(stream, &t, SZ_SEEK_SET);
+}
+
+SRes LookInStream_LookRead(ILookInStream *stream, void *buf, size_t *size)
+{
+  void *lookBuf;
+  if (*size == 0)
+    return SZ_OK;
+  RINOK(stream->Look(stream, &lookBuf, size));
+  memcpy(buf, lookBuf, *size);
+  return stream->Skip(stream, *size);
+}
+
+SRes LookInStream_Read2(ILookInStream *stream, void *buf, size_t size, SRes errorType)
+{
+  while (size != 0)
+  {
+    size_t processed = size;
+    RINOK(stream->Read(stream, buf, &processed));
+    if (processed == 0)
+      return errorType;
+    buf = (void *)((Byte *)buf + processed);
+    size -= processed;
+  }
+  return SZ_OK;
+}
+
+SRes LookInStream_Read(ILookInStream *stream, void *buf, size_t size)
+{
+  return LookInStream_Read2(stream, buf, size, SZ_ERROR_INPUT_EOF);
+}
+
+static SRes LookToRead_Look_Lookahead(void *pp, void **buf, size_t *size)
+{
+  SRes res = SZ_OK;
+  CLookToRead *p = (CLookToRead *)pp;
+  size_t size2 = p->size - p->pos;
+  if (size2 == 0 && *size > 0)
+  {
+    p->pos = 0;
+    size2 = LookToRead_BUF_SIZE;
+    res = p->realStream->Read(p->realStream, p->buf, &size2);
+    p->size = size2;
+  }
+  if (size2 < *size)
+    *size = size2;
+  *buf = p->buf + p->pos;
+  return res;
+}
+
+static SRes LookToRead_Look_Exact(void *pp, void **buf, size_t *size)
+{
+  SRes res = SZ_OK;
+  CLookToRead *p = (CLookToRead *)pp;
+  size_t size2 = p->size - p->pos;
+  if (size2 == 0 && *size > 0)
+  {
+    p->pos = 0;
+    if (*size > LookToRead_BUF_SIZE)
+      *size = LookToRead_BUF_SIZE;
+    res = p->realStream->Read(p->realStream, p->buf, size);
+    size2 = p->size = *size;
+  }
+  if (size2 < *size)
+    *size = size2;
+  *buf = p->buf + p->pos;
+  return res;
+}
+
+static SRes LookToRead_Skip(void *pp, size_t offset)
+{
+  CLookToRead *p = (CLookToRead *)pp;
+  p->pos += offset;
+  return SZ_OK;
+}
+
+static SRes LookToRead_Read(void *pp, void *buf, size_t *size)
+{
+  CLookToRead *p = (CLookToRead *)pp;
+  size_t rem = p->size - p->pos;
+  if (rem == 0)
+    return p->realStream->Read(p->realStream, buf, size);
+  if (rem > *size)
+    rem = *size;
+  memcpy(buf, p->buf + p->pos, rem);
+  p->pos += rem;
+  *size = rem;
+  return SZ_OK;
+}
+
+static SRes LookToRead_Seek(void *pp, Int64 *pos, ESzSeek origin)
+{
+  CLookToRead *p = (CLookToRead *)pp;
+  p->pos = p->size = 0;
+  return p->realStream->Seek(p->realStream, pos, origin);
+}
+
+void LookToRead_CreateVTable(CLookToRead *p, int lookahead)
+{
+  p->s.Look = lookahead ?
+      LookToRead_Look_Lookahead :
+      LookToRead_Look_Exact;
+  p->s.Skip = LookToRead_Skip;
+  p->s.Read = LookToRead_Read;
+  p->s.Seek = LookToRead_Seek;
+}
+
+void LookToRead_Init(CLookToRead *p)
+{
+  p->pos = p->size = 0;
+}
+
+static SRes SecToLook_Read(void *pp, void *buf, size_t *size)
+{
+  CSecToLook *p = (CSecToLook *)pp;
+  return LookInStream_LookRead(p->realStream, buf, size);
+}
+
+void SecToLook_CreateVTable(CSecToLook *p)
+{
+  p->s.Read = SecToLook_Read;
+}
+
+static SRes SecToRead_Read(void *pp, void *buf, size_t *size)
+{
+  CSecToRead *p = (CSecToRead *)pp;
+  return p->realStream->Read(p->realStream, buf, size);
+}
+
+void SecToRead_CreateVTable(CSecToRead *p)
+{
+  p->s.Read = SecToRead_Read;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/7zVersion.h squashfs-tools-patched/LZMA/lzma465/C/7zVersion.h
--- squashfs-tools/LZMA/lzma465/C/7zVersion.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/7zVersion.h	2022-01-01 15:08:47.861171447 +0800
@@ -0,0 +1,7 @@
+#define MY_VER_MAJOR 4
+#define MY_VER_MINOR 65
+#define MY_VER_BUILD 0
+#define MY_VERSION "4.65"
+#define MY_DATE "2009-02-03"
+#define MY_COPYRIGHT ": Igor Pavlov : Public domain"
+#define MY_VERSION_COPYRIGHT_DATE MY_VERSION " " MY_COPYRIGHT " : " MY_DATE
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Alloc.c squashfs-tools-patched/LZMA/lzma465/C/Alloc.c
--- squashfs-tools/LZMA/lzma465/C/Alloc.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Alloc.c	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,127 @@
+/* Alloc.c -- Memory allocation functions
+2008-09-24
+Igor Pavlov
+Public domain */
+
+#ifdef _WIN32
+#include <windows.h>
+#endif
+#include <stdlib.h>
+
+#include "Alloc.h"
+
+/* #define _SZ_ALLOC_DEBUG */
+
+/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
+#ifdef _SZ_ALLOC_DEBUG
+#include <stdio.h>
+int g_allocCount = 0;
+int g_allocCountMid = 0;
+int g_allocCountBig = 0;
+#endif
+
+void *MyAlloc(size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  {
+    void *p = malloc(size);
+    fprintf(stderr, "\nAlloc %10d bytes, count = %10d,  addr = %8X", size, g_allocCount++, (unsigned)p);
+    return p;
+  }
+  #else
+  return malloc(size);
+  #endif
+}
+
+void MyFree(void *address)
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+    fprintf(stderr, "\nFree; count = %10d,  addr = %8X", --g_allocCount, (unsigned)address);
+  #endif
+  free(address);
+}
+
+#ifdef _WIN32
+
+void *MidAlloc(size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, "\nAlloc_Mid %10d bytes;  count = %10d", size, g_allocCountMid++);
+  #endif
+  return VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
+}
+
+void MidFree(void *address)
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+    fprintf(stderr, "\nFree_Mid; count = %10d", --g_allocCountMid);
+  #endif
+  if (address == 0)
+    return;
+  VirtualFree(address, 0, MEM_RELEASE);
+}
+
+#ifndef MEM_LARGE_PAGES
+#undef _7ZIP_LARGE_PAGES
+#endif
+
+#ifdef _7ZIP_LARGE_PAGES
+SIZE_T g_LargePageSize = 0;
+typedef SIZE_T (WINAPI *GetLargePageMinimumP)();
+#endif
+
+void SetLargePageSize()
+{
+  #ifdef _7ZIP_LARGE_PAGES
+  SIZE_T size = 0;
+  GetLargePageMinimumP largePageMinimum = (GetLargePageMinimumP)
+        GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "GetLargePageMinimum");
+  if (largePageMinimum == 0)
+    return;
+  size = largePageMinimum();
+  if (size == 0 || (size & (size - 1)) != 0)
+    return;
+  g_LargePageSize = size;
+  #endif
+}
+
+
+void *BigAlloc(size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, "\nAlloc_Big %10d bytes;  count = %10d", size, g_allocCountBig++);
+  #endif
+  
+  #ifdef _7ZIP_LARGE_PAGES
+  if (g_LargePageSize != 0 && g_LargePageSize <= (1 << 30) && size >= (1 << 18))
+  {
+    void *res = VirtualAlloc(0, (size + g_LargePageSize - 1) & (~(g_LargePageSize - 1)),
+        MEM_COMMIT | MEM_LARGE_PAGES, PAGE_READWRITE);
+    if (res != 0)
+      return res;
+  }
+  #endif
+  return VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
+}
+
+void BigFree(void *address)
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+    fprintf(stderr, "\nFree_Big; count = %10d", --g_allocCountBig);
+  #endif
+  
+  if (address == 0)
+    return;
+  VirtualFree(address, 0, MEM_RELEASE);
+}
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Alloc.h squashfs-tools-patched/LZMA/lzma465/C/Alloc.h
--- squashfs-tools/LZMA/lzma465/C/Alloc.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Alloc.h	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,32 @@
+/* Alloc.h -- Memory allocation functions
+2008-03-13
+Igor Pavlov
+Public domain */
+
+#ifndef __COMMON_ALLOC_H
+#define __COMMON_ALLOC_H
+
+#include <stddef.h>
+
+void *MyAlloc(size_t size);
+void MyFree(void *address);
+
+#ifdef _WIN32
+
+void SetLargePageSize();
+
+void *MidAlloc(size_t size);
+void MidFree(void *address);
+void *BigAlloc(size_t size);
+void BigFree(void *address);
+
+#else
+
+#define MidAlloc(size) MyAlloc(size)
+#define MidFree(address) MyFree(address)
+#define BigAlloc(size) MyAlloc(size)
+#define BigFree(address) MyFree(address)
+
+#endif
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Archive/7z/7zAlloc.c squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zAlloc.c
--- squashfs-tools/LZMA/lzma465/C/Archive/7z/7zAlloc.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zAlloc.c	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,77 @@
+/* 7zAlloc.c -- Allocation functions
+2008-10-04 : Igor Pavlov : Public domain */
+
+#include <stdlib.h>
+#include "7zAlloc.h"
+
+/* #define _SZ_ALLOC_DEBUG */
+/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
+
+#ifdef _SZ_ALLOC_DEBUG
+
+#ifdef _WIN32
+#include <windows.h>
+#endif
+
+#include <stdio.h>
+int g_allocCount = 0;
+int g_allocCountTemp = 0;
+
+#endif
+
+void *SzAlloc(void *p, size_t size)
+{
+  p = p;
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, "\nAlloc %10d bytes; count = %10d", size, g_allocCount);
+  g_allocCount++;
+  #endif
+  return malloc(size);
+}
+
+void SzFree(void *p, void *address)
+{
+  p = p;
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+  {
+    g_allocCount--;
+    fprintf(stderr, "\nFree; count = %10d", g_allocCount);
+  }
+  #endif
+  free(address);
+}
+
+void *SzAllocTemp(void *p, size_t size)
+{
+  p = p;
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, "\nAlloc_temp %10d bytes;  count = %10d", size, g_allocCountTemp);
+  g_allocCountTemp++;
+  #ifdef _WIN32
+  return HeapAlloc(GetProcessHeap(), 0, size);
+  #endif
+  #endif
+  return malloc(size);
+}
+
+void SzFreeTemp(void *p, void *address)
+{
+  p = p;
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+  {
+    g_allocCountTemp--;
+    fprintf(stderr, "\nFree_temp; count = %10d", g_allocCountTemp);
+  }
+  #ifdef _WIN32
+  HeapFree(GetProcessHeap(), 0, address);
+  return;
+  #endif
+  #endif
+  free(address);
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Archive/7z/7zAlloc.h squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zAlloc.h
--- squashfs-tools/LZMA/lzma465/C/Archive/7z/7zAlloc.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zAlloc.h	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,15 @@
+/* 7zAlloc.h -- Allocation functions
+2008-10-04 : Igor Pavlov : Public domain */
+
+#ifndef __7Z_ALLOC_H
+#define __7Z_ALLOC_H
+
+#include <stddef.h>
+
+void *SzAlloc(void *p, size_t size);
+void SzFree(void *p, void *address);
+
+void *SzAllocTemp(void *p, size_t size);
+void SzFreeTemp(void *p, void *address);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Archive/7z/7zDecode.c squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zDecode.c
--- squashfs-tools/LZMA/lzma465/C/Archive/7z/7zDecode.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zDecode.c	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,254 @@
+/* 7zDecode.c -- Decoding from 7z folder
+2008-11-23 : Igor Pavlov : Public domain */
+
+#include <string.h>
+
+#include "../../Bcj2.h"
+#include "../../Bra.h"
+#include "../../LzmaDec.h"
+#include "7zDecode.h"
+
+#define k_Copy 0
+#define k_LZMA 0x30101
+#define k_BCJ 0x03030103
+#define k_BCJ2 0x0303011B
+
+static SRes SzDecodeLzma(CSzCoderInfo *coder, UInt64 inSize, ILookInStream *inStream,
+    Byte *outBuffer, SizeT outSize, ISzAlloc *allocMain)
+{
+  CLzmaDec state;
+  SRes res = SZ_OK;
+
+  LzmaDec_Construct(&state);
+  RINOK(LzmaDec_AllocateProbs(&state, coder->Props.data, (unsigned)coder->Props.size, allocMain));
+  state.dic = outBuffer;
+  state.dicBufSize = outSize;
+  LzmaDec_Init(&state);
+
+  for (;;)
+  {
+    Byte *inBuf = NULL;
+    size_t lookahead = (1 << 18);
+    if (lookahead > inSize)
+      lookahead = (size_t)inSize;
+    res = inStream->Look((void *)inStream, (void **)&inBuf, &lookahead);
+    if (res != SZ_OK)
+      break;
+
+    {
+      SizeT inProcessed = (SizeT)lookahead, dicPos = state.dicPos;
+      ELzmaStatus status;
+      res = LzmaDec_DecodeToDic(&state, outSize, inBuf, &inProcessed, LZMA_FINISH_END, &status);
+      lookahead -= inProcessed;
+      inSize -= inProcessed;
+      if (res != SZ_OK)
+        break;
+      if (state.dicPos == state.dicBufSize || (inProcessed == 0 && dicPos == state.dicPos))
+      {
+        if (state.dicBufSize != outSize || lookahead != 0 ||
+            (status != LZMA_STATUS_FINISHED_WITH_MARK &&
+             status != LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK))
+          res = SZ_ERROR_DATA;
+        break;
+      }
+      res = inStream->Skip((void *)inStream, inProcessed);
+      if (res != SZ_OK)
+        break;
+    }
+  }
+
+  LzmaDec_FreeProbs(&state, allocMain);
+  return res;
+}
+
+static SRes SzDecodeCopy(UInt64 inSize, ILookInStream *inStream, Byte *outBuffer)
+{
+  while (inSize > 0)
+  {
+    void *inBuf;
+    size_t curSize = (1 << 18);
+    if (curSize > inSize)
+      curSize = (size_t)inSize;
+    RINOK(inStream->Look((void *)inStream, (void **)&inBuf, &curSize));
+    if (curSize == 0)
+      return SZ_ERROR_INPUT_EOF;
+    memcpy(outBuffer, inBuf, curSize);
+    outBuffer += curSize;
+    inSize -= curSize;
+    RINOK(inStream->Skip((void *)inStream, curSize));
+  }
+  return SZ_OK;
+}
+
+#define IS_UNSUPPORTED_METHOD(m) ((m) != k_Copy && (m) != k_LZMA)
+#define IS_UNSUPPORTED_CODER(c) (IS_UNSUPPORTED_METHOD(c.MethodID) || c.NumInStreams != 1 || c.NumOutStreams != 1)
+#define IS_NO_BCJ(c) (c.MethodID != k_BCJ || c.NumInStreams != 1 || c.NumOutStreams != 1)
+#define IS_NO_BCJ2(c) (c.MethodID != k_BCJ2 || c.NumInStreams != 4 || c.NumOutStreams != 1)
+
+SRes CheckSupportedFolder(const CSzFolder *f)
+{
+  if (f->NumCoders < 1 || f->NumCoders > 4)
+    return SZ_ERROR_UNSUPPORTED;
+  if (IS_UNSUPPORTED_CODER(f->Coders[0]))
+    return SZ_ERROR_UNSUPPORTED;
+  if (f->NumCoders == 1)
+  {
+    if (f->NumPackStreams != 1 || f->PackStreams[0] != 0 || f->NumBindPairs != 0)
+      return SZ_ERROR_UNSUPPORTED;
+    return SZ_OK;
+  }
+  if (f->NumCoders == 2)
+  {
+    if (IS_NO_BCJ(f->Coders[1]) ||
+        f->NumPackStreams != 1 || f->PackStreams[0] != 0 ||
+        f->NumBindPairs != 1 ||
+        f->BindPairs[0].InIndex != 1 || f->BindPairs[0].OutIndex != 0)
+      return SZ_ERROR_UNSUPPORTED;
+    return SZ_OK;
+  }
+  if (f->NumCoders == 4)
+  {
+    if (IS_UNSUPPORTED_CODER(f->Coders[1]) ||
+        IS_UNSUPPORTED_CODER(f->Coders[2]) ||
+        IS_NO_BCJ2(f->Coders[3]))
+      return SZ_ERROR_UNSUPPORTED;
+    if (f->NumPackStreams != 4 ||
+        f->PackStreams[0] != 2 ||
+        f->PackStreams[1] != 6 ||
+        f->PackStreams[2] != 1 ||
+        f->PackStreams[3] != 0 ||
+        f->NumBindPairs != 3 ||
+        f->BindPairs[0].InIndex != 5 || f->BindPairs[0].OutIndex != 0 ||
+        f->BindPairs[1].InIndex != 4 || f->BindPairs[1].OutIndex != 1 ||
+        f->BindPairs[2].InIndex != 3 || f->BindPairs[2].OutIndex != 2)
+      return SZ_ERROR_UNSUPPORTED;
+    return SZ_OK;
+  }
+  return SZ_ERROR_UNSUPPORTED;
+}
+
+UInt64 GetSum(const UInt64 *values, UInt32 index)
+{
+  UInt64 sum = 0;
+  UInt32 i;
+  for (i = 0; i < index; i++)
+    sum += values[i];
+  return sum;
+}
+
+SRes SzDecode2(const UInt64 *packSizes, const CSzFolder *folder,
+    ILookInStream *inStream, UInt64 startPos,
+    Byte *outBuffer, SizeT outSize, ISzAlloc *allocMain,
+    Byte *tempBuf[])
+{
+  UInt32 ci;
+  SizeT tempSizes[3] = { 0, 0, 0};
+  SizeT tempSize3 = 0;
+  Byte *tempBuf3 = 0;
+
+  RINOK(CheckSupportedFolder(folder));
+
+  for (ci = 0; ci < folder->NumCoders; ci++)
+  {
+    CSzCoderInfo *coder = &folder->Coders[ci];
+
+    if (coder->MethodID == k_Copy || coder->MethodID == k_LZMA)
+    {
+      UInt32 si = 0;
+      UInt64 offset;
+      UInt64 inSize;
+      Byte *outBufCur = outBuffer;
+      SizeT outSizeCur = outSize;
+      if (folder->NumCoders == 4)
+      {
+        UInt32 indices[] = { 3, 2, 0 };
+        UInt64 unpackSize = folder->UnpackSizes[ci];
+        si = indices[ci];
+        if (ci < 2)
+        {
+          Byte *temp;
+          outSizeCur = (SizeT)unpackSize;
+          if (outSizeCur != unpackSize)
+            return SZ_ERROR_MEM;
+          temp = (Byte *)IAlloc_Alloc(allocMain, outSizeCur);
+          if (temp == 0 && outSizeCur != 0)
+            return SZ_ERROR_MEM;
+          outBufCur = tempBuf[1 - ci] = temp;
+          tempSizes[1 - ci] = outSizeCur;
+        }
+        else if (ci == 2)
+        {
+          if (unpackSize > outSize) /* check it */
+            return SZ_ERROR_PARAM;
+          tempBuf3 = outBufCur = outBuffer + (outSize - (size_t)unpackSize);
+          tempSize3 = outSizeCur = (SizeT)unpackSize;
+        }
+        else
+          return SZ_ERROR_UNSUPPORTED;
+      }
+      offset = GetSum(packSizes, si);
+      inSize = packSizes[si];
+      RINOK(LookInStream_SeekTo(inStream, startPos + offset));
+
+      if (coder->MethodID == k_Copy)
+      {
+        if (inSize != outSizeCur) /* check it */
+          return SZ_ERROR_DATA;
+        RINOK(SzDecodeCopy(inSize, inStream, outBufCur));
+      }
+      else
+      {
+        RINOK(SzDecodeLzma(coder, inSize, inStream, outBufCur, outSizeCur, allocMain));
+      }
+    }
+    else if (coder->MethodID == k_BCJ)
+    {
+      UInt32 state;
+      if (ci != 1)
+        return SZ_ERROR_UNSUPPORTED;
+      x86_Convert_Init(state);
+      x86_Convert(outBuffer, outSize, 0, &state, 0);
+    }
+    else if (coder->MethodID == k_BCJ2)
+    {
+      UInt64 offset = GetSum(packSizes, 1);
+      UInt64 s3Size = packSizes[1];
+      SRes res;
+      if (ci != 3)
+        return SZ_ERROR_UNSUPPORTED;
+      RINOK(LookInStream_SeekTo(inStream, startPos + offset));
+      tempSizes[2] = (SizeT)s3Size;
+      if (tempSizes[2] != s3Size)
+        return SZ_ERROR_MEM;
+      tempBuf[2] = (Byte *)IAlloc_Alloc(allocMain, tempSizes[2]);
+      if (tempBuf[2] == 0 && tempSizes[2] != 0)
+        return SZ_ERROR_MEM;
+      res = SzDecodeCopy(s3Size, inStream, tempBuf[2]);
+      RINOK(res)
+
+      res = Bcj2_Decode(
+          tempBuf3, tempSize3,
+          tempBuf[0], tempSizes[0],
+          tempBuf[1], tempSizes[1],
+          tempBuf[2], tempSizes[2],
+          outBuffer, outSize);
+      RINOK(res)
+    }
+    else
+      return SZ_ERROR_UNSUPPORTED;
+  }
+  return SZ_OK;
+}
+
+SRes SzDecode(const UInt64 *packSizes, const CSzFolder *folder,
+    ILookInStream *inStream, UInt64 startPos,
+    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain)
+{
+  Byte *tempBuf[3] = { 0, 0, 0};
+  int i;
+  SRes res = SzDecode2(packSizes, folder, inStream, startPos,
+      outBuffer, (SizeT)outSize, allocMain, tempBuf);
+  for (i = 0; i < 3; i++)
+    IAlloc_Free(allocMain, tempBuf[i]);
+  return res;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Archive/7z/7zDecode.h squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zDecode.h
--- squashfs-tools/LZMA/lzma465/C/Archive/7z/7zDecode.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zDecode.h	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,13 @@
+/* 7zDecode.h -- Decoding from 7z folder
+2008-11-23 : Igor Pavlov : Public domain */
+
+#ifndef __7Z_DECODE_H
+#define __7Z_DECODE_H
+
+#include "7zItem.h"
+
+SRes SzDecode(const UInt64 *packSizes, const CSzFolder *folder,
+    ILookInStream *stream, UInt64 startPos,
+    Byte *outBuffer, size_t outSize, ISzAlloc *allocMain);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Archive/7z/7z.dsp squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7z.dsp
--- squashfs-tools/LZMA/lzma465/C/Archive/7z/7z.dsp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7z.dsp	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,199 @@
+# Microsoft Developer Studio Project File - Name="7z" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=7z - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "7z.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "7z.mak" CFG="7z - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "7z - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "7z - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "7z - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MD /W3 /GX /O2 /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /FAs /YX /FD /c
+# ADD BASE RSC /l 0x419 /d "NDEBUG"
+# ADD RSC /l 0x419 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:"Release/7zDec.exe" /opt:NOWIN98
+# SUBTRACT LINK32 /pdb:none
+
+!ELSEIF  "$(CFG)" == "7z - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /W4 /Gm /GX /ZI /Od /D "_DEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "_SZ_ALLOC_DEBUG2" /D "_SZ_NO_INT_64_A" /YX /FD /GZ /c
+# ADD BASE RSC /l 0x419 /d "_DEBUG"
+# ADD RSC /l 0x419 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:"Debug/7zDec.exe" /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "7z - Win32 Release"
+# Name "7z - Win32 Debug"
+# Begin Group "Common"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\7zBuf.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\7zBuf.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\7zCrc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\7zCrc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\7zFile.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\7zFile.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\7zStream.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Bcj2.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Bcj2.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Bra.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Bra86.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\LzmaDec.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\LzmaDec.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Types.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=.\7zAlloc.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zAlloc.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zDecode.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zDecode.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zExtract.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zExtract.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zHeader.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zHeader.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zIn.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zIn.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zItem.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zItem.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zMain.c
+# End Source File
+# End Target
+# End Project
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Archive/7z/7z.dsw squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7z.dsw
--- squashfs-tools/LZMA/lzma465/C/Archive/7z/7z.dsw	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7z.dsw	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,29 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "7z"=.\7z.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Archive/7z/7zExtract.c squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zExtract.c
--- squashfs-tools/LZMA/lzma465/C/Archive/7z/7zExtract.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zExtract.c	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,93 @@
+/* 7zExtract.c -- Extracting from 7z archive
+2008-11-23 : Igor Pavlov : Public domain */
+
+#include "../../7zCrc.h"
+#include "7zDecode.h"
+#include "7zExtract.h"
+
+SRes SzAr_Extract(
+    const CSzArEx *p,
+    ILookInStream *inStream,
+    UInt32 fileIndex,
+    UInt32 *blockIndex,
+    Byte **outBuffer,
+    size_t *outBufferSize,
+    size_t *offset,
+    size_t *outSizeProcessed,
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp)
+{
+  UInt32 folderIndex = p->FileIndexToFolderIndexMap[fileIndex];
+  SRes res = SZ_OK;
+  *offset = 0;
+  *outSizeProcessed = 0;
+  if (folderIndex == (UInt32)-1)
+  {
+    IAlloc_Free(allocMain, *outBuffer);
+    *blockIndex = folderIndex;
+    *outBuffer = 0;
+    *outBufferSize = 0;
+    return SZ_OK;
+  }
+
+  if (*outBuffer == 0 || *blockIndex != folderIndex)
+  {
+    CSzFolder *folder = p->db.Folders + folderIndex;
+    UInt64 unpackSizeSpec = SzFolder_GetUnpackSize(folder);
+    size_t unpackSize = (size_t)unpackSizeSpec;
+    UInt64 startOffset = SzArEx_GetFolderStreamPos(p, folderIndex, 0);
+
+    if (unpackSize != unpackSizeSpec)
+      return SZ_ERROR_MEM;
+    *blockIndex = folderIndex;
+    IAlloc_Free(allocMain, *outBuffer);
+    *outBuffer = 0;
+    
+    RINOK(LookInStream_SeekTo(inStream, startOffset));
+    
+    if (res == SZ_OK)
+    {
+      *outBufferSize = unpackSize;
+      if (unpackSize != 0)
+      {
+        *outBuffer = (Byte *)IAlloc_Alloc(allocMain, unpackSize);
+        if (*outBuffer == 0)
+          res = SZ_ERROR_MEM;
+      }
+      if (res == SZ_OK)
+      {
+        res = SzDecode(p->db.PackSizes +
+          p->FolderStartPackStreamIndex[folderIndex], folder,
+          inStream, startOffset,
+          *outBuffer, unpackSize, allocTemp);
+        if (res == SZ_OK)
+        {
+          if (folder->UnpackCRCDefined)
+          {
+            if (CrcCalc(*outBuffer, unpackSize) != folder->UnpackCRC)
+              res = SZ_ERROR_CRC;
+          }
+        }
+      }
+    }
+  }
+  if (res == SZ_OK)
+  {
+    UInt32 i;
+    CSzFileItem *fileItem = p->db.Files + fileIndex;
+    *offset = 0;
+    for (i = p->FolderStartFileIndex[folderIndex]; i < fileIndex; i++)
+      *offset += (UInt32)p->db.Files[i].Size;
+    *outSizeProcessed = (size_t)fileItem->Size;
+    if (*offset + *outSizeProcessed > *outBufferSize)
+      return SZ_ERROR_FAIL;
+    {
+      if (fileItem->FileCRCDefined)
+      {
+        if (CrcCalc(*outBuffer + *offset, *outSizeProcessed) != fileItem->FileCRC)
+          res = SZ_ERROR_CRC;
+      }
+    }
+  }
+  return res;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Archive/7z/7zExtract.h squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zExtract.h
--- squashfs-tools/LZMA/lzma465/C/Archive/7z/7zExtract.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zExtract.h	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,41 @@
+/* 7zExtract.h -- Extracting from 7z archive
+2008-11-23 : Igor Pavlov : Public domain */
+
+#ifndef __7Z_EXTRACT_H
+#define __7Z_EXTRACT_H
+
+#include "7zIn.h"
+
+/*
+  SzExtract extracts file from archive
+
+  *outBuffer must be 0 before first call for each new archive.
+
+  Extracting cache:
+    If you need to decompress more than one file, you can send
+    these values from previous call:
+      *blockIndex,
+      *outBuffer,
+      *outBufferSize
+    You can consider "*outBuffer" as cache of solid block. If your archive is solid,
+    it will increase decompression speed.
+  
+    If you use external function, you can declare these 3 cache variables
+    (blockIndex, outBuffer, outBufferSize) as static in that external function.
+    
+    Free *outBuffer and set *outBuffer to 0, if you want to flush cache.
+*/
+
+SRes SzAr_Extract(
+    const CSzArEx *db,
+    ILookInStream *inStream,
+    UInt32 fileIndex,         /* index of file */
+    UInt32 *blockIndex,       /* index of solid block */
+    Byte **outBuffer,         /* pointer to pointer to output buffer (allocated with allocMain) */
+    size_t *outBufferSize,    /* buffer size for output buffer */
+    size_t *offset,           /* offset of stream for required file in *outBuffer */
+    size_t *outSizeProcessed, /* size of file in *outBuffer */
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Archive/7z/7zHeader.c squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zHeader.c
--- squashfs-tools/LZMA/lzma465/C/Archive/7z/7zHeader.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zHeader.c	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,6 @@
+/*  7zHeader.c -- 7z Headers
+2008-10-04 : Igor Pavlov : Public domain */
+
+#include "7zHeader.h"
+
+Byte k7zSignature[k7zSignatureSize] = {'7', 'z', 0xBC, 0xAF, 0x27, 0x1C};
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Archive/7z/7zHeader.h squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zHeader.h
--- squashfs-tools/LZMA/lzma465/C/Archive/7z/7zHeader.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zHeader.h	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,57 @@
+/* 7zHeader.h -- 7z Headers
+2008-10-04 : Igor Pavlov : Public domain */
+
+#ifndef __7Z_HEADER_H
+#define __7Z_HEADER_H
+
+#include "../../Types.h"
+
+#define k7zSignatureSize 6
+extern Byte k7zSignature[k7zSignatureSize];
+
+#define k7zMajorVersion 0
+
+#define k7zStartHeaderSize 0x20
+
+enum EIdEnum
+{
+  k7zIdEnd,
+    
+  k7zIdHeader,
+    
+  k7zIdArchiveProperties,
+    
+  k7zIdAdditionalStreamsInfo,
+  k7zIdMainStreamsInfo,
+  k7zIdFilesInfo,
+  
+  k7zIdPackInfo,
+  k7zIdUnpackInfo,
+  k7zIdSubStreamsInfo,
+  
+  k7zIdSize,
+  k7zIdCRC,
+  
+  k7zIdFolder,
+  
+  k7zIdCodersUnpackSize,
+  k7zIdNumUnpackStream,
+  
+  k7zIdEmptyStream,
+  k7zIdEmptyFile,
+  k7zIdAnti,
+  
+  k7zIdName,
+  k7zIdCTime,
+  k7zIdATime,
+  k7zIdMTime,
+  k7zIdWinAttributes,
+  k7zIdComment,
+  
+  k7zIdEncodedHeader,
+  
+  k7zIdStartPos,
+  k7zIdDummy
+};
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Archive/7z/7zIn.c squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zIn.c
--- squashfs-tools/LZMA/lzma465/C/Archive/7z/7zIn.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zIn.c	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,1204 @@
+/* 7zIn.c -- 7z Input functions
+2008-12-31 : Igor Pavlov : Public domain */
+
+#include "../../7zCrc.h"
+#include "../../CpuArch.h"
+
+#include "7zDecode.h"
+#include "7zIn.h"
+
+#define RINOM(x) { if ((x) == 0) return SZ_ERROR_MEM; }
+
+#define NUM_FOLDER_CODERS_MAX 32
+#define NUM_CODER_STREAMS_MAX 32
+
+void SzArEx_Init(CSzArEx *p)
+{
+  SzAr_Init(&p->db);
+  p->FolderStartPackStreamIndex = 0;
+  p->PackStreamStartPositions = 0;
+  p->FolderStartFileIndex = 0;
+  p->FileIndexToFolderIndexMap = 0;
+}
+
+void SzArEx_Free(CSzArEx *p, ISzAlloc *alloc)
+{
+  IAlloc_Free(alloc, p->FolderStartPackStreamIndex);
+  IAlloc_Free(alloc, p->PackStreamStartPositions);
+  IAlloc_Free(alloc, p->FolderStartFileIndex);
+  IAlloc_Free(alloc, p->FileIndexToFolderIndexMap);
+  SzAr_Free(&p->db, alloc);
+  SzArEx_Init(p);
+}
+
+/*
+UInt64 GetFolderPackStreamSize(int folderIndex, int streamIndex) const
+{
+  return PackSizes[FolderStartPackStreamIndex[folderIndex] + streamIndex];
+}
+
+UInt64 GetFilePackSize(int fileIndex) const
+{
+  int folderIndex = FileIndexToFolderIndexMap[fileIndex];
+  if (folderIndex >= 0)
+  {
+    const CSzFolder &folderInfo = Folders[folderIndex];
+    if (FolderStartFileIndex[folderIndex] == fileIndex)
+    return GetFolderFullPackSize(folderIndex);
+  }
+  return 0;
+}
+*/
+
+#define MY_ALLOC(T, p, size, alloc) { if ((size) == 0) p = 0; else \
+  if ((p = (T *)IAlloc_Alloc(alloc, (size) * sizeof(T))) == 0) return SZ_ERROR_MEM; }
+
+static SRes SzArEx_Fill(CSzArEx *p, ISzAlloc *alloc)
+{
+  UInt32 startPos = 0;
+  UInt64 startPosSize = 0;
+  UInt32 i;
+  UInt32 folderIndex = 0;
+  UInt32 indexInFolder = 0;
+  MY_ALLOC(UInt32, p->FolderStartPackStreamIndex, p->db.NumFolders, alloc);
+  for (i = 0; i < p->db.NumFolders; i++)
+  {
+    p->FolderStartPackStreamIndex[i] = startPos;
+    startPos += p->db.Folders[i].NumPackStreams;
+  }
+
+  MY_ALLOC(UInt64, p->PackStreamStartPositions, p->db.NumPackStreams, alloc);
+
+  for (i = 0; i < p->db.NumPackStreams; i++)
+  {
+    p->PackStreamStartPositions[i] = startPosSize;
+    startPosSize += p->db.PackSizes[i];
+  }
+
+  MY_ALLOC(UInt32, p->FolderStartFileIndex, p->db.NumFolders, alloc);
+  MY_ALLOC(UInt32, p->FileIndexToFolderIndexMap, p->db.NumFiles, alloc);
+
+  for (i = 0; i < p->db.NumFiles; i++)
+  {
+    CSzFileItem *file = p->db.Files + i;
+    int emptyStream = !file->HasStream;
+    if (emptyStream && indexInFolder == 0)
+    {
+      p->FileIndexToFolderIndexMap[i] = (UInt32)-1;
+      continue;
+    }
+    if (indexInFolder == 0)
+    {
+      /*
+      v3.13 incorrectly worked with empty folders
+      v4.07: Loop for skipping empty folders
+      */
+      for (;;)
+      {
+        if (folderIndex >= p->db.NumFolders)
+          return SZ_ERROR_ARCHIVE;
+        p->FolderStartFileIndex[folderIndex] = i;
+        if (p->db.Folders[folderIndex].NumUnpackStreams != 0)
+          break;
+        folderIndex++;
+      }
+    }
+    p->FileIndexToFolderIndexMap[i] = folderIndex;
+    if (emptyStream)
+      continue;
+    indexInFolder++;
+    if (indexInFolder >= p->db.Folders[folderIndex].NumUnpackStreams)
+    {
+      folderIndex++;
+      indexInFolder = 0;
+    }
+  }
+  return SZ_OK;
+}
+
+
+UInt64 SzArEx_GetFolderStreamPos(const CSzArEx *p, UInt32 folderIndex, UInt32 indexInFolder)
+{
+  return p->dataPos +
+    p->PackStreamStartPositions[p->FolderStartPackStreamIndex[folderIndex] + indexInFolder];
+}
+
+int SzArEx_GetFolderFullPackSize(const CSzArEx *p, UInt32 folderIndex, UInt64 *resSize)
+{
+  UInt32 packStreamIndex = p->FolderStartPackStreamIndex[folderIndex];
+  CSzFolder *folder = p->db.Folders + folderIndex;
+  UInt64 size = 0;
+  UInt32 i;
+  for (i = 0; i < folder->NumPackStreams; i++)
+  {
+    UInt64 t = size + p->db.PackSizes[packStreamIndex + i];
+    if (t < size) /* check it */
+      return SZ_ERROR_FAIL;
+    size = t;
+  }
+  *resSize = size;
+  return SZ_OK;
+}
+
+
+/*
+SRes SzReadTime(const CObjectVector<CBuf> &dataVector,
+    CObjectVector<CSzFileItem> &files, UInt64 type)
+{
+  CBoolVector boolVector;
+  RINOK(ReadBoolVector2(files.Size(), boolVector))
+
+  CStreamSwitch streamSwitch;
+  RINOK(streamSwitch.Set(this, &dataVector));
+
+  for (int i = 0; i < files.Size(); i++)
+  {
+    CSzFileItem &file = files[i];
+    CArchiveFileTime fileTime;
+    bool defined = boolVector[i];
+    if (defined)
+    {
+      UInt32 low, high;
+      RINOK(SzReadUInt32(low));
+      RINOK(SzReadUInt32(high));
+      fileTime.dwLowDateTime = low;
+      fileTime.dwHighDateTime = high;
+    }
+    switch(type)
+    {
+      case k7zIdCTime: file.IsCTimeDefined = defined; if (defined) file.CTime = fileTime; break;
+      case k7zIdATime: file.IsATimeDefined = defined; if (defined) file.ATime = fileTime; break;
+      case k7zIdMTime: file.IsMTimeDefined = defined; if (defined) file.MTime = fileTime; break;
+    }
+  }
+  return SZ_OK;
+}
+*/
+
+static int TestSignatureCandidate(Byte *testBytes)
+{
+  size_t i;
+  for (i = 0; i < k7zSignatureSize; i++)
+    if (testBytes[i] != k7zSignature[i])
+      return 0;
+  return 1;
+}
+
+typedef struct _CSzState
+{
+  Byte *Data;
+  size_t Size;
+}CSzData;
+
+static SRes SzReadByte(CSzData *sd, Byte *b)
+{
+  if (sd->Size == 0)
+    return SZ_ERROR_ARCHIVE;
+  sd->Size--;
+  *b = *sd->Data++;
+  return SZ_OK;
+}
+
+static SRes SzReadBytes(CSzData *sd, Byte *data, size_t size)
+{
+  size_t i;
+  for (i = 0; i < size; i++)
+  {
+    RINOK(SzReadByte(sd, data + i));
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadUInt32(CSzData *sd, UInt32 *value)
+{
+  int i;
+  *value = 0;
+  for (i = 0; i < 4; i++)
+  {
+    Byte b;
+    RINOK(SzReadByte(sd, &b));
+    *value |= ((UInt32)(b) << (8 * i));
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadNumber(CSzData *sd, UInt64 *value)
+{
+  Byte firstByte;
+  Byte mask = 0x80;
+  int i;
+  RINOK(SzReadByte(sd, &firstByte));
+  *value = 0;
+  for (i = 0; i < 8; i++)
+  {
+    Byte b;
+    if ((firstByte & mask) == 0)
+    {
+      UInt64 highPart = firstByte & (mask - 1);
+      *value += (highPart << (8 * i));
+      return SZ_OK;
+    }
+    RINOK(SzReadByte(sd, &b));
+    *value |= ((UInt64)b << (8 * i));
+    mask >>= 1;
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadNumber32(CSzData *sd, UInt32 *value)
+{
+  UInt64 value64;
+  RINOK(SzReadNumber(sd, &value64));
+  if (value64 >= 0x80000000)
+    return SZ_ERROR_UNSUPPORTED;
+  if (value64 >= ((UInt64)(1) << ((sizeof(size_t) - 1) * 8 + 2)))
+    return SZ_ERROR_UNSUPPORTED;
+  *value = (UInt32)value64;
+  return SZ_OK;
+}
+
+static SRes SzReadID(CSzData *sd, UInt64 *value)
+{
+  return SzReadNumber(sd, value);
+}
+
+static SRes SzSkeepDataSize(CSzData *sd, UInt64 size)
+{
+  if (size > sd->Size)
+    return SZ_ERROR_ARCHIVE;
+  sd->Size -= (size_t)size;
+  sd->Data += (size_t)size;
+  return SZ_OK;
+}
+
+static SRes SzSkeepData(CSzData *sd)
+{
+  UInt64 size;
+  RINOK(SzReadNumber(sd, &size));
+  return SzSkeepDataSize(sd, size);
+}
+
+static SRes SzReadArchiveProperties(CSzData *sd)
+{
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &type));
+    if (type == k7zIdEnd)
+      break;
+    SzSkeepData(sd);
+  }
+  return SZ_OK;
+}
+
+static SRes SzWaitAttribute(CSzData *sd, UInt64 attribute)
+{
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &type));
+    if (type == attribute)
+      return SZ_OK;
+    if (type == k7zIdEnd)
+      return SZ_ERROR_ARCHIVE;
+    RINOK(SzSkeepData(sd));
+  }
+}
+
+static SRes SzReadBoolVector(CSzData *sd, size_t numItems, Byte **v, ISzAlloc *alloc)
+{
+  Byte b = 0;
+  Byte mask = 0;
+  size_t i;
+  MY_ALLOC(Byte, *v, numItems, alloc);
+  for (i = 0; i < numItems; i++)
+  {
+    if (mask == 0)
+    {
+      RINOK(SzReadByte(sd, &b));
+      mask = 0x80;
+    }
+    (*v)[i] = (Byte)(((b & mask) != 0) ? 1 : 0);
+    mask >>= 1;
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadBoolVector2(CSzData *sd, size_t numItems, Byte **v, ISzAlloc *alloc)
+{
+  Byte allAreDefined;
+  size_t i;
+  RINOK(SzReadByte(sd, &allAreDefined));
+  if (allAreDefined == 0)
+    return SzReadBoolVector(sd, numItems, v, alloc);
+  MY_ALLOC(Byte, *v, numItems, alloc);
+  for (i = 0; i < numItems; i++)
+    (*v)[i] = 1;
+  return SZ_OK;
+}
+
+static SRes SzReadHashDigests(
+    CSzData *sd,
+    size_t numItems,
+    Byte **digestsDefined,
+    UInt32 **digests,
+    ISzAlloc *alloc)
+{
+  size_t i;
+  RINOK(SzReadBoolVector2(sd, numItems, digestsDefined, alloc));
+  MY_ALLOC(UInt32, *digests, numItems, alloc);
+  for (i = 0; i < numItems; i++)
+    if ((*digestsDefined)[i])
+    {
+      RINOK(SzReadUInt32(sd, (*digests) + i));
+    }
+  return SZ_OK;
+}
+
+static SRes SzReadPackInfo(
+    CSzData *sd,
+    UInt64 *dataOffset,
+    UInt32 *numPackStreams,
+    UInt64 **packSizes,
+    Byte **packCRCsDefined,
+    UInt32 **packCRCs,
+    ISzAlloc *alloc)
+{
+  UInt32 i;
+  RINOK(SzReadNumber(sd, dataOffset));
+  RINOK(SzReadNumber32(sd, numPackStreams));
+
+  RINOK(SzWaitAttribute(sd, k7zIdSize));
+
+  MY_ALLOC(UInt64, *packSizes, (size_t)*numPackStreams, alloc);
+
+  for (i = 0; i < *numPackStreams; i++)
+  {
+    RINOK(SzReadNumber(sd, (*packSizes) + i));
+  }
+
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &type));
+    if (type == k7zIdEnd)
+      break;
+    if (type == k7zIdCRC)
+    {
+      RINOK(SzReadHashDigests(sd, (size_t)*numPackStreams, packCRCsDefined, packCRCs, alloc));
+      continue;
+    }
+    RINOK(SzSkeepData(sd));
+  }
+  if (*packCRCsDefined == 0)
+  {
+    MY_ALLOC(Byte, *packCRCsDefined, (size_t)*numPackStreams, alloc);
+    MY_ALLOC(UInt32, *packCRCs, (size_t)*numPackStreams, alloc);
+    for (i = 0; i < *numPackStreams; i++)
+    {
+      (*packCRCsDefined)[i] = 0;
+      (*packCRCs)[i] = 0;
+    }
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadSwitch(CSzData *sd)
+{
+  Byte external;
+  RINOK(SzReadByte(sd, &external));
+  return (external == 0) ? SZ_OK: SZ_ERROR_UNSUPPORTED;
+}
+
+static SRes SzGetNextFolderItem(CSzData *sd, CSzFolder *folder, ISzAlloc *alloc)
+{
+  UInt32 numCoders, numBindPairs, numPackStreams, i;
+  UInt32 numInStreams = 0, numOutStreams = 0;
+  
+  RINOK(SzReadNumber32(sd, &numCoders));
+  if (numCoders > NUM_FOLDER_CODERS_MAX)
+    return SZ_ERROR_UNSUPPORTED;
+  folder->NumCoders = numCoders;
+  
+  MY_ALLOC(CSzCoderInfo, folder->Coders, (size_t)numCoders, alloc);
+
+  for (i = 0; i < numCoders; i++)
+    SzCoderInfo_Init(folder->Coders + i);
+
+  for (i = 0; i < numCoders; i++)
+  {
+    Byte mainByte;
+    CSzCoderInfo *coder = folder->Coders + i;
+    {
+      unsigned idSize, j;
+      Byte longID[15];
+      RINOK(SzReadByte(sd, &mainByte));
+      idSize = (unsigned)(mainByte & 0xF);
+      RINOK(SzReadBytes(sd, longID, idSize));
+      if (idSize > sizeof(coder->MethodID))
+        return SZ_ERROR_UNSUPPORTED;
+      coder->MethodID = 0;
+      for (j = 0; j < idSize; j++)
+        coder->MethodID |= (UInt64)longID[idSize - 1 - j] << (8 * j);
+
+      if ((mainByte & 0x10) != 0)
+      {
+        RINOK(SzReadNumber32(sd, &coder->NumInStreams));
+        RINOK(SzReadNumber32(sd, &coder->NumOutStreams));
+        if (coder->NumInStreams > NUM_CODER_STREAMS_MAX ||
+            coder->NumOutStreams > NUM_CODER_STREAMS_MAX)
+          return SZ_ERROR_UNSUPPORTED;
+      }
+      else
+      {
+        coder->NumInStreams = 1;
+        coder->NumOutStreams = 1;
+      }
+      if ((mainByte & 0x20) != 0)
+      {
+        UInt64 propertiesSize = 0;
+        RINOK(SzReadNumber(sd, &propertiesSize));
+        if (!Buf_Create(&coder->Props, (size_t)propertiesSize, alloc))
+          return SZ_ERROR_MEM;
+        RINOK(SzReadBytes(sd, coder->Props.data, (size_t)propertiesSize));
+      }
+    }
+    while ((mainByte & 0x80) != 0)
+    {
+      RINOK(SzReadByte(sd, &mainByte));
+      RINOK(SzSkeepDataSize(sd, (mainByte & 0xF)));
+      if ((mainByte & 0x10) != 0)
+      {
+        UInt32 n;
+        RINOK(SzReadNumber32(sd, &n));
+        RINOK(SzReadNumber32(sd, &n));
+      }
+      if ((mainByte & 0x20) != 0)
+      {
+        UInt64 propertiesSize = 0;
+        RINOK(SzReadNumber(sd, &propertiesSize));
+        RINOK(SzSkeepDataSize(sd, propertiesSize));
+      }
+    }
+    numInStreams += coder->NumInStreams;
+    numOutStreams += coder->NumOutStreams;
+  }
+
+  if (numOutStreams == 0)
+    return SZ_ERROR_UNSUPPORTED;
+
+  folder->NumBindPairs = numBindPairs = numOutStreams - 1;
+  MY_ALLOC(CBindPair, folder->BindPairs, (size_t)numBindPairs, alloc);
+
+  for (i = 0; i < numBindPairs; i++)
+  {
+    CBindPair *bp = folder->BindPairs + i;
+    RINOK(SzReadNumber32(sd, &bp->InIndex));
+    RINOK(SzReadNumber32(sd, &bp->OutIndex));
+  }
+
+  if (numInStreams < numBindPairs)
+    return SZ_ERROR_UNSUPPORTED;
+
+  folder->NumPackStreams = numPackStreams = numInStreams - numBindPairs;
+  MY_ALLOC(UInt32, folder->PackStreams, (size_t)numPackStreams, alloc);
+
+  if (numPackStreams == 1)
+  {
+    for (i = 0; i < numInStreams ; i++)
+      if (SzFolder_FindBindPairForInStream(folder, i) < 0)
+        break;
+    if (i == numInStreams)
+      return SZ_ERROR_UNSUPPORTED;
+    folder->PackStreams[0] = i;
+  }
+  else
+    for (i = 0; i < numPackStreams; i++)
+    {
+      RINOK(SzReadNumber32(sd, folder->PackStreams + i));
+    }
+  return SZ_OK;
+}
+
+static SRes SzReadUnpackInfo(
+    CSzData *sd,
+    UInt32 *numFolders,
+    CSzFolder **folders,  /* for alloc */
+    ISzAlloc *alloc,
+    ISzAlloc *allocTemp)
+{
+  UInt32 i;
+  RINOK(SzWaitAttribute(sd, k7zIdFolder));
+  RINOK(SzReadNumber32(sd, numFolders));
+  {
+    RINOK(SzReadSwitch(sd));
+
+    MY_ALLOC(CSzFolder, *folders, (size_t)*numFolders, alloc);
+
+    for (i = 0; i < *numFolders; i++)
+      SzFolder_Init((*folders) + i);
+
+    for (i = 0; i < *numFolders; i++)
+    {
+      RINOK(SzGetNextFolderItem(sd, (*folders) + i, alloc));
+    }
+  }
+
+  RINOK(SzWaitAttribute(sd, k7zIdCodersUnpackSize));
+
+  for (i = 0; i < *numFolders; i++)
+  {
+    UInt32 j;
+    CSzFolder *folder = (*folders) + i;
+    UInt32 numOutStreams = SzFolder_GetNumOutStreams(folder);
+
+    MY_ALLOC(UInt64, folder->UnpackSizes, (size_t)numOutStreams, alloc);
+
+    for (j = 0; j < numOutStreams; j++)
+    {
+      RINOK(SzReadNumber(sd, folder->UnpackSizes + j));
+    }
+  }
+
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &type));
+    if (type == k7zIdEnd)
+      return SZ_OK;
+    if (type == k7zIdCRC)
+    {
+      SRes res;
+      Byte *crcsDefined = 0;
+      UInt32 *crcs = 0;
+      res = SzReadHashDigests(sd, *numFolders, &crcsDefined, &crcs, allocTemp);
+      if (res == SZ_OK)
+      {
+        for (i = 0; i < *numFolders; i++)
+        {
+          CSzFolder *folder = (*folders) + i;
+          folder->UnpackCRCDefined = crcsDefined[i];
+          folder->UnpackCRC = crcs[i];
+        }
+      }
+      IAlloc_Free(allocTemp, crcs);
+      IAlloc_Free(allocTemp, crcsDefined);
+      RINOK(res);
+      continue;
+    }
+    RINOK(SzSkeepData(sd));
+  }
+}
+
+static SRes SzReadSubStreamsInfo(
+    CSzData *sd,
+    UInt32 numFolders,
+    CSzFolder *folders,
+    UInt32 *numUnpackStreams,
+    UInt64 **unpackSizes,
+    Byte **digestsDefined,
+    UInt32 **digests,
+    ISzAlloc *allocTemp)
+{
+  UInt64 type = 0;
+  UInt32 i;
+  UInt32 si = 0;
+  UInt32 numDigests = 0;
+
+  for (i = 0; i < numFolders; i++)
+    folders[i].NumUnpackStreams = 1;
+  *numUnpackStreams = numFolders;
+
+  for (;;)
+  {
+    RINOK(SzReadID(sd, &type));
+    if (type == k7zIdNumUnpackStream)
+    {
+      *numUnpackStreams = 0;
+      for (i = 0; i < numFolders; i++)
+      {
+        UInt32 numStreams;
+        RINOK(SzReadNumber32(sd, &numStreams));
+        folders[i].NumUnpackStreams = numStreams;
+        *numUnpackStreams += numStreams;
+      }
+      continue;
+    }
+    if (type == k7zIdCRC || type == k7zIdSize)
+      break;
+    if (type == k7zIdEnd)
+      break;
+    RINOK(SzSkeepData(sd));
+  }
+
+  if (*numUnpackStreams == 0)
+  {
+    *unpackSizes = 0;
+    *digestsDefined = 0;
+    *digests = 0;
+  }
+  else
+  {
+    *unpackSizes = (UInt64 *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(UInt64));
+    RINOM(*unpackSizes);
+    *digestsDefined = (Byte *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(Byte));
+    RINOM(*digestsDefined);
+    *digests = (UInt32 *)IAlloc_Alloc(allocTemp, (size_t)*numUnpackStreams * sizeof(UInt32));
+    RINOM(*digests);
+  }
+
+  for (i = 0; i < numFolders; i++)
+  {
+    /*
+    v3.13 incorrectly worked with empty folders
+    v4.07: we check that folder is empty
+    */
+    UInt64 sum = 0;
+    UInt32 j;
+    UInt32 numSubstreams = folders[i].NumUnpackStreams;
+    if (numSubstreams == 0)
+      continue;
+    if (type == k7zIdSize)
+    for (j = 1; j < numSubstreams; j++)
+    {
+      UInt64 size;
+      RINOK(SzReadNumber(sd, &size));
+      (*unpackSizes)[si++] = size;
+      sum += size;
+    }
+    (*unpackSizes)[si++] = SzFolder_GetUnpackSize(folders + i) - sum;
+  }
+  if (type == k7zIdSize)
+  {
+    RINOK(SzReadID(sd, &type));
+  }
+
+  for (i = 0; i < *numUnpackStreams; i++)
+  {
+    (*digestsDefined)[i] = 0;
+    (*digests)[i] = 0;
+  }
+
+
+  for (i = 0; i < numFolders; i++)
+  {
+    UInt32 numSubstreams = folders[i].NumUnpackStreams;
+    if (numSubstreams != 1 || !folders[i].UnpackCRCDefined)
+      numDigests += numSubstreams;
+  }
+
+ 
+  si = 0;
+  for (;;)
+  {
+    if (type == k7zIdCRC)
+    {
+      int digestIndex = 0;
+      Byte *digestsDefined2 = 0;
+      UInt32 *digests2 = 0;
+      SRes res = SzReadHashDigests(sd, numDigests, &digestsDefined2, &digests2, allocTemp);
+      if (res == SZ_OK)
+      {
+        for (i = 0; i < numFolders; i++)
+        {
+          CSzFolder *folder = folders + i;
+          UInt32 numSubstreams = folder->NumUnpackStreams;
+          if (numSubstreams == 1 && folder->UnpackCRCDefined)
+          {
+            (*digestsDefined)[si] = 1;
+            (*digests)[si] = folder->UnpackCRC;
+            si++;
+          }
+          else
+          {
+            UInt32 j;
+            for (j = 0; j < numSubstreams; j++, digestIndex++)
+            {
+              (*digestsDefined)[si] = digestsDefined2[digestIndex];
+              (*digests)[si] = digests2[digestIndex];
+              si++;
+            }
+          }
+        }
+      }
+      IAlloc_Free(allocTemp, digestsDefined2);
+      IAlloc_Free(allocTemp, digests2);
+      RINOK(res);
+    }
+    else if (type == k7zIdEnd)
+      return SZ_OK;
+    else
+    {
+      RINOK(SzSkeepData(sd));
+    }
+    RINOK(SzReadID(sd, &type));
+  }
+}
+
+
+static SRes SzReadStreamsInfo(
+    CSzData *sd,
+    UInt64 *dataOffset,
+    CSzAr *p,
+    UInt32 *numUnpackStreams,
+    UInt64 **unpackSizes, /* allocTemp */
+    Byte **digestsDefined,   /* allocTemp */
+    UInt32 **digests,        /* allocTemp */
+    ISzAlloc *alloc,
+    ISzAlloc *allocTemp)
+{
+  for (;;)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &type));
+    if ((UInt64)(int)type != type)
+      return SZ_ERROR_UNSUPPORTED;
+    switch((int)type)
+    {
+      case k7zIdEnd:
+        return SZ_OK;
+      case k7zIdPackInfo:
+      {
+        RINOK(SzReadPackInfo(sd, dataOffset, &p->NumPackStreams,
+            &p->PackSizes, &p->PackCRCsDefined, &p->PackCRCs, alloc));
+        break;
+      }
+      case k7zIdUnpackInfo:
+      {
+        RINOK(SzReadUnpackInfo(sd, &p->NumFolders, &p->Folders, alloc, allocTemp));
+        break;
+      }
+      case k7zIdSubStreamsInfo:
+      {
+        RINOK(SzReadSubStreamsInfo(sd, p->NumFolders, p->Folders,
+            numUnpackStreams, unpackSizes, digestsDefined, digests, allocTemp));
+        break;
+      }
+      default:
+        return SZ_ERROR_UNSUPPORTED;
+    }
+  }
+}
+
+Byte kUtf8Limits[5] = { 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+static SRes SzReadFileNames(CSzData *sd, UInt32 numFiles, CSzFileItem *files, ISzAlloc *alloc)
+{
+  UInt32 i;
+  for (i = 0; i < numFiles; i++)
+  {
+    UInt32 len = 0;
+    UInt32 pos = 0;
+    CSzFileItem *file = files + i;
+    while (pos + 2 <= sd->Size)
+    {
+      int numAdds;
+      UInt32 value = (UInt32)(sd->Data[pos] | (((UInt32)sd->Data[pos + 1]) << 8));
+      pos += 2;
+      len++;
+      if (value == 0)
+        break;
+      if (value < 0x80)
+        continue;
+      if (value >= 0xD800 && value < 0xE000)
+      {
+        UInt32 c2;
+        if (value >= 0xDC00)
+          return SZ_ERROR_ARCHIVE;
+        if (pos + 2 > sd->Size)
+          return SZ_ERROR_ARCHIVE;
+        c2 = (UInt32)(sd->Data[pos] | (((UInt32)sd->Data[pos + 1]) << 8));
+        pos += 2;
+        if (c2 < 0xDC00 || c2 >= 0xE000)
+          return SZ_ERROR_ARCHIVE;
+        value = ((value - 0xD800) << 10) | (c2 - 0xDC00);
+      }
+      for (numAdds = 1; numAdds < 5; numAdds++)
+        if (value < (((UInt32)1) << (numAdds * 5 + 6)))
+          break;
+      len += numAdds;
+    }
+
+    MY_ALLOC(char, file->Name, (size_t)len, alloc);
+
+    len = 0;
+    while (2 <= sd->Size)
+    {
+      int numAdds;
+      UInt32 value = (UInt32)(sd->Data[0] | (((UInt32)sd->Data[1]) << 8));
+      SzSkeepDataSize(sd, 2);
+      if (value < 0x80)
+      {
+        file->Name[len++] = (char)value;
+        if (value == 0)
+          break;
+        continue;
+      }
+      if (value >= 0xD800 && value < 0xE000)
+      {
+        UInt32 c2 = (UInt32)(sd->Data[0] | (((UInt32)sd->Data[1]) << 8));
+        SzSkeepDataSize(sd, 2);
+        value = ((value - 0xD800) << 10) | (c2 - 0xDC00);
+      }
+      for (numAdds = 1; numAdds < 5; numAdds++)
+        if (value < (((UInt32)1) << (numAdds * 5 + 6)))
+          break;
+      file->Name[len++] = (char)(kUtf8Limits[numAdds - 1] + (value >> (6 * numAdds)));
+      do
+      {
+        numAdds--;
+        file->Name[len++] = (char)(0x80 + ((value >> (6 * numAdds)) & 0x3F));
+      }
+      while (numAdds > 0);
+
+      len += numAdds;
+    }
+  }
+  return SZ_OK;
+}
+
+static SRes SzReadHeader2(
+    CSzArEx *p,   /* allocMain */
+    CSzData *sd,
+    UInt64 **unpackSizes,  /* allocTemp */
+    Byte **digestsDefined,    /* allocTemp */
+    UInt32 **digests,         /* allocTemp */
+    Byte **emptyStreamVector, /* allocTemp */
+    Byte **emptyFileVector,   /* allocTemp */
+    Byte **lwtVector,         /* allocTemp */
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp)
+{
+  UInt64 type;
+  UInt32 numUnpackStreams = 0;
+  UInt32 numFiles = 0;
+  CSzFileItem *files = 0;
+  UInt32 numEmptyStreams = 0;
+  UInt32 i;
+
+  RINOK(SzReadID(sd, &type));
+
+  if (type == k7zIdArchiveProperties)
+  {
+    RINOK(SzReadArchiveProperties(sd));
+    RINOK(SzReadID(sd, &type));
+  }
+ 
+ 
+  if (type == k7zIdMainStreamsInfo)
+  {
+    RINOK(SzReadStreamsInfo(sd,
+        &p->dataPos,
+        &p->db,
+        &numUnpackStreams,
+        unpackSizes,
+        digestsDefined,
+        digests, allocMain, allocTemp));
+    p->dataPos += p->startPosAfterHeader;
+    RINOK(SzReadID(sd, &type));
+  }
+
+  if (type == k7zIdEnd)
+    return SZ_OK;
+  if (type != k7zIdFilesInfo)
+    return SZ_ERROR_ARCHIVE;
+  
+  RINOK(SzReadNumber32(sd, &numFiles));
+  p->db.NumFiles = numFiles;
+
+  MY_ALLOC(CSzFileItem, files, (size_t)numFiles, allocMain);
+
+  p->db.Files = files;
+  for (i = 0; i < numFiles; i++)
+    SzFile_Init(files + i);
+
+  for (;;)
+  {
+    UInt64 type;
+    UInt64 size;
+    RINOK(SzReadID(sd, &type));
+    if (type == k7zIdEnd)
+      break;
+    RINOK(SzReadNumber(sd, &size));
+
+    if ((UInt64)(int)type != type)
+    {
+      RINOK(SzSkeepDataSize(sd, size));
+    }
+    else
+    switch((int)type)
+    {
+      case k7zIdName:
+      {
+        RINOK(SzReadSwitch(sd));
+        RINOK(SzReadFileNames(sd, numFiles, files, allocMain))
+        break;
+      }
+      case k7zIdEmptyStream:
+      {
+        RINOK(SzReadBoolVector(sd, numFiles, emptyStreamVector, allocTemp));
+        numEmptyStreams = 0;
+        for (i = 0; i < numFiles; i++)
+          if ((*emptyStreamVector)[i])
+            numEmptyStreams++;
+        break;
+      }
+      case k7zIdEmptyFile:
+      {
+        RINOK(SzReadBoolVector(sd, numEmptyStreams, emptyFileVector, allocTemp));
+        break;
+      }
+      case k7zIdMTime:
+      {
+        RINOK(SzReadBoolVector2(sd, numFiles, lwtVector, allocTemp));
+        RINOK(SzReadSwitch(sd));
+        for (i = 0; i < numFiles; i++)
+        {
+          CSzFileItem *f = &files[i];
+          Byte defined = (*lwtVector)[i];
+          f->MTimeDefined = defined;
+          f->MTime.Low = f->MTime.High = 0;
+          if (defined)
+          {
+            RINOK(SzReadUInt32(sd, &f->MTime.Low));
+            RINOK(SzReadUInt32(sd, &f->MTime.High));
+          }
+        }
+        break;
+      }
+      default:
+      {
+        RINOK(SzSkeepDataSize(sd, size));
+      }
+    }
+  }
+
+  {
+    UInt32 emptyFileIndex = 0;
+    UInt32 sizeIndex = 0;
+    for (i = 0; i < numFiles; i++)
+    {
+      CSzFileItem *file = files + i;
+      file->IsAnti = 0;
+      if (*emptyStreamVector == 0)
+        file->HasStream = 1;
+      else
+        file->HasStream = (Byte)((*emptyStreamVector)[i] ? 0 : 1);
+      if (file->HasStream)
+      {
+        file->IsDir = 0;
+        file->Size = (*unpackSizes)[sizeIndex];
+        file->FileCRC = (*digests)[sizeIndex];
+        file->FileCRCDefined = (Byte)(*digestsDefined)[sizeIndex];
+        sizeIndex++;
+      }
+      else
+      {
+        if (*emptyFileVector == 0)
+          file->IsDir = 1;
+        else
+          file->IsDir = (Byte)((*emptyFileVector)[emptyFileIndex] ? 0 : 1);
+        emptyFileIndex++;
+        file->Size = 0;
+        file->FileCRCDefined = 0;
+      }
+    }
+  }
+  return SzArEx_Fill(p, allocMain);
+}
+
+static SRes SzReadHeader(
+    CSzArEx *p,
+    CSzData *sd,
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp)
+{
+  UInt64 *unpackSizes = 0;
+  Byte *digestsDefined = 0;
+  UInt32 *digests = 0;
+  Byte *emptyStreamVector = 0;
+  Byte *emptyFileVector = 0;
+  Byte *lwtVector = 0;
+  SRes res = SzReadHeader2(p, sd,
+      &unpackSizes, &digestsDefined, &digests,
+      &emptyStreamVector, &emptyFileVector, &lwtVector,
+      allocMain, allocTemp);
+  IAlloc_Free(allocTemp, unpackSizes);
+  IAlloc_Free(allocTemp, digestsDefined);
+  IAlloc_Free(allocTemp, digests);
+  IAlloc_Free(allocTemp, emptyStreamVector);
+  IAlloc_Free(allocTemp, emptyFileVector);
+  IAlloc_Free(allocTemp, lwtVector);
+  return res;
+}
+
+static SRes SzReadAndDecodePackedStreams2(
+    ILookInStream *inStream,
+    CSzData *sd,
+    CBuf *outBuffer,
+    UInt64 baseOffset,
+    CSzAr *p,
+    UInt64 **unpackSizes,
+    Byte **digestsDefined,
+    UInt32 **digests,
+    ISzAlloc *allocTemp)
+{
+
+  UInt32 numUnpackStreams = 0;
+  UInt64 dataStartPos;
+  CSzFolder *folder;
+  UInt64 unpackSize;
+  SRes res;
+
+  RINOK(SzReadStreamsInfo(sd, &dataStartPos, p,
+      &numUnpackStreams,  unpackSizes, digestsDefined, digests,
+      allocTemp, allocTemp));
+  
+  dataStartPos += baseOffset;
+  if (p->NumFolders != 1)
+    return SZ_ERROR_ARCHIVE;
+
+  folder = p->Folders;
+  unpackSize = SzFolder_GetUnpackSize(folder);
+  
+  RINOK(LookInStream_SeekTo(inStream, dataStartPos));
+
+  if (!Buf_Create(outBuffer, (size_t)unpackSize, allocTemp))
+    return SZ_ERROR_MEM;
+  
+  res = SzDecode(p->PackSizes, folder,
+          inStream, dataStartPos,
+          outBuffer->data, (size_t)unpackSize, allocTemp);
+  RINOK(res);
+  if (folder->UnpackCRCDefined)
+    if (CrcCalc(outBuffer->data, (size_t)unpackSize) != folder->UnpackCRC)
+      return SZ_ERROR_CRC;
+  return SZ_OK;
+}
+
+static SRes SzReadAndDecodePackedStreams(
+    ILookInStream *inStream,
+    CSzData *sd,
+    CBuf *outBuffer,
+    UInt64 baseOffset,
+    ISzAlloc *allocTemp)
+{
+  CSzAr p;
+  UInt64 *unpackSizes = 0;
+  Byte *digestsDefined = 0;
+  UInt32 *digests = 0;
+  SRes res;
+  SzAr_Init(&p);
+  res = SzReadAndDecodePackedStreams2(inStream, sd, outBuffer, baseOffset,
+    &p, &unpackSizes, &digestsDefined, &digests,
+    allocTemp);
+  SzAr_Free(&p, allocTemp);
+  IAlloc_Free(allocTemp, unpackSizes);
+  IAlloc_Free(allocTemp, digestsDefined);
+  IAlloc_Free(allocTemp, digests);
+  return res;
+}
+
+static SRes SzArEx_Open2(
+    CSzArEx *p,
+    ILookInStream *inStream,
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp)
+{
+  Byte header[k7zStartHeaderSize];
+  UInt64 nextHeaderOffset, nextHeaderSize;
+  size_t nextHeaderSizeT;
+  UInt32 nextHeaderCRC;
+  CBuf buffer;
+  SRes res;
+
+  RINOK(LookInStream_Read2(inStream, header, k7zStartHeaderSize, SZ_ERROR_NO_ARCHIVE));
+
+  if (!TestSignatureCandidate(header))
+    return SZ_ERROR_NO_ARCHIVE;
+  if (header[6] != k7zMajorVersion)
+    return SZ_ERROR_UNSUPPORTED;
+
+  nextHeaderOffset = GetUi64(header + 12);
+  nextHeaderSize = GetUi64(header + 20);
+  nextHeaderCRC = GetUi32(header + 28);
+
+  p->startPosAfterHeader = k7zStartHeaderSize;
+  
+  if (CrcCalc(header + 12, 20) != GetUi32(header + 8))
+    return SZ_ERROR_CRC;
+
+  nextHeaderSizeT = (size_t)nextHeaderSize;
+  if (nextHeaderSizeT != nextHeaderSize)
+    return SZ_ERROR_MEM;
+  if (nextHeaderSizeT == 0)
+    return SZ_OK;
+  if (nextHeaderOffset > nextHeaderOffset + nextHeaderSize ||
+      nextHeaderOffset > nextHeaderOffset + nextHeaderSize + k7zStartHeaderSize)
+    return SZ_ERROR_NO_ARCHIVE;
+
+  {
+    Int64 pos = 0;
+    RINOK(inStream->Seek(inStream, &pos, SZ_SEEK_END));
+    if ((UInt64)pos < nextHeaderOffset ||
+        (UInt64)pos < k7zStartHeaderSize + nextHeaderOffset ||
+        (UInt64)pos < k7zStartHeaderSize + nextHeaderOffset + nextHeaderSize)
+      return SZ_ERROR_INPUT_EOF;
+  }
+
+  RINOK(LookInStream_SeekTo(inStream, k7zStartHeaderSize + nextHeaderOffset));
+
+  if (!Buf_Create(&buffer, nextHeaderSizeT, allocTemp))
+    return SZ_ERROR_MEM;
+
+  res = LookInStream_Read(inStream, buffer.data, nextHeaderSizeT);
+  if (res == SZ_OK)
+  {
+    res = SZ_ERROR_ARCHIVE;
+    if (CrcCalc(buffer.data, nextHeaderSizeT) == nextHeaderCRC)
+    {
+      CSzData sd;
+      UInt64 type;
+      sd.Data = buffer.data;
+      sd.Size = buffer.size;
+      res = SzReadID(&sd, &type);
+      if (res == SZ_OK)
+      {
+        if (type == k7zIdEncodedHeader)
+        {
+          CBuf outBuffer;
+          Buf_Init(&outBuffer);
+          res = SzReadAndDecodePackedStreams(inStream, &sd, &outBuffer, p->startPosAfterHeader, allocTemp);
+          if (res != SZ_OK)
+            Buf_Free(&outBuffer, allocTemp);
+          else
+          {
+            Buf_Free(&buffer, allocTemp);
+            buffer.data = outBuffer.data;
+            buffer.size = outBuffer.size;
+            sd.Data = buffer.data;
+            sd.Size = buffer.size;
+            res = SzReadID(&sd, &type);
+          }
+        }
+      }
+      if (res == SZ_OK)
+      {
+        if (type == k7zIdHeader)
+          res = SzReadHeader(p, &sd, allocMain, allocTemp);
+        else
+          res = SZ_ERROR_UNSUPPORTED;
+      }
+    }
+  }
+  Buf_Free(&buffer, allocTemp);
+  return res;
+}
+
+SRes SzArEx_Open(CSzArEx *p, ILookInStream *inStream, ISzAlloc *allocMain, ISzAlloc *allocTemp)
+{
+  SRes res = SzArEx_Open2(p, inStream, allocMain, allocTemp);
+  if (res != SZ_OK)
+    SzArEx_Free(p, allocMain);
+  return res;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Archive/7z/7zIn.h squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zIn.h
--- squashfs-tools/LZMA/lzma465/C/Archive/7z/7zIn.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zIn.h	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,41 @@
+/* 7zIn.h -- 7z Input functions
+2008-11-23 : Igor Pavlov : Public domain */
+
+#ifndef __7Z_IN_H
+#define __7Z_IN_H
+
+#include "7zHeader.h"
+#include "7zItem.h"
+
+typedef struct
+{
+  CSzAr db;
+  
+  UInt64 startPosAfterHeader;
+  UInt64 dataPos;
+
+  UInt32 *FolderStartPackStreamIndex;
+  UInt64 *PackStreamStartPositions;
+  UInt32 *FolderStartFileIndex;
+  UInt32 *FileIndexToFolderIndexMap;
+} CSzArEx;
+
+void SzArEx_Init(CSzArEx *p);
+void SzArEx_Free(CSzArEx *p, ISzAlloc *alloc);
+UInt64 SzArEx_GetFolderStreamPos(const CSzArEx *p, UInt32 folderIndex, UInt32 indexInFolder);
+int SzArEx_GetFolderFullPackSize(const CSzArEx *p, UInt32 folderIndex, UInt64 *resSize);
+
+/*
+Errors:
+SZ_ERROR_NO_ARCHIVE
+SZ_ERROR_ARCHIVE
+SZ_ERROR_UNSUPPORTED
+SZ_ERROR_MEM
+SZ_ERROR_CRC
+SZ_ERROR_INPUT_EOF
+SZ_ERROR_FAIL
+*/
+
+SRes SzArEx_Open(CSzArEx *p, ILookInStream *inStream, ISzAlloc *allocMain, ISzAlloc *allocTemp);
+ 
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Archive/7z/7zItem.c squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zItem.c
--- squashfs-tools/LZMA/lzma465/C/Archive/7z/7zItem.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zItem.c	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,127 @@
+/* 7zItem.c -- 7z Items
+2008-10-04 : Igor Pavlov : Public domain */
+
+#include "7zItem.h"
+
+void SzCoderInfo_Init(CSzCoderInfo *p)
+{
+  Buf_Init(&p->Props);
+}
+
+void SzCoderInfo_Free(CSzCoderInfo *p, ISzAlloc *alloc)
+{
+  Buf_Free(&p->Props, alloc);
+  SzCoderInfo_Init(p);
+}
+
+void SzFolder_Init(CSzFolder *p)
+{
+  p->Coders = 0;
+  p->BindPairs = 0;
+  p->PackStreams = 0;
+  p->UnpackSizes = 0;
+  p->NumCoders = 0;
+  p->NumBindPairs = 0;
+  p->NumPackStreams = 0;
+  p->UnpackCRCDefined = 0;
+  p->UnpackCRC = 0;
+  p->NumUnpackStreams = 0;
+}
+
+void SzFolder_Free(CSzFolder *p, ISzAlloc *alloc)
+{
+  UInt32 i;
+  if (p->Coders)
+    for (i = 0; i < p->NumCoders; i++)
+      SzCoderInfo_Free(&p->Coders[i], alloc);
+  IAlloc_Free(alloc, p->Coders);
+  IAlloc_Free(alloc, p->BindPairs);
+  IAlloc_Free(alloc, p->PackStreams);
+  IAlloc_Free(alloc, p->UnpackSizes);
+  SzFolder_Init(p);
+}
+
+UInt32 SzFolder_GetNumOutStreams(CSzFolder *p)
+{
+  UInt32 result = 0;
+  UInt32 i;
+  for (i = 0; i < p->NumCoders; i++)
+    result += p->Coders[i].NumOutStreams;
+  return result;
+}
+
+int SzFolder_FindBindPairForInStream(CSzFolder *p, UInt32 inStreamIndex)
+{
+  UInt32 i;
+  for (i = 0; i < p->NumBindPairs; i++)
+    if (p->BindPairs[i].InIndex == inStreamIndex)
+      return i;
+  return -1;
+}
+
+
+int SzFolder_FindBindPairForOutStream(CSzFolder *p, UInt32 outStreamIndex)
+{
+  UInt32 i;
+  for (i = 0; i < p->NumBindPairs; i++)
+    if (p->BindPairs[i].OutIndex == outStreamIndex)
+      return i;
+  return -1;
+}
+
+UInt64 SzFolder_GetUnpackSize(CSzFolder *p)
+{
+  int i = (int)SzFolder_GetNumOutStreams(p);
+  if (i == 0)
+    return 0;
+  for (i--; i >= 0; i--)
+    if (SzFolder_FindBindPairForOutStream(p, i) < 0)
+      return p->UnpackSizes[i];
+  /* throw 1; */
+  return 0;
+}
+
+void SzFile_Init(CSzFileItem *p)
+{
+  p->HasStream = 1;
+  p->IsDir = 0;
+  p->IsAnti = 0;
+  p->FileCRCDefined = 0;
+  p->MTimeDefined = 0;
+  p->Name = 0;
+}
+
+static void SzFile_Free(CSzFileItem *p, ISzAlloc *alloc)
+{
+  IAlloc_Free(alloc, p->Name);
+  SzFile_Init(p);
+}
+
+void SzAr_Init(CSzAr *p)
+{
+  p->PackSizes = 0;
+  p->PackCRCsDefined = 0;
+  p->PackCRCs = 0;
+  p->Folders = 0;
+  p->Files = 0;
+  p->NumPackStreams = 0;
+  p->NumFolders = 0;
+  p->NumFiles = 0;
+}
+
+void SzAr_Free(CSzAr *p, ISzAlloc *alloc)
+{
+  UInt32 i;
+  if (p->Folders)
+    for (i = 0; i < p->NumFolders; i++)
+      SzFolder_Free(&p->Folders[i], alloc);
+  if (p->Files)
+    for (i = 0; i < p->NumFiles; i++)
+      SzFile_Free(&p->Files[i], alloc);
+  IAlloc_Free(alloc, p->PackSizes);
+  IAlloc_Free(alloc, p->PackCRCsDefined);
+  IAlloc_Free(alloc, p->PackCRCs);
+  IAlloc_Free(alloc, p->Folders);
+  IAlloc_Free(alloc, p->Files);
+  SzAr_Init(p);
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Archive/7z/7zItem.h squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zItem.h
--- squashfs-tools/LZMA/lzma465/C/Archive/7z/7zItem.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zItem.h	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,84 @@
+/* 7zItem.h -- 7z Items
+2008-10-04 : Igor Pavlov : Public domain */
+
+#ifndef __7Z_ITEM_H
+#define __7Z_ITEM_H
+
+#include "../../7zBuf.h"
+
+typedef struct
+{
+  UInt32 NumInStreams;
+  UInt32 NumOutStreams;
+  UInt64 MethodID;
+  CBuf Props;
+} CSzCoderInfo;
+
+void SzCoderInfo_Init(CSzCoderInfo *p);
+void SzCoderInfo_Free(CSzCoderInfo *p, ISzAlloc *alloc);
+
+typedef struct
+{
+  UInt32 InIndex;
+  UInt32 OutIndex;
+} CBindPair;
+
+typedef struct
+{
+  CSzCoderInfo *Coders;
+  CBindPair *BindPairs;
+  UInt32 *PackStreams;
+  UInt64 *UnpackSizes;
+  UInt32 NumCoders;
+  UInt32 NumBindPairs;
+  UInt32 NumPackStreams;
+  int UnpackCRCDefined;
+  UInt32 UnpackCRC;
+
+  UInt32 NumUnpackStreams;
+} CSzFolder;
+
+void SzFolder_Init(CSzFolder *p);
+UInt64 SzFolder_GetUnpackSize(CSzFolder *p);
+int SzFolder_FindBindPairForInStream(CSzFolder *p, UInt32 inStreamIndex);
+UInt32 SzFolder_GetNumOutStreams(CSzFolder *p);
+UInt64 SzFolder_GetUnpackSize(CSzFolder *p);
+
+typedef struct
+{
+  UInt32 Low;
+  UInt32 High;
+} CNtfsFileTime;
+
+typedef struct
+{
+  CNtfsFileTime MTime;
+  UInt64 Size;
+  char *Name;
+  UInt32 FileCRC;
+
+  Byte HasStream;
+  Byte IsDir;
+  Byte IsAnti;
+  Byte FileCRCDefined;
+  Byte MTimeDefined;
+} CSzFileItem;
+
+void SzFile_Init(CSzFileItem *p);
+
+typedef struct
+{
+  UInt64 *PackSizes;
+  Byte *PackCRCsDefined;
+  UInt32 *PackCRCs;
+  CSzFolder *Folders;
+  CSzFileItem *Files;
+  UInt32 NumPackStreams;
+  UInt32 NumFolders;
+  UInt32 NumFiles;
+} CSzAr;
+
+void SzAr_Init(CSzAr *p);
+void SzAr_Free(CSzAr *p, ISzAlloc *alloc);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Archive/7z/7zMain.c squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zMain.c
--- squashfs-tools/LZMA/lzma465/C/Archive/7z/7zMain.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/7zMain.c	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,262 @@
+/* 7zMain.c - Test application for 7z Decoder
+2008-11-23 : Igor Pavlov : Public domain */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "../../7zCrc.h"
+#include "../../7zFile.h"
+#include "../../7zVersion.h"
+
+#include "7zAlloc.h"
+#include "7zExtract.h"
+#include "7zIn.h"
+
+static void ConvertNumberToString(UInt64 value, char *s)
+{
+  char temp[32];
+  int pos = 0;
+  do
+  {
+    temp[pos++] = (char)('0' + (int)(value % 10));
+    value /= 10;
+  }
+  while (value != 0);
+  do
+    *s++ = temp[--pos];
+  while (pos > 0);
+  *s = '\0';
+}
+
+#define PERIOD_4 (4 * 365 + 1)
+#define PERIOD_100 (PERIOD_4 * 25 - 1)
+#define PERIOD_400 (PERIOD_100 * 4 + 1)
+
+static void ConvertFileTimeToString(CNtfsFileTime *ft, char *s)
+{
+  unsigned year, mon, day, hour, min, sec;
+  UInt64 v64 = ft->Low | ((UInt64)ft->High << 32);
+  Byte ms[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
+  unsigned temp;
+  UInt32 v;
+  v64 /= 10000000;
+  sec = (unsigned)(v64 % 60);
+  v64 /= 60;
+  min = (unsigned)(v64 % 60);
+  v64 /= 60;
+  hour = (unsigned)(v64 % 24);
+  v64 /= 24;
+
+  v = (UInt32)v64;
+
+  year = (unsigned)(1601 + v / PERIOD_400 * 400);
+  v %= PERIOD_400;
+
+  temp = (unsigned)(v / PERIOD_100);
+  if (temp == 4)
+    temp = 3;
+  year += temp * 100;
+  v -= temp * PERIOD_100;
+
+  temp = v / PERIOD_4;
+  if (temp == 25)
+    temp = 24;
+  year += temp * 4;
+  v -= temp * PERIOD_4;
+
+  temp = v / 365;
+  if (temp == 4)
+    temp = 3;
+  year += temp;
+  v -= temp * 365;
+
+  if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0))
+    ms[1] = 29;
+  for (mon = 1; mon <= 12; mon++)
+  {
+    unsigned s = ms[mon - 1];
+    if (v < s)
+      break;
+    v -= s;
+  }
+  day = (unsigned)v + 1;
+  sprintf(s, "%04d-%02d-%02d %02d:%02d:%02d", year, mon, day, hour, min, sec);
+}
+
+void PrintError(char *sz)
+{
+  printf("\nERROR: %s\n", sz);
+}
+
+int MY_CDECL main(int numargs, char *args[])
+{
+  CFileInStream archiveStream;
+  CLookToRead lookStream;
+  CSzArEx db;
+  SRes res;
+  ISzAlloc allocImp;
+  ISzAlloc allocTempImp;
+
+  printf("\n7z ANSI-C Decoder " MY_VERSION_COPYRIGHT_DATE "\n");
+  if (numargs == 1)
+  {
+    printf(
+      "\nUsage: 7zDec <command> <archive_name>\n\n"
+      "<Commands>\n"
+      "  e: Extract files from archive\n"
+      "  l: List contents of archive\n"
+      "  t: Test integrity of archive\n");
+    return 0;
+  }
+  if (numargs < 3)
+  {
+    PrintError("incorrect command");
+    return 1;
+  }
+
+  if (InFile_Open(&archiveStream.file, args[2]))
+  {
+    PrintError("can not open input file");
+    return 1;
+  }
+
+  
+  FileInStream_CreateVTable(&archiveStream);
+  LookToRead_CreateVTable(&lookStream, False);
+  
+  lookStream.realStream = &archiveStream.s;
+  LookToRead_Init(&lookStream);
+
+  allocImp.Alloc = SzAlloc;
+  allocImp.Free = SzFree;
+
+  allocTempImp.Alloc = SzAllocTemp;
+  allocTempImp.Free = SzFreeTemp;
+
+  CrcGenerateTable();
+
+  SzArEx_Init(&db);
+  res = SzArEx_Open(&db, &lookStream.s, &allocImp, &allocTempImp);
+  if (res == SZ_OK)
+  {
+    char *command = args[1];
+    int listCommand = 0, testCommand = 0, extractCommand = 0;
+    if (strcmp(command, "l") == 0) listCommand = 1;
+    else if (strcmp(command, "t") == 0) testCommand = 1;
+    else if (strcmp(command, "e") == 0) extractCommand = 1;
+
+    if (listCommand)
+    {
+      UInt32 i;
+      for (i = 0; i < db.db.NumFiles; i++)
+      {
+        CSzFileItem *f = db.db.Files + i;
+        char s[32], t[32];
+        ConvertNumberToString(f->Size, s);
+        if (f->MTimeDefined)
+          ConvertFileTimeToString(&f->MTime, t);
+        else
+          strcpy(t, "                   ");
+
+        printf("%s %10s  %s\n", t, s, f->Name);
+      }
+    }
+    else if (testCommand || extractCommand)
+    {
+      UInt32 i;
+
+      /*
+      if you need cache, use these 3 variables.
+      if you use external function, you can make these variable as static.
+      */
+      UInt32 blockIndex = 0xFFFFFFFF; /* it can have any value before first call (if outBuffer = 0) */
+      Byte *outBuffer = 0; /* it must be 0 before first call for each new archive. */
+      size_t outBufferSize = 0;  /* it can have any value before first call (if outBuffer = 0) */
+
+      printf("\n");
+      for (i = 0; i < db.db.NumFiles; i++)
+      {
+        size_t offset;
+        size_t outSizeProcessed;
+        CSzFileItem *f = db.db.Files + i;
+        if (f->IsDir)
+          printf("Directory ");
+        else
+          printf(testCommand ?
+            "Testing   ":
+            "Extracting");
+        printf(" %s", f->Name);
+        if (f->IsDir)
+        {
+          printf("\n");
+          continue;
+        }
+        res = SzAr_Extract(&db, &lookStream.s, i,
+            &blockIndex, &outBuffer, &outBufferSize,
+            &offset, &outSizeProcessed,
+            &allocImp, &allocTempImp);
+        if (res != SZ_OK)
+          break;
+        if (!testCommand)
+        {
+          CSzFile outFile;
+          size_t processedSize;
+          char *fileName = f->Name;
+          size_t nameLen = strlen(f->Name);
+          for (; nameLen > 0; nameLen--)
+            if (f->Name[nameLen - 1] == '/')
+            {
+              fileName = f->Name + nameLen;
+              break;
+            }
+            
+          if (OutFile_Open(&outFile, fileName))
+          {
+            PrintError("can not open output file");
+            res = SZ_ERROR_FAIL;
+            break;
+          }
+          processedSize = outSizeProcessed;
+          if (File_Write(&outFile, outBuffer + offset, &processedSize) != 0 ||
+              processedSize != outSizeProcessed)
+          {
+            PrintError("can not write output file");
+            res = SZ_ERROR_FAIL;
+            break;
+          }
+          if (File_Close(&outFile))
+          {
+            PrintError("can not close output file");
+            res = SZ_ERROR_FAIL;
+            break;
+          }
+        }
+        printf("\n");
+      }
+      IAlloc_Free(&allocImp, outBuffer);
+    }
+    else
+    {
+      PrintError("incorrect command");
+      res = SZ_ERROR_FAIL;
+    }
+  }
+  SzArEx_Free(&db, &allocImp);
+
+  File_Close(&archiveStream.file);
+  if (res == SZ_OK)
+  {
+    printf("\nEverything is Ok\n");
+    return 0;
+  }
+  if (res == SZ_ERROR_UNSUPPORTED)
+    PrintError("decoder doesn't support this archive");
+  else if (res == SZ_ERROR_MEM)
+    PrintError("can not allocate memory");
+  else if (res == SZ_ERROR_CRC)
+    PrintError("CRC error");
+  else
+    printf("\nERROR #%d\n", res);
+  return 1;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Archive/7z/makefile squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/makefile
--- squashfs-tools/LZMA/lzma465/C/Archive/7z/makefile	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/makefile	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,33 @@
+MY_STATIC_LINK=1
+
+PROG = 7zDec.exe
+
+C_OBJS = \
+  $O\7zBuf.obj \
+  $O\7zBuf2.obj \
+  $O\7zCrc.obj \
+  $O\LzmaDec.obj \
+  $O\Bra86.obj \
+  $O\Bcj2.obj \
+  $O\7zFile.obj \
+  $O\7zStream.obj \
+
+7Z_OBJS = \
+  $O\7zAlloc.obj \
+  $O\7zDecode.obj \
+  $O\7zExtract.obj \
+  $O\7zHeader.obj \
+  $O\7zIn.obj \
+  $O\7zItem.obj \
+  $O\7zMain.obj \
+
+OBJS = \
+  $(7Z_OBJS) \
+  $(C_OBJS) \
+
+!include "../../../CPP/Build.mak"
+
+$(7Z_OBJS): $(*B).c
+	$(COMPL_O1)
+$(C_OBJS): ../../$(*B).c
+	$(COMPL_O2)
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Archive/7z/makefile.gcc squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/makefile.gcc
--- squashfs-tools/LZMA/lzma465/C/Archive/7z/makefile.gcc	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Archive/7z/makefile.gcc	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,61 @@
+PROG = 7zDec
+CXX = g++
+LIB =
+RM = rm -f
+CFLAGS = -c -O2 -Wall
+
+OBJS = 7zAlloc.o 7zBuf.o 7zBuf2.o 7zCrc.o 7zDecode.o 7zExtract.o 7zHeader.o 7zIn.o 7zItem.o 7zMain.o LzmaDec.o Bra86.o Bcj2.o 7zFile.o 7zStream.o
+
+all: $(PROG)
+
+$(PROG): $(OBJS)
+	$(CXX) -o $(PROG) $(LDFLAGS) $(OBJS) $(LIB)
+
+7zAlloc.o: 7zAlloc.c
+	$(CXX) $(CFLAGS) 7zAlloc.c
+
+7zBuf.o: ../../7zBuf.c
+	$(CXX) $(CFLAGS) ../../7zBuf.c
+
+7zBuf2.o: ../../7zBuf2.c
+	$(CXX) $(CFLAGS) ../../7zBuf2.c
+
+7zCrc.o: ../../7zCrc.c
+	$(CXX) $(CFLAGS) ../../7zCrc.c
+
+7zDecode.o: 7zDecode.c
+	$(CXX) $(CFLAGS) 7zDecode.c
+
+7zExtract.o: 7zExtract.c
+	$(CXX) $(CFLAGS) 7zExtract.c
+
+7zHeader.o: 7zHeader.c
+	$(CXX) $(CFLAGS) 7zHeader.c
+
+7zIn.o: 7zIn.c
+	$(CXX) $(CFLAGS) 7zIn.c
+
+7zItem.o: 7zItem.c
+	$(CXX) $(CFLAGS) 7zItem.c
+
+7zMain.o: 7zMain.c
+	$(CXX) $(CFLAGS) 7zMain.c
+
+LzmaDec.o: ../../LzmaDec.c
+	$(CXX) $(CFLAGS) ../../LzmaDec.c
+
+Bra86.o: ../../Bra86.c
+	$(CXX) $(CFLAGS) ../../Bra86.c
+
+Bcj2.o: ../../Bcj2.c
+	$(CXX) $(CFLAGS) ../../Bcj2.c
+
+7zFile.o: ../../7zFile.c
+	$(CXX) $(CFLAGS) ../../7zFile.c
+
+7zStream.o: ../../7zStream.c
+	$(CXX) $(CFLAGS) ../../7zStream.c
+
+clean:
+	-$(RM) $(PROG) $(OBJS)
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Bcj2.c squashfs-tools-patched/LZMA/lzma465/C/Bcj2.c
--- squashfs-tools/LZMA/lzma465/C/Bcj2.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Bcj2.c	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,132 @@
+/* Bcj2.c -- Converter for x86 code (BCJ2)
+2008-10-04 : Igor Pavlov : Public domain */
+
+#include "Bcj2.h"
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb UInt16
+#endif
+
+#define IsJcc(b0, b1) ((b0) == 0x0F && ((b1) & 0xF0) == 0x80)
+#define IsJ(b0, b1) ((b1 & 0xFE) == 0xE8 || IsJcc(b0, b1))
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*buffer++)
+#define RC_TEST { if (buffer == bufferLim) return SZ_ERROR_DATA; }
+#define RC_INIT2 code = 0; range = 0xFFFFFFFF; \
+  { int i; for (i = 0; i < 5; i++) { RC_TEST; code = (code << 8) | RC_READ_BYTE; }}
+
+#define NORMALIZE if (range < kTopValue) { RC_TEST; range <<= 8; code = (code << 8) | RC_READ_BYTE; }
+
+#define IF_BIT_0(p) ttt = *(p); bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
+#define UPDATE_0(p) range = bound; *(p) = (CProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits)); NORMALIZE;
+#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CProb)(ttt - (ttt >> kNumMoveBits)); NORMALIZE;
+
+int Bcj2_Decode(
+    const Byte *buf0, SizeT size0,
+    const Byte *buf1, SizeT size1,
+    const Byte *buf2, SizeT size2,
+    const Byte *buf3, SizeT size3,
+    Byte *outBuf, SizeT outSize)
+{
+  CProb p[256 + 2];
+  SizeT inPos = 0, outPos = 0;
+
+  const Byte *buffer, *bufferLim;
+  UInt32 range, code;
+  Byte prevByte = 0;
+
+  unsigned int i;
+  for (i = 0; i < sizeof(p) / sizeof(p[0]); i++)
+    p[i] = kBitModelTotal >> 1;
+
+  buffer = buf3;
+  bufferLim = buffer + size3;
+  RC_INIT2
+
+  if (outSize == 0)
+    return SZ_OK;
+
+  for (;;)
+  {
+    Byte b;
+    CProb *prob;
+    UInt32 bound;
+    UInt32 ttt;
+
+    SizeT limit = size0 - inPos;
+    if (outSize - outPos < limit)
+      limit = outSize - outPos;
+    while (limit != 0)
+    {
+      Byte b = buf0[inPos];
+      outBuf[outPos++] = b;
+      if (IsJ(prevByte, b))
+        break;
+      inPos++;
+      prevByte = b;
+      limit--;
+    }
+
+    if (limit == 0 || outPos == outSize)
+      break;
+
+    b = buf0[inPos++];
+
+    if (b == 0xE8)
+      prob = p + prevByte;
+    else if (b == 0xE9)
+      prob = p + 256;
+    else
+      prob = p + 257;
+
+    IF_BIT_0(prob)
+    {
+      UPDATE_0(prob)
+      prevByte = b;
+    }
+    else
+    {
+      UInt32 dest;
+      const Byte *v;
+      UPDATE_1(prob)
+      if (b == 0xE8)
+      {
+        v = buf1;
+        if (size1 < 4)
+          return SZ_ERROR_DATA;
+        buf1 += 4;
+        size1 -= 4;
+      }
+      else
+      {
+        v = buf2;
+        if (size2 < 4)
+          return SZ_ERROR_DATA;
+        buf2 += 4;
+        size2 -= 4;
+      }
+      dest = (((UInt32)v[0] << 24) | ((UInt32)v[1] << 16) |
+          ((UInt32)v[2] << 8) | ((UInt32)v[3])) - ((UInt32)outPos + 4);
+      outBuf[outPos++] = (Byte)dest;
+      if (outPos == outSize)
+        break;
+      outBuf[outPos++] = (Byte)(dest >> 8);
+      if (outPos == outSize)
+        break;
+      outBuf[outPos++] = (Byte)(dest >> 16);
+      if (outPos == outSize)
+        break;
+      outBuf[outPos++] = prevByte = (Byte)(dest >> 24);
+    }
+  }
+  return (outPos == outSize) ? SZ_OK : SZ_ERROR_DATA;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Bcj2.h squashfs-tools-patched/LZMA/lzma465/C/Bcj2.h
--- squashfs-tools/LZMA/lzma465/C/Bcj2.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Bcj2.h	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,30 @@
+/* Bcj2.h -- Converter for x86 code (BCJ2)
+2008-10-04 : Igor Pavlov : Public domain */
+
+#ifndef __BCJ2_H
+#define __BCJ2_H
+
+#include "Types.h"
+
+/*
+Conditions:
+  outSize <= FullOutputSize,
+  where FullOutputSize is full size of output stream of x86_2 filter.
+
+If buf0 overlaps outBuf, there are two required conditions:
+  1) (buf0 >= outBuf)
+  2) (buf0 + size0 >= outBuf + FullOutputSize).
+
+Returns:
+  SZ_OK
+  SZ_ERROR_DATA - Data error
+*/
+
+int Bcj2_Decode(
+    const Byte *buf0, SizeT size0,
+    const Byte *buf1, SizeT size1,
+    const Byte *buf2, SizeT size2,
+    const Byte *buf3, SizeT size3,
+    Byte *outBuf, SizeT outSize);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Bra86.c squashfs-tools-patched/LZMA/lzma465/C/Bra86.c
--- squashfs-tools/LZMA/lzma465/C/Bra86.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Bra86.c	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,85 @@
+/* Bra86.c -- Converter for x86 code (BCJ)
+2008-10-04 : Igor Pavlov : Public domain */
+
+#include "Bra.h"
+
+#define Test86MSByte(b) ((b) == 0 || (b) == 0xFF)
+
+const Byte kMaskToAllowedStatus[8] = {1, 1, 1, 0, 1, 0, 0, 0};
+const Byte kMaskToBitNumber[8] = {0, 1, 2, 2, 3, 3, 3, 3};
+
+SizeT x86_Convert(Byte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding)
+{
+  SizeT bufferPos = 0, prevPosT;
+  UInt32 prevMask = *state & 0x7;
+  if (size < 5)
+    return 0;
+  ip += 5;
+  prevPosT = (SizeT)0 - 1;
+
+  for (;;)
+  {
+    Byte *p = data + bufferPos;
+    Byte *limit = data + size - 4;
+    for (; p < limit; p++)
+      if ((*p & 0xFE) == 0xE8)
+        break;
+    bufferPos = (SizeT)(p - data);
+    if (p >= limit)
+      break;
+    prevPosT = bufferPos - prevPosT;
+    if (prevPosT > 3)
+      prevMask = 0;
+    else
+    {
+      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;
+      if (prevMask != 0)
+      {
+        Byte b = p[4 - kMaskToBitNumber[prevMask]];
+        if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))
+        {
+          prevPosT = bufferPos;
+          prevMask = ((prevMask << 1) & 0x7) | 1;
+          bufferPos++;
+          continue;
+        }
+      }
+    }
+    prevPosT = bufferPos;
+
+    if (Test86MSByte(p[4]))
+    {
+      UInt32 src = ((UInt32)p[4] << 24) | ((UInt32)p[3] << 16) | ((UInt32)p[2] << 8) | ((UInt32)p[1]);
+      UInt32 dest;
+      for (;;)
+      {
+        Byte b;
+        int index;
+        if (encoding)
+          dest = (ip + (UInt32)bufferPos) + src;
+        else
+          dest = src - (ip + (UInt32)bufferPos);
+        if (prevMask == 0)
+          break;
+        index = kMaskToBitNumber[prevMask] * 8;
+        b = (Byte)(dest >> (24 - index));
+        if (!Test86MSByte(b))
+          break;
+        src = dest ^ ((1 << (32 - index)) - 1);
+      }
+      p[4] = (Byte)(~(((dest >> 24) & 1) - 1));
+      p[3] = (Byte)(dest >> 16);
+      p[2] = (Byte)(dest >> 8);
+      p[1] = (Byte)dest;
+      bufferPos += 5;
+    }
+    else
+    {
+      prevMask = ((prevMask << 1) & 0x7) | 1;
+      bufferPos++;
+    }
+  }
+  prevPosT = bufferPos - prevPosT;
+  *state = ((prevPosT > 3) ? 0 : ((prevMask << ((int)prevPosT - 1)) & 0x7));
+  return bufferPos;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Bra.c squashfs-tools-patched/LZMA/lzma465/C/Bra.c
--- squashfs-tools/LZMA/lzma465/C/Bra.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Bra.c	2022-01-01 15:08:47.865171447 +0800
@@ -0,0 +1,133 @@
+/* Bra.c -- Converters for RISC code
+2008-10-04 : Igor Pavlov : Public domain */
+
+#include "Bra.h"
+
+SizeT ARM_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  SizeT i;
+  if (size < 4)
+    return 0;
+  size -= 4;
+  ip += 8;
+  for (i = 0; i <= size; i += 4)
+  {
+    if (data[i + 3] == 0xEB)
+    {
+      UInt32 dest;
+      UInt32 src = ((UInt32)data[i + 2] << 16) | ((UInt32)data[i + 1] << 8) | (data[i + 0]);
+      src <<= 2;
+      if (encoding)
+        dest = ip + (UInt32)i + src;
+      else
+        dest = src - (ip + (UInt32)i);
+      dest >>= 2;
+      data[i + 2] = (Byte)(dest >> 16);
+      data[i + 1] = (Byte)(dest >> 8);
+      data[i + 0] = (Byte)dest;
+    }
+  }
+  return i;
+}
+
+SizeT ARMT_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  SizeT i;
+  if (size < 4)
+    return 0;
+  size -= 4;
+  ip += 4;
+  for (i = 0; i <= size; i += 2)
+  {
+    if ((data[i + 1] & 0xF8) == 0xF0 &&
+        (data[i + 3] & 0xF8) == 0xF8)
+    {
+      UInt32 dest;
+      UInt32 src =
+        (((UInt32)data[i + 1] & 0x7) << 19) |
+        ((UInt32)data[i + 0] << 11) |
+        (((UInt32)data[i + 3] & 0x7) << 8) |
+        (data[i + 2]);
+      
+      src <<= 1;
+      if (encoding)
+        dest = ip + (UInt32)i + src;
+      else
+        dest = src - (ip + (UInt32)i);
+      dest >>= 1;
+      
+      data[i + 1] = (Byte)(0xF0 | ((dest >> 19) & 0x7));
+      data[i + 0] = (Byte)(dest >> 11);
+      data[i + 3] = (Byte)(0xF8 | ((dest >> 8) & 0x7));
+      data[i + 2] = (Byte)dest;
+      i += 2;
+    }
+  }
+  return i;
+}
+
+SizeT PPC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  SizeT i;
+  if (size < 4)
+    return 0;
+  size -= 4;
+  for (i = 0; i <= size; i += 4)
+  {
+    if ((data[i] >> 2) == 0x12 && (data[i + 3] & 3) == 1)
+    {
+      UInt32 src = ((UInt32)(data[i + 0] & 3) << 24) |
+        ((UInt32)data[i + 1] << 16) |
+        ((UInt32)data[i + 2] << 8) |
+        ((UInt32)data[i + 3] & (~3));
+      
+      UInt32 dest;
+      if (encoding)
+        dest = ip + (UInt32)i + src;
+      else
+        dest = src - (ip + (UInt32)i);
+      data[i + 0] = (Byte)(0x48 | ((dest >> 24) &  0x3));
+      data[i + 1] = (Byte)(dest >> 16);
+      data[i + 2] = (Byte)(dest >> 8);
+      data[i + 3] &= 0x3;
+      data[i + 3] |= dest;
+    }
+  }
+  return i;
+}
+
+SizeT SPARC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  UInt32 i;
+  if (size < 4)
+    return 0;
+  size -= 4;
+  for (i = 0; i <= size; i += 4)
+  {
+    if (data[i] == 0x40 && (data[i + 1] & 0xC0) == 0x00 ||
+        data[i] == 0x7F && (data[i + 1] & 0xC0) == 0xC0)
+    {
+      UInt32 src =
+        ((UInt32)data[i + 0] << 24) |
+        ((UInt32)data[i + 1] << 16) |
+        ((UInt32)data[i + 2] << 8) |
+        ((UInt32)data[i + 3]);
+      UInt32 dest;
+      
+      src <<= 2;
+      if (encoding)
+        dest = ip + i + src;
+      else
+        dest = src - (ip + i);
+      dest >>= 2;
+      
+      dest = (((0 - ((dest >> 22) & 1)) << 22) & 0x3FFFFFFF) | (dest & 0x3FFFFF) | 0x40000000;
+
+      data[i + 0] = (Byte)(dest >> 24);
+      data[i + 1] = (Byte)(dest >> 16);
+      data[i + 2] = (Byte)(dest >> 8);
+      data[i + 3] = (Byte)dest;
+    }
+  }
+  return i;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Bra.h squashfs-tools-patched/LZMA/lzma465/C/Bra.h
--- squashfs-tools/LZMA/lzma465/C/Bra.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Bra.h	2022-01-01 15:08:47.869171447 +0800
@@ -0,0 +1,60 @@
+/* Bra.h -- Branch converters for executables
+2008-10-04 : Igor Pavlov : Public domain */
+
+#ifndef __BRA_H
+#define __BRA_H
+
+#include "Types.h"
+
+/*
+These functions convert relative addresses to absolute addresses
+in CALL instructions to increase the compression ratio.
+  
+  In:
+    data     - data buffer
+    size     - size of data
+    ip       - current virtual Instruction Pinter (IP) value
+    state    - state variable for x86 converter
+    encoding - 0 (for decoding), 1 (for encoding)
+  
+  Out:
+    state    - state variable for x86 converter
+
+  Returns:
+    The number of processed bytes. If you call these functions with multiple calls,
+    you must start next call with first byte after block of processed bytes.
+  
+  Type   Endian  Alignment  LookAhead
+  
+  x86    little      1          4
+  ARMT   little      2          2
+  ARM    little      4          0
+  PPC     big        4          0
+  SPARC   big        4          0
+  IA64   little     16          0
+
+  size must be >= Alignment + LookAhead, if it's not last block.
+  If (size < Alignment + LookAhead), converter returns 0.
+
+  Example:
+
+    UInt32 ip = 0;
+    for ()
+    {
+      ; size must be >= Alignment + LookAhead, if it's not last block
+      SizeT processed = Convert(data, size, ip, 1);
+      data += processed;
+      size -= processed;
+      ip += processed;
+    }
+*/
+
+#define x86_Convert_Init(state) { state = 0; }
+SizeT x86_Convert(Byte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding);
+SizeT ARM_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+SizeT ARMT_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+SizeT PPC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+SizeT SPARC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+SizeT IA64_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/BraIA64.c squashfs-tools-patched/LZMA/lzma465/C/BraIA64.c
--- squashfs-tools/LZMA/lzma465/C/BraIA64.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/BraIA64.c	2022-01-01 15:08:47.869171447 +0800
@@ -0,0 +1,67 @@
+/* BraIA64.c -- Converter for IA-64 code
+2008-10-04 : Igor Pavlov : Public domain */
+
+#include "Bra.h"
+
+static const Byte kBranchTable[32] =
+{
+  0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,
+  4, 4, 6, 6, 0, 0, 7, 7,
+  4, 4, 0, 0, 4, 4, 0, 0
+};
+
+SizeT IA64_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
+{
+  SizeT i;
+  if (size < 16)
+    return 0;
+  size -= 16;
+  for (i = 0; i <= size; i += 16)
+  {
+    UInt32 instrTemplate = data[i] & 0x1F;
+    UInt32 mask = kBranchTable[instrTemplate];
+    UInt32 bitPos = 5;
+    int slot;
+    for (slot = 0; slot < 3; slot++, bitPos += 41)
+    {
+      UInt32 bytePos, bitRes;
+      UInt64 instruction, instNorm;
+      int j;
+      if (((mask >> slot) & 1) == 0)
+        continue;
+      bytePos = (bitPos >> 3);
+      bitRes = bitPos & 0x7;
+      instruction = 0;
+      for (j = 0; j < 6; j++)
+        instruction += (UInt64)data[i + j + bytePos] << (8 * j);
+
+      instNorm = instruction >> bitRes;
+      if (((instNorm >> 37) & 0xF) == 0x5 && ((instNorm >> 9) & 0x7) == 0)
+      {
+        UInt32 src = (UInt32)((instNorm >> 13) & 0xFFFFF);
+        UInt32 dest;
+        src |= ((UInt32)(instNorm >> 36) & 1) << 20;
+        
+        src <<= 4;
+        
+        if (encoding)
+          dest = ip + (UInt32)i + src;
+        else
+          dest = src - (ip + (UInt32)i);
+        
+        dest >>= 4;
+        
+        instNorm &= ~((UInt64)(0x8FFFFF) << 13);
+        instNorm |= ((UInt64)(dest & 0xFFFFF) << 13);
+        instNorm |= ((UInt64)(dest & 0x100000) << (36 - 20));
+        
+        instruction &= (1 << bitRes) - 1;
+        instruction |= (instNorm << bitRes);
+        for (j = 0; j < 6; j++)
+          data[i + j + bytePos] = (Byte)(instruction >> (8 * j));
+      }
+    }
+  }
+  return i;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/CpuArch.h squashfs-tools-patched/LZMA/lzma465/C/CpuArch.h
--- squashfs-tools/LZMA/lzma465/C/CpuArch.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/CpuArch.h	2022-01-01 15:08:47.869171447 +0800
@@ -0,0 +1,69 @@
+/* CpuArch.h
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#ifndef __CPUARCH_H
+#define __CPUARCH_H
+
+/*
+LITTLE_ENDIAN_UNALIGN means:
+  1) CPU is LITTLE_ENDIAN
+  2) it's allowed to make unaligned memory accesses
+if LITTLE_ENDIAN_UNALIGN is not defined, it means that we don't know
+about these properties of platform.
+*/
+
+#if defined(_M_IX86) || defined(_M_X64) || defined(_M_AMD64) || defined(__i386__) || defined(__x86_64__)
+#define LITTLE_ENDIAN_UNALIGN
+#endif
+
+#ifdef LITTLE_ENDIAN_UNALIGN
+
+#define GetUi16(p) (*(const UInt16 *)(p))
+#define GetUi32(p) (*(const UInt32 *)(p))
+#define GetUi64(p) (*(const UInt64 *)(p))
+#define SetUi32(p, d) *(UInt32 *)(p) = (d);
+
+#else
+
+#define GetUi16(p) (((const Byte *)(p))[0] | ((UInt16)((const Byte *)(p))[1] << 8))
+
+#define GetUi32(p) ( \
+             ((const Byte *)(p))[0]        | \
+    ((UInt32)((const Byte *)(p))[1] <<  8) | \
+    ((UInt32)((const Byte *)(p))[2] << 16) | \
+    ((UInt32)((const Byte *)(p))[3] << 24))
+
+#define GetUi64(p) (GetUi32(p) | ((UInt64)GetUi32(((const Byte *)(p)) + 4) << 32))
+
+#define SetUi32(p, d) { UInt32 _x_ = (d); \
+    ((Byte *)(p))[0] = (Byte)_x_; \
+    ((Byte *)(p))[1] = (Byte)(_x_ >> 8); \
+    ((Byte *)(p))[2] = (Byte)(_x_ >> 16); \
+    ((Byte *)(p))[3] = (Byte)(_x_ >> 24); }
+
+#endif
+
+#if defined(LITTLE_ENDIAN_UNALIGN) && defined(_WIN64) && (_MSC_VER >= 1300)
+
+#pragma intrinsic(_byteswap_ulong)
+#pragma intrinsic(_byteswap_uint64)
+#define GetBe32(p) _byteswap_ulong(*(const UInt32 *)(const Byte *)(p))
+#define GetBe64(p) _byteswap_uint64(*(const UInt64 *)(const Byte *)(p))
+
+#else
+
+#define GetBe32(p) ( \
+    ((UInt32)((const Byte *)(p))[0] << 24) | \
+    ((UInt32)((const Byte *)(p))[1] << 16) | \
+    ((UInt32)((const Byte *)(p))[2] <<  8) | \
+             ((const Byte *)(p))[3] )
+
+#define GetBe64(p) (((UInt64)GetBe32(p) << 32) | GetBe32(((const Byte *)(p)) + 4))
+
+#endif
+
+#define GetBe16(p) (((UInt16)((const Byte *)(p))[0] << 8) | ((const Byte *)(p))[1])
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzFind.c squashfs-tools-patched/LZMA/lzma465/C/LzFind.c
--- squashfs-tools/LZMA/lzma465/C/LzFind.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzFind.c	2022-01-01 15:08:47.869171447 +0800
@@ -0,0 +1,751 @@
+/* LzFind.c -- Match finder for LZ algorithms
+2008-10-04 : Igor Pavlov : Public domain */
+
+#include <string.h>
+
+#include "LzFind.h"
+#include "LzHash.h"
+
+#define kEmptyHashValue 0
+#define kMaxValForNormalize ((UInt32)0xFFFFFFFF)
+#define kNormalizeStepMin (1 << 10) /* it must be power of 2 */
+#define kNormalizeMask (~(kNormalizeStepMin - 1))
+#define kMaxHistorySize ((UInt32)3 << 30)
+
+#define kStartMaxLen 3
+
+static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
+{
+  if (!p->directInput)
+  {
+    alloc->Free(alloc, p->bufferBase);
+    p->bufferBase = 0;
+  }
+}
+
+/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be < 4G) */
+
+static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
+{
+  UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
+  if (p->directInput)
+  {
+    p->blockSize = blockSize;
+    return 1;
+  }
+  if (p->bufferBase == 0 || p->blockSize != blockSize)
+  {
+    LzInWindow_Free(p, alloc);
+    p->blockSize = blockSize;
+    p->bufferBase = (Byte *)alloc->Alloc(alloc, (size_t)blockSize);
+  }
+  return (p->bufferBase != 0);
+}
+
+Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
+Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
+
+UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
+
+void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
+{
+  p->posLimit -= subValue;
+  p->pos -= subValue;
+  p->streamPos -= subValue;
+}
+
+static void MatchFinder_ReadBlock(CMatchFinder *p)
+{
+  if (p->streamEndWasReached || p->result != SZ_OK)
+    return;
+  for (;;)
+  {
+    Byte *dest = p->buffer + (p->streamPos - p->pos);
+    size_t size = (p->bufferBase + p->blockSize - dest);
+    if (size == 0)
+      return;
+    p->result = p->stream->Read(p->stream, dest, &size);
+    if (p->result != SZ_OK)
+      return;
+    if (size == 0)
+    {
+      p->streamEndWasReached = 1;
+      return;
+    }
+    p->streamPos += (UInt32)size;
+    if (p->streamPos - p->pos > p->keepSizeAfter)
+      return;
+  }
+}
+
+void MatchFinder_MoveBlock(CMatchFinder *p)
+{
+  memmove(p->bufferBase,
+    p->buffer - p->keepSizeBefore,
+    (size_t)(p->streamPos - p->pos + p->keepSizeBefore));
+  p->buffer = p->bufferBase + p->keepSizeBefore;
+}
+
+int MatchFinder_NeedMove(CMatchFinder *p)
+{
+  /* if (p->streamEndWasReached) return 0; */
+  return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
+}
+
+void MatchFinder_ReadIfRequired(CMatchFinder *p)
+{
+  if (p->streamEndWasReached)
+    return;
+  if (p->keepSizeAfter >= p->streamPos - p->pos)
+    MatchFinder_ReadBlock(p);
+}
+
+static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
+{
+  if (MatchFinder_NeedMove(p))
+    MatchFinder_MoveBlock(p);
+  MatchFinder_ReadBlock(p);
+}
+
+static void MatchFinder_SetDefaultSettings(CMatchFinder *p)
+{
+  p->cutValue = 32;
+  p->btMode = 1;
+  p->numHashBytes = 4;
+  /* p->skipModeBits = 0; */
+  p->directInput = 0;
+  p->bigHash = 0;
+}
+
+#define kCrcPoly 0xEDB88320
+
+void MatchFinder_Construct(CMatchFinder *p)
+{
+  UInt32 i;
+  p->bufferBase = 0;
+  p->directInput = 0;
+  p->hash = 0;
+  MatchFinder_SetDefaultSettings(p);
+
+  for (i = 0; i < 256; i++)
+  {
+    UInt32 r = i;
+    int j;
+    for (j = 0; j < 8; j++)
+      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
+    p->crc[i] = r;
+  }
+}
+
+static void MatchFinder_FreeThisClassMemory(CMatchFinder *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->hash);
+  p->hash = 0;
+}
+
+void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc)
+{
+  MatchFinder_FreeThisClassMemory(p, alloc);
+  LzInWindow_Free(p, alloc);
+}
+
+static CLzRef* AllocRefs(UInt32 num, ISzAlloc *alloc)
+{
+  size_t sizeInBytes = (size_t)num * sizeof(CLzRef);
+  if (sizeInBytes / sizeof(CLzRef) != num)
+    return 0;
+  return (CLzRef *)alloc->Alloc(alloc, sizeInBytes);
+}
+
+int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
+    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
+    ISzAlloc *alloc)
+{
+  UInt32 sizeReserv;
+  if (historySize > kMaxHistorySize)
+  {
+    MatchFinder_Free(p, alloc);
+    return 0;
+  }
+  sizeReserv = historySize >> 1;
+  if (historySize > ((UInt32)2 << 30))
+    sizeReserv = historySize >> 2;
+  sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 << 19);
+
+  p->keepSizeBefore = historySize + keepAddBufferBefore + 1;
+  p->keepSizeAfter = matchMaxLen + keepAddBufferAfter;
+  /* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */
+  if (LzInWindow_Create(p, sizeReserv, alloc))
+  {
+    UInt32 newCyclicBufferSize = (historySize /* >> p->skipModeBits */) + 1;
+    UInt32 hs;
+    p->matchMaxLen = matchMaxLen;
+    {
+      p->fixedHashSize = 0;
+      if (p->numHashBytes == 2)
+        hs = (1 << 16) - 1;
+      else
+      {
+        hs = historySize - 1;
+        hs |= (hs >> 1);
+        hs |= (hs >> 2);
+        hs |= (hs >> 4);
+        hs |= (hs >> 8);
+        hs >>= 1;
+        /* hs >>= p->skipModeBits; */
+        hs |= 0xFFFF; /* don't change it! It's required for Deflate */
+        if (hs > (1 << 24))
+        {
+          if (p->numHashBytes == 3)
+            hs = (1 << 24) - 1;
+          else
+            hs >>= 1;
+        }
+      }
+      p->hashMask = hs;
+      hs++;
+      if (p->numHashBytes > 2) p->fixedHashSize += kHash2Size;
+      if (p->numHashBytes > 3) p->fixedHashSize += kHash3Size;
+      if (p->numHashBytes > 4) p->fixedHashSize += kHash4Size;
+      hs += p->fixedHashSize;
+    }
+
+    {
+      UInt32 prevSize = p->hashSizeSum + p->numSons;
+      UInt32 newSize;
+      p->historySize = historySize;
+      p->hashSizeSum = hs;
+      p->cyclicBufferSize = newCyclicBufferSize;
+      p->numSons = (p->btMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);
+      newSize = p->hashSizeSum + p->numSons;
+      if (p->hash != 0 && prevSize == newSize)
+        return 1;
+      MatchFinder_FreeThisClassMemory(p, alloc);
+      p->hash = AllocRefs(newSize, alloc);
+      if (p->hash != 0)
+      {
+        p->son = p->hash + p->hashSizeSum;
+        return 1;
+      }
+    }
+  }
+  MatchFinder_Free(p, alloc);
+  return 0;
+}
+
+static void MatchFinder_SetLimits(CMatchFinder *p)
+{
+  UInt32 limit = kMaxValForNormalize - p->pos;
+  UInt32 limit2 = p->cyclicBufferSize - p->cyclicBufferPos;
+  if (limit2 < limit)
+    limit = limit2;
+  limit2 = p->streamPos - p->pos;
+  if (limit2 <= p->keepSizeAfter)
+  {
+    if (limit2 > 0)
+      limit2 = 1;
+  }
+  else
+    limit2 -= p->keepSizeAfter;
+  if (limit2 < limit)
+    limit = limit2;
+  {
+    UInt32 lenLimit = p->streamPos - p->pos;
+    if (lenLimit > p->matchMaxLen)
+      lenLimit = p->matchMaxLen;
+    p->lenLimit = lenLimit;
+  }
+  p->posLimit = p->pos + limit;
+}
+
+void MatchFinder_Init(CMatchFinder *p)
+{
+  UInt32 i;
+  for (i = 0; i < p->hashSizeSum; i++)
+    p->hash[i] = kEmptyHashValue;
+  p->cyclicBufferPos = 0;
+  p->buffer = p->bufferBase;
+  p->pos = p->streamPos = p->cyclicBufferSize;
+  p->result = SZ_OK;
+  p->streamEndWasReached = 0;
+  MatchFinder_ReadBlock(p);
+  MatchFinder_SetLimits(p);
+}
+
+static UInt32 MatchFinder_GetSubValue(CMatchFinder *p)
+{
+  return (p->pos - p->historySize - 1) & kNormalizeMask;
+}
+
+void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
+{
+  UInt32 i;
+  for (i = 0; i < numItems; i++)
+  {
+    UInt32 value = items[i];
+    if (value <= subValue)
+      value = kEmptyHashValue;
+    else
+      value -= subValue;
+    items[i] = value;
+  }
+}
+
+static void MatchFinder_Normalize(CMatchFinder *p)
+{
+  UInt32 subValue = MatchFinder_GetSubValue(p);
+  MatchFinder_Normalize3(subValue, p->hash, p->hashSizeSum + p->numSons);
+  MatchFinder_ReduceOffsets(p, subValue);
+}
+
+static void MatchFinder_CheckLimits(CMatchFinder *p)
+{
+  if (p->pos == kMaxValForNormalize)
+    MatchFinder_Normalize(p);
+  if (!p->streamEndWasReached && p->keepSizeAfter == p->streamPos - p->pos)
+    MatchFinder_CheckAndMoveAndRead(p);
+  if (p->cyclicBufferPos == p->cyclicBufferSize)
+    p->cyclicBufferPos = 0;
+  MatchFinder_SetLimits(p);
+}
+
+static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
+    UInt32 *distances, UInt32 maxLen)
+{
+  son[_cyclicBufferPos] = curMatch;
+  for (;;)
+  {
+    UInt32 delta = pos - curMatch;
+    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
+      return distances;
+    {
+      const Byte *pb = cur - delta;
+      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
+      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
+      {
+        UInt32 len = 0;
+        while (++len != lenLimit)
+          if (pb[len] != cur[len])
+            break;
+        if (maxLen < len)
+        {
+          *distances++ = maxLen = len;
+          *distances++ = delta - 1;
+          if (len == lenLimit)
+            return distances;
+        }
+      }
+    }
+  }
+}
+
+UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
+    UInt32 *distances, UInt32 maxLen)
+{
+  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
+  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
+  UInt32 len0 = 0, len1 = 0;
+  for (;;)
+  {
+    UInt32 delta = pos - curMatch;
+    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
+    {
+      *ptr0 = *ptr1 = kEmptyHashValue;
+      return distances;
+    }
+    {
+      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
+      const Byte *pb = cur - delta;
+      UInt32 len = (len0 < len1 ? len0 : len1);
+      if (pb[len] == cur[len])
+      {
+        if (++len != lenLimit && pb[len] == cur[len])
+          while (++len != lenLimit)
+            if (pb[len] != cur[len])
+              break;
+        if (maxLen < len)
+        {
+          *distances++ = maxLen = len;
+          *distances++ = delta - 1;
+          if (len == lenLimit)
+          {
+            *ptr1 = pair[0];
+            *ptr0 = pair[1];
+            return distances;
+          }
+        }
+      }
+      if (pb[len] < cur[len])
+      {
+        *ptr1 = curMatch;
+        ptr1 = pair + 1;
+        curMatch = *ptr1;
+        len1 = len;
+      }
+      else
+      {
+        *ptr0 = curMatch;
+        ptr0 = pair;
+        curMatch = *ptr0;
+        len0 = len;
+      }
+    }
+  }
+}
+
+static void SkipMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue)
+{
+  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
+  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
+  UInt32 len0 = 0, len1 = 0;
+  for (;;)
+  {
+    UInt32 delta = pos - curMatch;
+    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
+    {
+      *ptr0 = *ptr1 = kEmptyHashValue;
+      return;
+    }
+    {
+      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
+      const Byte *pb = cur - delta;
+      UInt32 len = (len0 < len1 ? len0 : len1);
+      if (pb[len] == cur[len])
+      {
+        while (++len != lenLimit)
+          if (pb[len] != cur[len])
+            break;
+        {
+          if (len == lenLimit)
+          {
+            *ptr1 = pair[0];
+            *ptr0 = pair[1];
+            return;
+          }
+        }
+      }
+      if (pb[len] < cur[len])
+      {
+        *ptr1 = curMatch;
+        ptr1 = pair + 1;
+        curMatch = *ptr1;
+        len1 = len;
+      }
+      else
+      {
+        *ptr0 = curMatch;
+        ptr0 = pair;
+        curMatch = *ptr0;
+        len0 = len;
+      }
+    }
+  }
+}
+
+#define MOVE_POS \
+  ++p->cyclicBufferPos; \
+  p->buffer++; \
+  if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);
+
+#define MOVE_POS_RET MOVE_POS return offset;
+
+static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
+
+#define GET_MATCHES_HEADER2(minLen, ret_op) \
+  UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
+  lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
+  cur = p->buffer;
+
+#define GET_MATCHES_HEADER(minLen) GET_MATCHES_HEADER2(minLen, return 0)
+#define SKIP_HEADER(minLen)        GET_MATCHES_HEADER2(minLen, continue)
+
+#define MF_PARAMS(p) p->pos, p->buffer, p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue
+
+#define GET_MATCHES_FOOTER(offset, maxLen) \
+  offset = (UInt32)(GetMatchesSpec1(lenLimit, curMatch, MF_PARAMS(p), \
+  distances + offset, maxLen) - distances); MOVE_POS_RET;
+
+#define SKIP_FOOTER \
+  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
+
+static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 offset;
+  GET_MATCHES_HEADER(2)
+  HASH2_CALC;
+  curMatch = p->hash[hashValue];
+  p->hash[hashValue] = p->pos;
+  offset = 0;
+  GET_MATCHES_FOOTER(offset, 1)
+}
+
+UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 offset;
+  GET_MATCHES_HEADER(3)
+  HASH_ZIP_CALC;
+  curMatch = p->hash[hashValue];
+  p->hash[hashValue] = p->pos;
+  offset = 0;
+  GET_MATCHES_FOOTER(offset, 2)
+}
+
+static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 hash2Value, delta2, maxLen, offset;
+  GET_MATCHES_HEADER(3)
+
+  HASH3_CALC;
+
+  delta2 = p->pos - p->hash[hash2Value];
+  curMatch = p->hash[kFix3HashSize + hashValue];
+  
+  p->hash[hash2Value] =
+  p->hash[kFix3HashSize + hashValue] = p->pos;
+
+
+  maxLen = 2;
+  offset = 0;
+  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
+  {
+    for (; maxLen != lenLimit; maxLen++)
+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
+        break;
+    distances[0] = maxLen;
+    distances[1] = delta2 - 1;
+    offset = 2;
+    if (maxLen == lenLimit)
+    {
+      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
+      MOVE_POS_RET;
+    }
+  }
+  GET_MATCHES_FOOTER(offset, maxLen)
+}
+
+static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
+  GET_MATCHES_HEADER(4)
+
+  HASH4_CALC;
+
+  delta2 = p->pos - p->hash[                hash2Value];
+  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
+  curMatch = p->hash[kFix4HashSize + hashValue];
+  
+  p->hash[                hash2Value] =
+  p->hash[kFix3HashSize + hash3Value] =
+  p->hash[kFix4HashSize + hashValue] = p->pos;
+
+  maxLen = 1;
+  offset = 0;
+  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
+  {
+    distances[0] = maxLen = 2;
+    distances[1] = delta2 - 1;
+    offset = 2;
+  }
+  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
+  {
+    maxLen = 3;
+    distances[offset + 1] = delta3 - 1;
+    offset += 2;
+    delta2 = delta3;
+  }
+  if (offset != 0)
+  {
+    for (; maxLen != lenLimit; maxLen++)
+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
+        break;
+    distances[offset - 2] = maxLen;
+    if (maxLen == lenLimit)
+    {
+      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
+      MOVE_POS_RET;
+    }
+  }
+  if (maxLen < 3)
+    maxLen = 3;
+  GET_MATCHES_FOOTER(offset, maxLen)
+}
+
+static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
+  GET_MATCHES_HEADER(4)
+
+  HASH4_CALC;
+
+  delta2 = p->pos - p->hash[                hash2Value];
+  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
+  curMatch = p->hash[kFix4HashSize + hashValue];
+
+  p->hash[                hash2Value] =
+  p->hash[kFix3HashSize + hash3Value] =
+  p->hash[kFix4HashSize + hashValue] = p->pos;
+
+  maxLen = 1;
+  offset = 0;
+  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
+  {
+    distances[0] = maxLen = 2;
+    distances[1] = delta2 - 1;
+    offset = 2;
+  }
+  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
+  {
+    maxLen = 3;
+    distances[offset + 1] = delta3 - 1;
+    offset += 2;
+    delta2 = delta3;
+  }
+  if (offset != 0)
+  {
+    for (; maxLen != lenLimit; maxLen++)
+      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
+        break;
+    distances[offset - 2] = maxLen;
+    if (maxLen == lenLimit)
+    {
+      p->son[p->cyclicBufferPos] = curMatch;
+      MOVE_POS_RET;
+    }
+  }
+  if (maxLen < 3)
+    maxLen = 3;
+  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
+    distances + offset, maxLen) - (distances));
+  MOVE_POS_RET
+}
+
+UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+{
+  UInt32 offset;
+  GET_MATCHES_HEADER(3)
+  HASH_ZIP_CALC;
+  curMatch = p->hash[hashValue];
+  p->hash[hashValue] = p->pos;
+  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
+    distances, 2) - (distances));
+  MOVE_POS_RET
+}
+
+static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    SKIP_HEADER(2)
+    HASH2_CALC;
+    curMatch = p->hash[hashValue];
+    p->hash[hashValue] = p->pos;
+    SKIP_FOOTER
+  }
+  while (--num != 0);
+}
+
+void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    SKIP_HEADER(3)
+    HASH_ZIP_CALC;
+    curMatch = p->hash[hashValue];
+    p->hash[hashValue] = p->pos;
+    SKIP_FOOTER
+  }
+  while (--num != 0);
+}
+
+static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    UInt32 hash2Value;
+    SKIP_HEADER(3)
+    HASH3_CALC;
+    curMatch = p->hash[kFix3HashSize + hashValue];
+    p->hash[hash2Value] =
+    p->hash[kFix3HashSize + hashValue] = p->pos;
+    SKIP_FOOTER
+  }
+  while (--num != 0);
+}
+
+static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    UInt32 hash2Value, hash3Value;
+    SKIP_HEADER(4)
+    HASH4_CALC;
+    curMatch = p->hash[kFix4HashSize + hashValue];
+    p->hash[                hash2Value] =
+    p->hash[kFix3HashSize + hash3Value] = p->pos;
+    p->hash[kFix4HashSize + hashValue] = p->pos;
+    SKIP_FOOTER
+  }
+  while (--num != 0);
+}
+
+static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    UInt32 hash2Value, hash3Value;
+    SKIP_HEADER(4)
+    HASH4_CALC;
+    curMatch = p->hash[kFix4HashSize + hashValue];
+    p->hash[                hash2Value] =
+    p->hash[kFix3HashSize + hash3Value] =
+    p->hash[kFix4HashSize + hashValue] = p->pos;
+    p->son[p->cyclicBufferPos] = curMatch;
+    MOVE_POS
+  }
+  while (--num != 0);
+}
+
+void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+{
+  do
+  {
+    SKIP_HEADER(3)
+    HASH_ZIP_CALC;
+    curMatch = p->hash[hashValue];
+    p->hash[hashValue] = p->pos;
+    p->son[p->cyclicBufferPos] = curMatch;
+    MOVE_POS
+  }
+  while (--num != 0);
+}
+
+void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
+{
+  vTable->Init = (Mf_Init_Func)MatchFinder_Init;
+  vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
+  vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
+  vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
+  if (!p->btMode)
+  {
+    vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
+    vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
+  }
+  else if (p->numHashBytes == 2)
+  {
+    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
+    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
+  }
+  else if (p->numHashBytes == 3)
+  {
+    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
+    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
+  }
+  else
+  {
+    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
+    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
+  }
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzFind.h squashfs-tools-patched/LZMA/lzma465/C/LzFind.h
--- squashfs-tools/LZMA/lzma465/C/LzFind.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzFind.h	2022-01-01 15:08:47.869171447 +0800
@@ -0,0 +1,107 @@
+/* LzFind.h -- Match finder for LZ algorithms
+2008-10-04 : Igor Pavlov : Public domain */
+
+#ifndef __LZFIND_H
+#define __LZFIND_H
+
+#include "Types.h"
+
+typedef UInt32 CLzRef;
+
+typedef struct _CMatchFinder
+{
+  Byte *buffer;
+  UInt32 pos;
+  UInt32 posLimit;
+  UInt32 streamPos;
+  UInt32 lenLimit;
+
+  UInt32 cyclicBufferPos;
+  UInt32 cyclicBufferSize; /* it must be = (historySize + 1) */
+
+  UInt32 matchMaxLen;
+  CLzRef *hash;
+  CLzRef *son;
+  UInt32 hashMask;
+  UInt32 cutValue;
+
+  Byte *bufferBase;
+  ISeqInStream *stream;
+  int streamEndWasReached;
+
+  UInt32 blockSize;
+  UInt32 keepSizeBefore;
+  UInt32 keepSizeAfter;
+
+  UInt32 numHashBytes;
+  int directInput;
+  int btMode;
+  /* int skipModeBits; */
+  int bigHash;
+  UInt32 historySize;
+  UInt32 fixedHashSize;
+  UInt32 hashSizeSum;
+  UInt32 numSons;
+  SRes result;
+  UInt32 crc[256];
+} CMatchFinder;
+
+#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)->buffer)
+#define Inline_MatchFinder_GetIndexByte(p, index) ((p)->buffer[(Int32)(index)])
+
+#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
+
+int MatchFinder_NeedMove(CMatchFinder *p);
+Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
+void MatchFinder_MoveBlock(CMatchFinder *p);
+void MatchFinder_ReadIfRequired(CMatchFinder *p);
+
+void MatchFinder_Construct(CMatchFinder *p);
+
+/* Conditions:
+     historySize <= 3 GB
+     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter < 511MB
+*/
+int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
+    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
+    ISzAlloc *alloc);
+void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
+void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
+void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
+
+UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
+    UInt32 *distances, UInt32 maxLen);
+
+/*
+Conditions:
+  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.
+  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function
+*/
+
+typedef void (*Mf_Init_Func)(void *object);
+typedef Byte (*Mf_GetIndexByte_Func)(void *object, Int32 index);
+typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *object);
+typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *object);
+typedef UInt32 (*Mf_GetMatches_Func)(void *object, UInt32 *distances);
+typedef void (*Mf_Skip_Func)(void *object, UInt32);
+
+typedef struct _IMatchFinder
+{
+  Mf_Init_Func Init;
+  Mf_GetIndexByte_Func GetIndexByte;
+  Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
+  Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
+  Mf_GetMatches_Func GetMatches;
+  Mf_Skip_Func Skip;
+} IMatchFinder;
+
+void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
+
+void MatchFinder_Init(CMatchFinder *p);
+UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
+UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
+void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
+void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzFindMt.c squashfs-tools-patched/LZMA/lzma465/C/LzFindMt.c
--- squashfs-tools/LZMA/lzma465/C/LzFindMt.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzFindMt.c	2022-01-01 15:08:47.869171447 +0800
@@ -0,0 +1,793 @@
+/* LzFindMt.c -- multithreaded Match finder for LZ algorithms
+2008-10-04 : Igor Pavlov : Public domain */
+
+#include "LzHash.h"
+
+#include "LzFindMt.h"
+
+void MtSync_Construct(CMtSync *p)
+{
+  p->wasCreated = False;
+  p->csWasInitialized = False;
+  p->csWasEntered = False;
+  Thread_Construct(&p->thread);
+  Event_Construct(&p->canStart);
+  Event_Construct(&p->wasStarted);
+  Event_Construct(&p->wasStopped);
+  Semaphore_Construct(&p->freeSemaphore);
+  Semaphore_Construct(&p->filledSemaphore);
+}
+
+void MtSync_GetNextBlock(CMtSync *p)
+{
+  if (p->needStart)
+  {
+    p->numProcessedBlocks = 1;
+    p->needStart = False;
+    p->stopWriting = False;
+    p->exit = False;
+    Event_Reset(&p->wasStarted);
+    Event_Reset(&p->wasStopped);
+
+    Event_Set(&p->canStart);
+    Event_Wait(&p->wasStarted);
+  }
+  else
+  {
+    CriticalSection_Leave(&p->cs);
+    p->csWasEntered = False;
+    p->numProcessedBlocks++;
+    Semaphore_Release1(&p->freeSemaphore);
+  }
+  Semaphore_Wait(&p->filledSemaphore);
+  CriticalSection_Enter(&p->cs);
+  p->csWasEntered = True;
+}
+
+/* MtSync_StopWriting must be called if Writing was started */
+
+void MtSync_StopWriting(CMtSync *p)
+{
+  UInt32 myNumBlocks = p->numProcessedBlocks;
+  if (!Thread_WasCreated(&p->thread) || p->needStart)
+    return;
+  p->stopWriting = True;
+  if (p->csWasEntered)
+  {
+    CriticalSection_Leave(&p->cs);
+    p->csWasEntered = False;
+  }
+  Semaphore_Release1(&p->freeSemaphore);
+ 
+  Event_Wait(&p->wasStopped);
+
+  while (myNumBlocks++ != p->numProcessedBlocks)
+  {
+    Semaphore_Wait(&p->filledSemaphore);
+    Semaphore_Release1(&p->freeSemaphore);
+  }
+  p->needStart = True;
+}
+
+void MtSync_Destruct(CMtSync *p)
+{
+  if (Thread_WasCreated(&p->thread))
+  {
+    MtSync_StopWriting(p);
+    p->exit = True;
+    if (p->needStart)
+      Event_Set(&p->canStart);
+    Thread_Wait(&p->thread);
+    Thread_Close(&p->thread);
+  }
+  if (p->csWasInitialized)
+  {
+    CriticalSection_Delete(&p->cs);
+    p->csWasInitialized = False;
+  }
+
+  Event_Close(&p->canStart);
+  Event_Close(&p->wasStarted);
+  Event_Close(&p->wasStopped);
+  Semaphore_Close(&p->freeSemaphore);
+  Semaphore_Close(&p->filledSemaphore);
+
+  p->wasCreated = False;
+}
+
+#define RINOK_THREAD(x) { if ((x) != 0) return SZ_ERROR_THREAD; }
+
+static SRes MtSync_Create2(CMtSync *p, unsigned (MY_STD_CALL *startAddress)(void *), void *obj, UInt32 numBlocks)
+{
+  if (p->wasCreated)
+    return SZ_OK;
+
+  RINOK_THREAD(CriticalSection_Init(&p->cs));
+  p->csWasInitialized = True;
+
+  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&p->canStart));
+  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&p->wasStarted));
+  RINOK_THREAD(AutoResetEvent_CreateNotSignaled(&p->wasStopped));
+  
+  RINOK_THREAD(Semaphore_Create(&p->freeSemaphore, numBlocks, numBlocks));
+  RINOK_THREAD(Semaphore_Create(&p->filledSemaphore, 0, numBlocks));
+
+  p->needStart = True;
+  
+  RINOK_THREAD(Thread_Create(&p->thread, startAddress, obj));
+  p->wasCreated = True;
+  return SZ_OK;
+}
+
+static SRes MtSync_Create(CMtSync *p, unsigned (MY_STD_CALL *startAddress)(void *), void *obj, UInt32 numBlocks)
+{
+  SRes res = MtSync_Create2(p, startAddress, obj, numBlocks);
+  if (res != SZ_OK)
+    MtSync_Destruct(p);
+  return res;
+}
+
+void MtSync_Init(CMtSync *p) { p->needStart = True; }
+
+#define kMtMaxValForNormalize 0xFFFFFFFF
+
+#define DEF_GetHeads2(name, v, action) \
+static void GetHeads ## name(const Byte *p, UInt32 pos, \
+UInt32 *hash, UInt32 hashMask, UInt32 *heads, UInt32 numHeads, const UInt32 *crc) \
+{ action; for (; numHeads != 0; numHeads--) { \
+const UInt32 value = (v); p++; *heads++ = pos - hash[value]; hash[value] = pos++;  } }
+
+#define DEF_GetHeads(name, v) DEF_GetHeads2(name, v, ;)
+
+DEF_GetHeads2(2,  (p[0] | ((UInt32)p[1] << 8)), hashMask = hashMask; crc = crc; )
+DEF_GetHeads(3,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] << 8)) & hashMask)
+DEF_GetHeads(4,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] << 8) ^ (crc[p[3]] << 5)) & hashMask)
+DEF_GetHeads(4b, (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] << 8) ^ ((UInt32)p[3] << 16)) & hashMask)
+DEF_GetHeads(5,  (crc[p[0]] ^ p[1] ^ ((UInt32)p[2] << 8) ^ (crc[p[3]] << 5) ^ (crc[p[4]] << 3)) & hashMask)
+
+void HashThreadFunc(CMatchFinderMt *mt)
+{
+  CMtSync *p = &mt->hashSync;
+  for (;;)
+  {
+    UInt32 numProcessedBlocks = 0;
+    Event_Wait(&p->canStart);
+    Event_Set(&p->wasStarted);
+    for (;;)
+    {
+      if (p->exit)
+        return;
+      if (p->stopWriting)
+      {
+        p->numProcessedBlocks = numProcessedBlocks;
+        Event_Set(&p->wasStopped);
+        break;
+      }
+
+      {
+        CMatchFinder *mf = mt->MatchFinder;
+        if (MatchFinder_NeedMove(mf))
+        {
+          CriticalSection_Enter(&mt->btSync.cs);
+          CriticalSection_Enter(&mt->hashSync.cs);
+          {
+            const Byte *beforePtr = MatchFinder_GetPointerToCurrentPos(mf);
+            const Byte *afterPtr;
+            MatchFinder_MoveBlock(mf);
+            afterPtr = MatchFinder_GetPointerToCurrentPos(mf);
+            mt->pointerToCurPos -= beforePtr - afterPtr;
+            mt->buffer -= beforePtr - afterPtr;
+          }
+          CriticalSection_Leave(&mt->btSync.cs);
+          CriticalSection_Leave(&mt->hashSync.cs);
+          continue;
+        }
+
+        Semaphore_Wait(&p->freeSemaphore);
+
+        MatchFinder_ReadIfRequired(mf);
+        if (mf->pos > (kMtMaxValForNormalize - kMtHashBlockSize))
+        {
+          UInt32 subValue = (mf->pos - mf->historySize - 1);
+          MatchFinder_ReduceOffsets(mf, subValue);
+          MatchFinder_Normalize3(subValue, mf->hash + mf->fixedHashSize, mf->hashMask + 1);
+        }
+        {
+          UInt32 *heads = mt->hashBuf + ((numProcessedBlocks++) & kMtHashNumBlocksMask) * kMtHashBlockSize;
+          UInt32 num = mf->streamPos - mf->pos;
+          heads[0] = 2;
+          heads[1] = num;
+          if (num >= mf->numHashBytes)
+          {
+            num = num - mf->numHashBytes + 1;
+            if (num > kMtHashBlockSize - 2)
+              num = kMtHashBlockSize - 2;
+            mt->GetHeadsFunc(mf->buffer, mf->pos, mf->hash + mf->fixedHashSize, mf->hashMask, heads + 2, num, mf->crc);
+            heads[0] += num;
+          }
+          mf->pos += num;
+          mf->buffer += num;
+        }
+      }
+
+      Semaphore_Release1(&p->filledSemaphore);
+    }
+  }
+}
+
+void MatchFinderMt_GetNextBlock_Hash(CMatchFinderMt *p)
+{
+  MtSync_GetNextBlock(&p->hashSync);
+  p->hashBufPosLimit = p->hashBufPos = ((p->hashSync.numProcessedBlocks - 1) & kMtHashNumBlocksMask) * kMtHashBlockSize;
+  p->hashBufPosLimit += p->hashBuf[p->hashBufPos++];
+  p->hashNumAvail = p->hashBuf[p->hashBufPos++];
+}
+
+#define kEmptyHashValue 0
+
+/* #define MFMT_GM_INLINE */
+
+#ifdef MFMT_GM_INLINE
+
+#define NO_INLINE MY_FAST_CALL
+
+Int32 NO_INLINE GetMatchesSpecN(UInt32 lenLimit, UInt32 pos, const Byte *cur, CLzRef *son,
+    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
+    UInt32 *_distances, UInt32 _maxLen, const UInt32 *hash, Int32 limit, UInt32 size, UInt32 *posRes)
+{
+  do
+  {
+  UInt32 *distances = _distances + 1;
+  UInt32 curMatch = pos - *hash++;
+
+  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
+  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
+  UInt32 len0 = 0, len1 = 0;
+  UInt32 cutValue = _cutValue;
+  UInt32 maxLen = _maxLen;
+  for (;;)
+  {
+    UInt32 delta = pos - curMatch;
+    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
+    {
+      *ptr0 = *ptr1 = kEmptyHashValue;
+      break;
+    }
+    {
+      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
+      const Byte *pb = cur - delta;
+      UInt32 len = (len0 < len1 ? len0 : len1);
+      if (pb[len] == cur[len])
+      {
+        if (++len != lenLimit && pb[len] == cur[len])
+          while (++len != lenLimit)
+            if (pb[len] != cur[len])
+              break;
+        if (maxLen < len)
+        {
+          *distances++ = maxLen = len;
+          *distances++ = delta - 1;
+          if (len == lenLimit)
+          {
+            *ptr1 = pair[0];
+            *ptr0 = pair[1];
+            break;
+          }
+        }
+      }
+      if (pb[len] < cur[len])
+      {
+        *ptr1 = curMatch;
+        ptr1 = pair + 1;
+        curMatch = *ptr1;
+        len1 = len;
+      }
+      else
+      {
+        *ptr0 = curMatch;
+        ptr0 = pair;
+        curMatch = *ptr0;
+        len0 = len;
+      }
+    }
+  }
+  pos++;
+  _cyclicBufferPos++;
+  cur++;
+  {
+    UInt32 num = (UInt32)(distances - _distances);
+    *_distances = num - 1;
+    _distances += num;
+    limit -= num;
+  }
+  }
+  while (limit > 0 && --size != 0);
+  *posRes = pos;
+  return limit;
+}
+
+#endif
+
+void BtGetMatches(CMatchFinderMt *p, UInt32 *distances)
+{
+  UInt32 numProcessed = 0;
+  UInt32 curPos = 2;
+  UInt32 limit = kMtBtBlockSize - (p->matchMaxLen * 2);
+  distances[1] = p->hashNumAvail;
+  while (curPos < limit)
+  {
+    if (p->hashBufPos == p->hashBufPosLimit)
+    {
+      MatchFinderMt_GetNextBlock_Hash(p);
+      distances[1] = numProcessed + p->hashNumAvail;
+      if (p->hashNumAvail >= p->numHashBytes)
+        continue;
+      for (; p->hashNumAvail != 0; p->hashNumAvail--)
+        distances[curPos++] = 0;
+      break;
+    }
+    {
+      UInt32 size = p->hashBufPosLimit - p->hashBufPos;
+      UInt32 lenLimit = p->matchMaxLen;
+      UInt32 pos = p->pos;
+      UInt32 cyclicBufferPos = p->cyclicBufferPos;
+      if (lenLimit >= p->hashNumAvail)
+        lenLimit = p->hashNumAvail;
+      {
+        UInt32 size2 = p->hashNumAvail - lenLimit + 1;
+        if (size2 < size)
+          size = size2;
+        size2 = p->cyclicBufferSize - cyclicBufferPos;
+        if (size2 < size)
+          size = size2;
+      }
+      #ifndef MFMT_GM_INLINE
+      while (curPos < limit && size-- != 0)
+      {
+        UInt32 *startDistances = distances + curPos;
+        UInt32 num = (UInt32)(GetMatchesSpec1(lenLimit, pos - p->hashBuf[p->hashBufPos++],
+          pos, p->buffer, p->son, cyclicBufferPos, p->cyclicBufferSize, p->cutValue,
+          startDistances + 1, p->numHashBytes - 1) - startDistances);
+        *startDistances = num - 1;
+        curPos += num;
+        cyclicBufferPos++;
+        pos++;
+        p->buffer++;
+      }
+      #else
+      {
+        UInt32 posRes;
+        curPos = limit - GetMatchesSpecN(lenLimit, pos, p->buffer, p->son, cyclicBufferPos, p->cyclicBufferSize, p->cutValue,
+          distances + curPos, p->numHashBytes - 1, p->hashBuf + p->hashBufPos, (Int32)(limit - curPos) , size, &posRes);
+        p->hashBufPos += posRes - pos;
+        cyclicBufferPos += posRes - pos;
+        p->buffer += posRes - pos;
+        pos = posRes;
+      }
+      #endif
+
+      numProcessed += pos - p->pos;
+      p->hashNumAvail -= pos - p->pos;
+      p->pos = pos;
+      if (cyclicBufferPos == p->cyclicBufferSize)
+        cyclicBufferPos = 0;
+      p->cyclicBufferPos = cyclicBufferPos;
+    }
+  }
+  distances[0] = curPos;
+}
+
+void BtFillBlock(CMatchFinderMt *p, UInt32 globalBlockIndex)
+{
+  CMtSync *sync = &p->hashSync;
+  if (!sync->needStart)
+  {
+    CriticalSection_Enter(&sync->cs);
+    sync->csWasEntered = True;
+  }
+  
+  BtGetMatches(p, p->btBuf + (globalBlockIndex & kMtBtNumBlocksMask) * kMtBtBlockSize);
+
+  if (p->pos > kMtMaxValForNormalize - kMtBtBlockSize)
+  {
+    UInt32 subValue = p->pos - p->cyclicBufferSize;
+    MatchFinder_Normalize3(subValue, p->son, p->cyclicBufferSize * 2);
+    p->pos -= subValue;
+  }
+
+  if (!sync->needStart)
+  {
+    CriticalSection_Leave(&sync->cs);
+    sync->csWasEntered = False;
+  }
+}
+
+void BtThreadFunc(CMatchFinderMt *mt)
+{
+  CMtSync *p = &mt->btSync;
+  for (;;)
+  {
+    UInt32 blockIndex = 0;
+    Event_Wait(&p->canStart);
+    Event_Set(&p->wasStarted);
+    for (;;)
+    {
+      if (p->exit)
+        return;
+      if (p->stopWriting)
+      {
+        p->numProcessedBlocks = blockIndex;
+        MtSync_StopWriting(&mt->hashSync);
+        Event_Set(&p->wasStopped);
+        break;
+      }
+      Semaphore_Wait(&p->freeSemaphore);
+      BtFillBlock(mt, blockIndex++);
+      Semaphore_Release1(&p->filledSemaphore);
+    }
+  }
+}
+
+void MatchFinderMt_Construct(CMatchFinderMt *p)
+{
+  p->hashBuf = 0;
+  MtSync_Construct(&p->hashSync);
+  MtSync_Construct(&p->btSync);
+}
+
+void MatchFinderMt_FreeMem(CMatchFinderMt *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->hashBuf);
+  p->hashBuf = 0;
+}
+
+void MatchFinderMt_Destruct(CMatchFinderMt *p, ISzAlloc *alloc)
+{
+  MtSync_Destruct(&p->hashSync);
+  MtSync_Destruct(&p->btSync);
+  MatchFinderMt_FreeMem(p, alloc);
+}
+
+#define kHashBufferSize (kMtHashBlockSize * kMtHashNumBlocks)
+#define kBtBufferSize (kMtBtBlockSize * kMtBtNumBlocks)
+
+static unsigned MY_STD_CALL HashThreadFunc2(void *p) { HashThreadFunc((CMatchFinderMt *)p);  return 0; }
+static unsigned MY_STD_CALL BtThreadFunc2(void *p)
+{
+  Byte allocaDummy[0x180];
+  int i = 0;
+  for (i = 0; i < 16; i++)
+    allocaDummy[i] = (Byte)i;
+  BtThreadFunc((CMatchFinderMt *)p);
+  return 0;
+}
+
+SRes MatchFinderMt_Create(CMatchFinderMt *p, UInt32 historySize, UInt32 keepAddBufferBefore,
+    UInt32 matchMaxLen, UInt32 keepAddBufferAfter, ISzAlloc *alloc)
+{
+  CMatchFinder *mf = p->MatchFinder;
+  p->historySize = historySize;
+  if (kMtBtBlockSize <= matchMaxLen * 4)
+    return SZ_ERROR_PARAM;
+  if (p->hashBuf == 0)
+  {
+    p->hashBuf = (UInt32 *)alloc->Alloc(alloc, (kHashBufferSize + kBtBufferSize) * sizeof(UInt32));
+    if (p->hashBuf == 0)
+      return SZ_ERROR_MEM;
+    p->btBuf = p->hashBuf + kHashBufferSize;
+  }
+  keepAddBufferBefore += (kHashBufferSize + kBtBufferSize);
+  keepAddBufferAfter += kMtHashBlockSize;
+  if (!MatchFinder_Create(mf, historySize, keepAddBufferBefore, matchMaxLen, keepAddBufferAfter, alloc))
+    return SZ_ERROR_MEM;
+
+  RINOK(MtSync_Create(&p->hashSync, HashThreadFunc2, p, kMtHashNumBlocks));
+  RINOK(MtSync_Create(&p->btSync, BtThreadFunc2, p, kMtBtNumBlocks));
+  return SZ_OK;
+}
+
+/* Call it after ReleaseStream / SetStream */
+void MatchFinderMt_Init(CMatchFinderMt *p)
+{
+  CMatchFinder *mf = p->MatchFinder;
+  p->btBufPos = p->btBufPosLimit = 0;
+  p->hashBufPos = p->hashBufPosLimit = 0;
+  MatchFinder_Init(mf);
+  p->pointerToCurPos = MatchFinder_GetPointerToCurrentPos(mf);
+  p->btNumAvailBytes = 0;
+  p->lzPos = p->historySize + 1;
+
+  p->hash = mf->hash;
+  p->fixedHashSize = mf->fixedHashSize;
+  p->crc = mf->crc;
+
+  p->son = mf->son;
+  p->matchMaxLen = mf->matchMaxLen;
+  p->numHashBytes = mf->numHashBytes;
+  p->pos = mf->pos;
+  p->buffer = mf->buffer;
+  p->cyclicBufferPos = mf->cyclicBufferPos;
+  p->cyclicBufferSize = mf->cyclicBufferSize;
+  p->cutValue = mf->cutValue;
+}
+
+/* ReleaseStream is required to finish multithreading */
+void MatchFinderMt_ReleaseStream(CMatchFinderMt *p)
+{
+  MtSync_StopWriting(&p->btSync);
+  /* p->MatchFinder->ReleaseStream(); */
+}
+
+void MatchFinderMt_Normalize(CMatchFinderMt *p)
+{
+  MatchFinder_Normalize3(p->lzPos - p->historySize - 1, p->hash, p->fixedHashSize);
+  p->lzPos = p->historySize + 1;
+}
+
+void MatchFinderMt_GetNextBlock_Bt(CMatchFinderMt *p)
+{
+  UInt32 blockIndex;
+  MtSync_GetNextBlock(&p->btSync);
+  blockIndex = ((p->btSync.numProcessedBlocks - 1) & kMtBtNumBlocksMask);
+  p->btBufPosLimit = p->btBufPos = blockIndex * kMtBtBlockSize;
+  p->btBufPosLimit += p->btBuf[p->btBufPos++];
+  p->btNumAvailBytes = p->btBuf[p->btBufPos++];
+  if (p->lzPos >= kMtMaxValForNormalize - kMtBtBlockSize)
+    MatchFinderMt_Normalize(p);
+}
+
+const Byte * MatchFinderMt_GetPointerToCurrentPos(CMatchFinderMt *p)
+{
+  return p->pointerToCurPos;
+}
+
+#define GET_NEXT_BLOCK_IF_REQUIRED if (p->btBufPos == p->btBufPosLimit) MatchFinderMt_GetNextBlock_Bt(p);
+
+UInt32 MatchFinderMt_GetNumAvailableBytes(CMatchFinderMt *p)
+{
+  GET_NEXT_BLOCK_IF_REQUIRED;
+  return p->btNumAvailBytes;
+}
+
+Byte MatchFinderMt_GetIndexByte(CMatchFinderMt *p, Int32 index)
+{
+  return p->pointerToCurPos[index];
+}
+
+UInt32 * MixMatches2(CMatchFinderMt *p, UInt32 matchMinPos, UInt32 *distances)
+{
+  UInt32 hash2Value, curMatch2;
+  UInt32 *hash = p->hash;
+  const Byte *cur = p->pointerToCurPos;
+  UInt32 lzPos = p->lzPos;
+  MT_HASH2_CALC
+      
+  curMatch2 = hash[hash2Value];
+  hash[hash2Value] = lzPos;
+
+  if (curMatch2 >= matchMinPos)
+    if (cur[(ptrdiff_t)curMatch2 - lzPos] == cur[0])
+    {
+      *distances++ = 2;
+      *distances++ = lzPos - curMatch2 - 1;
+    }
+  return distances;
+}
+
+UInt32 * MixMatches3(CMatchFinderMt *p, UInt32 matchMinPos, UInt32 *distances)
+{
+  UInt32 hash2Value, hash3Value, curMatch2, curMatch3;
+  UInt32 *hash = p->hash;
+  const Byte *cur = p->pointerToCurPos;
+  UInt32 lzPos = p->lzPos;
+  MT_HASH3_CALC
+
+  curMatch2 = hash[                hash2Value];
+  curMatch3 = hash[kFix3HashSize + hash3Value];
+  
+  hash[                hash2Value] =
+  hash[kFix3HashSize + hash3Value] =
+    lzPos;
+
+  if (curMatch2 >= matchMinPos && cur[(ptrdiff_t)curMatch2 - lzPos] == cur[0])
+  {
+    distances[1] = lzPos - curMatch2 - 1;
+    if (cur[(ptrdiff_t)curMatch2 - lzPos + 2] == cur[2])
+    {
+      distances[0] = 3;
+      return distances + 2;
+    }
+    distances[0] = 2;
+    distances += 2;
+  }
+  if (curMatch3 >= matchMinPos && cur[(ptrdiff_t)curMatch3 - lzPos] == cur[0])
+  {
+    *distances++ = 3;
+    *distances++ = lzPos - curMatch3 - 1;
+  }
+  return distances;
+}
+
+/*
+UInt32 *MixMatches4(CMatchFinderMt *p, UInt32 matchMinPos, UInt32 *distances)
+{
+  UInt32 hash2Value, hash3Value, hash4Value, curMatch2, curMatch3, curMatch4;
+  UInt32 *hash = p->hash;
+  const Byte *cur = p->pointerToCurPos;
+  UInt32 lzPos = p->lzPos;
+  MT_HASH4_CALC
+      
+  curMatch2 = hash[                hash2Value];
+  curMatch3 = hash[kFix3HashSize + hash3Value];
+  curMatch4 = hash[kFix4HashSize + hash4Value];
+  
+  hash[                hash2Value] =
+  hash[kFix3HashSize + hash3Value] =
+  hash[kFix4HashSize + hash4Value] =
+    lzPos;
+
+  if (curMatch2 >= matchMinPos && cur[(ptrdiff_t)curMatch2 - lzPos] == cur[0])
+  {
+    distances[1] = lzPos - curMatch2 - 1;
+    if (cur[(ptrdiff_t)curMatch2 - lzPos + 2] == cur[2])
+    {
+      distances[0] =  (cur[(ptrdiff_t)curMatch2 - lzPos + 3] == cur[3]) ? 4 : 3;
+      return distances + 2;
+    }
+    distances[0] = 2;
+    distances += 2;
+  }
+  if (curMatch3 >= matchMinPos && cur[(ptrdiff_t)curMatch3 - lzPos] == cur[0])
+  {
+    distances[1] = lzPos - curMatch3 - 1;
+    if (cur[(ptrdiff_t)curMatch3 - lzPos + 3] == cur[3])
+    {
+      distances[0] = 4;
+      return distances + 2;
+    }
+    distances[0] = 3;
+    distances += 2;
+  }
+
+  if (curMatch4 >= matchMinPos)
+    if (
+      cur[(ptrdiff_t)curMatch4 - lzPos] == cur[0] &&
+      cur[(ptrdiff_t)curMatch4 - lzPos + 3] == cur[3]
+      )
+    {
+      *distances++ = 4;
+      *distances++ = lzPos - curMatch4 - 1;
+    }
+  return distances;
+}
+*/
+
+#define INCREASE_LZ_POS p->lzPos++; p->pointerToCurPos++;
+
+UInt32 MatchFinderMt2_GetMatches(CMatchFinderMt *p, UInt32 *distances)
+{
+  const UInt32 *btBuf = p->btBuf + p->btBufPos;
+  UInt32 len = *btBuf++;
+  p->btBufPos += 1 + len;
+  p->btNumAvailBytes--;
+  {
+    UInt32 i;
+    for (i = 0; i < len; i += 2)
+    {
+      *distances++ = *btBuf++;
+      *distances++ = *btBuf++;
+    }
+  }
+  INCREASE_LZ_POS
+  return len;
+}
+
+UInt32 MatchFinderMt_GetMatches(CMatchFinderMt *p, UInt32 *distances)
+{
+  const UInt32 *btBuf = p->btBuf + p->btBufPos;
+  UInt32 len = *btBuf++;
+  p->btBufPos += 1 + len;
+
+  if (len == 0)
+  {
+    if (p->btNumAvailBytes-- >= 4)
+      len = (UInt32)(p->MixMatchesFunc(p, p->lzPos - p->historySize, distances) - (distances));
+  }
+  else
+  {
+    /* Condition: there are matches in btBuf with length < p->numHashBytes */
+    UInt32 *distances2;
+    p->btNumAvailBytes--;
+    distances2 = p->MixMatchesFunc(p, p->lzPos - btBuf[1], distances);
+    do
+    {
+      *distances2++ = *btBuf++;
+      *distances2++ = *btBuf++;
+    }
+    while ((len -= 2) != 0);
+    len  = (UInt32)(distances2 - (distances));
+  }
+  INCREASE_LZ_POS
+  return len;
+}
+
+#define SKIP_HEADER2  do { GET_NEXT_BLOCK_IF_REQUIRED
+#define SKIP_HEADER(n) SKIP_HEADER2 if (p->btNumAvailBytes-- >= (n)) { const Byte *cur = p->pointerToCurPos; UInt32 *hash = p->hash;
+#define SKIP_FOOTER } INCREASE_LZ_POS p->btBufPos += p->btBuf[p->btBufPos] + 1; } while (--num != 0);
+
+void MatchFinderMt0_Skip(CMatchFinderMt *p, UInt32 num)
+{
+  SKIP_HEADER2 { p->btNumAvailBytes--;
+  SKIP_FOOTER
+}
+
+void MatchFinderMt2_Skip(CMatchFinderMt *p, UInt32 num)
+{
+  SKIP_HEADER(2)
+      UInt32 hash2Value;
+      MT_HASH2_CALC
+      hash[hash2Value] = p->lzPos;
+  SKIP_FOOTER
+}
+
+void MatchFinderMt3_Skip(CMatchFinderMt *p, UInt32 num)
+{
+  SKIP_HEADER(3)
+      UInt32 hash2Value, hash3Value;
+      MT_HASH3_CALC
+      hash[kFix3HashSize + hash3Value] =
+      hash[                hash2Value] =
+        p->lzPos;
+  SKIP_FOOTER
+}
+
+/*
+void MatchFinderMt4_Skip(CMatchFinderMt *p, UInt32 num)
+{
+  SKIP_HEADER(4)
+      UInt32 hash2Value, hash3Value, hash4Value;
+      MT_HASH4_CALC
+      hash[kFix4HashSize + hash4Value] =
+      hash[kFix3HashSize + hash3Value] =
+      hash[                hash2Value] =
+        p->lzPos;
+  SKIP_FOOTER
+}
+*/
+
+void MatchFinderMt_CreateVTable(CMatchFinderMt *p, IMatchFinder *vTable)
+{
+  vTable->Init = (Mf_Init_Func)MatchFinderMt_Init;
+  vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinderMt_GetIndexByte;
+  vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinderMt_GetNumAvailableBytes;
+  vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinderMt_GetPointerToCurrentPos;
+  vTable->GetMatches = (Mf_GetMatches_Func)MatchFinderMt_GetMatches;
+  switch(p->MatchFinder->numHashBytes)
+  {
+    case 2:
+      p->GetHeadsFunc = GetHeads2;
+      p->MixMatchesFunc = (Mf_Mix_Matches)0;
+      vTable->Skip = (Mf_Skip_Func)MatchFinderMt0_Skip;
+      vTable->GetMatches = (Mf_GetMatches_Func)MatchFinderMt2_GetMatches;
+      break;
+    case 3:
+      p->GetHeadsFunc = GetHeads3;
+      p->MixMatchesFunc = (Mf_Mix_Matches)MixMatches2;
+      vTable->Skip = (Mf_Skip_Func)MatchFinderMt2_Skip;
+      break;
+    default:
+    /* case 4: */
+      p->GetHeadsFunc = p->MatchFinder->bigHash ? GetHeads4b : GetHeads4;
+      /* p->GetHeadsFunc = GetHeads4; */
+      p->MixMatchesFunc = (Mf_Mix_Matches)MixMatches3;
+      vTable->Skip = (Mf_Skip_Func)MatchFinderMt3_Skip;
+      break;
+    /*
+    default:
+      p->GetHeadsFunc = GetHeads5;
+      p->MixMatchesFunc = (Mf_Mix_Matches)MixMatches4;
+      vTable->Skip = (Mf_Skip_Func)MatchFinderMt4_Skip;
+      break;
+    */
+  }
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzFindMt.h squashfs-tools-patched/LZMA/lzma465/C/LzFindMt.h
--- squashfs-tools/LZMA/lzma465/C/LzFindMt.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzFindMt.h	2022-01-01 15:08:47.869171447 +0800
@@ -0,0 +1,97 @@
+/* LzFindMt.h -- multithreaded Match finder for LZ algorithms
+2008-10-04 : Igor Pavlov : Public domain */
+
+#ifndef __LZFINDMT_H
+#define __LZFINDMT_H
+
+#include "Threads.h"
+#include "LzFind.h"
+
+#define kMtHashBlockSize (1 << 13)
+#define kMtHashNumBlocks (1 << 3)
+#define kMtHashNumBlocksMask (kMtHashNumBlocks - 1)
+
+#define kMtBtBlockSize (1 << 14)
+#define kMtBtNumBlocks (1 << 6)
+#define kMtBtNumBlocksMask (kMtBtNumBlocks - 1)
+
+typedef struct _CMtSync
+{
+  Bool wasCreated;
+  Bool needStart;
+  Bool exit;
+  Bool stopWriting;
+
+  CThread thread;
+  CAutoResetEvent canStart;
+  CAutoResetEvent wasStarted;
+  CAutoResetEvent wasStopped;
+  CSemaphore freeSemaphore;
+  CSemaphore filledSemaphore;
+  Bool csWasInitialized;
+  Bool csWasEntered;
+  CCriticalSection cs;
+  UInt32 numProcessedBlocks;
+} CMtSync;
+
+typedef UInt32 * (*Mf_Mix_Matches)(void *p, UInt32 matchMinPos, UInt32 *distances);
+
+/* kMtCacheLineDummy must be >= size_of_CPU_cache_line */
+#define kMtCacheLineDummy 128
+
+typedef void (*Mf_GetHeads)(const Byte *buffer, UInt32 pos,
+  UInt32 *hash, UInt32 hashMask, UInt32 *heads, UInt32 numHeads, const UInt32 *crc);
+
+typedef struct _CMatchFinderMt
+{
+  /* LZ */
+  const Byte *pointerToCurPos;
+  UInt32 *btBuf;
+  UInt32 btBufPos;
+  UInt32 btBufPosLimit;
+  UInt32 lzPos;
+  UInt32 btNumAvailBytes;
+
+  UInt32 *hash;
+  UInt32 fixedHashSize;
+  UInt32 historySize;
+  const UInt32 *crc;
+
+  Mf_Mix_Matches MixMatchesFunc;
+  
+  /* LZ + BT */
+  CMtSync btSync;
+  Byte btDummy[kMtCacheLineDummy];
+
+  /* BT */
+  UInt32 *hashBuf;
+  UInt32 hashBufPos;
+  UInt32 hashBufPosLimit;
+  UInt32 hashNumAvail;
+
+  CLzRef *son;
+  UInt32 matchMaxLen;
+  UInt32 numHashBytes;
+  UInt32 pos;
+  Byte *buffer;
+  UInt32 cyclicBufferPos;
+  UInt32 cyclicBufferSize; /* it must be historySize + 1 */
+  UInt32 cutValue;
+
+  /* BT + Hash */
+  CMtSync hashSync;
+  /* Byte hashDummy[kMtCacheLineDummy]; */
+  
+  /* Hash */
+  Mf_GetHeads GetHeadsFunc;
+  CMatchFinder *MatchFinder;
+} CMatchFinderMt;
+
+void MatchFinderMt_Construct(CMatchFinderMt *p);
+void MatchFinderMt_Destruct(CMatchFinderMt *p, ISzAlloc *alloc);
+SRes MatchFinderMt_Create(CMatchFinderMt *p, UInt32 historySize, UInt32 keepAddBufferBefore,
+    UInt32 matchMaxLen, UInt32 keepAddBufferAfter, ISzAlloc *alloc);
+void MatchFinderMt_CreateVTable(CMatchFinderMt *p, IMatchFinder *vTable);
+void MatchFinderMt_ReleaseStream(CMatchFinderMt *p);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzHash.h squashfs-tools-patched/LZMA/lzma465/C/LzHash.h
--- squashfs-tools/LZMA/lzma465/C/LzHash.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzHash.h	2022-01-01 15:08:47.869171447 +0800
@@ -0,0 +1,54 @@
+/* LzHash.h -- HASH functions for LZ algorithms
+2008-10-04 : Igor Pavlov : Public domain */
+
+#ifndef __LZHASH_H
+#define __LZHASH_H
+
+#define kHash2Size (1 << 10)
+#define kHash3Size (1 << 16)
+#define kHash4Size (1 << 20)
+
+#define kFix3HashSize (kHash2Size)
+#define kFix4HashSize (kHash2Size + kHash3Size)
+#define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)
+
+#define HASH2_CALC hashValue = cur[0] | ((UInt32)cur[1] << 8);
+
+#define HASH3_CALC { \
+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp & (kHash2Size - 1); \
+  hashValue = (temp ^ ((UInt32)cur[2] << 8)) & p->hashMask; }
+
+#define HASH4_CALC { \
+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp & (kHash2Size - 1); \
+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
+  hashValue = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & p->hashMask; }
+
+#define HASH5_CALC { \
+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp & (kHash2Size - 1); \
+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
+  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)); \
+  hashValue = (hash4Value ^ (p->crc[cur[4]] << 3)) & p->hashMask; \
+  hash4Value &= (kHash4Size - 1); }
+
+/* #define HASH_ZIP_CALC hashValue = ((cur[0] | ((UInt32)cur[1] << 8)) ^ p->crc[cur[2]]) & 0xFFFF; */
+#define HASH_ZIP_CALC hashValue = ((cur[2] | ((UInt32)cur[0] << 8)) ^ p->crc[cur[1]]) & 0xFFFF;
+
+
+#define MT_HASH2_CALC \
+  hash2Value = (p->crc[cur[0]] ^ cur[1]) & (kHash2Size - 1);
+
+#define MT_HASH3_CALC { \
+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp & (kHash2Size - 1); \
+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); }
+
+#define MT_HASH4_CALC { \
+  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
+  hash2Value = temp & (kHash2Size - 1); \
+  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
+  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & (kHash4Size - 1); }
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaDec.c squashfs-tools-patched/LZMA/lzma465/C/LzmaDec.c
--- squashfs-tools/LZMA/lzma465/C/LzmaDec.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaDec.c	2022-01-01 15:08:47.869171447 +0800
@@ -0,0 +1,1007 @@
+/* LzmaDec.c -- LZMA Decoder
+2008-11-06 : Igor Pavlov : Public domain */
+
+#include "LzmaDec.h"
+
+#include <string.h>
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_INIT_SIZE 5
+
+#define NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | (*buf++); }
+
+#define IF_BIT_0(p) ttt = *(p); NORMALIZE; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
+#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));
+#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits));
+#define GET_BIT2(p, i, A0, A1) IF_BIT_0(p) \
+  { UPDATE_0(p); i = (i + i); A0; } else \
+  { UPDATE_1(p); i = (i + i) + 1; A1; }
+#define GET_BIT(p, i) GET_BIT2(p, i, ; , ;)
+
+#define TREE_GET_BIT(probs, i) { GET_BIT((probs + i), i); }
+#define TREE_DECODE(probs, limit, i) \
+  { i = 1; do { TREE_GET_BIT(probs, i); } while (i < limit); i -= limit; }
+
+/* #define _LZMA_SIZE_OPT */
+
+#ifdef _LZMA_SIZE_OPT
+#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 << 6), i)
+#else
+#define TREE_6_DECODE(probs, i) \
+  { i = 1; \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  TREE_GET_BIT(probs, i); \
+  i -= 0x40; }
+#endif
+
+#define NORMALIZE_CHECK if (range < kTopValue) { if (buf >= bufLimit) return DUMMY_ERROR; range <<= 8; code = (code << 8) | (*buf++); }
+
+#define IF_BIT_0_CHECK(p) ttt = *(p); NORMALIZE_CHECK; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
+#define UPDATE_0_CHECK range = bound;
+#define UPDATE_1_CHECK range -= bound; code -= bound;
+#define GET_BIT2_CHECK(p, i, A0, A1) IF_BIT_0_CHECK(p) \
+  { UPDATE_0_CHECK; i = (i + i); A0; } else \
+  { UPDATE_1_CHECK; i = (i + i) + 1; A1; }
+#define GET_BIT_CHECK(p, i) GET_BIT2_CHECK(p, i, ; , ;)
+#define TREE_DECODE_CHECK(probs, limit, i) \
+  { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i < limit); i -= limit; }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols)
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+#define kMatchSpecLenStart (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LzmaProps_GetNumProbs(p) ((UInt32)LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+static const Byte kLiteralNextStates[kNumStates * 2] =
+{
+  0, 0, 0, 0, 1, 2, 3,  4,  5,  6,  4,  5,
+  7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10
+};
+
+#define LZMA_DIC_MIN (1 << 12)
+
+/* First LZMA-symbol is always decoded.
+And it decodes new LZMA-symbols while (buf < bufLimit), but "buf" is without last normalization
+Out:
+  Result:
+    SZ_OK - OK
+    SZ_ERROR_DATA - Error
+  p->remainLen:
+    < kMatchSpecLenStart : normal remain
+    = kMatchSpecLenStart : finished
+    = kMatchSpecLenStart + 1 : Flush marker
+    = kMatchSpecLenStart + 2 : State Init Marker
+*/
+
+static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
+{
+  CLzmaProb *probs = p->probs;
+
+  unsigned state = p->state;
+  UInt32 rep0 = p->reps[0], rep1 = p->reps[1], rep2 = p->reps[2], rep3 = p->reps[3];
+  unsigned pbMask = ((unsigned)1 << (p->prop.pb)) - 1;
+  unsigned lpMask = ((unsigned)1 << (p->prop.lp)) - 1;
+  unsigned lc = p->prop.lc;
+
+  Byte *dic = p->dic;
+  SizeT dicBufSize = p->dicBufSize;
+  SizeT dicPos = p->dicPos;
+  
+  UInt32 processedPos = p->processedPos;
+  UInt32 checkDicSize = p->checkDicSize;
+  unsigned len = 0;
+
+  const Byte *buf = p->buf;
+  UInt32 range = p->range;
+  UInt32 code = p->code;
+
+  do
+  {
+    CLzmaProb *prob;
+    UInt32 bound;
+    unsigned ttt;
+    unsigned posState = processedPos & pbMask;
+
+    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
+    IF_BIT_0(prob)
+    {
+      unsigned symbol;
+      UPDATE_0(prob);
+      prob = probs + Literal;
+      if (checkDicSize != 0 || processedPos != 0)
+        prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc) +
+        (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));
+
+      if (state < kNumLitStates)
+      {
+        symbol = 1;
+        do { GET_BIT(prob + symbol, symbol) } while (symbol < 0x100);
+      }
+      else
+      {
+        unsigned matchByte = p->dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
+        unsigned offs = 0x100;
+        symbol = 1;
+        do
+        {
+          unsigned bit;
+          CLzmaProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & offs);
+          probLit = prob + offs + bit + symbol;
+          GET_BIT2(probLit, symbol, offs &= ~bit, offs &= bit)
+        }
+        while (symbol < 0x100);
+      }
+      dic[dicPos++] = (Byte)symbol;
+      processedPos++;
+
+      state = kLiteralNextStates[state];
+      /* if (state < 4) state = 0; else if (state < 10) state -= 3; else state -= 6; */
+      continue;
+    }
+    else
+    {
+      UPDATE_1(prob);
+      prob = probs + IsRep + state;
+      IF_BIT_0(prob)
+      {
+        UPDATE_0(prob);
+        state += kNumStates;
+        prob = probs + LenCoder;
+      }
+      else
+      {
+        UPDATE_1(prob);
+        if (checkDicSize == 0 && processedPos == 0)
+          return SZ_ERROR_DATA;
+        prob = probs + IsRepG0 + state;
+        IF_BIT_0(prob)
+        {
+          UPDATE_0(prob);
+          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IF_BIT_0(prob)
+          {
+            UPDATE_0(prob);
+            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
+            dicPos++;
+            processedPos++;
+            state = state < kNumLitStates ? 9 : 11;
+            continue;
+          }
+          UPDATE_1(prob);
+        }
+        else
+        {
+          UInt32 distance;
+          UPDATE_1(prob);
+          prob = probs + IsRepG1 + state;
+          IF_BIT_0(prob)
+          {
+            UPDATE_0(prob);
+            distance = rep1;
+          }
+          else
+          {
+            UPDATE_1(prob);
+            prob = probs + IsRepG2 + state;
+            IF_BIT_0(prob)
+            {
+              UPDATE_0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UPDATE_1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state < kNumLitStates ? 8 : 11;
+        prob = probs + RepLenCoder;
+      }
+      {
+        unsigned limit, offset;
+        CLzmaProb *probLen = prob + LenChoice;
+        IF_BIT_0(probLen)
+        {
+          UPDATE_0(probLen);
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          limit = (1 << kLenNumLowBits);
+        }
+        else
+        {
+          UPDATE_1(probLen);
+          probLen = prob + LenChoice2;
+          IF_BIT_0(probLen)
+          {
+            UPDATE_0(probLen);
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            limit = (1 << kLenNumMidBits);
+          }
+          else
+          {
+            UPDATE_1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            limit = (1 << kLenNumHighBits);
+          }
+        }
+        TREE_DECODE(probLen, limit, len);
+        len += offset;
+      }
+
+      if (state >= kNumStates)
+      {
+        UInt32 distance;
+        prob = probs + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);
+        TREE_6_DECODE(prob, distance);
+        if (distance >= kStartPosModelIndex)
+        {
+          unsigned posSlot = (unsigned)distance;
+          int numDirectBits = (int)(((distance >> 1) - 1));
+          distance = (2 | (distance & 1));
+          if (posSlot < kEndPosModelIndex)
+          {
+            distance <<= numDirectBits;
+            prob = probs + SpecPos + distance - posSlot - 1;
+            {
+              UInt32 mask = 1;
+              unsigned i = 1;
+              do
+              {
+                GET_BIT2(prob + i, i, ; , distance |= mask);
+                mask <<= 1;
+              }
+              while (--numDirectBits != 0);
+            }
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              NORMALIZE
+              range >>= 1;
+              
+              {
+                UInt32 t;
+                code -= range;
+                t = (0 - ((UInt32)code >> 31)); /* (UInt32)((Int32)code >> 31) */
+                distance = (distance << 1) + (t + 1);
+                code += range & t;
+              }
+              /*
+              distance <<= 1;
+              if (code >= range)
+              {
+                code -= range;
+                distance |= 1;
+              }
+              */
+            }
+            while (--numDirectBits != 0);
+            prob = probs + Align;
+            distance <<= kNumAlignBits;
+            {
+              unsigned i = 1;
+              GET_BIT2(prob + i, i, ; , distance |= 1);
+              GET_BIT2(prob + i, i, ; , distance |= 2);
+              GET_BIT2(prob + i, i, ; , distance |= 4);
+              GET_BIT2(prob + i, i, ; , distance |= 8);
+            }
+            if (distance == (UInt32)0xFFFFFFFF)
+            {
+              len += kMatchSpecLenStart;
+              state -= kNumStates;
+              break;
+            }
+          }
+        }
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        rep0 = distance + 1;
+        if (checkDicSize == 0)
+        {
+          if (distance >= processedPos)
+            return SZ_ERROR_DATA;
+        }
+        else if (distance >= checkDicSize)
+          return SZ_ERROR_DATA;
+        state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;
+        /* state = kLiteralNextStates[state]; */
+      }
+
+      len += kMatchMinLen;
+
+      if (limit == dicPos)
+        return SZ_ERROR_DATA;
+      {
+        SizeT rem = limit - dicPos;
+        unsigned curLen = ((rem < len) ? (unsigned)rem : len);
+        SizeT pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);
+
+        processedPos += curLen;
+
+        len -= curLen;
+        if (pos + curLen <= dicBufSize)
+        {
+          Byte *dest = dic + dicPos;
+          ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
+          const Byte *lim = dest + curLen;
+          dicPos += curLen;
+          do
+            *(dest) = (Byte)*(dest + src);
+          while (++dest != lim);
+        }
+        else
+        {
+          do
+          {
+            dic[dicPos++] = dic[pos];
+            if (++pos == dicBufSize)
+              pos = 0;
+          }
+          while (--curLen != 0);
+        }
+      }
+    }
+  }
+  while (dicPos < limit && buf < bufLimit);
+  NORMALIZE;
+  p->buf = buf;
+  p->range = range;
+  p->code = code;
+  p->remainLen = len;
+  p->dicPos = dicPos;
+  p->processedPos = processedPos;
+  p->reps[0] = rep0;
+  p->reps[1] = rep1;
+  p->reps[2] = rep2;
+  p->reps[3] = rep3;
+  p->state = state;
+
+  return SZ_OK;
+}
+
+static void MY_FAST_CALL LzmaDec_WriteRem(CLzmaDec *p, SizeT limit)
+{
+  if (p->remainLen != 0 && p->remainLen < kMatchSpecLenStart)
+  {
+    Byte *dic = p->dic;
+    SizeT dicPos = p->dicPos;
+    SizeT dicBufSize = p->dicBufSize;
+    unsigned len = p->remainLen;
+    UInt32 rep0 = p->reps[0];
+    if (limit - dicPos < len)
+      len = (unsigned)(limit - dicPos);
+
+    if (p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= len)
+      p->checkDicSize = p->prop.dicSize;
+
+    p->processedPos += len;
+    p->remainLen -= len;
+    while (len-- != 0)
+    {
+      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
+      dicPos++;
+    }
+    p->dicPos = dicPos;
+  }
+}
+
+static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
+{
+  do
+  {
+    SizeT limit2 = limit;
+    if (p->checkDicSize == 0)
+    {
+      UInt32 rem = p->prop.dicSize - p->processedPos;
+      if (limit - p->dicPos > rem)
+        limit2 = p->dicPos + rem;
+    }
+    RINOK(LzmaDec_DecodeReal(p, limit2, bufLimit));
+    if (p->processedPos >= p->prop.dicSize)
+      p->checkDicSize = p->prop.dicSize;
+    LzmaDec_WriteRem(p, limit);
+  }
+  while (p->dicPos < limit && p->buf < bufLimit && p->remainLen < kMatchSpecLenStart);
+
+  if (p->remainLen > kMatchSpecLenStart)
+  {
+    p->remainLen = kMatchSpecLenStart;
+  }
+  return 0;
+}
+
+typedef enum
+{
+  DUMMY_ERROR, /* unexpected end of input stream */
+  DUMMY_LIT,
+  DUMMY_MATCH,
+  DUMMY_REP
+} ELzmaDummy;
+
+static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const Byte *buf, SizeT inSize)
+{
+  UInt32 range = p->range;
+  UInt32 code = p->code;
+  const Byte *bufLimit = buf + inSize;
+  CLzmaProb *probs = p->probs;
+  unsigned state = p->state;
+  ELzmaDummy res;
+
+  {
+    CLzmaProb *prob;
+    UInt32 bound;
+    unsigned ttt;
+    unsigned posState = (p->processedPos) & ((1 << p->prop.pb) - 1);
+
+    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
+    IF_BIT_0_CHECK(prob)
+    {
+      UPDATE_0_CHECK
+
+      /* if (bufLimit - buf >= 7) return DUMMY_LIT; */
+
+      prob = probs + Literal;
+      if (p->checkDicSize != 0 || p->processedPos != 0)
+        prob += (LZMA_LIT_SIZE *
+          ((((p->processedPos) & ((1 << (p->prop.lp)) - 1)) << p->prop.lc) +
+          (p->dic[(p->dicPos == 0 ? p->dicBufSize : p->dicPos) - 1] >> (8 - p->prop.lc))));
+
+      if (state < kNumLitStates)
+      {
+        unsigned symbol = 1;
+        do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol < 0x100);
+      }
+      else
+      {
+        unsigned matchByte = p->dic[p->dicPos - p->reps[0] +
+            ((p->dicPos < p->reps[0]) ? p->dicBufSize : 0)];
+        unsigned offs = 0x100;
+        unsigned symbol = 1;
+        do
+        {
+          unsigned bit;
+          CLzmaProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & offs);
+          probLit = prob + offs + bit + symbol;
+          GET_BIT2_CHECK(probLit, symbol, offs &= ~bit, offs &= bit)
+        }
+        while (symbol < 0x100);
+      }
+      res = DUMMY_LIT;
+    }
+    else
+    {
+      unsigned len;
+      UPDATE_1_CHECK;
+
+      prob = probs + IsRep + state;
+      IF_BIT_0_CHECK(prob)
+      {
+        UPDATE_0_CHECK;
+        state = 0;
+        prob = probs + LenCoder;
+        res = DUMMY_MATCH;
+      }
+      else
+      {
+        UPDATE_1_CHECK;
+        res = DUMMY_REP;
+        prob = probs + IsRepG0 + state;
+        IF_BIT_0_CHECK(prob)
+        {
+          UPDATE_0_CHECK;
+          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IF_BIT_0_CHECK(prob)
+          {
+            UPDATE_0_CHECK;
+            NORMALIZE_CHECK;
+            return DUMMY_REP;
+          }
+          else
+          {
+            UPDATE_1_CHECK;
+          }
+        }
+        else
+        {
+          UPDATE_1_CHECK;
+          prob = probs + IsRepG1 + state;
+          IF_BIT_0_CHECK(prob)
+          {
+            UPDATE_0_CHECK;
+          }
+          else
+          {
+            UPDATE_1_CHECK;
+            prob = probs + IsRepG2 + state;
+            IF_BIT_0_CHECK(prob)
+            {
+              UPDATE_0_CHECK;
+            }
+            else
+            {
+              UPDATE_1_CHECK;
+            }
+          }
+        }
+        state = kNumStates;
+        prob = probs + RepLenCoder;
+      }
+      {
+        unsigned limit, offset;
+        CLzmaProb *probLen = prob + LenChoice;
+        IF_BIT_0_CHECK(probLen)
+        {
+          UPDATE_0_CHECK;
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          limit = 1 << kLenNumLowBits;
+        }
+        else
+        {
+          UPDATE_1_CHECK;
+          probLen = prob + LenChoice2;
+          IF_BIT_0_CHECK(probLen)
+          {
+            UPDATE_0_CHECK;
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            limit = 1 << kLenNumMidBits;
+          }
+          else
+          {
+            UPDATE_1_CHECK;
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            limit = 1 << kLenNumHighBits;
+          }
+        }
+        TREE_DECODE_CHECK(probLen, limit, len);
+        len += offset;
+      }
+
+      if (state < 4)
+      {
+        unsigned posSlot;
+        prob = probs + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) <<
+            kNumPosSlotBits);
+        TREE_DECODE_CHECK(prob, 1 << kNumPosSlotBits, posSlot);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+
+          /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */
+
+          if (posSlot < kEndPosModelIndex)
+          {
+            prob = probs + SpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              NORMALIZE_CHECK
+              range >>= 1;
+              code -= range & (((code - range) >> 31) - 1);
+              /* if (code >= range) code -= range; */
+            }
+            while (--numDirectBits != 0);
+            prob = probs + Align;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            unsigned i = 1;
+            do
+            {
+              GET_BIT_CHECK(prob + i, i);
+            }
+            while (--numDirectBits != 0);
+          }
+        }
+      }
+    }
+  }
+  NORMALIZE_CHECK;
+  return res;
+}
+
+
+static void LzmaDec_InitRc(CLzmaDec *p, const Byte *data)
+{
+  p->code = ((UInt32)data[1] << 24) | ((UInt32)data[2] << 16) | ((UInt32)data[3] << 8) | ((UInt32)data[4]);
+  p->range = 0xFFFFFFFF;
+  p->needFlush = 0;
+}
+
+void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
+{
+  p->needFlush = 1;
+  p->remainLen = 0;
+  p->tempBufSize = 0;
+
+  if (initDic)
+  {
+    p->processedPos = 0;
+    p->checkDicSize = 0;
+    p->needInitState = 1;
+  }
+  if (initState)
+    p->needInitState = 1;
+}
+
+void LzmaDec_Init(CLzmaDec *p)
+{
+  p->dicPos = 0;
+  LzmaDec_InitDicAndState(p, True, True);
+}
+
+static void LzmaDec_InitStateReal(CLzmaDec *p)
+{
+  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (p->prop.lc + p->prop.lp));
+  UInt32 i;
+  CLzmaProb *probs = p->probs;
+  for (i = 0; i < numProbs; i++)
+    probs[i] = kBitModelTotal >> 1;
+  p->reps[0] = p->reps[1] = p->reps[2] = p->reps[3] = 1;
+  p->state = 0;
+  p->needInitState = 0;
+}
+
+SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
+    ELzmaFinishMode finishMode, ELzmaStatus *status)
+{
+  SizeT inSize = *srcLen;
+  (*srcLen) = 0;
+  LzmaDec_WriteRem(p, dicLimit);
+  
+  *status = LZMA_STATUS_NOT_SPECIFIED;
+
+  while (p->remainLen != kMatchSpecLenStart)
+  {
+      int checkEndMarkNow;
+
+      if (p->needFlush != 0)
+      {
+        for (; inSize > 0 && p->tempBufSize < RC_INIT_SIZE; (*srcLen)++, inSize--)
+          p->tempBuf[p->tempBufSize++] = *src++;
+        if (p->tempBufSize < RC_INIT_SIZE)
+        {
+          *status = LZMA_STATUS_NEEDS_MORE_INPUT;
+          return SZ_OK;
+        }
+        if (p->tempBuf[0] != 0)
+          return SZ_ERROR_DATA;
+
+        LzmaDec_InitRc(p, p->tempBuf);
+        p->tempBufSize = 0;
+      }
+
+      checkEndMarkNow = 0;
+      if (p->dicPos >= dicLimit)
+      {
+        if (p->remainLen == 0 && p->code == 0)
+        {
+          *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;
+          return SZ_OK;
+        }
+        if (finishMode == LZMA_FINISH_ANY)
+        {
+          *status = LZMA_STATUS_NOT_FINISHED;
+          return SZ_OK;
+        }
+        if (p->remainLen != 0)
+        {
+          *status = LZMA_STATUS_NOT_FINISHED;
+          return SZ_ERROR_DATA;
+        }
+        checkEndMarkNow = 1;
+      }
+
+      if (p->needInitState)
+        LzmaDec_InitStateReal(p);
+  
+      if (p->tempBufSize == 0)
+      {
+        SizeT processed;
+        const Byte *bufLimit;
+        if (inSize < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
+        {
+          int dummyRes = LzmaDec_TryDummy(p, src, inSize);
+          if (dummyRes == DUMMY_ERROR)
+          {
+            memcpy(p->tempBuf, src, inSize);
+            p->tempBufSize = (unsigned)inSize;
+            (*srcLen) += inSize;
+            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
+            return SZ_OK;
+          }
+          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
+          {
+            *status = LZMA_STATUS_NOT_FINISHED;
+            return SZ_ERROR_DATA;
+          }
+          bufLimit = src;
+        }
+        else
+          bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
+        p->buf = src;
+        if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)
+          return SZ_ERROR_DATA;
+        processed = (SizeT)(p->buf - src);
+        (*srcLen) += processed;
+        src += processed;
+        inSize -= processed;
+      }
+      else
+      {
+        unsigned rem = p->tempBufSize, lookAhead = 0;
+        while (rem < LZMA_REQUIRED_INPUT_MAX && lookAhead < inSize)
+          p->tempBuf[rem++] = src[lookAhead++];
+        p->tempBufSize = rem;
+        if (rem < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
+        {
+          int dummyRes = LzmaDec_TryDummy(p, p->tempBuf, rem);
+          if (dummyRes == DUMMY_ERROR)
+          {
+            (*srcLen) += lookAhead;
+            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
+            return SZ_OK;
+          }
+          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
+          {
+            *status = LZMA_STATUS_NOT_FINISHED;
+            return SZ_ERROR_DATA;
+          }
+        }
+        p->buf = p->tempBuf;
+        if (LzmaDec_DecodeReal2(p, dicLimit, p->buf) != 0)
+          return SZ_ERROR_DATA;
+        lookAhead -= (rem - (unsigned)(p->buf - p->tempBuf));
+        (*srcLen) += lookAhead;
+        src += lookAhead;
+        inSize -= lookAhead;
+        p->tempBufSize = 0;
+      }
+  }
+  if (p->code == 0)
+    *status = LZMA_STATUS_FINISHED_WITH_MARK;
+  return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
+}
+
+SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
+{
+  SizeT outSize = *destLen;
+  SizeT inSize = *srcLen;
+  *srcLen = *destLen = 0;
+  for (;;)
+  {
+    SizeT inSizeCur = inSize, outSizeCur, dicPos;
+    ELzmaFinishMode curFinishMode;
+    SRes res;
+    if (p->dicPos == p->dicBufSize)
+      p->dicPos = 0;
+    dicPos = p->dicPos;
+    if (outSize > p->dicBufSize - dicPos)
+    {
+      outSizeCur = p->dicBufSize;
+      curFinishMode = LZMA_FINISH_ANY;
+    }
+    else
+    {
+      outSizeCur = dicPos + outSize;
+      curFinishMode = finishMode;
+    }
+
+    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
+    src += inSizeCur;
+    inSize -= inSizeCur;
+    *srcLen += inSizeCur;
+    outSizeCur = p->dicPos - dicPos;
+    memcpy(dest, p->dic + dicPos, outSizeCur);
+    dest += outSizeCur;
+    outSize -= outSizeCur;
+    *destLen += outSizeCur;
+    if (res != 0)
+      return res;
+    if (outSizeCur == 0 || outSize == 0)
+      return SZ_OK;
+  }
+}
+
+void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->probs);
+  p->probs = 0;
+}
+
+static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->dic);
+  p->dic = 0;
+}
+
+void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
+{
+  LzmaDec_FreeProbs(p, alloc);
+  LzmaDec_FreeDict(p, alloc);
+}
+
+SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
+{
+  UInt32 dicSize;
+  Byte d;
+  
+  if (size < LZMA_PROPS_SIZE)
+    return SZ_ERROR_UNSUPPORTED;
+  else
+    dicSize = data[1] | ((UInt32)data[2] << 8) | ((UInt32)data[3] << 16) | ((UInt32)data[4] << 24);
+ 
+  if (dicSize < LZMA_DIC_MIN)
+    dicSize = LZMA_DIC_MIN;
+  p->dicSize = dicSize;
+
+  d = data[0];
+  if (d >= (9 * 5 * 5))
+    return SZ_ERROR_UNSUPPORTED;
+
+  p->lc = d % 9;
+  d /= 9;
+  p->pb = d / 5;
+  p->lp = d % 5;
+
+  return SZ_OK;
+}
+
+static SRes LzmaDec_AllocateProbs2(CLzmaDec *p, const CLzmaProps *propNew, ISzAlloc *alloc)
+{
+  UInt32 numProbs = LzmaProps_GetNumProbs(propNew);
+  if (p->probs == 0 || numProbs != p->numProbs)
+  {
+    LzmaDec_FreeProbs(p, alloc);
+    p->probs = (CLzmaProb *)alloc->Alloc(alloc, numProbs * sizeof(CLzmaProb));
+    p->numProbs = numProbs;
+    if (p->probs == 0)
+      return SZ_ERROR_MEM;
+  }
+  return SZ_OK;
+}
+
+SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
+{
+  CLzmaProps propNew;
+  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
+  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
+  p->prop = propNew;
+  return SZ_OK;
+}
+
+SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
+{
+  CLzmaProps propNew;
+  SizeT dicBufSize;
+  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
+  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
+  dicBufSize = propNew.dicSize;
+  if (p->dic == 0 || dicBufSize != p->dicBufSize)
+  {
+    LzmaDec_FreeDict(p, alloc);
+    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
+    if (p->dic == 0)
+    {
+      LzmaDec_FreeProbs(p, alloc);
+      return SZ_ERROR_MEM;
+    }
+  }
+  p->dicBufSize = dicBufSize;
+  p->prop = propNew;
+  return SZ_OK;
+}
+
+SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
+    ELzmaStatus *status, ISzAlloc *alloc)
+{
+  CLzmaDec p;
+  SRes res;
+  SizeT inSize = *srcLen;
+  SizeT outSize = *destLen;
+  *srcLen = *destLen = 0;
+  if (inSize < RC_INIT_SIZE)
+    return SZ_ERROR_INPUT_EOF;
+
+  LzmaDec_Construct(&p);
+  res = LzmaDec_AllocateProbs(&p, propData, propSize, alloc);
+  if (res != 0)
+    return res;
+  p.dic = dest;
+  p.dicBufSize = outSize;
+
+  LzmaDec_Init(&p);
+  
+  *srcLen = inSize;
+  res = LzmaDec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);
+
+  if (res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)
+    res = SZ_ERROR_INPUT_EOF;
+
+  (*destLen) = p.dicPos;
+  LzmaDec_FreeProbs(&p, alloc);
+  return res;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaDec.h squashfs-tools-patched/LZMA/lzma465/C/LzmaDec.h
--- squashfs-tools/LZMA/lzma465/C/LzmaDec.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaDec.h	2022-01-01 15:08:47.869171447 +0800
@@ -0,0 +1,223 @@
+/* LzmaDec.h -- LZMA Decoder
+2008-10-04 : Igor Pavlov : Public domain */
+
+#ifndef __LZMADEC_H
+#define __LZMADEC_H
+
+#include "Types.h"
+
+/* #define _LZMA_PROB32 */
+/* _LZMA_PROB32 can increase the speed on some CPUs,
+   but memory usage for CLzmaDec::probs will be doubled in that case */
+
+#ifdef _LZMA_PROB32
+#define CLzmaProb UInt32
+#else
+#define CLzmaProb UInt16
+#endif
+
+
+/* ---------- LZMA Properties ---------- */
+
+#define LZMA_PROPS_SIZE 5
+
+typedef struct _CLzmaProps
+{
+  unsigned lc, lp, pb;
+  UInt32 dicSize;
+} CLzmaProps;
+
+/* LzmaProps_Decode - decodes properties
+Returns:
+  SZ_OK
+  SZ_ERROR_UNSUPPORTED - Unsupported properties
+*/
+
+SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
+
+
+/* ---------- LZMA Decoder state ---------- */
+
+/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
+   Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; */
+
+#define LZMA_REQUIRED_INPUT_MAX 20
+
+typedef struct
+{
+  CLzmaProps prop;
+  CLzmaProb *probs;
+  Byte *dic;
+  const Byte *buf;
+  UInt32 range, code;
+  SizeT dicPos;
+  SizeT dicBufSize;
+  UInt32 processedPos;
+  UInt32 checkDicSize;
+  unsigned state;
+  UInt32 reps[4];
+  unsigned remainLen;
+  int needFlush;
+  int needInitState;
+  UInt32 numProbs;
+  unsigned tempBufSize;
+  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
+} CLzmaDec;
+
+#define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
+
+void LzmaDec_Init(CLzmaDec *p);
+
+/* There are two types of LZMA streams:
+     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
+     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
+
+typedef enum
+{
+  LZMA_FINISH_ANY,   /* finish at any point */
+  LZMA_FINISH_END    /* block must be finished at the end */
+} ELzmaFinishMode;
+
+/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!
+
+   You must use LZMA_FINISH_END, when you know that current output buffer
+   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.
+
+   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
+   and output value of destLen will be less than output buffer size limit.
+   You can check status result also.
+
+   You can use multiple checks to test data integrity after full decompression:
+     1) Check Result and "status" variable.
+     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
+     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
+        You must use correct finish mode in that case. */
+
+typedef enum
+{
+  LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */
+  LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
+  LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */
+  LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */
+  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */
+} ELzmaStatus;
+
+/* ELzmaStatus is used only as output value for function call */
+
+
+/* ---------- Interfaces ---------- */
+
+/* There are 3 levels of interfaces:
+     1) Dictionary Interface
+     2) Buffer Interface
+     3) One Call Interface
+   You can select any of these interfaces, but don't mix functions from different
+   groups for same object. */
+
+
+/* There are two variants to allocate state for Dictionary Interface:
+     1) LzmaDec_Allocate / LzmaDec_Free
+     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
+   You can use variant 2, if you set dictionary buffer manually.
+   For Buffer Interface you must always use variant 1.
+
+LzmaDec_Allocate* can return:
+  SZ_OK
+  SZ_ERROR_MEM         - Memory allocation error
+  SZ_ERROR_UNSUPPORTED - Unsupported properties
+*/
+   
+SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
+void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
+
+SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
+void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
+
+/* ---------- Dictionary Interface ---------- */
+
+/* You can use it, if you want to eliminate the overhead for data copying from
+   dictionary to some other external buffer.
+   You must work with CLzmaDec variables directly in this interface.
+
+   STEPS:
+     LzmaDec_Constr()
+     LzmaDec_Allocate()
+     for (each new stream)
+     {
+       LzmaDec_Init()
+       while (it needs more decompression)
+       {
+         LzmaDec_DecodeToDic()
+         use data from CLzmaDec::dic and update CLzmaDec::dicPos
+       }
+     }
+     LzmaDec_Free()
+*/
+
+/* LzmaDec_DecodeToDic
+   
+   The decoding to internal dictionary buffer (CLzmaDec::dic).
+   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
+
+finishMode:
+  It has meaning only if the decoding reaches output limit (dicLimit).
+  LZMA_FINISH_ANY - Decode just dicLimit bytes.
+  LZMA_FINISH_END - Stream must be finished after dicLimit.
+
+Returns:
+  SZ_OK
+    status:
+      LZMA_STATUS_FINISHED_WITH_MARK
+      LZMA_STATUS_NOT_FINISHED
+      LZMA_STATUS_NEEDS_MORE_INPUT
+      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
+  SZ_ERROR_DATA - Data error
+*/
+
+SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
+    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+
+
+/* ---------- Buffer Interface ---------- */
+
+/* It's zlib-like interface.
+   See LzmaDec_DecodeToDic description for information about STEPS and return results,
+   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
+   to work with CLzmaDec variables manually.
+
+finishMode:
+  It has meaning only if the decoding reaches output limit (*destLen).
+  LZMA_FINISH_ANY - Decode just destLen bytes.
+  LZMA_FINISH_END - Stream must be finished after (*destLen).
+*/
+
+SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
+    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+
+
+/* ---------- One Call Interface ---------- */
+
+/* LzmaDecode
+
+finishMode:
+  It has meaning only if the decoding reaches output limit (*destLen).
+  LZMA_FINISH_ANY - Decode just destLen bytes.
+  LZMA_FINISH_END - Stream must be finished after (*destLen).
+
+Returns:
+  SZ_OK
+    status:
+      LZMA_STATUS_FINISHED_WITH_MARK
+      LZMA_STATUS_NOT_FINISHED
+      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
+  SZ_ERROR_DATA - Data error
+  SZ_ERROR_MEM  - Memory allocation error
+  SZ_ERROR_UNSUPPORTED - Unsupported properties
+  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
+*/
+
+SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
+    ELzmaStatus *status, ISzAlloc *alloc);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaEnc.c squashfs-tools-patched/LZMA/lzma465/C/LzmaEnc.c
--- squashfs-tools/LZMA/lzma465/C/LzmaEnc.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaEnc.c	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,2281 @@
+/* LzmaEnc.c -- LZMA Encoder
+2009-02-02 : Igor Pavlov : Public domain */
+
+#include <string.h>
+
+/* #define SHOW_STAT */
+/* #define SHOW_STAT2 */
+
+#if defined(SHOW_STAT) || defined(SHOW_STAT2)
+#include <stdio.h>
+#endif
+
+#include "LzmaEnc.h"
+
+#include "LzFind.h"
+#ifdef COMPRESS_MF_MT
+#include "LzFindMt.h"
+#endif
+
+#ifdef SHOW_STAT
+static int ttt = 0;
+#endif
+
+#define kBlockSizeMax ((1 << LZMA_NUM_BLOCK_SIZE_BITS) - 1)
+
+#define kBlockSize (9 << 10)
+#define kUnpackBlockSize (1 << 18)
+#define kMatchArraySize (1 << 21)
+#define kMatchRecordMaxSize ((LZMA_MATCH_LEN_MAX * 2 + 3) * LZMA_MATCH_LEN_MAX)
+
+#define kNumMaxDirectBits (31)
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+#define kProbInitValue (kBitModelTotal >> 1)
+
+#define kNumMoveReducingBits 4
+#define kNumBitPriceShiftBits 4
+#define kBitPrice (1 << kNumBitPriceShiftBits)
+
+void LzmaEncProps_Init(CLzmaEncProps *p)
+{
+  p->level = 5;
+  p->dictSize = p->mc = 0;
+  p->lc = p->lp = p->pb = p->algo = p->fb = p->btMode = p->numHashBytes = p->numThreads = -1;
+  p->writeEndMark = 0;
+}
+
+void LzmaEncProps_Normalize(CLzmaEncProps *p)
+{
+  int level = p->level;
+  if (level < 0) level = 5;
+  p->level = level;
+  if (p->dictSize == 0) p->dictSize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 25) : (1 << 26)));
+  if (p->lc < 0) p->lc = 3;
+  if (p->lp < 0) p->lp = 0;
+  if (p->pb < 0) p->pb = 2;
+  if (p->algo < 0) p->algo = (level < 5 ? 0 : 1);
+  if (p->fb < 0) p->fb = (level < 7 ? 32 : 64);
+  if (p->btMode < 0) p->btMode = (p->algo == 0 ? 0 : 1);
+  if (p->numHashBytes < 0) p->numHashBytes = 4;
+  if (p->mc == 0)  p->mc = (16 + (p->fb >> 1)) >> (p->btMode ? 0 : 1);
+  if (p->numThreads < 0)
+    p->numThreads =
+      #ifdef COMPRESS_MF_MT
+      ((p->btMode && p->algo) ? 2 : 1);
+      #else
+      1;
+      #endif
+}
+
+UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
+{
+  CLzmaEncProps props = *props2;
+  LzmaEncProps_Normalize(&props);
+  return props.dictSize;
+}
+
+/* #define LZMA_LOG_BSR */
+/* Define it for Intel's CPU */
+
+
+#ifdef LZMA_LOG_BSR
+
+#define kDicLogSizeMaxCompress 30
+
+#define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }
+
+UInt32 GetPosSlot1(UInt32 pos)
+{
+  UInt32 res;
+  BSR2_RET(pos, res);
+  return res;
+}
+#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
+#define GetPosSlot(pos, res) { if (pos < 2) res = pos; else BSR2_RET(pos, res); }
+
+#else
+
+#define kNumLogBits (9 + (int)sizeof(size_t) / 2)
+#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
+
+void LzmaEnc_FastPosInit(Byte *g_FastPos)
+{
+  int c = 2, slotFast;
+  g_FastPos[0] = 0;
+  g_FastPos[1] = 1;
+  
+  for (slotFast = 2; slotFast < kNumLogBits * 2; slotFast++)
+  {
+    UInt32 k = (1 << ((slotFast >> 1) - 1));
+    UInt32 j;
+    for (j = 0; j < k; j++, c++)
+      g_FastPos[c] = (Byte)slotFast;
+  }
+}
+
+#define BSR2_RET(pos, res) { UInt32 i = 6 + ((kNumLogBits - 1) & \
+  (0 - (((((UInt32)1 << (kNumLogBits + 6)) - 1) - pos) >> 31))); \
+  res = p->g_FastPos[pos >> i] + (i * 2); }
+/*
+#define BSR2_RET(pos, res) { res = (pos < (1 << (kNumLogBits + 6))) ? \
+  p->g_FastPos[pos >> 6] + 12 : \
+  p->g_FastPos[pos >> (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
+*/
+
+#define GetPosSlot1(pos) p->g_FastPos[pos]
+#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
+#define GetPosSlot(pos, res) { if (pos < kNumFullDistances) res = p->g_FastPos[pos]; else BSR2_RET(pos, res); }
+
+#endif
+
+
+#define LZMA_NUM_REPS 4
+
+typedef unsigned CState;
+
+typedef struct _COptimal
+{
+  UInt32 price;
+
+  CState state;
+  int prev1IsChar;
+  int prev2;
+
+  UInt32 posPrev2;
+  UInt32 backPrev2;
+
+  UInt32 posPrev;
+  UInt32 backPrev;
+  UInt32 backs[LZMA_NUM_REPS];
+} COptimal;
+
+#define kNumOpts (1 << 12)
+
+#define kNumLenToPosStates 4
+#define kNumPosSlotBits 6
+#define kDicLogSizeMin 0
+#define kDicLogSizeMax 32
+#define kDistTableSizeMax (kDicLogSizeMax * 2)
+
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+#define kAlignMask (kAlignTableSize - 1)
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumPosModels (kEndPosModelIndex - kStartPosModelIndex)
+
+#define kNumFullDistances (1 << (kEndPosModelIndex / 2))
+
+#ifdef _LZMA_PROB32
+#define CLzmaProb UInt32
+#else
+#define CLzmaProb UInt16
+#endif
+
+#define LZMA_PB_MAX 4
+#define LZMA_LC_MAX 8
+#define LZMA_LP_MAX 4
+
+#define LZMA_NUM_PB_STATES_MAX (1 << LZMA_PB_MAX)
+
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define kLenNumSymbolsTotal (kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
+
+#define LZMA_MATCH_LEN_MIN 2
+#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)
+
+#define kNumStates 12
+
+typedef struct
+{
+  CLzmaProb choice;
+  CLzmaProb choice2;
+  CLzmaProb low[LZMA_NUM_PB_STATES_MAX << kLenNumLowBits];
+  CLzmaProb mid[LZMA_NUM_PB_STATES_MAX << kLenNumMidBits];
+  CLzmaProb high[kLenNumHighSymbols];
+} CLenEnc;
+
+typedef struct
+{
+  CLenEnc p;
+  UInt32 prices[LZMA_NUM_PB_STATES_MAX][kLenNumSymbolsTotal];
+  UInt32 tableSize;
+  UInt32 counters[LZMA_NUM_PB_STATES_MAX];
+} CLenPriceEnc;
+
+typedef struct _CRangeEnc
+{
+  UInt32 range;
+  Byte cache;
+  UInt64 low;
+  UInt64 cacheSize;
+  Byte *buf;
+  Byte *bufLim;
+  Byte *bufBase;
+  ISeqOutStream *outStream;
+  UInt64 processed;
+  SRes res;
+} CRangeEnc;
+
+typedef struct _CSeqInStreamBuf
+{
+  ISeqInStream funcTable;
+  const Byte *data;
+  SizeT rem;
+} CSeqInStreamBuf;
+
+static SRes MyRead(void *pp, void *data, size_t *size)
+{
+  size_t curSize = *size;
+  CSeqInStreamBuf *p = (CSeqInStreamBuf *)pp;
+  if (p->rem < curSize)
+    curSize = p->rem;
+  memcpy(data, p->data, curSize);
+  p->rem -= curSize;
+  p->data += curSize;
+  *size = curSize;
+  return SZ_OK;
+}
+
+typedef struct
+{
+  CLzmaProb *litProbs;
+
+  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
+  CLzmaProb isRep[kNumStates];
+  CLzmaProb isRepG0[kNumStates];
+  CLzmaProb isRepG1[kNumStates];
+  CLzmaProb isRepG2[kNumStates];
+  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
+
+  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
+  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
+  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
+  
+  CLenPriceEnc lenEnc;
+  CLenPriceEnc repLenEnc;
+
+  UInt32 reps[LZMA_NUM_REPS];
+  UInt32 state;
+} CSaveState;
+
+typedef struct _CLzmaEnc
+{
+  IMatchFinder matchFinder;
+  void *matchFinderObj;
+
+  #ifdef COMPRESS_MF_MT
+  Bool mtMode;
+  CMatchFinderMt matchFinderMt;
+  #endif
+
+  CMatchFinder matchFinderBase;
+
+  #ifdef COMPRESS_MF_MT
+  Byte pad[128];
+  #endif
+  
+  UInt32 optimumEndIndex;
+  UInt32 optimumCurrentIndex;
+
+  UInt32 longestMatchLength;
+  UInt32 numPairs;
+  UInt32 numAvail;
+  COptimal opt[kNumOpts];
+  
+  #ifndef LZMA_LOG_BSR
+  Byte g_FastPos[1 << kNumLogBits];
+  #endif
+
+  UInt32 ProbPrices[kBitModelTotal >> kNumMoveReducingBits];
+  UInt32 matches[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];
+  UInt32 numFastBytes;
+  UInt32 additionalOffset;
+  UInt32 reps[LZMA_NUM_REPS];
+  UInt32 state;
+
+  UInt32 posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];
+  UInt32 distancesPrices[kNumLenToPosStates][kNumFullDistances];
+  UInt32 alignPrices[kAlignTableSize];
+  UInt32 alignPriceCount;
+
+  UInt32 distTableSize;
+
+  unsigned lc, lp, pb;
+  unsigned lpMask, pbMask;
+
+  CLzmaProb *litProbs;
+
+  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
+  CLzmaProb isRep[kNumStates];
+  CLzmaProb isRepG0[kNumStates];
+  CLzmaProb isRepG1[kNumStates];
+  CLzmaProb isRepG2[kNumStates];
+  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
+
+  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
+  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
+  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
+  
+  CLenPriceEnc lenEnc;
+  CLenPriceEnc repLenEnc;
+
+  unsigned lclp;
+
+  Bool fastMode;
+  
+  CRangeEnc rc;
+
+  Bool writeEndMark;
+  UInt64 nowPos64;
+  UInt32 matchPriceCount;
+  Bool finished;
+  Bool multiThread;
+
+  SRes result;
+  UInt32 dictSize;
+  UInt32 matchFinderCycles;
+
+  ISeqInStream *inStream;
+  CSeqInStreamBuf seqBufInStream;
+
+  CSaveState saveState;
+} CLzmaEnc;
+
+void LzmaEnc_SaveState(CLzmaEncHandle pp)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  CSaveState *dest = &p->saveState;
+  int i;
+  dest->lenEnc = p->lenEnc;
+  dest->repLenEnc = p->repLenEnc;
+  dest->state = p->state;
+
+  for (i = 0; i < kNumStates; i++)
+  {
+    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
+    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
+  }
+  for (i = 0; i < kNumLenToPosStates; i++)
+    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
+  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
+  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
+  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
+  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
+  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
+  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
+  memcpy(dest->reps, p->reps, sizeof(p->reps));
+  memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
+}
+
+void LzmaEnc_RestoreState(CLzmaEncHandle pp)
+{
+  CLzmaEnc *dest = (CLzmaEnc *)pp;
+  const CSaveState *p = &dest->saveState;
+  int i;
+  dest->lenEnc = p->lenEnc;
+  dest->repLenEnc = p->repLenEnc;
+  dest->state = p->state;
+
+  for (i = 0; i < kNumStates; i++)
+  {
+    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
+    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
+  }
+  for (i = 0; i < kNumLenToPosStates; i++)
+    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
+  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
+  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
+  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
+  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
+  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
+  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
+  memcpy(dest->reps, p->reps, sizeof(p->reps));
+  memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
+}
+
+SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  CLzmaEncProps props = *props2;
+  LzmaEncProps_Normalize(&props);
+
+  if (props.lc > LZMA_LC_MAX || props.lp > LZMA_LP_MAX || props.pb > LZMA_PB_MAX ||
+      props.dictSize > (1 << kDicLogSizeMaxCompress) || props.dictSize > (1 << 30))
+    return SZ_ERROR_PARAM;
+  p->dictSize = props.dictSize;
+  p->matchFinderCycles = props.mc;
+  {
+    unsigned fb = props.fb;
+    if (fb < 5)
+      fb = 5;
+    if (fb > LZMA_MATCH_LEN_MAX)
+      fb = LZMA_MATCH_LEN_MAX;
+    p->numFastBytes = fb;
+  }
+  p->lc = props.lc;
+  p->lp = props.lp;
+  p->pb = props.pb;
+  p->fastMode = (props.algo == 0);
+  p->matchFinderBase.btMode = props.btMode;
+  {
+    UInt32 numHashBytes = 4;
+    if (props.btMode)
+    {
+      if (props.numHashBytes < 2)
+        numHashBytes = 2;
+      else if (props.numHashBytes < 4)
+        numHashBytes = props.numHashBytes;
+    }
+    p->matchFinderBase.numHashBytes = numHashBytes;
+  }
+
+  p->matchFinderBase.cutValue = props.mc;
+
+  p->writeEndMark = props.writeEndMark;
+
+  #ifdef COMPRESS_MF_MT
+  /*
+  if (newMultiThread != _multiThread)
+  {
+    ReleaseMatchFinder();
+    _multiThread = newMultiThread;
+  }
+  */
+  p->multiThread = (props.numThreads > 1);
+  #endif
+
+  return SZ_OK;
+}
+
+static const int kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
+static const int kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
+static const int kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
+static const int kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};
+
+#define IsCharState(s) ((s) < 7)
+
+#define GetLenToPosState(len) (((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)
+
+#define kInfinityPrice (1 << 30)
+
+static void RangeEnc_Construct(CRangeEnc *p)
+{
+  p->outStream = 0;
+  p->bufBase = 0;
+}
+
+#define RangeEnc_GetProcessed(p) ((p)->processed + ((p)->buf - (p)->bufBase) + (p)->cacheSize)
+
+#define RC_BUF_SIZE (1 << 16)
+static int RangeEnc_Alloc(CRangeEnc *p, ISzAlloc *alloc)
+{
+  if (p->bufBase == 0)
+  {
+    p->bufBase = (Byte *)alloc->Alloc(alloc, RC_BUF_SIZE);
+    if (p->bufBase == 0)
+      return 0;
+    p->bufLim = p->bufBase + RC_BUF_SIZE;
+  }
+  return 1;
+}
+
+static void RangeEnc_Free(CRangeEnc *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->bufBase);
+  p->bufBase = 0;
+}
+
+static void RangeEnc_Init(CRangeEnc *p)
+{
+  /* Stream.Init(); */
+  p->low = 0;
+  p->range = 0xFFFFFFFF;
+  p->cacheSize = 1;
+  p->cache = 0;
+
+  p->buf = p->bufBase;
+
+  p->processed = 0;
+  p->res = SZ_OK;
+}
+
+static void RangeEnc_FlushStream(CRangeEnc *p)
+{
+  size_t num;
+  if (p->res != SZ_OK)
+    return;
+  num = p->buf - p->bufBase;
+  if (num != p->outStream->Write(p->outStream, p->bufBase, num))
+    p->res = SZ_ERROR_WRITE;
+  p->processed += num;
+  p->buf = p->bufBase;
+}
+
+static void MY_FAST_CALL RangeEnc_ShiftLow(CRangeEnc *p)
+{
+  if ((UInt32)p->low < (UInt32)0xFF000000 || (int)(p->low >> 32) != 0)
+  {
+    Byte temp = p->cache;
+    do
+    {
+      Byte *buf = p->buf;
+      *buf++ = (Byte)(temp + (Byte)(p->low >> 32));
+      p->buf = buf;
+      if (buf == p->bufLim)
+        RangeEnc_FlushStream(p);
+      temp = 0xFF;
+    }
+    while (--p->cacheSize != 0);
+    p->cache = (Byte)((UInt32)p->low >> 24);
+  }
+  p->cacheSize++;
+  p->low = (UInt32)p->low << 8;
+}
+
+static void RangeEnc_FlushData(CRangeEnc *p)
+{
+  int i;
+  for (i = 0; i < 5; i++)
+    RangeEnc_ShiftLow(p);
+}
+
+static void RangeEnc_EncodeDirectBits(CRangeEnc *p, UInt32 value, int numBits)
+{
+  do
+  {
+    p->range >>= 1;
+    p->low += p->range & (0 - ((value >> --numBits) & 1));
+    if (p->range < kTopValue)
+    {
+      p->range <<= 8;
+      RangeEnc_ShiftLow(p);
+    }
+  }
+  while (numBits != 0);
+}
+
+static void RangeEnc_EncodeBit(CRangeEnc *p, CLzmaProb *prob, UInt32 symbol)
+{
+  UInt32 ttt = *prob;
+  UInt32 newBound = (p->range >> kNumBitModelTotalBits) * ttt;
+  if (symbol == 0)
+  {
+    p->range = newBound;
+    ttt += (kBitModelTotal - ttt) >> kNumMoveBits;
+  }
+  else
+  {
+    p->low += newBound;
+    p->range -= newBound;
+    ttt -= ttt >> kNumMoveBits;
+  }
+  *prob = (CLzmaProb)ttt;
+  if (p->range < kTopValue)
+  {
+    p->range <<= 8;
+    RangeEnc_ShiftLow(p);
+  }
+}
+
+static void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol)
+{
+  symbol |= 0x100;
+  do
+  {
+    RangeEnc_EncodeBit(p, probs + (symbol >> 8), (symbol >> 7) & 1);
+    symbol <<= 1;
+  }
+  while (symbol < 0x10000);
+}
+
+static void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol, UInt32 matchByte)
+{
+  UInt32 offs = 0x100;
+  symbol |= 0x100;
+  do
+  {
+    matchByte <<= 1;
+    RangeEnc_EncodeBit(p, probs + (offs + (matchByte & offs) + (symbol >> 8)), (symbol >> 7) & 1);
+    symbol <<= 1;
+    offs &= ~(matchByte ^ symbol);
+  }
+  while (symbol < 0x10000);
+}
+
+void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
+{
+  UInt32 i;
+  for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
+  {
+    const int kCyclesBits = kNumBitPriceShiftBits;
+    UInt32 w = i;
+    UInt32 bitCount = 0;
+    int j;
+    for (j = 0; j < kCyclesBits; j++)
+    {
+      w = w * w;
+      bitCount <<= 1;
+      while (w >= ((UInt32)1 << 16))
+      {
+        w >>= 1;
+        bitCount++;
+      }
+    }
+    ProbPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);
+  }
+}
+
+
+#define GET_PRICE(prob, symbol) \
+  p->ProbPrices[((prob) ^ (((-(int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
+
+#define GET_PRICEa(prob, symbol) \
+  ProbPrices[((prob) ^ ((-((int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
+
+#define GET_PRICE_0(prob) p->ProbPrices[(prob) >> kNumMoveReducingBits]
+#define GET_PRICE_1(prob) p->ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
+
+#define GET_PRICE_0a(prob) ProbPrices[(prob) >> kNumMoveReducingBits]
+#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
+
+static UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 symbol, UInt32 *ProbPrices)
+{
+  UInt32 price = 0;
+  symbol |= 0x100;
+  do
+  {
+    price += GET_PRICEa(probs[symbol >> 8], (symbol >> 7) & 1);
+    symbol <<= 1;
+  }
+  while (symbol < 0x10000);
+  return price;
+}
+
+static UInt32 LitEnc_GetPriceMatched(const CLzmaProb *probs, UInt32 symbol, UInt32 matchByte, UInt32 *ProbPrices)
+{
+  UInt32 price = 0;
+  UInt32 offs = 0x100;
+  symbol |= 0x100;
+  do
+  {
+    matchByte <<= 1;
+    price += GET_PRICEa(probs[offs + (matchByte & offs) + (symbol >> 8)], (symbol >> 7) & 1);
+    symbol <<= 1;
+    offs &= ~(matchByte ^ symbol);
+  }
+  while (symbol < 0x10000);
+  return price;
+}
+
+
+static void RcTree_Encode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
+{
+  UInt32 m = 1;
+  int i;
+  for (i = numBitLevels; i != 0;)
+  {
+    UInt32 bit;
+    i--;
+    bit = (symbol >> i) & 1;
+    RangeEnc_EncodeBit(rc, probs + m, bit);
+    m = (m << 1) | bit;
+  }
+}
+
+static void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
+{
+  UInt32 m = 1;
+  int i;
+  for (i = 0; i < numBitLevels; i++)
+  {
+    UInt32 bit = symbol & 1;
+    RangeEnc_EncodeBit(rc, probs + m, bit);
+    m = (m << 1) | bit;
+    symbol >>= 1;
+  }
+}
+
+static UInt32 RcTree_GetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
+{
+  UInt32 price = 0;
+  symbol |= (1 << numBitLevels);
+  while (symbol != 1)
+  {
+    price += GET_PRICEa(probs[symbol >> 1], symbol & 1);
+    symbol >>= 1;
+  }
+  return price;
+}
+
+static UInt32 RcTree_ReverseGetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
+{
+  UInt32 price = 0;
+  UInt32 m = 1;
+  int i;
+  for (i = numBitLevels; i != 0; i--)
+  {
+    UInt32 bit = symbol & 1;
+    symbol >>= 1;
+    price += GET_PRICEa(probs[m], bit);
+    m = (m << 1) | bit;
+  }
+  return price;
+}
+
+
+static void LenEnc_Init(CLenEnc *p)
+{
+  unsigned i;
+  p->choice = p->choice2 = kProbInitValue;
+  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumLowBits); i++)
+    p->low[i] = kProbInitValue;
+  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumMidBits); i++)
+    p->mid[i] = kProbInitValue;
+  for (i = 0; i < kLenNumHighSymbols; i++)
+    p->high[i] = kProbInitValue;
+}
+
+static void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState)
+{
+  if (symbol < kLenNumLowSymbols)
+  {
+    RangeEnc_EncodeBit(rc, &p->choice, 0);
+    RcTree_Encode(rc, p->low + (posState << kLenNumLowBits), kLenNumLowBits, symbol);
+  }
+  else
+  {
+    RangeEnc_EncodeBit(rc, &p->choice, 1);
+    if (symbol < kLenNumLowSymbols + kLenNumMidSymbols)
+    {
+      RangeEnc_EncodeBit(rc, &p->choice2, 0);
+      RcTree_Encode(rc, p->mid + (posState << kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
+    }
+    else
+    {
+      RangeEnc_EncodeBit(rc, &p->choice2, 1);
+      RcTree_Encode(rc, p->high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
+    }
+  }
+}
+
+static void LenEnc_SetPrices(CLenEnc *p, UInt32 posState, UInt32 numSymbols, UInt32 *prices, UInt32 *ProbPrices)
+{
+  UInt32 a0 = GET_PRICE_0a(p->choice);
+  UInt32 a1 = GET_PRICE_1a(p->choice);
+  UInt32 b0 = a1 + GET_PRICE_0a(p->choice2);
+  UInt32 b1 = a1 + GET_PRICE_1a(p->choice2);
+  UInt32 i = 0;
+  for (i = 0; i < kLenNumLowSymbols; i++)
+  {
+    if (i >= numSymbols)
+      return;
+    prices[i] = a0 + RcTree_GetPrice(p->low + (posState << kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
+  }
+  for (; i < kLenNumLowSymbols + kLenNumMidSymbols; i++)
+  {
+    if (i >= numSymbols)
+      return;
+    prices[i] = b0 + RcTree_GetPrice(p->mid + (posState << kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
+  }
+  for (; i < numSymbols; i++)
+    prices[i] = b1 + RcTree_GetPrice(p->high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
+}
+
+static void MY_FAST_CALL LenPriceEnc_UpdateTable(CLenPriceEnc *p, UInt32 posState, UInt32 *ProbPrices)
+{
+  LenEnc_SetPrices(&p->p, posState, p->tableSize, p->prices[posState], ProbPrices);
+  p->counters[posState] = p->tableSize;
+}
+
+static void LenPriceEnc_UpdateTables(CLenPriceEnc *p, UInt32 numPosStates, UInt32 *ProbPrices)
+{
+  UInt32 posState;
+  for (posState = 0; posState < numPosStates; posState++)
+    LenPriceEnc_UpdateTable(p, posState, ProbPrices);
+}
+
+static void LenEnc_Encode2(CLenPriceEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState, Bool updatePrice, UInt32 *ProbPrices)
+{
+  LenEnc_Encode(&p->p, rc, symbol, posState);
+  if (updatePrice)
+    if (--p->counters[posState] == 0)
+      LenPriceEnc_UpdateTable(p, posState, ProbPrices);
+}
+
+
+
+
+static void MovePos(CLzmaEnc *p, UInt32 num)
+{
+  #ifdef SHOW_STAT
+  ttt += num;
+  printf("\n MovePos %d", num);
+  #endif
+  if (num != 0)
+  {
+    p->additionalOffset += num;
+    p->matchFinder.Skip(p->matchFinderObj, num);
+  }
+}
+
+static UInt32 ReadMatchDistances(CLzmaEnc *p, UInt32 *numDistancePairsRes)
+{
+  UInt32 lenRes = 0, numPairs;
+  p->numAvail = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
+  numPairs = p->matchFinder.GetMatches(p->matchFinderObj, p->matches);
+  #ifdef SHOW_STAT
+  printf("\n i = %d numPairs = %d    ", ttt, numPairs / 2);
+  ttt++;
+  {
+    UInt32 i;
+    for (i = 0; i < numPairs; i += 2)
+      printf("%2d %6d   | ", p->matches[i], p->matches[i + 1]);
+  }
+  #endif
+  if (numPairs > 0)
+  {
+    lenRes = p->matches[numPairs - 2];
+    if (lenRes == p->numFastBytes)
+    {
+      const Byte *pby = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
+      UInt32 distance = p->matches[numPairs - 1] + 1;
+      UInt32 numAvail = p->numAvail;
+      if (numAvail > LZMA_MATCH_LEN_MAX)
+        numAvail = LZMA_MATCH_LEN_MAX;
+      {
+        const Byte *pby2 = pby - distance;
+        for (; lenRes < numAvail && pby[lenRes] == pby2[lenRes]; lenRes++);
+      }
+    }
+  }
+  p->additionalOffset++;
+  *numDistancePairsRes = numPairs;
+  return lenRes;
+}
+
+
+#define MakeAsChar(p) (p)->backPrev = (UInt32)(-1); (p)->prev1IsChar = False;
+#define MakeAsShortRep(p) (p)->backPrev = 0; (p)->prev1IsChar = False;
+#define IsShortRep(p) ((p)->backPrev == 0)
+
+static UInt32 GetRepLen1Price(CLzmaEnc *p, UInt32 state, UInt32 posState)
+{
+  return
+    GET_PRICE_0(p->isRepG0[state]) +
+    GET_PRICE_0(p->isRep0Long[state][posState]);
+}
+
+static UInt32 GetPureRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 state, UInt32 posState)
+{
+  UInt32 price;
+  if (repIndex == 0)
+  {
+    price = GET_PRICE_0(p->isRepG0[state]);
+    price += GET_PRICE_1(p->isRep0Long[state][posState]);
+  }
+  else
+  {
+    price = GET_PRICE_1(p->isRepG0[state]);
+    if (repIndex == 1)
+      price += GET_PRICE_0(p->isRepG1[state]);
+    else
+    {
+      price += GET_PRICE_1(p->isRepG1[state]);
+      price += GET_PRICE(p->isRepG2[state], repIndex - 2);
+    }
+  }
+  return price;
+}
+
+static UInt32 GetRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 len, UInt32 state, UInt32 posState)
+{
+  return p->repLenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN] +
+    GetPureRepPrice(p, repIndex, state, posState);
+}
+
+static UInt32 Backward(CLzmaEnc *p, UInt32 *backRes, UInt32 cur)
+{
+  UInt32 posMem = p->opt[cur].posPrev;
+  UInt32 backMem = p->opt[cur].backPrev;
+  p->optimumEndIndex = cur;
+  do
+  {
+    if (p->opt[cur].prev1IsChar)
+    {
+      MakeAsChar(&p->opt[posMem])
+      p->opt[posMem].posPrev = posMem - 1;
+      if (p->opt[cur].prev2)
+      {
+        p->opt[posMem - 1].prev1IsChar = False;
+        p->opt[posMem - 1].posPrev = p->opt[cur].posPrev2;
+        p->opt[posMem - 1].backPrev = p->opt[cur].backPrev2;
+      }
+    }
+    {
+      UInt32 posPrev = posMem;
+      UInt32 backCur = backMem;
+      
+      backMem = p->opt[posPrev].backPrev;
+      posMem = p->opt[posPrev].posPrev;
+      
+      p->opt[posPrev].backPrev = backCur;
+      p->opt[posPrev].posPrev = cur;
+      cur = posPrev;
+    }
+  }
+  while (cur != 0);
+  *backRes = p->opt[0].backPrev;
+  p->optimumCurrentIndex  = p->opt[0].posPrev;
+  return p->optimumCurrentIndex;
+}
+
+#define LIT_PROBS(pos, prevByte) (p->litProbs + ((((pos) & p->lpMask) << p->lc) + ((prevByte) >> (8 - p->lc))) * 0x300)
+
+static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
+{
+  UInt32 numAvail, mainLen, numPairs, repMaxIndex, i, posState, lenEnd, len, cur;
+  UInt32 matchPrice, repMatchPrice, normalMatchPrice;
+  UInt32 reps[LZMA_NUM_REPS], repLens[LZMA_NUM_REPS];
+  UInt32 *matches;
+  const Byte *data;
+  Byte curByte, matchByte;
+  if (p->optimumEndIndex != p->optimumCurrentIndex)
+  {
+    const COptimal *opt = &p->opt[p->optimumCurrentIndex];
+    UInt32 lenRes = opt->posPrev - p->optimumCurrentIndex;
+    *backRes = opt->backPrev;
+    p->optimumCurrentIndex = opt->posPrev;
+    return lenRes;
+  }
+  p->optimumCurrentIndex = p->optimumEndIndex = 0;
+  
+  if (p->additionalOffset == 0)
+    mainLen = ReadMatchDistances(p, &numPairs);
+  else
+  {
+    mainLen = p->longestMatchLength;
+    numPairs = p->numPairs;
+  }
+
+  numAvail = p->numAvail;
+  if (numAvail < 2)
+  {
+    *backRes = (UInt32)(-1);
+    return 1;
+  }
+  if (numAvail > LZMA_MATCH_LEN_MAX)
+    numAvail = LZMA_MATCH_LEN_MAX;
+
+  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
+  repMaxIndex = 0;
+  for (i = 0; i < LZMA_NUM_REPS; i++)
+  {
+    UInt32 lenTest;
+    const Byte *data2;
+    reps[i] = p->reps[i];
+    data2 = data - (reps[i] + 1);
+    if (data[0] != data2[0] || data[1] != data2[1])
+    {
+      repLens[i] = 0;
+      continue;
+    }
+    for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
+    repLens[i] = lenTest;
+    if (lenTest > repLens[repMaxIndex])
+      repMaxIndex = i;
+  }
+  if (repLens[repMaxIndex] >= p->numFastBytes)
+  {
+    UInt32 lenRes;
+    *backRes = repMaxIndex;
+    lenRes = repLens[repMaxIndex];
+    MovePos(p, lenRes - 1);
+    return lenRes;
+  }
+
+  matches = p->matches;
+  if (mainLen >= p->numFastBytes)
+  {
+    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
+    MovePos(p, mainLen - 1);
+    return mainLen;
+  }
+  curByte = *data;
+  matchByte = *(data - (reps[0] + 1));
+
+  if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)
+  {
+    *backRes = (UInt32)-1;
+    return 1;
+  }
+
+  p->opt[0].state = (CState)p->state;
+
+  posState = (position & p->pbMask);
+
+  {
+    const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
+    p->opt[1].price = GET_PRICE_0(p->isMatch[p->state][posState]) +
+        (!IsCharState(p->state) ?
+          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
+          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
+  }
+
+  MakeAsChar(&p->opt[1]);
+
+  matchPrice = GET_PRICE_1(p->isMatch[p->state][posState]);
+  repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[p->state]);
+
+  if (matchByte == curByte)
+  {
+    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p->state, posState);
+    if (shortRepPrice < p->opt[1].price)
+    {
+      p->opt[1].price = shortRepPrice;
+      MakeAsShortRep(&p->opt[1]);
+    }
+  }
+  lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);
+
+  if (lenEnd < 2)
+  {
+    *backRes = p->opt[1].backPrev;
+    return 1;
+  }
+
+  p->opt[1].posPrev = 0;
+  for (i = 0; i < LZMA_NUM_REPS; i++)
+    p->opt[0].backs[i] = reps[i];
+
+  len = lenEnd;
+  do
+    p->opt[len--].price = kInfinityPrice;
+  while (len >= 2);
+
+  for (i = 0; i < LZMA_NUM_REPS; i++)
+  {
+    UInt32 repLen = repLens[i];
+    UInt32 price;
+    if (repLen < 2)
+      continue;
+    price = repMatchPrice + GetPureRepPrice(p, i, p->state, posState);
+    do
+    {
+      UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][repLen - 2];
+      COptimal *opt = &p->opt[repLen];
+      if (curAndLenPrice < opt->price)
+      {
+        opt->price = curAndLenPrice;
+        opt->posPrev = 0;
+        opt->backPrev = i;
+        opt->prev1IsChar = False;
+      }
+    }
+    while (--repLen >= 2);
+  }
+
+  normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[p->state]);
+
+  len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
+  if (len <= mainLen)
+  {
+    UInt32 offs = 0;
+    while (len > matches[offs])
+      offs += 2;
+    for (; ; len++)
+    {
+      COptimal *opt;
+      UInt32 distance = matches[offs + 1];
+
+      UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
+      UInt32 lenToPosState = GetLenToPosState(len);
+      if (distance < kNumFullDistances)
+        curAndLenPrice += p->distancesPrices[lenToPosState][distance];
+      else
+      {
+        UInt32 slot;
+        GetPosSlot2(distance, slot);
+        curAndLenPrice += p->alignPrices[distance & kAlignMask] + p->posSlotPrices[lenToPosState][slot];
+      }
+      opt = &p->opt[len];
+      if (curAndLenPrice < opt->price)
+      {
+        opt->price = curAndLenPrice;
+        opt->posPrev = 0;
+        opt->backPrev = distance + LZMA_NUM_REPS;
+        opt->prev1IsChar = False;
+      }
+      if (len == matches[offs])
+      {
+        offs += 2;
+        if (offs == numPairs)
+          break;
+      }
+    }
+  }
+
+  cur = 0;
+
+    #ifdef SHOW_STAT2
+    if (position >= 0)
+    {
+      unsigned i;
+      printf("\n pos = %4X", position);
+      for (i = cur; i <= lenEnd; i++)
+      printf("\nprice[%4X] = %d", position - cur + i, p->opt[i].price);
+    }
+    #endif
+
+  for (;;)
+  {
+    UInt32 numAvailFull, newLen, numPairs, posPrev, state, posState, startLen;
+    UInt32 curPrice, curAnd1Price, matchPrice, repMatchPrice;
+    Bool nextIsChar;
+    Byte curByte, matchByte;
+    const Byte *data;
+    COptimal *curOpt;
+    COptimal *nextOpt;
+
+    cur++;
+    if (cur == lenEnd)
+      return Backward(p, backRes, cur);
+
+    newLen = ReadMatchDistances(p, &numPairs);
+    if (newLen >= p->numFastBytes)
+    {
+      p->numPairs = numPairs;
+      p->longestMatchLength = newLen;
+      return Backward(p, backRes, cur);
+    }
+    position++;
+    curOpt = &p->opt[cur];
+    posPrev = curOpt->posPrev;
+    if (curOpt->prev1IsChar)
+    {
+      posPrev--;
+      if (curOpt->prev2)
+      {
+        state = p->opt[curOpt->posPrev2].state;
+        if (curOpt->backPrev2 < LZMA_NUM_REPS)
+          state = kRepNextStates[state];
+        else
+          state = kMatchNextStates[state];
+      }
+      else
+        state = p->opt[posPrev].state;
+      state = kLiteralNextStates[state];
+    }
+    else
+      state = p->opt[posPrev].state;
+    if (posPrev == cur - 1)
+    {
+      if (IsShortRep(curOpt))
+        state = kShortRepNextStates[state];
+      else
+        state = kLiteralNextStates[state];
+    }
+    else
+    {
+      UInt32 pos;
+      const COptimal *prevOpt;
+      if (curOpt->prev1IsChar && curOpt->prev2)
+      {
+        posPrev = curOpt->posPrev2;
+        pos = curOpt->backPrev2;
+        state = kRepNextStates[state];
+      }
+      else
+      {
+        pos = curOpt->backPrev;
+        if (pos < LZMA_NUM_REPS)
+          state = kRepNextStates[state];
+        else
+          state = kMatchNextStates[state];
+      }
+      prevOpt = &p->opt[posPrev];
+      if (pos < LZMA_NUM_REPS)
+      {
+        UInt32 i;
+        reps[0] = prevOpt->backs[pos];
+        for (i = 1; i <= pos; i++)
+          reps[i] = prevOpt->backs[i - 1];
+        for (; i < LZMA_NUM_REPS; i++)
+          reps[i] = prevOpt->backs[i];
+      }
+      else
+      {
+        UInt32 i;
+        reps[0] = (pos - LZMA_NUM_REPS);
+        for (i = 1; i < LZMA_NUM_REPS; i++)
+          reps[i] = prevOpt->backs[i - 1];
+      }
+    }
+    curOpt->state = (CState)state;
+
+    curOpt->backs[0] = reps[0];
+    curOpt->backs[1] = reps[1];
+    curOpt->backs[2] = reps[2];
+    curOpt->backs[3] = reps[3];
+
+    curPrice = curOpt->price;
+    nextIsChar = False;
+    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
+    curByte = *data;
+    matchByte = *(data - (reps[0] + 1));
+
+    posState = (position & p->pbMask);
+
+    curAnd1Price = curPrice + GET_PRICE_0(p->isMatch[state][posState]);
+    {
+      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
+      curAnd1Price +=
+        (!IsCharState(state) ?
+          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
+          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
+    }
+
+    nextOpt = &p->opt[cur + 1];
+
+    if (curAnd1Price < nextOpt->price)
+    {
+      nextOpt->price = curAnd1Price;
+      nextOpt->posPrev = cur;
+      MakeAsChar(nextOpt);
+      nextIsChar = True;
+    }
+
+    matchPrice = curPrice + GET_PRICE_1(p->isMatch[state][posState]);
+    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[state]);
+    
+    if (matchByte == curByte && !(nextOpt->posPrev < cur && nextOpt->backPrev == 0))
+    {
+      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, state, posState);
+      if (shortRepPrice <= nextOpt->price)
+      {
+        nextOpt->price = shortRepPrice;
+        nextOpt->posPrev = cur;
+        MakeAsShortRep(nextOpt);
+        nextIsChar = True;
+      }
+    }
+    numAvailFull = p->numAvail;
+    {
+      UInt32 temp = kNumOpts - 1 - cur;
+      if (temp < numAvailFull)
+        numAvailFull = temp;
+    }
+
+    if (numAvailFull < 2)
+      continue;
+    numAvail = (numAvailFull <= p->numFastBytes ? numAvailFull : p->numFastBytes);
+
+    if (!nextIsChar && matchByte != curByte) /* speed optimization */
+    {
+      /* try Literal + rep0 */
+      UInt32 temp;
+      UInt32 lenTest2;
+      const Byte *data2 = data - (reps[0] + 1);
+      UInt32 limit = p->numFastBytes + 1;
+      if (limit > numAvailFull)
+        limit = numAvailFull;
+
+      for (temp = 1; temp < limit && data[temp] == data2[temp]; temp++);
+      lenTest2 = temp - 1;
+      if (lenTest2 >= 2)
+      {
+        UInt32 state2 = kLiteralNextStates[state];
+        UInt32 posStateNext = (position + 1) & p->pbMask;
+        UInt32 nextRepMatchPrice = curAnd1Price +
+            GET_PRICE_1(p->isMatch[state2][posStateNext]) +
+            GET_PRICE_1(p->isRep[state2]);
+        /* for (; lenTest2 >= 2; lenTest2--) */
+        {
+          UInt32 curAndLenPrice;
+          COptimal *opt;
+          UInt32 offset = cur + 1 + lenTest2;
+          while (lenEnd < offset)
+            p->opt[++lenEnd].price = kInfinityPrice;
+          curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
+          opt = &p->opt[offset];
+          if (curAndLenPrice < opt->price)
+          {
+            opt->price = curAndLenPrice;
+            opt->posPrev = cur + 1;
+            opt->backPrev = 0;
+            opt->prev1IsChar = True;
+            opt->prev2 = False;
+          }
+        }
+      }
+    }
+    
+    startLen = 2; /* speed optimization */
+    {
+    UInt32 repIndex;
+    for (repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)
+    {
+      UInt32 lenTest;
+      UInt32 lenTestTemp;
+      UInt32 price;
+      const Byte *data2 = data - (reps[repIndex] + 1);
+      if (data[0] != data2[0] || data[1] != data2[1])
+        continue;
+      for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
+      while (lenEnd < cur + lenTest)
+        p->opt[++lenEnd].price = kInfinityPrice;
+      lenTestTemp = lenTest;
+      price = repMatchPrice + GetPureRepPrice(p, repIndex, state, posState);
+      do
+      {
+        UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][lenTest - 2];
+        COptimal *opt = &p->opt[cur + lenTest];
+        if (curAndLenPrice < opt->price)
+        {
+          opt->price = curAndLenPrice;
+          opt->posPrev = cur;
+          opt->backPrev = repIndex;
+          opt->prev1IsChar = False;
+        }
+      }
+      while (--lenTest >= 2);
+      lenTest = lenTestTemp;
+      
+      if (repIndex == 0)
+        startLen = lenTest + 1;
+        
+      /* if (_maxMode) */
+        {
+          UInt32 lenTest2 = lenTest + 1;
+          UInt32 limit = lenTest2 + p->numFastBytes;
+          UInt32 nextRepMatchPrice;
+          if (limit > numAvailFull)
+            limit = numAvailFull;
+          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
+          lenTest2 -= lenTest + 1;
+          if (lenTest2 >= 2)
+          {
+            UInt32 state2 = kRepNextStates[state];
+            UInt32 posStateNext = (position + lenTest) & p->pbMask;
+            UInt32 curAndLenCharPrice =
+                price + p->repLenEnc.prices[posState][lenTest - 2] +
+                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
+                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
+                    data[lenTest], data2[lenTest], p->ProbPrices);
+            state2 = kLiteralNextStates[state2];
+            posStateNext = (position + lenTest + 1) & p->pbMask;
+            nextRepMatchPrice = curAndLenCharPrice +
+                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
+                GET_PRICE_1(p->isRep[state2]);
+            
+            /* for (; lenTest2 >= 2; lenTest2--) */
+            {
+              UInt32 curAndLenPrice;
+              COptimal *opt;
+              UInt32 offset = cur + lenTest + 1 + lenTest2;
+              while (lenEnd < offset)
+                p->opt[++lenEnd].price = kInfinityPrice;
+              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
+              opt = &p->opt[offset];
+              if (curAndLenPrice < opt->price)
+              {
+                opt->price = curAndLenPrice;
+                opt->posPrev = cur + lenTest + 1;
+                opt->backPrev = 0;
+                opt->prev1IsChar = True;
+                opt->prev2 = True;
+                opt->posPrev2 = cur;
+                opt->backPrev2 = repIndex;
+              }
+            }
+          }
+        }
+    }
+    }
+    /* for (UInt32 lenTest = 2; lenTest <= newLen; lenTest++) */
+    if (newLen > numAvail)
+    {
+      newLen = numAvail;
+      for (numPairs = 0; newLen > matches[numPairs]; numPairs += 2);
+      matches[numPairs] = newLen;
+      numPairs += 2;
+    }
+    if (newLen >= startLen)
+    {
+      UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[state]);
+      UInt32 offs, curBack, posSlot;
+      UInt32 lenTest;
+      while (lenEnd < cur + newLen)
+        p->opt[++lenEnd].price = kInfinityPrice;
+
+      offs = 0;
+      while (startLen > matches[offs])
+        offs += 2;
+      curBack = matches[offs + 1];
+      GetPosSlot2(curBack, posSlot);
+      for (lenTest = /*2*/ startLen; ; lenTest++)
+      {
+        UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][lenTest - LZMA_MATCH_LEN_MIN];
+        UInt32 lenToPosState = GetLenToPosState(lenTest);
+        COptimal *opt;
+        if (curBack < kNumFullDistances)
+          curAndLenPrice += p->distancesPrices[lenToPosState][curBack];
+        else
+          curAndLenPrice += p->posSlotPrices[lenToPosState][posSlot] + p->alignPrices[curBack & kAlignMask];
+        
+        opt = &p->opt[cur + lenTest];
+        if (curAndLenPrice < opt->price)
+        {
+          opt->price = curAndLenPrice;
+          opt->posPrev = cur;
+          opt->backPrev = curBack + LZMA_NUM_REPS;
+          opt->prev1IsChar = False;
+        }
+
+        if (/*_maxMode && */lenTest == matches[offs])
+        {
+          /* Try Match + Literal + Rep0 */
+          const Byte *data2 = data - (curBack + 1);
+          UInt32 lenTest2 = lenTest + 1;
+          UInt32 limit = lenTest2 + p->numFastBytes;
+          UInt32 nextRepMatchPrice;
+          if (limit > numAvailFull)
+            limit = numAvailFull;
+          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
+          lenTest2 -= lenTest + 1;
+          if (lenTest2 >= 2)
+          {
+            UInt32 state2 = kMatchNextStates[state];
+            UInt32 posStateNext = (position + lenTest) & p->pbMask;
+            UInt32 curAndLenCharPrice = curAndLenPrice +
+                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
+                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
+                    data[lenTest], data2[lenTest], p->ProbPrices);
+            state2 = kLiteralNextStates[state2];
+            posStateNext = (posStateNext + 1) & p->pbMask;
+            nextRepMatchPrice = curAndLenCharPrice +
+                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
+                GET_PRICE_1(p->isRep[state2]);
+            
+            /* for (; lenTest2 >= 2; lenTest2--) */
+            {
+              UInt32 offset = cur + lenTest + 1 + lenTest2;
+              UInt32 curAndLenPrice;
+              COptimal *opt;
+              while (lenEnd < offset)
+                p->opt[++lenEnd].price = kInfinityPrice;
+              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
+              opt = &p->opt[offset];
+              if (curAndLenPrice < opt->price)
+              {
+                opt->price = curAndLenPrice;
+                opt->posPrev = cur + lenTest + 1;
+                opt->backPrev = 0;
+                opt->prev1IsChar = True;
+                opt->prev2 = True;
+                opt->posPrev2 = cur;
+                opt->backPrev2 = curBack + LZMA_NUM_REPS;
+              }
+            }
+          }
+          offs += 2;
+          if (offs == numPairs)
+            break;
+          curBack = matches[offs + 1];
+          if (curBack >= kNumFullDistances)
+            GetPosSlot2(curBack, posSlot);
+        }
+      }
+    }
+  }
+}
+
+#define ChangePair(smallDist, bigDist) (((bigDist) >> 7) > (smallDist))
+
+static UInt32 GetOptimumFast(CLzmaEnc *p, UInt32 *backRes)
+{
+  UInt32 numAvail, mainLen, mainDist, numPairs, repIndex, repLen, i;
+  const Byte *data;
+  const UInt32 *matches;
+
+  if (p->additionalOffset == 0)
+    mainLen = ReadMatchDistances(p, &numPairs);
+  else
+  {
+    mainLen = p->longestMatchLength;
+    numPairs = p->numPairs;
+  }
+
+  numAvail = p->numAvail;
+  *backRes = (UInt32)-1;
+  if (numAvail < 2)
+    return 1;
+  if (numAvail > LZMA_MATCH_LEN_MAX)
+    numAvail = LZMA_MATCH_LEN_MAX;
+  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
+
+  repLen = repIndex = 0;
+  for (i = 0; i < LZMA_NUM_REPS; i++)
+  {
+    UInt32 len;
+    const Byte *data2 = data - (p->reps[i] + 1);
+    if (data[0] != data2[0] || data[1] != data2[1])
+      continue;
+    for (len = 2; len < numAvail && data[len] == data2[len]; len++);
+    if (len >= p->numFastBytes)
+    {
+      *backRes = i;
+      MovePos(p, len - 1);
+      return len;
+    }
+    if (len > repLen)
+    {
+      repIndex = i;
+      repLen = len;
+    }
+  }
+
+  matches = p->matches;
+  if (mainLen >= p->numFastBytes)
+  {
+    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
+    MovePos(p, mainLen - 1);
+    return mainLen;
+  }
+
+  mainDist = 0; /* for GCC */
+  if (mainLen >= 2)
+  {
+    mainDist = matches[numPairs - 1];
+    while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)
+    {
+      if (!ChangePair(matches[numPairs - 3], mainDist))
+        break;
+      numPairs -= 2;
+      mainLen = matches[numPairs - 2];
+      mainDist = matches[numPairs - 1];
+    }
+    if (mainLen == 2 && mainDist >= 0x80)
+      mainLen = 1;
+  }
+
+  if (repLen >= 2 && (
+        (repLen + 1 >= mainLen) ||
+        (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||
+        (repLen + 3 >= mainLen && mainDist >= (1 << 15))))
+  {
+    *backRes = repIndex;
+    MovePos(p, repLen - 1);
+    return repLen;
+  }
+  
+  if (mainLen < 2 || numAvail <= 2)
+    return 1;
+
+  p->longestMatchLength = ReadMatchDistances(p, &p->numPairs);
+  if (p->longestMatchLength >= 2)
+  {
+    UInt32 newDistance = matches[p->numPairs - 1];
+    if ((p->longestMatchLength >= mainLen && newDistance < mainDist) ||
+        (p->longestMatchLength == mainLen + 1 && !ChangePair(mainDist, newDistance)) ||
+        (p->longestMatchLength > mainLen + 1) ||
+        (p->longestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance, mainDist)))
+      return 1;
+  }
+  
+  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
+  for (i = 0; i < LZMA_NUM_REPS; i++)
+  {
+    UInt32 len, limit;
+    const Byte *data2 = data - (p->reps[i] + 1);
+    if (data[0] != data2[0] || data[1] != data2[1])
+      continue;
+    limit = mainLen - 1;
+    for (len = 2; len < limit && data[len] == data2[len]; len++);
+    if (len >= limit)
+      return 1;
+  }
+  *backRes = mainDist + LZMA_NUM_REPS;
+  MovePos(p, mainLen - 2);
+  return mainLen;
+}
+
+static void WriteEndMarker(CLzmaEnc *p, UInt32 posState)
+{
+  UInt32 len;
+  RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
+  RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
+  p->state = kMatchNextStates[p->state];
+  len = LZMA_MATCH_LEN_MIN;
+  LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
+  RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 << kNumPosSlotBits) - 1);
+  RangeEnc_EncodeDirectBits(&p->rc, (((UInt32)1 << 30) - 1) >> kNumAlignBits, 30 - kNumAlignBits);
+  RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, kAlignMask);
+}
+
+static SRes CheckErrors(CLzmaEnc *p)
+{
+  if (p->result != SZ_OK)
+    return p->result;
+  if (p->rc.res != SZ_OK)
+    p->result = SZ_ERROR_WRITE;
+  if (p->matchFinderBase.result != SZ_OK)
+    p->result = SZ_ERROR_READ;
+  if (p->result != SZ_OK)
+    p->finished = True;
+  return p->result;
+}
+
+static SRes Flush(CLzmaEnc *p, UInt32 nowPos)
+{
+  /* ReleaseMFStream(); */
+  p->finished = True;
+  if (p->writeEndMark)
+    WriteEndMarker(p, nowPos & p->pbMask);
+  RangeEnc_FlushData(&p->rc);
+  RangeEnc_FlushStream(&p->rc);
+  return CheckErrors(p);
+}
+
+static void FillAlignPrices(CLzmaEnc *p)
+{
+  UInt32 i;
+  for (i = 0; i < kAlignTableSize; i++)
+    p->alignPrices[i] = RcTree_ReverseGetPrice(p->posAlignEncoder, kNumAlignBits, i, p->ProbPrices);
+  p->alignPriceCount = 0;
+}
+
+static void FillDistancesPrices(CLzmaEnc *p)
+{
+  UInt32 tempPrices[kNumFullDistances];
+  UInt32 i, lenToPosState;
+  for (i = kStartPosModelIndex; i < kNumFullDistances; i++)
+  {
+    UInt32 posSlot = GetPosSlot1(i);
+    UInt32 footerBits = ((posSlot >> 1) - 1);
+    UInt32 base = ((2 | (posSlot & 1)) << footerBits);
+    tempPrices[i] = RcTree_ReverseGetPrice(p->posEncoders + base - posSlot - 1, footerBits, i - base, p->ProbPrices);
+  }
+
+  for (lenToPosState = 0; lenToPosState < kNumLenToPosStates; lenToPosState++)
+  {
+    UInt32 posSlot;
+    const CLzmaProb *encoder = p->posSlotEncoder[lenToPosState];
+    UInt32 *posSlotPrices = p->posSlotPrices[lenToPosState];
+    for (posSlot = 0; posSlot < p->distTableSize; posSlot++)
+      posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, p->ProbPrices);
+    for (posSlot = kEndPosModelIndex; posSlot < p->distTableSize; posSlot++)
+      posSlotPrices[posSlot] += ((((posSlot >> 1) - 1) - kNumAlignBits) << kNumBitPriceShiftBits);
+
+    {
+      UInt32 *distancesPrices = p->distancesPrices[lenToPosState];
+      UInt32 i;
+      for (i = 0; i < kStartPosModelIndex; i++)
+        distancesPrices[i] = posSlotPrices[i];
+      for (; i < kNumFullDistances; i++)
+        distancesPrices[i] = posSlotPrices[GetPosSlot1(i)] + tempPrices[i];
+    }
+  }
+  p->matchPriceCount = 0;
+}
+
+void LzmaEnc_Construct(CLzmaEnc *p)
+{
+  RangeEnc_Construct(&p->rc);
+  MatchFinder_Construct(&p->matchFinderBase);
+  #ifdef COMPRESS_MF_MT
+  MatchFinderMt_Construct(&p->matchFinderMt);
+  p->matchFinderMt.MatchFinder = &p->matchFinderBase;
+  #endif
+
+  {
+    CLzmaEncProps props;
+    LzmaEncProps_Init(&props);
+    LzmaEnc_SetProps(p, &props);
+  }
+
+  #ifndef LZMA_LOG_BSR
+  LzmaEnc_FastPosInit(p->g_FastPos);
+  #endif
+
+  LzmaEnc_InitPriceTables(p->ProbPrices);
+  p->litProbs = 0;
+  p->saveState.litProbs = 0;
+}
+
+CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc)
+{
+  void *p;
+  p = alloc->Alloc(alloc, sizeof(CLzmaEnc));
+  if (p != 0)
+    LzmaEnc_Construct((CLzmaEnc *)p);
+  return p;
+}
+
+void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
+{
+  alloc->Free(alloc, p->litProbs);
+  alloc->Free(alloc, p->saveState.litProbs);
+  p->litProbs = 0;
+  p->saveState.litProbs = 0;
+}
+
+void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  #ifdef COMPRESS_MF_MT
+  MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
+  #endif
+  MatchFinder_Free(&p->matchFinderBase, allocBig);
+  LzmaEnc_FreeLits(p, alloc);
+  RangeEnc_Free(&p->rc, alloc);
+}
+
+void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  LzmaEnc_Destruct((CLzmaEnc *)p, alloc, allocBig);
+  alloc->Free(alloc, p);
+}
+
+static SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p, Bool useLimits, UInt32 maxPackSize, UInt32 maxUnpackSize)
+{
+  UInt32 nowPos32, startPos32;
+  if (p->inStream != 0)
+  {
+    p->matchFinderBase.stream = p->inStream;
+    p->matchFinder.Init(p->matchFinderObj);
+    p->inStream = 0;
+  }
+
+  if (p->finished)
+    return p->result;
+  RINOK(CheckErrors(p));
+
+  nowPos32 = (UInt32)p->nowPos64;
+  startPos32 = nowPos32;
+
+  if (p->nowPos64 == 0)
+  {
+    UInt32 numPairs;
+    Byte curByte;
+    if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
+      return Flush(p, nowPos32);
+    ReadMatchDistances(p, &numPairs);
+    RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][0], 0);
+    p->state = kLiteralNextStates[p->state];
+    curByte = p->matchFinder.GetIndexByte(p->matchFinderObj, 0 - p->additionalOffset);
+    LitEnc_Encode(&p->rc, p->litProbs, curByte);
+    p->additionalOffset--;
+    nowPos32++;
+  }
+
+  if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) != 0)
+  for (;;)
+  {
+    UInt32 pos, len, posState;
+
+    if (p->fastMode)
+      len = GetOptimumFast(p, &pos);
+    else
+      len = GetOptimum(p, nowPos32, &pos);
+
+    #ifdef SHOW_STAT2
+    printf("\n pos = %4X,   len = %d   pos = %d", nowPos32, len, pos);
+    #endif
+
+    posState = nowPos32 & p->pbMask;
+    if (len == 1 && pos == (UInt32)-1)
+    {
+      Byte curByte;
+      CLzmaProb *probs;
+      const Byte *data;
+
+      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 0);
+      data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
+      curByte = *data;
+      probs = LIT_PROBS(nowPos32, *(data - 1));
+      if (IsCharState(p->state))
+        LitEnc_Encode(&p->rc, probs, curByte);
+      else
+        LitEnc_EncodeMatched(&p->rc, probs, curByte, *(data - p->reps[0] - 1));
+      p->state = kLiteralNextStates[p->state];
+    }
+    else
+    {
+      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
+      if (pos < LZMA_NUM_REPS)
+      {
+        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 1);
+        if (pos == 0)
+        {
+          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 0);
+          RangeEnc_EncodeBit(&p->rc, &p->isRep0Long[p->state][posState], ((len == 1) ? 0 : 1));
+        }
+        else
+        {
+          UInt32 distance = p->reps[pos];
+          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 1);
+          if (pos == 1)
+            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 0);
+          else
+          {
+            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 1);
+            RangeEnc_EncodeBit(&p->rc, &p->isRepG2[p->state], pos - 2);
+            if (pos == 3)
+              p->reps[3] = p->reps[2];
+            p->reps[2] = p->reps[1];
+          }
+          p->reps[1] = p->reps[0];
+          p->reps[0] = distance;
+        }
+        if (len == 1)
+          p->state = kShortRepNextStates[p->state];
+        else
+        {
+          LenEnc_Encode2(&p->repLenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
+          p->state = kRepNextStates[p->state];
+        }
+      }
+      else
+      {
+        UInt32 posSlot;
+        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
+        p->state = kMatchNextStates[p->state];
+        LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
+        pos -= LZMA_NUM_REPS;
+        GetPosSlot(pos, posSlot);
+        RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);
+        
+        if (posSlot >= kStartPosModelIndex)
+        {
+          UInt32 footerBits = ((posSlot >> 1) - 1);
+          UInt32 base = ((2 | (posSlot & 1)) << footerBits);
+          UInt32 posReduced = pos - base;
+
+          if (posSlot < kEndPosModelIndex)
+            RcTree_ReverseEncode(&p->rc, p->posEncoders + base - posSlot - 1, footerBits, posReduced);
+          else
+          {
+            RangeEnc_EncodeDirectBits(&p->rc, posReduced >> kNumAlignBits, footerBits - kNumAlignBits);
+            RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, posReduced & kAlignMask);
+            p->alignPriceCount++;
+          }
+        }
+        p->reps[3] = p->reps[2];
+        p->reps[2] = p->reps[1];
+        p->reps[1] = p->reps[0];
+        p->reps[0] = pos;
+        p->matchPriceCount++;
+      }
+    }
+    p->additionalOffset -= len;
+    nowPos32 += len;
+    if (p->additionalOffset == 0)
+    {
+      UInt32 processed;
+      if (!p->fastMode)
+      {
+        if (p->matchPriceCount >= (1 << 7))
+          FillDistancesPrices(p);
+        if (p->alignPriceCount >= kAlignTableSize)
+          FillAlignPrices(p);
+      }
+      if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
+        break;
+      processed = nowPos32 - startPos32;
+      if (useLimits)
+      {
+        if (processed + kNumOpts + 300 >= maxUnpackSize ||
+            RangeEnc_GetProcessed(&p->rc) + kNumOpts * 2 >= maxPackSize)
+          break;
+      }
+      else if (processed >= (1 << 15))
+      {
+        p->nowPos64 += nowPos32 - startPos32;
+        return CheckErrors(p);
+      }
+    }
+  }
+  p->nowPos64 += nowPos32 - startPos32;
+  return Flush(p, nowPos32);
+}
+
+#define kBigHashDicLimit ((UInt32)1 << 24)
+
+static SRes LzmaEnc_Alloc(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  UInt32 beforeSize = kNumOpts;
+  if (!RangeEnc_Alloc(&p->rc, alloc))
+    return SZ_ERROR_MEM;
+  #ifdef COMPRESS_MF_MT
+  Bool btMode;
+  btMode = (p->matchFinderBase.btMode != 0);
+  p->mtMode = (p->multiThread && !p->fastMode && btMode);
+  #endif
+
+  {
+    unsigned lclp = p->lc + p->lp;
+    if (p->litProbs == 0 || p->saveState.litProbs == 0 || p->lclp != lclp)
+    {
+      LzmaEnc_FreeLits(p, alloc);
+      p->litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
+      p->saveState.litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
+      if (p->litProbs == 0 || p->saveState.litProbs == 0)
+      {
+        LzmaEnc_FreeLits(p, alloc);
+        return SZ_ERROR_MEM;
+      }
+      p->lclp = lclp;
+    }
+  }
+
+  p->matchFinderBase.bigHash = (p->dictSize > kBigHashDicLimit);
+
+  if (beforeSize + p->dictSize < keepWindowSize)
+    beforeSize = keepWindowSize - p->dictSize;
+
+  #ifdef COMPRESS_MF_MT
+  if (p->mtMode)
+  {
+    RINOK(MatchFinderMt_Create(&p->matchFinderMt, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig));
+    p->matchFinderObj = &p->matchFinderMt;
+    MatchFinderMt_CreateVTable(&p->matchFinderMt, &p->matchFinder);
+  }
+  else
+  #endif
+  {
+    if (!MatchFinder_Create(&p->matchFinderBase, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))
+      return SZ_ERROR_MEM;
+    p->matchFinderObj = &p->matchFinderBase;
+    MatchFinder_CreateVTable(&p->matchFinderBase, &p->matchFinder);
+  }
+  return SZ_OK;
+}
+
+void LzmaEnc_Init(CLzmaEnc *p)
+{
+  UInt32 i;
+  p->state = 0;
+  for (i = 0 ; i < LZMA_NUM_REPS; i++)
+    p->reps[i] = 0;
+
+  RangeEnc_Init(&p->rc);
+
+
+  for (i = 0; i < kNumStates; i++)
+  {
+    UInt32 j;
+    for (j = 0; j < LZMA_NUM_PB_STATES_MAX; j++)
+    {
+      p->isMatch[i][j] = kProbInitValue;
+      p->isRep0Long[i][j] = kProbInitValue;
+    }
+    p->isRep[i] = kProbInitValue;
+    p->isRepG0[i] = kProbInitValue;
+    p->isRepG1[i] = kProbInitValue;
+    p->isRepG2[i] = kProbInitValue;
+  }
+
+  {
+    UInt32 num = 0x300 << (p->lp + p->lc);
+    for (i = 0; i < num; i++)
+      p->litProbs[i] = kProbInitValue;
+  }
+
+  {
+    for (i = 0; i < kNumLenToPosStates; i++)
+    {
+      CLzmaProb *probs = p->posSlotEncoder[i];
+      UInt32 j;
+      for (j = 0; j < (1 << kNumPosSlotBits); j++)
+        probs[j] = kProbInitValue;
+    }
+  }
+  {
+    for (i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
+      p->posEncoders[i] = kProbInitValue;
+  }
+
+  LenEnc_Init(&p->lenEnc.p);
+  LenEnc_Init(&p->repLenEnc.p);
+
+  for (i = 0; i < (1 << kNumAlignBits); i++)
+    p->posAlignEncoder[i] = kProbInitValue;
+
+  p->optimumEndIndex = 0;
+  p->optimumCurrentIndex = 0;
+  p->additionalOffset = 0;
+
+  p->pbMask = (1 << p->pb) - 1;
+  p->lpMask = (1 << p->lp) - 1;
+}
+
+void LzmaEnc_InitPrices(CLzmaEnc *p)
+{
+  if (!p->fastMode)
+  {
+    FillDistancesPrices(p);
+    FillAlignPrices(p);
+  }
+
+  p->lenEnc.tableSize =
+  p->repLenEnc.tableSize =
+      p->numFastBytes + 1 - LZMA_MATCH_LEN_MIN;
+  LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, p->ProbPrices);
+  LenPriceEnc_UpdateTables(&p->repLenEnc, 1 << p->pb, p->ProbPrices);
+}
+
+static SRes LzmaEnc_AllocAndInit(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  UInt32 i;
+  for (i = 0; i < (UInt32)kDicLogSizeMaxCompress; i++)
+    if (p->dictSize <= ((UInt32)1 << i))
+      break;
+  p->distTableSize = i * 2;
+
+  p->finished = False;
+  p->result = SZ_OK;
+  RINOK(LzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig));
+  LzmaEnc_Init(p);
+  LzmaEnc_InitPrices(p);
+  p->nowPos64 = 0;
+  return SZ_OK;
+}
+
+static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqInStream *inStream, ISeqOutStream *outStream,
+    ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  p->inStream = inStream;
+  p->rc.outStream = outStream;
+  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
+}
+
+SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
+    ISeqInStream *inStream, UInt32 keepWindowSize,
+    ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  p->inStream = inStream;
+  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
+}
+
+static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
+{
+  p->seqBufInStream.funcTable.Read = MyRead;
+  p->seqBufInStream.data = src;
+  p->seqBufInStream.rem = srcLen;
+}
+
+SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
+    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  LzmaEnc_SetInputBuf(p, src, srcLen);
+  p->inStream = &p->seqBufInStream.funcTable;
+  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
+}
+
+void LzmaEnc_Finish(CLzmaEncHandle pp)
+{
+  #ifdef COMPRESS_MF_MT
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  if (p->mtMode)
+    MatchFinderMt_ReleaseStream(&p->matchFinderMt);
+  #else
+  pp = pp;
+  #endif
+}
+
+typedef struct _CSeqOutStreamBuf
+{
+  ISeqOutStream funcTable;
+  Byte *data;
+  SizeT rem;
+  Bool overflow;
+} CSeqOutStreamBuf;
+
+static size_t MyWrite(void *pp, const void *data, size_t size)
+{
+  CSeqOutStreamBuf *p = (CSeqOutStreamBuf *)pp;
+  if (p->rem < size)
+  {
+    size = p->rem;
+    p->overflow = True;
+  }
+  memcpy(p->data, data, size);
+  p->rem -= size;
+  p->data += size;
+  return size;
+}
+
+
+UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
+{
+  const CLzmaEnc *p = (CLzmaEnc *)pp;
+  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
+}
+
+const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
+{
+  const CLzmaEnc *p = (CLzmaEnc *)pp;
+  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
+}
+
+SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
+    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  UInt64 nowPos64;
+  SRes res;
+  CSeqOutStreamBuf outStream;
+
+  outStream.funcTable.Write = MyWrite;
+  outStream.data = dest;
+  outStream.rem = *destLen;
+  outStream.overflow = False;
+
+  p->writeEndMark = False;
+  p->finished = False;
+  p->result = SZ_OK;
+
+  if (reInit)
+    LzmaEnc_Init(p);
+  LzmaEnc_InitPrices(p);
+  nowPos64 = p->nowPos64;
+  RangeEnc_Init(&p->rc);
+  p->rc.outStream = &outStream.funcTable;
+
+  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
+  
+  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
+  *destLen -= outStream.rem;
+  if (outStream.overflow)
+    return SZ_ERROR_OUTPUT_EOF;
+
+  return res;
+}
+
+SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
+    ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  SRes res = SZ_OK;
+
+  #ifdef COMPRESS_MF_MT
+  Byte allocaDummy[0x300];
+  int i = 0;
+  for (i = 0; i < 16; i++)
+    allocaDummy[i] = (Byte)i;
+  #endif
+
+  RINOK(LzmaEnc_Prepare(pp, inStream, outStream, alloc, allocBig));
+
+  for (;;)
+  {
+    res = LzmaEnc_CodeOneBlock(p, False, 0, 0);
+    if (res != SZ_OK || p->finished != 0)
+      break;
+    if (progress != 0)
+    {
+      res = progress->Progress(progress, p->nowPos64, RangeEnc_GetProcessed(&p->rc));
+      if (res != SZ_OK)
+      {
+        res = SZ_ERROR_PROGRESS;
+        break;
+      }
+    }
+  }
+  LzmaEnc_Finish(pp);
+  return res;
+}
+
+SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
+{
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+  int i;
+  UInt32 dictSize = p->dictSize;
+  if (*size < LZMA_PROPS_SIZE)
+    return SZ_ERROR_PARAM;
+  *size = LZMA_PROPS_SIZE;
+  props[0] = (Byte)((p->pb * 5 + p->lp) * 9 + p->lc);
+
+  for (i = 11; i <= 30; i++)
+  {
+    if (dictSize <= ((UInt32)2 << i))
+    {
+      dictSize = (2 << i);
+      break;
+    }
+    if (dictSize <= ((UInt32)3 << i))
+    {
+      dictSize = (3 << i);
+      break;
+    }
+  }
+
+  for (i = 0; i < 4; i++)
+    props[1 + i] = (Byte)(dictSize >> (8 * i));
+  return SZ_OK;
+}
+
+SRes LzmaEnc_MemEncode(CLzmaEncHandle pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  SRes res;
+  CLzmaEnc *p = (CLzmaEnc *)pp;
+
+  CSeqOutStreamBuf outStream;
+
+  LzmaEnc_SetInputBuf(p, src, srcLen);
+
+  outStream.funcTable.Write = MyWrite;
+  outStream.data = dest;
+  outStream.rem = *destLen;
+  outStream.overflow = False;
+
+  p->writeEndMark = writeEndMark;
+  res = LzmaEnc_Encode(pp, &outStream.funcTable, &p->seqBufInStream.funcTable,
+      progress, alloc, allocBig);
+
+  *destLen -= outStream.rem;
+  if (outStream.overflow)
+    return SZ_ERROR_OUTPUT_EOF;
+  return res;
+}
+
+SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
+{
+  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
+  SRes res;
+  if (p == 0)
+    return SZ_ERROR_MEM;
+
+  res = LzmaEnc_SetProps(p, props);
+  if (res == SZ_OK)
+  {
+    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
+    if (res == SZ_OK)
+      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
+          writeEndMark, progress, alloc, allocBig);
+  }
+
+  LzmaEnc_Destroy(p, alloc, allocBig);
+  return res;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaEnc.h squashfs-tools-patched/LZMA/lzma465/C/LzmaEnc.h
--- squashfs-tools/LZMA/lzma465/C/LzmaEnc.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaEnc.h	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,72 @@
+/*  LzmaEnc.h -- LZMA Encoder
+2008-10-04 : Igor Pavlov : Public domain */
+
+#ifndef __LZMAENC_H
+#define __LZMAENC_H
+
+#include "Types.h"
+
+#define LZMA_PROPS_SIZE 5
+
+typedef struct _CLzmaEncProps
+{
+  int level;       /*  0 <= level <= 9 */
+  UInt32 dictSize; /* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version
+                      (1 << 12) <= dictSize <= (1 << 30) for 64-bit version
+                       default = (1 << 24) */
+  int lc;          /* 0 <= lc <= 8, default = 3 */
+  int lp;          /* 0 <= lp <= 4, default = 0 */
+  int pb;          /* 0 <= pb <= 4, default = 2 */
+  int algo;        /* 0 - fast, 1 - normal, default = 1 */
+  int fb;          /* 5 <= fb <= 273, default = 32 */
+  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
+  int numHashBytes; /* 2, 3 or 4, default = 4 */
+  UInt32 mc;        /* 1 <= mc <= (1 << 30), default = 32 */
+  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
+  int numThreads;  /* 1 or 2, default = 2 */
+} CLzmaEncProps;
+
+void LzmaEncProps_Init(CLzmaEncProps *p);
+void LzmaEncProps_Normalize(CLzmaEncProps *p);
+UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
+
+
+/* ---------- CLzmaEncHandle Interface ---------- */
+
+/* LzmaEnc_* functions can return the following exit codes:
+Returns:
+  SZ_OK           - OK
+  SZ_ERROR_MEM    - Memory allocation error
+  SZ_ERROR_PARAM  - Incorrect paramater in props
+  SZ_ERROR_WRITE  - Write callback error.
+  SZ_ERROR_PROGRESS - some break from progress callback
+  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
+*/
+
+typedef void * CLzmaEncHandle;
+
+CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc);
+void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
+SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
+SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
+SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+
+/* ---------- One Call Interface ---------- */
+
+/* LzmaEncode
+Return code:
+  SZ_OK               - OK
+  SZ_ERROR_MEM        - Memory allocation error
+  SZ_ERROR_PARAM      - Incorrect paramater
+  SZ_ERROR_OUTPUT_EOF - output buffer overflow
+  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
+*/
+
+SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaLib/LzmaLib.def squashfs-tools-patched/LZMA/lzma465/C/LzmaLib/LzmaLib.def
--- squashfs-tools/LZMA/lzma465/C/LzmaLib/LzmaLib.def	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaLib/LzmaLib.def	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,4 @@
+EXPORTS
+  LzmaCompress
+  LzmaUncompress
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaLib/LzmaLib.dsp squashfs-tools-patched/LZMA/lzma465/C/LzmaLib/LzmaLib.dsp
--- squashfs-tools/LZMA/lzma465/C/LzmaLib/LzmaLib.dsp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaLib/LzmaLib.dsp	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,178 @@
+# Microsoft Developer Studio Project File - Name="LzmaLib" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
+
+CFG=LzmaLib - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "LzmaLib.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "LzmaLib.mak" CFG="LzmaLib - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "LzmaLib - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE "LzmaLib - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+MTL=midl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "LzmaLib - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "LZMALIB_EXPORTS" /YX /FD /c
+# ADD CPP /nologo /Gr /MT /W3 /O2 /D "NDEBUG" /D "WIN32" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "LZMALIB_EXPORTS" /D "COMPRESS_MF_MT" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x419 /d "NDEBUG"
+# ADD RSC /l 0x419 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386 /out:"C:\Util\LZMA.dll" /opt:NOWIN98
+# SUBTRACT LINK32 /pdb:none
+
+!ELSEIF  "$(CFG)" == "LzmaLib - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "LZMALIB_EXPORTS" /YX /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /ZI /Od /D "_DEBUG" /D "WIN32" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "LZMALIB_EXPORTS" /D "COMPRESS_MF_MT" /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x419 /d "_DEBUG"
+# ADD RSC /l 0x419 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /out:"C:\Util\LZMA.dll" /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "LzmaLib - Win32 Release"
+# Name "LzmaLib - Win32 Debug"
+# Begin Group "Spec"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\LzmaLib.def
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaLibExports.c
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=..\Alloc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\Alloc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\IStream.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFind.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFind.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFindMt.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFindMt.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzHash.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaDec.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaDec.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaEnc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaEnc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaLib.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaLib.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\resource.rc
+# End Source File
+# Begin Source File
+
+SOURCE=..\Threads.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\Threads.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\Types.h
+# End Source File
+# End Target
+# End Project
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaLib/LzmaLib.dsw squashfs-tools-patched/LZMA/lzma465/C/LzmaLib/LzmaLib.dsw
--- squashfs-tools/LZMA/lzma465/C/LzmaLib/LzmaLib.dsw	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaLib/LzmaLib.dsw	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,29 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "LzmaLib"=.\LzmaLib.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaLib/LzmaLibExports.c squashfs-tools-patched/LZMA/lzma465/C/LzmaLib/LzmaLibExports.c
--- squashfs-tools/LZMA/lzma465/C/LzmaLib/LzmaLibExports.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaLib/LzmaLibExports.c	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,12 @@
+/* LzmaLibExports.c -- LZMA library DLL Entry point
+2008-10-04 : Igor Pavlov : Public domain */
+
+#include <windows.h>
+
+BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
+{
+  hInstance = hInstance;
+  dwReason = dwReason;
+  lpReserved = lpReserved;
+  return TRUE;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaLib/makefile squashfs-tools-patched/LZMA/lzma465/C/LzmaLib/makefile
--- squashfs-tools/LZMA/lzma465/C/LzmaLib/makefile	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaLib/makefile	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,37 @@
+MY_STATIC_LINK=1
+SLIB = sLZMA.lib
+PROG = LZMA.dll
+SLIBPATH = $O\$(SLIB)
+
+DEF_FILE = LzmaLib.def
+CFLAGS = $(CFLAGS) \
+  -DCOMPRESS_MF_MT \
+
+LIBS = $(LIBS) oleaut32.lib
+
+LIB_OBJS = \
+  $O\LzmaLibExports.obj \
+
+C_OBJS = \
+  $O\Alloc.obj \
+  $O\LzFind.obj \
+  $O\LzFindMt.obj \
+  $O\LzmaDec.obj \
+  $O\LzmaEnc.obj \
+  $O\LzmaLib.obj \
+  $O\Threads.obj \
+
+OBJS = \
+  $(LIB_OBJS) \
+  $(C_OBJS) \
+  $O\resource.res
+
+!include "../../CPP/Build.mak"
+
+$(SLIBPATH): $O $(OBJS)
+	lib -out:$(SLIBPATH) $(OBJS) $(LIBS)
+
+$(LIB_OBJS): $(*B).c
+	$(COMPL_O2)
+$(C_OBJS): ../$(*B).c
+	$(COMPL_O2)
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaLib/resource.rc squashfs-tools-patched/LZMA/lzma465/C/LzmaLib/resource.rc
--- squashfs-tools/LZMA/lzma465/C/LzmaLib/resource.rc	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaLib/resource.rc	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,4 @@
+#include "../../CPP/7zip/MyVersionInfo.rc"
+
+MY_VERSION_INFO_DLL("LZMA library", "LZMA")
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaLib.c squashfs-tools-patched/LZMA/lzma465/C/LzmaLib.c
--- squashfs-tools/LZMA/lzma465/C/LzmaLib.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaLib.c	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,46 @@
+/* LzmaLib.c -- LZMA library wrapper
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#include "LzmaEnc.h"
+#include "LzmaDec.h"
+#include "Alloc.h"
+#include "LzmaLib.h"
+
+static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
+static void SzFree(void *p, void *address) { p = p; MyFree(address); }
+static ISzAlloc g_Alloc = { SzAlloc, SzFree };
+
+MY_STDAPI LzmaCompress(unsigned char *dest, size_t  *destLen, const unsigned char *src, size_t  srcLen,
+  unsigned char *outProps, size_t *outPropsSize,
+  int level, /* 0 <= level <= 9, default = 5 */
+  unsigned dictSize, /* use (1 << N) or (3 << N). 4 KB < dictSize <= 128 MB */
+  int lc, /* 0 <= lc <= 8, default = 3  */
+  int lp, /* 0 <= lp <= 4, default = 0  */
+  int pb, /* 0 <= pb <= 4, default = 2  */
+  int fb,  /* 5 <= fb <= 273, default = 32 */
+  int numThreads /* 1 or 2, default = 2 */
+)
+{
+  CLzmaEncProps props;
+  LzmaEncProps_Init(&props);
+  props.level = level;
+  props.dictSize = dictSize;
+  props.lc = lc;
+  props.lp = lp;
+  props.pb = pb;
+  props.fb = fb;
+  props.numThreads = numThreads;
+
+  return LzmaEncode(dest, destLen, src, srcLen, &props, outProps, outPropsSize, 0,
+      NULL, &g_Alloc, &g_Alloc);
+}
+
+
+MY_STDAPI LzmaUncompress(unsigned char *dest, size_t  *destLen, const unsigned char *src, size_t  *srcLen,
+  const unsigned char *props, size_t propsSize)
+{
+  ELzmaStatus status;
+  return LzmaDecode(dest, destLen, src, srcLen, props, (unsigned)propsSize, LZMA_FINISH_ANY, &status, &g_Alloc);
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaLib.h squashfs-tools-patched/LZMA/lzma465/C/LzmaLib.h
--- squashfs-tools/LZMA/lzma465/C/LzmaLib.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaLib.h	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,135 @@
+/* LzmaLib.h -- LZMA library interface
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#ifndef __LZMALIB_H
+#define __LZMALIB_H
+
+#include "Types.h"
+
+#ifdef __cplusplus
+  #define MY_EXTERN_C extern "C"
+#else
+  #define MY_EXTERN_C extern
+#endif
+
+#define MY_STDAPI MY_EXTERN_C int MY_STD_CALL
+
+#define LZMA_PROPS_SIZE 5
+
+/*
+RAM requirements for LZMA:
+  for compression:   (dictSize * 11.5 + 6 MB) + state_size
+  for decompression: dictSize + state_size
+    state_size = (4 + (1.5 << (lc + lp))) KB
+    by default (lc=3, lp=0), state_size = 16 KB.
+
+LZMA properties (5 bytes) format
+    Offset Size  Description
+      0     1    lc, lp and pb in encoded form.
+      1     4    dictSize (little endian).
+*/
+
+/*
+LzmaCompress
+------------
+
+outPropsSize -
+     In:  the pointer to the size of outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.
+     Out: the pointer to the size of written properties in outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.
+
+  LZMA Encoder will use defult values for any parameter, if it is
+  -1  for any from: level, loc, lp, pb, fb, numThreads
+   0  for dictSize
+  
+level - compression level: 0 <= level <= 9;
+
+  level dictSize algo  fb
+    0:    16 KB   0    32
+    1:    64 KB   0    32
+    2:   256 KB   0    32
+    3:     1 MB   0    32
+    4:     4 MB   0    32
+    5:    16 MB   1    32
+    6:    32 MB   1    32
+    7+:   64 MB   1    64
+ 
+  The default value for "level" is 5.
+
+  algo = 0 means fast method
+  algo = 1 means normal method
+
+dictSize - The dictionary size in bytes. The maximum value is
+        128 MB = (1 << 27) bytes for 32-bit version
+          1 GB = (1 << 30) bytes for 64-bit version
+     The default value is 16 MB = (1 << 24) bytes.
+     It's recommended to use the dictionary that is larger than 4 KB and
+     that can be calculated as (1 << N) or (3 << N) sizes.
+
+lc - The number of literal context bits (high bits of previous literal).
+     It can be in the range from 0 to 8. The default value is 3.
+     Sometimes lc=4 gives the gain for big files.
+
+lp - The number of literal pos bits (low bits of current position for literals).
+     It can be in the range from 0 to 4. The default value is 0.
+     The lp switch is intended for periodical data when the period is equal to 2^lp.
+     For example, for 32-bit (4 bytes) periodical data you can use lp=2. Often it's
+     better to set lc=0, if you change lp switch.
+
+pb - The number of pos bits (low bits of current position).
+     It can be in the range from 0 to 4. The default value is 2.
+     The pb switch is intended for periodical data when the period is equal 2^pb.
+
+fb - Word size (the number of fast bytes).
+     It can be in the range from 5 to 273. The default value is 32.
+     Usually, a big number gives a little bit better compression ratio and
+     slower compression process.
+
+numThreads - The number of thereads. 1 or 2. The default value is 2.
+     Fast mode (algo = 0) can use only 1 thread.
+
+Out:
+  destLen  - processed output size
+Returns:
+  SZ_OK               - OK
+  SZ_ERROR_MEM        - Memory allocation error
+  SZ_ERROR_PARAM      - Incorrect paramater
+  SZ_ERROR_OUTPUT_EOF - output buffer overflow
+  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
+*/
+
+MY_STDAPI LzmaCompress(unsigned char *dest, size_t *destLen, const unsigned char *src, size_t srcLen,
+  unsigned char *outProps, size_t *outPropsSize, /* *outPropsSize must be = 5 */
+  int level,      /* 0 <= level <= 9, default = 5 */
+  unsigned dictSize,  /* default = (1 << 24) */
+  int lc,        /* 0 <= lc <= 8, default = 3  */
+  int lp,        /* 0 <= lp <= 4, default = 0  */
+  int pb,        /* 0 <= pb <= 4, default = 2  */
+  int fb,        /* 5 <= fb <= 273, default = 32 */
+  int numThreads /* 1 or 2, default = 2 */
+  );
+
+/*
+LzmaUncompress
+--------------
+In:
+  dest     - output data
+  destLen  - output data size
+  src      - input data
+  srcLen   - input data size
+Out:
+  destLen  - processed output size
+  srcLen   - processed input size
+Returns:
+  SZ_OK                - OK
+  SZ_ERROR_DATA        - Data error
+  SZ_ERROR_MEM         - Memory allocation arror
+  SZ_ERROR_UNSUPPORTED - Unsupported properties
+  SZ_ERROR_INPUT_EOF   - it needs more bytes in input buffer (src)
+*/
+
+MY_STDAPI LzmaUncompress(unsigned char *dest, size_t *destLen, const unsigned char *src, SizeT *srcLen,
+  const unsigned char *props, size_t propsSize);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaUtil/Lzma86Dec.c squashfs-tools-patched/LZMA/lzma465/C/LzmaUtil/Lzma86Dec.c
--- squashfs-tools/LZMA/lzma465/C/LzmaUtil/Lzma86Dec.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaUtil/Lzma86Dec.c	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,61 @@
+/* Lzma86Dec.c -- LZMA + x86 (BCJ) Filter Decoder
+2008-04-07
+Igor Pavlov
+Public domain */
+
+#include "Lzma86Dec.h"
+
+#include "../Alloc.h"
+#include "../Bra.h"
+#include "../LzmaDec.h"
+
+#define LZMA86_SIZE_OFFSET (1 + LZMA_PROPS_SIZE)
+#define LZMA86_HEADER_SIZE (LZMA86_SIZE_OFFSET + 8)
+
+static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
+static void SzFree(void *p, void *address) { p = p; MyFree(address); }
+static ISzAlloc g_Alloc = { SzAlloc, SzFree };
+
+SRes Lzma86_GetUnpackSize(const Byte *src, SizeT srcLen, UInt64 *unpackSize)
+{
+  unsigned i;
+  if (srcLen < LZMA86_HEADER_SIZE)
+    return SZ_ERROR_INPUT_EOF;
+  *unpackSize = 0;
+  for (i = 0; i < sizeof(UInt64); i++)
+    *unpackSize += ((UInt64)src[LZMA86_SIZE_OFFSET + i]) << (8 * i);
+  return SZ_OK;
+}
+
+SRes Lzma86_Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen)
+{
+  SRes res;
+  int useFilter;
+  SizeT inSizePure;
+  ELzmaStatus status;
+
+  if (*srcLen < LZMA86_HEADER_SIZE)
+    return SZ_ERROR_INPUT_EOF;
+
+  useFilter = src[0];
+
+  if (useFilter > 1)
+  {
+    *destLen = 0;
+    return SZ_ERROR_UNSUPPORTED;
+  }
+
+  inSizePure = *srcLen - LZMA86_HEADER_SIZE;
+  res = LzmaDecode(dest, destLen, src + LZMA86_HEADER_SIZE, &inSizePure,
+      src + 1, LZMA_PROPS_SIZE, LZMA_FINISH_ANY, &status, &g_Alloc);
+  *srcLen = inSizePure + LZMA86_HEADER_SIZE;
+  if (res != SZ_OK)
+    return res;
+  if (useFilter == 1)
+  {
+    UInt32 x86State;
+    x86_Convert_Init(x86State);
+    x86_Convert(dest, *destLen, 0, &x86State, 0);
+  }
+  return SZ_OK;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaUtil/Lzma86Dec.h squashfs-tools-patched/LZMA/lzma465/C/LzmaUtil/Lzma86Dec.h
--- squashfs-tools/LZMA/lzma465/C/LzmaUtil/Lzma86Dec.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaUtil/Lzma86Dec.h	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,45 @@
+/* Lzma86Dec.h -- LZMA + x86 (BCJ) Filter Decoder
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#ifndef __LZMA86DEC_H
+#define __LZMA86DEC_H
+
+#include "../Types.h"
+
+/*
+Lzma86_GetUnpackSize:
+  In:
+    src      - input data
+    srcLen   - input data size
+  Out:
+    unpackSize - size of uncompressed stream
+  Return code:
+    SZ_OK               - OK
+    SZ_ERROR_INPUT_EOF  - Error in headers
+*/
+
+SRes Lzma86_GetUnpackSize(const Byte *src, SizeT srcLen, UInt64 *unpackSize);
+
+/*
+Lzma86_Decode:
+  In:
+    dest     - output data
+    destLen  - output data size
+    src      - input data
+    srcLen   - input data size
+  Out:
+    destLen  - processed output size
+    srcLen   - processed input size
+  Return code:
+    SZ_OK           - OK
+    SZ_ERROR_DATA  - Data error
+    SZ_ERROR_MEM   - Memory allocation error
+    SZ_ERROR_UNSUPPORTED - unsupported file
+    SZ_ERROR_INPUT_EOF - it needs more bytes in input buffer
+*/
+
+SRes Lzma86_Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaUtil/Lzma86Enc.c squashfs-tools-patched/LZMA/lzma465/C/LzmaUtil/Lzma86Enc.c
--- squashfs-tools/LZMA/lzma465/C/LzmaUtil/Lzma86Enc.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaUtil/Lzma86Enc.c	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,113 @@
+/* Lzma86Enc.c -- LZMA + x86 (BCJ) Filter Encoder
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#include <string.h>
+
+#include "Lzma86Enc.h"
+
+#include "../Alloc.h"
+#include "../Bra.h"
+#include "../LzmaEnc.h"
+
+#define SZE_OUT_OVERFLOW SZE_DATA_ERROR
+
+static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
+static void SzFree(void *p, void *address) { p = p; MyFree(address); }
+static ISzAlloc g_Alloc = { SzAlloc, SzFree };
+
+#define LZMA86_SIZE_OFFSET (1 + LZMA_PROPS_SIZE)
+#define LZMA86_HEADER_SIZE (LZMA86_SIZE_OFFSET + 8)
+
+int Lzma86_Encode(Byte *dest, size_t *destLen, const Byte *src, size_t srcLen,
+    int level, UInt32 dictSize, int filterMode)
+{
+  size_t outSize2 = *destLen;
+  Byte *filteredStream;
+  Bool useFilter;
+  int mainResult = SZ_ERROR_OUTPUT_EOF;
+  CLzmaEncProps props;
+  LzmaEncProps_Init(&props);
+  props.level = level;
+  props.dictSize = dictSize;
+  
+  *destLen = 0;
+  if (outSize2 < LZMA86_HEADER_SIZE)
+    return SZ_ERROR_OUTPUT_EOF;
+
+  {
+    int i;
+    UInt64 t = srcLen;
+    for (i = 0; i < 8; i++, t >>= 8)
+      dest[LZMA86_SIZE_OFFSET + i] = (Byte)t;
+  }
+
+  filteredStream = 0;
+  useFilter = (filterMode != SZ_FILTER_NO);
+  if (useFilter)
+  {
+    if (srcLen != 0)
+    {
+      filteredStream = (Byte *)MyAlloc(srcLen);
+      if (filteredStream == 0)
+        return SZ_ERROR_MEM;
+      memcpy(filteredStream, src, srcLen);
+    }
+    {
+      UInt32 x86State;
+      x86_Convert_Init(x86State);
+      x86_Convert(filteredStream, srcLen, 0, &x86State, 1);
+    }
+  }
+
+  {
+    size_t minSize = 0;
+    Bool bestIsFiltered = False;
+
+    /* passes for SZ_FILTER_AUTO:
+        0 - BCJ + LZMA
+        1 - LZMA
+        2 - BCJ + LZMA agaian, if pass 0 (BCJ + LZMA) is better.
+    */
+    int numPasses = (filterMode == SZ_FILTER_AUTO) ? 3 : 1;
+
+    int i;
+    for (i = 0; i < numPasses; i++)
+    {
+      size_t outSizeProcessed = outSize2 - LZMA86_HEADER_SIZE;
+      size_t outPropsSize = 5;
+      SRes curRes;
+      Bool curModeIsFiltered = (numPasses > 1 && i == numPasses - 1);
+      if (curModeIsFiltered && !bestIsFiltered)
+        break;
+      if (useFilter && i == 0)
+        curModeIsFiltered = True;
+      
+      curRes = LzmaEncode(dest + LZMA86_HEADER_SIZE, &outSizeProcessed,
+          curModeIsFiltered ? filteredStream : src, srcLen,
+          &props, dest + 1, &outPropsSize, 0,
+          NULL, &g_Alloc, &g_Alloc);
+      
+      if (curRes != SZ_ERROR_OUTPUT_EOF)
+      {
+        if (curRes != SZ_OK)
+        {
+          mainResult = curRes;
+          break;
+        }
+        if (outSizeProcessed <= minSize || mainResult != SZ_OK)
+        {
+          minSize = outSizeProcessed;
+          bestIsFiltered = curModeIsFiltered;
+          mainResult = SZ_OK;
+        }
+      }
+    }
+    dest[0] = (bestIsFiltered ? 1 : 0);
+    *destLen = LZMA86_HEADER_SIZE + minSize;
+  }
+  if (useFilter)
+    MyFree(filteredStream);
+  return mainResult;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaUtil/Lzma86Enc.h squashfs-tools-patched/LZMA/lzma465/C/LzmaUtil/Lzma86Enc.h
--- squashfs-tools/LZMA/lzma465/C/LzmaUtil/Lzma86Enc.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaUtil/Lzma86Enc.h	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,72 @@
+/* Lzma86Enc.h -- LZMA + x86 (BCJ) Filter Encoder
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#ifndef __LZMA86ENC_H
+#define __LZMA86ENC_H
+
+#include "../Types.h"
+
+/*
+It's an example for LZMA + x86 Filter use.
+You can use .lzma86 extension, if you write that stream to file.
+.lzma86 header adds one additional byte to standard .lzma header.
+.lzma86 header (14 bytes):
+  Offset Size  Description
+    0     1    = 0 - no filter,
+               = 1 - x86 filter
+    1     1    lc, lp and pb in encoded form
+    2     4    dictSize (little endian)
+    6     8    uncompressed size (little endian)
+
+
+Lzma86_Encode
+-------------
+level - compression level: 0 <= level <= 9, the default value for "level" is 5.
+
+
+dictSize - The dictionary size in bytes. The maximum value is
+        128 MB = (1 << 27) bytes for 32-bit version
+          1 GB = (1 << 30) bytes for 64-bit version
+     The default value is 16 MB = (1 << 24) bytes, for level = 5.
+     It's recommended to use the dictionary that is larger than 4 KB and
+     that can be calculated as (1 << N) or (3 << N) sizes.
+     For better compression ratio dictSize must be >= inSize.
+
+filterMode:
+    SZ_FILTER_NO   - no Filter
+    SZ_FILTER_YES  - x86 Filter
+    SZ_FILTER_AUTO - it tries both alternatives to select best.
+              Encoder will use 2 or 3 passes:
+              2 passes when FILTER_NO provides better compression.
+              3 passes when FILTER_YES provides better compression.
+
+Lzma86Encode allocates Data with MyAlloc functions.
+RAM Requirements for compressing:
+  RamSize = dictionarySize * 11.5 + 6MB + FilterBlockSize
+      filterMode     FilterBlockSize
+     SZ_FILTER_NO         0
+     SZ_FILTER_YES      inSize
+     SZ_FILTER_AUTO     inSize
+
+
+Return code:
+  SZ_OK               - OK
+  SZ_ERROR_MEM        - Memory allocation error
+  SZ_ERROR_PARAM      - Incorrect paramater
+  SZ_ERROR_OUTPUT_EOF - output buffer overflow
+  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
+*/
+
+enum ESzFilterMode
+{
+  SZ_FILTER_NO,
+  SZ_FILTER_YES,
+  SZ_FILTER_AUTO
+};
+
+SRes Lzma86_Encode(Byte *dest, size_t *destLen, const Byte *src, size_t srcLen,
+    int level, UInt32 dictSize, int filterMode);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaUtil/LzmaUtil.c squashfs-tools-patched/LZMA/lzma465/C/LzmaUtil/LzmaUtil.c
--- squashfs-tools/LZMA/lzma465/C/LzmaUtil/LzmaUtil.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaUtil/LzmaUtil.c	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,254 @@
+/* LzmaUtil.c -- Test application for LZMA compression
+2008-11-23 : Igor Pavlov : Public domain */
+
+#define _CRT_SECURE_NO_WARNINGS
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "../Alloc.h"
+#include "../7zFile.h"
+#include "../7zVersion.h"
+#include "../LzmaDec.h"
+#include "../LzmaEnc.h"
+
+const char *kCantReadMessage = "Can not read input file";
+const char *kCantWriteMessage = "Can not write output file";
+const char *kCantAllocateMessage = "Can not allocate memory";
+const char *kDataErrorMessage = "Data error";
+
+static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
+static void SzFree(void *p, void *address) { p = p; MyFree(address); }
+static ISzAlloc g_Alloc = { SzAlloc, SzFree };
+
+void PrintHelp(char *buffer)
+{
+  strcat(buffer, "\nLZMA Utility " MY_VERSION_COPYRIGHT_DATE "\n"
+      "\nUsage:  lzma <e|d> inputFile outputFile\n"
+             "  e: encode file\n"
+             "  d: decode file\n");
+}
+
+int PrintError(char *buffer, const char *message)
+{
+  strcat(buffer, "\nError: ");
+  strcat(buffer, message);
+  strcat(buffer, "\n");
+  return 1;
+}
+
+int PrintErrorNumber(char *buffer, SRes val)
+{
+  sprintf(buffer + strlen(buffer), "\nError code: %x\n", (unsigned)val);
+  return 1;
+}
+
+int PrintUserError(char *buffer)
+{
+  return PrintError(buffer, "Incorrect command");
+}
+
+#define IN_BUF_SIZE (1 << 16)
+#define OUT_BUF_SIZE (1 << 16)
+
+static SRes Decode2(CLzmaDec *state, ISeqOutStream *outStream, ISeqInStream *inStream,
+    UInt64 unpackSize)
+{
+  int thereIsSize = (unpackSize != (UInt64)(Int64)-1);
+  Byte inBuf[IN_BUF_SIZE];
+  Byte outBuf[OUT_BUF_SIZE];
+  size_t inPos = 0, inSize = 0, outPos = 0;
+  LzmaDec_Init(state);
+  for (;;)
+  {
+    if (inPos == inSize)
+    {
+      inSize = IN_BUF_SIZE;
+      RINOK(inStream->Read(inStream, inBuf, &inSize));
+      inPos = 0;
+    }
+    {
+      SRes res;
+      SizeT inProcessed = inSize - inPos;
+      SizeT outProcessed = OUT_BUF_SIZE - outPos;
+      ELzmaFinishMode finishMode = LZMA_FINISH_ANY;
+      ELzmaStatus status;
+      if (thereIsSize && outProcessed > unpackSize)
+      {
+        outProcessed = (SizeT)unpackSize;
+        finishMode = LZMA_FINISH_END;
+      }
+      
+      res = LzmaDec_DecodeToBuf(state, outBuf + outPos, &outProcessed,
+        inBuf + inPos, &inProcessed, finishMode, &status);
+      inPos += inProcessed;
+      outPos += outProcessed;
+      unpackSize -= outProcessed;
+      
+      if (outStream)
+        if (outStream->Write(outStream, outBuf, outPos) != outPos)
+          return SZ_ERROR_WRITE;
+        
+      outPos = 0;
+      
+      if (res != SZ_OK || thereIsSize && unpackSize == 0)
+        return res;
+      
+      if (inProcessed == 0 && outProcessed == 0)
+      {
+        if (thereIsSize || status != LZMA_STATUS_FINISHED_WITH_MARK)
+          return SZ_ERROR_DATA;
+        return res;
+      }
+    }
+  }
+}
+
+static SRes Decode(ISeqOutStream *outStream, ISeqInStream *inStream)
+{
+  UInt64 unpackSize;
+  int i;
+  SRes res = 0;
+
+  CLzmaDec state;
+
+  /* header: 5 bytes of LZMA properties and 8 bytes of uncompressed size */
+  unsigned char header[LZMA_PROPS_SIZE + 8];
+
+  /* Read and parse header */
+
+  RINOK(SeqInStream_Read(inStream, header, sizeof(header)));
+
+  unpackSize = 0;
+  for (i = 0; i < 8; i++)
+    unpackSize += (UInt64)header[LZMA_PROPS_SIZE + i] << (i * 8);
+
+  LzmaDec_Construct(&state);
+  RINOK(LzmaDec_Allocate(&state, header, LZMA_PROPS_SIZE, &g_Alloc));
+  res = Decode2(&state, outStream, inStream, unpackSize);
+  LzmaDec_Free(&state, &g_Alloc);
+  return res;
+}
+
+static SRes Encode(ISeqOutStream *outStream, ISeqInStream *inStream, UInt64 fileSize, char *rs)
+{
+  CLzmaEncHandle enc;
+  SRes res;
+  CLzmaEncProps props;
+
+  rs = rs;
+
+  enc = LzmaEnc_Create(&g_Alloc);
+  if (enc == 0)
+    return SZ_ERROR_MEM;
+
+  LzmaEncProps_Init(&props);
+  res = LzmaEnc_SetProps(enc, &props);
+
+  if (res == SZ_OK)
+  {
+    Byte header[LZMA_PROPS_SIZE + 8];
+    size_t headerSize = LZMA_PROPS_SIZE;
+    int i;
+
+    res = LzmaEnc_WriteProperties(enc, header, &headerSize);
+    for (i = 0; i < 8; i++)
+      header[headerSize++] = (Byte)(fileSize >> (8 * i));
+    if (outStream->Write(outStream, header, headerSize) != headerSize)
+      res = SZ_ERROR_WRITE;
+    else
+    {
+      if (res == SZ_OK)
+        res = LzmaEnc_Encode(enc, outStream, inStream, NULL, &g_Alloc, &g_Alloc);
+    }
+  }
+  LzmaEnc_Destroy(enc, &g_Alloc, &g_Alloc);
+  return res;
+}
+
+int main2(int numArgs, const char *args[], char *rs)
+{
+  CFileSeqInStream inStream;
+  CFileOutStream outStream;
+  char c;
+  int res;
+  int encodeMode;
+  Bool useOutFile = False;
+
+  FileSeqInStream_CreateVTable(&inStream);
+  File_Construct(&inStream.file);
+
+  FileOutStream_CreateVTable(&outStream);
+  File_Construct(&outStream.file);
+
+  if (numArgs == 1)
+  {
+    PrintHelp(rs);
+    return 0;
+  }
+
+  if (numArgs < 3 || numArgs > 4 || strlen(args[1]) != 1)
+    return PrintUserError(rs);
+
+  c = args[1][0];
+  encodeMode = (c == 'e' || c == 'E');
+  if (!encodeMode && c != 'd' && c != 'D')
+    return PrintUserError(rs);
+
+  {
+    size_t t4 = sizeof(UInt32);
+    size_t t8 = sizeof(UInt64);
+    if (t4 != 4 || t8 != 8)
+      return PrintError(rs, "Incorrect UInt32 or UInt64");
+  }
+
+  if (InFile_Open(&inStream.file, args[2]) != 0)
+    return PrintError(rs, "Can not open input file");
+
+  if (numArgs > 3)
+  {
+    useOutFile = True;
+    if (OutFile_Open(&outStream.file, args[3]) != 0)
+      return PrintError(rs, "Can not open output file");
+  }
+  else if (encodeMode)
+    PrintUserError(rs);
+
+  if (encodeMode)
+  {
+    UInt64 fileSize;
+    File_GetLength(&inStream.file, &fileSize);
+    res = Encode(&outStream.s, &inStream.s, fileSize, rs);
+  }
+  else
+  {
+    res = Decode(&outStream.s, useOutFile ? &inStream.s : NULL);
+  }
+
+  if (useOutFile)
+    File_Close(&outStream.file);
+  File_Close(&inStream.file);
+
+  if (res != SZ_OK)
+  {
+    if (res == SZ_ERROR_MEM)
+      return PrintError(rs, kCantAllocateMessage);
+    else if (res == SZ_ERROR_DATA)
+      return PrintError(rs, kDataErrorMessage);
+    else if (res == SZ_ERROR_WRITE)
+      return PrintError(rs, kCantWriteMessage);
+    else if (res == SZ_ERROR_READ)
+      return PrintError(rs, kCantReadMessage);
+    return PrintErrorNumber(rs, res);
+  }
+  return 0;
+}
+
+int MY_CDECL main(int numArgs, const char *args[])
+{
+  char rs[800] = { 0 };
+  int res = main2(numArgs, args, rs);
+  printf(rs);
+  return res;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaUtil/LzmaUtil.dsp squashfs-tools-patched/LZMA/lzma465/C/LzmaUtil/LzmaUtil.dsp
--- squashfs-tools/LZMA/lzma465/C/LzmaUtil/LzmaUtil.dsp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaUtil/LzmaUtil.dsp	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,168 @@
+# Microsoft Developer Studio Project File - Name="LzmaUtil" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=LzmaUtil - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "LzmaUtil.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "LzmaUtil.mak" CFG="LzmaUtil - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "LzmaUtil - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "LzmaUtil - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "LzmaUtil - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MT /W3 /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x419 /d "NDEBUG"
+# ADD RSC /l 0x419 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:"c:\util\lzmac.exe"
+
+!ELSEIF  "$(CFG)" == "LzmaUtil - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x419 /d "_DEBUG"
+# ADD RSC /l 0x419 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:"c:\util\lzmac.exe" /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "LzmaUtil - Win32 Release"
+# Name "LzmaUtil - Win32 Debug"
+# Begin Source File
+
+SOURCE=..\7zFile.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\7zFile.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\7zStream.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\7zVersion.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\Alloc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\Alloc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\CpuArch.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFind.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFind.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFindMt.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzFindMt.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzHash.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaDec.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaDec.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaEnc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\LzmaEnc.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaUtil.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\Threads.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\Threads.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\Types.h
+# End Source File
+# End Target
+# End Project
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaUtil/LzmaUtil.dsw squashfs-tools-patched/LZMA/lzma465/C/LzmaUtil/LzmaUtil.dsw
--- squashfs-tools/LZMA/lzma465/C/LzmaUtil/LzmaUtil.dsw	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaUtil/LzmaUtil.dsw	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,29 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "LzmaUtil"=.\LzmaUtil.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaUtil/makefile squashfs-tools-patched/LZMA/lzma465/C/LzmaUtil/makefile
--- squashfs-tools/LZMA/lzma465/C/LzmaUtil/makefile	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaUtil/makefile	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,29 @@
+MY_STATIC_LINK=1
+PROG = LZMAc.exe
+
+CFLAGS = $(CFLAGS) \
+  -DCOMPRESS_MF_MT \
+
+LIB_OBJS = \
+  $O\LzmaUtil.obj \
+
+C_OBJS = \
+  $O\Alloc.obj \
+  $O\LzFind.obj \
+  $O\LzFindMt.obj \
+  $O\LzmaDec.obj \
+  $O\LzmaEnc.obj \
+  $O\7zFile.obj \
+  $O\7zStream.obj \
+  $O\Threads.obj \
+
+OBJS = \
+  $(LIB_OBJS) \
+  $(C_OBJS) \
+
+!include "../../CPP/Build.mak"
+
+$(LIB_OBJS): $(*B).c
+	$(COMPL_O2)
+$(C_OBJS): ../$(*B).c
+	$(COMPL_O2)
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/LzmaUtil/makefile.gcc squashfs-tools-patched/LZMA/lzma465/C/LzmaUtil/makefile.gcc
--- squashfs-tools/LZMA/lzma465/C/LzmaUtil/makefile.gcc	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/LzmaUtil/makefile.gcc	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,44 @@
+PROG = lzma
+CXX = g++
+LIB =
+RM = rm -f
+CFLAGS = -c -O2 -Wall
+
+OBJS = \
+  LzmaUtil.o \
+  Alloc.o \
+  LzFind.o \
+  LzmaDec.o \
+  LzmaEnc.o \
+  7zFile.o \
+  7zStream.o \
+
+
+all: $(PROG)
+
+$(PROG): $(OBJS)
+	$(CXX) -o $(PROG) $(LDFLAGS) $(OBJS) $(LIB) $(LIB2)
+
+LzmaUtil.o: LzmaUtil.c
+	$(CXX) $(CFLAGS) LzmaUtil.c
+
+Alloc.o: ../Alloc.c
+	$(CXX) $(CFLAGS) ../Alloc.c
+
+LzFind.o: ../LzFind.c
+	$(CXX) $(CFLAGS) ../LzFind.c
+
+LzmaDec.o: ../LzmaDec.c
+	$(CXX) $(CFLAGS) ../LzmaDec.c
+
+LzmaEnc.o: ../LzmaEnc.c
+	$(CXX) $(CFLAGS) ../LzmaEnc.c
+
+7zFile.o: ../7zFile.c
+	$(CXX) $(CFLAGS) ../7zFile.c
+
+7zStream.o: ../7zStream.c
+	$(CXX) $(CFLAGS) ../7zStream.c
+
+clean:
+	-$(RM) $(PROG) $(OBJS)
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Threads.c squashfs-tools-patched/LZMA/lzma465/C/Threads.c
--- squashfs-tools/LZMA/lzma465/C/Threads.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Threads.c	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,109 @@
+/* Threads.c -- multithreading library
+2008-08-05
+Igor Pavlov
+Public domain */
+
+#include "Threads.h"
+#include <process.h>
+
+static WRes GetError()
+{
+  DWORD res = GetLastError();
+  return (res) ? (WRes)(res) : 1;
+}
+
+WRes HandleToWRes(HANDLE h) { return (h != 0) ? 0 : GetError(); }
+WRes BOOLToWRes(BOOL v) { return v ? 0 : GetError(); }
+
+static WRes MyCloseHandle(HANDLE *h)
+{
+  if (*h != NULL)
+    if (!CloseHandle(*h))
+      return GetError();
+  *h = NULL;
+  return 0;
+}
+
+WRes Thread_Create(CThread *thread, THREAD_FUNC_RET_TYPE (THREAD_FUNC_CALL_TYPE *startAddress)(void *), LPVOID parameter)
+{
+  unsigned threadId; /* Windows Me/98/95: threadId parameter may not be NULL in _beginthreadex/CreateThread functions */
+  thread->handle =
+    /* CreateThread(0, 0, startAddress, parameter, 0, &threadId); */
+    (HANDLE)_beginthreadex(NULL, 0, startAddress, parameter, 0, &threadId);
+    /* maybe we must use errno here, but probably GetLastError() is also OK. */
+  return HandleToWRes(thread->handle);
+}
+
+WRes WaitObject(HANDLE h)
+{
+  return (WRes)WaitForSingleObject(h, INFINITE);
+}
+
+WRes Thread_Wait(CThread *thread)
+{
+  if (thread->handle == NULL)
+    return 1;
+  return WaitObject(thread->handle);
+}
+
+WRes Thread_Close(CThread *thread)
+{
+  return MyCloseHandle(&thread->handle);
+}
+
+WRes Event_Create(CEvent *p, BOOL manualReset, int initialSignaled)
+{
+  p->handle = CreateEvent(NULL, manualReset, (initialSignaled ? TRUE : FALSE), NULL);
+  return HandleToWRes(p->handle);
+}
+
+WRes ManualResetEvent_Create(CManualResetEvent *p, int initialSignaled)
+  { return Event_Create(p, TRUE, initialSignaled); }
+WRes ManualResetEvent_CreateNotSignaled(CManualResetEvent *p)
+  { return ManualResetEvent_Create(p, 0); }
+
+WRes AutoResetEvent_Create(CAutoResetEvent *p, int initialSignaled)
+  { return Event_Create(p, FALSE, initialSignaled); }
+WRes AutoResetEvent_CreateNotSignaled(CAutoResetEvent *p)
+  { return AutoResetEvent_Create(p, 0); }
+
+WRes Event_Set(CEvent *p) { return BOOLToWRes(SetEvent(p->handle)); }
+WRes Event_Reset(CEvent *p) { return BOOLToWRes(ResetEvent(p->handle)); }
+WRes Event_Wait(CEvent *p) { return WaitObject(p->handle); }
+WRes Event_Close(CEvent *p) { return MyCloseHandle(&p->handle); }
+
+
+WRes Semaphore_Create(CSemaphore *p, UInt32 initiallyCount, UInt32 maxCount)
+{
+  p->handle = CreateSemaphore(NULL, (LONG)initiallyCount, (LONG)maxCount, NULL);
+  return HandleToWRes(p->handle);
+}
+
+WRes Semaphore_Release(CSemaphore *p, LONG releaseCount, LONG *previousCount)
+{
+  return BOOLToWRes(ReleaseSemaphore(p->handle, releaseCount, previousCount));
+}
+WRes Semaphore_ReleaseN(CSemaphore *p, UInt32 releaseCount)
+{
+  return Semaphore_Release(p, (LONG)releaseCount, NULL);
+}
+WRes Semaphore_Release1(CSemaphore *p)
+{
+  return Semaphore_ReleaseN(p, 1);
+}
+
+WRes Semaphore_Wait(CSemaphore *p) { return WaitObject(p->handle); }
+WRes Semaphore_Close(CSemaphore *p) { return MyCloseHandle(&p->handle); }
+
+WRes CriticalSection_Init(CCriticalSection *p)
+{
+  /* InitializeCriticalSection can raise only STATUS_NO_MEMORY exception */
+  __try
+  {
+    InitializeCriticalSection(p);
+    /* InitializeCriticalSectionAndSpinCount(p, 0); */
+  }
+  __except (EXCEPTION_EXECUTE_HANDLER) { return 1; }
+  return 0;
+}
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Threads.h squashfs-tools-patched/LZMA/lzma465/C/Threads.h
--- squashfs-tools/LZMA/lzma465/C/Threads.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Threads.h	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,68 @@
+/* Threads.h -- multithreading library
+2008-11-22 : Igor Pavlov : Public domain */
+
+#ifndef __7Z_THRESDS_H
+#define __7Z_THRESDS_H
+
+#include "Types.h"
+
+typedef struct _CThread
+{
+  HANDLE handle;
+} CThread;
+
+#define Thread_Construct(thread) (thread)->handle = NULL
+#define Thread_WasCreated(thread) ((thread)->handle != NULL)
+ 
+typedef unsigned THREAD_FUNC_RET_TYPE;
+#define THREAD_FUNC_CALL_TYPE MY_STD_CALL
+#define THREAD_FUNC_DECL THREAD_FUNC_RET_TYPE THREAD_FUNC_CALL_TYPE
+
+WRes Thread_Create(CThread *thread, THREAD_FUNC_RET_TYPE (THREAD_FUNC_CALL_TYPE *startAddress)(void *), LPVOID parameter);
+WRes Thread_Wait(CThread *thread);
+WRes Thread_Close(CThread *thread);
+
+typedef struct _CEvent
+{
+  HANDLE handle;
+} CEvent;
+
+typedef CEvent CAutoResetEvent;
+typedef CEvent CManualResetEvent;
+
+#define Event_Construct(event) (event)->handle = NULL
+#define Event_IsCreated(event) ((event)->handle != NULL)
+
+WRes ManualResetEvent_Create(CManualResetEvent *event, int initialSignaled);
+WRes ManualResetEvent_CreateNotSignaled(CManualResetEvent *event);
+WRes AutoResetEvent_Create(CAutoResetEvent *event, int initialSignaled);
+WRes AutoResetEvent_CreateNotSignaled(CAutoResetEvent *event);
+WRes Event_Set(CEvent *event);
+WRes Event_Reset(CEvent *event);
+WRes Event_Wait(CEvent *event);
+WRes Event_Close(CEvent *event);
+
+
+typedef struct _CSemaphore
+{
+  HANDLE handle;
+} CSemaphore;
+
+#define Semaphore_Construct(p) (p)->handle = NULL
+
+WRes Semaphore_Create(CSemaphore *p, UInt32 initiallyCount, UInt32 maxCount);
+WRes Semaphore_ReleaseN(CSemaphore *p, UInt32 num);
+WRes Semaphore_Release1(CSemaphore *p);
+WRes Semaphore_Wait(CSemaphore *p);
+WRes Semaphore_Close(CSemaphore *p);
+
+
+typedef CRITICAL_SECTION CCriticalSection;
+
+WRes CriticalSection_Init(CCriticalSection *p);
+#define CriticalSection_Delete(p) DeleteCriticalSection(p)
+#define CriticalSection_Enter(p) EnterCriticalSection(p)
+#define CriticalSection_Leave(p) LeaveCriticalSection(p)
+
+#endif
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/C/Types.h squashfs-tools-patched/LZMA/lzma465/C/Types.h
--- squashfs-tools/LZMA/lzma465/C/Types.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/C/Types.h	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,208 @@
+/* Types.h -- Basic types
+2008-11-23 : Igor Pavlov : Public domain */
+
+#ifndef __7Z_TYPES_H
+#define __7Z_TYPES_H
+
+#include <stddef.h>
+
+#ifdef _WIN32
+#include <windows.h>
+#endif
+
+#define SZ_OK 0
+
+#define SZ_ERROR_DATA 1
+#define SZ_ERROR_MEM 2
+#define SZ_ERROR_CRC 3
+#define SZ_ERROR_UNSUPPORTED 4
+#define SZ_ERROR_PARAM 5
+#define SZ_ERROR_INPUT_EOF 6
+#define SZ_ERROR_OUTPUT_EOF 7
+#define SZ_ERROR_READ 8
+#define SZ_ERROR_WRITE 9
+#define SZ_ERROR_PROGRESS 10
+#define SZ_ERROR_FAIL 11
+#define SZ_ERROR_THREAD 12
+
+#define SZ_ERROR_ARCHIVE 16
+#define SZ_ERROR_NO_ARCHIVE 17
+
+typedef int SRes;
+
+#ifdef _WIN32
+typedef DWORD WRes;
+#else
+typedef int WRes;
+#endif
+
+#ifndef RINOK
+#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
+#endif
+
+typedef unsigned char Byte;
+typedef short Int16;
+typedef unsigned short UInt16;
+
+#ifdef _LZMA_UINT32_IS_ULONG
+typedef long Int32;
+typedef unsigned long UInt32;
+#else
+typedef int Int32;
+typedef unsigned int UInt32;
+#endif
+
+#ifdef _SZ_NO_INT_64
+
+/* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
+   NOTES: Some code will work incorrectly in that case! */
+
+typedef long Int64;
+typedef unsigned long UInt64;
+
+#else
+
+#if defined(_MSC_VER) || defined(__BORLANDC__)
+typedef __int64 Int64;
+typedef unsigned __int64 UInt64;
+#else
+typedef long long int Int64;
+typedef unsigned long long int UInt64;
+#endif
+
+#endif
+
+#ifdef _LZMA_NO_SYSTEM_SIZE_T
+typedef UInt32 SizeT;
+#else
+typedef size_t SizeT;
+#endif
+
+typedef int Bool;
+#define True 1
+#define False 0
+
+
+#ifdef _MSC_VER
+
+#if _MSC_VER >= 1300
+#define MY_NO_INLINE __declspec(noinline)
+#else
+#define MY_NO_INLINE
+#endif
+
+#define MY_CDECL __cdecl
+#define MY_STD_CALL __stdcall
+#define MY_FAST_CALL MY_NO_INLINE __fastcall
+
+#else
+
+#define MY_CDECL
+#define MY_STD_CALL
+#define MY_FAST_CALL
+
+#endif
+
+
+/* The following interfaces use first parameter as pointer to structure */
+
+typedef struct
+{
+  SRes (*Read)(void *p, void *buf, size_t *size);
+    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
+       (output(*size) < input(*size)) is allowed */
+} ISeqInStream;
+
+/* it can return SZ_ERROR_INPUT_EOF */
+SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size);
+SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType);
+SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf);
+
+typedef struct
+{
+  size_t (*Write)(void *p, const void *buf, size_t size);
+    /* Returns: result - the number of actually written bytes.
+       (result < size) means error */
+} ISeqOutStream;
+
+typedef enum
+{
+  SZ_SEEK_SET = 0,
+  SZ_SEEK_CUR = 1,
+  SZ_SEEK_END = 2
+} ESzSeek;
+
+typedef struct
+{
+  SRes (*Read)(void *p, void *buf, size_t *size);  /* same as ISeqInStream::Read */
+  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
+} ISeekInStream;
+
+typedef struct
+{
+  SRes (*Look)(void *p, void **buf, size_t *size);
+    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
+       (output(*size) > input(*size)) is not allowed
+       (output(*size) < input(*size)) is allowed */
+  SRes (*Skip)(void *p, size_t offset);
+    /* offset must be <= output(*size) of Look */
+
+  SRes (*Read)(void *p, void *buf, size_t *size);
+    /* reads directly (without buffer). It's same as ISeqInStream::Read */
+  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
+} ILookInStream;
+
+SRes LookInStream_LookRead(ILookInStream *stream, void *buf, size_t *size);
+SRes LookInStream_SeekTo(ILookInStream *stream, UInt64 offset);
+
+/* reads via ILookInStream::Read */
+SRes LookInStream_Read2(ILookInStream *stream, void *buf, size_t size, SRes errorType);
+SRes LookInStream_Read(ILookInStream *stream, void *buf, size_t size);
+
+#define LookToRead_BUF_SIZE (1 << 14)
+
+typedef struct
+{
+  ILookInStream s;
+  ISeekInStream *realStream;
+  size_t pos;
+  size_t size;
+  Byte buf[LookToRead_BUF_SIZE];
+} CLookToRead;
+
+void LookToRead_CreateVTable(CLookToRead *p, int lookahead);
+void LookToRead_Init(CLookToRead *p);
+
+typedef struct
+{
+  ISeqInStream s;
+  ILookInStream *realStream;
+} CSecToLook;
+
+void SecToLook_CreateVTable(CSecToLook *p);
+
+typedef struct
+{
+  ISeqInStream s;
+  ILookInStream *realStream;
+} CSecToRead;
+
+void SecToRead_CreateVTable(CSecToRead *p);
+
+typedef struct
+{
+  SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
+    /* Returns: result. (result != SZ_OK) means break.
+       Value (UInt64)(Int64)-1 for size means unknown value. */
+} ICompressProgress;
+
+typedef struct
+{
+  void *(*Alloc)(void *p, size_t size);
+  void (*Free)(void *p, void *address); /* address can be 0 */
+} ISzAlloc;
+
+#define IAlloc_Alloc(p, size) (p)->Alloc((p), size)
+#define IAlloc_Free(p, a) (p)->Free((p), a)
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/history.txt squashfs-tools-patched/LZMA/lzma465/history.txt
--- squashfs-tools/LZMA/lzma465/history.txt	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/history.txt	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,236 @@
+HISTORY of the LZMA SDK
+-----------------------
+
+4.65           2009-02-03
+-------------------------
+- Some minor fixes
+
+
+4.63           2008-12-31
+-------------------------
+- Some minor fixes
+
+
+4.61 beta      2008-11-23
+-------------------------
+- The bug in ANSI-C LZMA Decoder was fixed:
+    If encoded stream was corrupted, decoder could access memory 
+    outside of allocated range.
+- Some changes in ANSI-C 7z Decoder interfaces.
+- LZMA SDK is placed in the public domain.
+
+
+4.60 beta      2008-08-19
+-------------------------
+- Some minor fixes.
+
+
+4.59 beta      2008-08-13
+-------------------------
+- The bug was fixed:
+    LZMA Encoder in fast compression mode could access memory outside of 
+    allocated range in some rare cases.
+
+
+4.58 beta      2008-05-05
+-------------------------
+- ANSI-C LZMA Decoder was rewritten for speed optimizations.
+- ANSI-C LZMA Encoder was included to LZMA SDK.
+- C++ LZMA code now is just wrapper over ANSI-C code.
+
+
+4.57           2007-12-12
+-------------------------
+- Speed optimizations in Ñ++ LZMA Decoder. 
+- Small changes for more compatibility with some C/C++ compilers.
+
+
+4.49 beta      2007-07-05
+-------------------------
+- .7z ANSI-C Decoder:
+     - now it supports BCJ and BCJ2 filters
+     - now it supports files larger than 4 GB.
+     - now it supports "Last Write Time" field for files.
+- C++ code for .7z archives compressing/decompressing from 7-zip 
+  was included to LZMA SDK.
+  
+
+4.43           2006-06-04
+-------------------------
+- Small changes for more compatibility with some C/C++ compilers.
+  
+
+4.42           2006-05-15
+-------------------------
+- Small changes in .h files in ANSI-C version.
+  
+
+4.39 beta      2006-04-14
+-------------------------
+- The bug in versions 4.33b:4.38b was fixed:
+  C++ version of LZMA encoder could not correctly compress 
+  files larger than 2 GB with HC4 match finder (-mfhc4).
+  
+
+4.37 beta      2005-04-06
+-------------------------
+- Fixes in C++ code: code could no be compiled if _NO_EXCEPTIONS was defined. 
+
+
+4.35 beta      2005-03-02
+-------------------------
+- The bug was fixed in C++ version of LZMA Decoder:
+    If encoded stream was corrupted, decoder could access memory 
+    outside of allocated range.
+
+
+4.34 beta      2006-02-27
+-------------------------
+- Compressing speed and memory requirements for compressing were increased
+- LZMA now can use only these match finders: HC4, BT2, BT3, BT4
+
+
+4.32           2005-12-09
+-------------------------
+- Java version of LZMA SDK was included
+
+
+4.30           2005-11-20
+-------------------------
+- Compression ratio was improved in -a2 mode
+- Speed optimizations for compressing in -a2 mode
+- -fb switch now supports values up to 273
+- The bug in 7z_C (7zIn.c) was fixed:
+  It used Alloc/Free functions from different memory pools.
+  So if program used two memory pools, it worked incorrectly.
+- 7z_C: .7z format supporting was improved
+- LZMA# SDK (C#.NET version) was included
+
+
+4.27 (Updated) 2005-09-21
+-------------------------
+- Some GUIDs/interfaces in C++ were changed.
+ IStream.h:
+   ISequentialInStream::Read now works as old ReadPart
+   ISequentialOutStream::Write now works as old WritePart
+
+
+4.27           2005-08-07
+-------------------------
+- The bug in LzmaDecodeSize.c was fixed:
+   if _LZMA_IN_CB and _LZMA_OUT_READ were defined,
+   decompressing worked incorrectly.
+
+
+4.26           2005-08-05
+-------------------------
+- Fixes in 7z_C code and LzmaTest.c:
+  previous versions could work incorrectly,
+  if malloc(0) returns 0
+
+
+4.23           2005-06-29
+-------------------------
+- Small fixes in C++ code
+
+
+4.22           2005-06-10
+-------------------------
+- Small fixes
+
+
+4.21           2005-06-08
+-------------------------
+- Interfaces for ANSI-C LZMA Decoder (LzmaDecode.c) were changed
+- New additional version of ANSI-C LZMA Decoder with zlib-like interface:
+    - LzmaStateDecode.h
+    - LzmaStateDecode.c
+    - LzmaStateTest.c
+- ANSI-C LZMA Decoder now can decompress files larger than 4 GB
+
+
+4.17           2005-04-18
+-------------------------
+- New example for RAM->RAM compressing/decompressing: 
+  LZMA + BCJ (filter for x86 code):
+    - LzmaRam.h
+    - LzmaRam.cpp
+    - LzmaRamDecode.h
+    - LzmaRamDecode.c
+    - -f86 switch for lzma.exe
+
+
+4.16           2005-03-29
+-------------------------
+- The bug was fixed in LzmaDecode.c (ANSI-C LZMA Decoder): 
+   If _LZMA_OUT_READ was defined, and if encoded stream was corrupted,
+   decoder could access memory outside of allocated range.
+- Speed optimization of ANSI-C LZMA Decoder (now it's about 20% faster).
+  Old version of LZMA Decoder now is in file LzmaDecodeSize.c. 
+  LzmaDecodeSize.c can provide slightly smaller code than LzmaDecode.c
+- Small speed optimization in LZMA C++ code
+- filter for SPARC's code was added
+- Simplified version of .7z ANSI-C Decoder was included
+
+
+4.06           2004-09-05
+-------------------------
+- The bug in v4.05 was fixed:
+    LZMA-Encoder didn't release output stream in some cases.
+
+
+4.05           2004-08-25
+-------------------------
+- Source code of filters for x86, IA-64, ARM, ARM-Thumb 
+  and PowerPC code was included to SDK
+- Some internal minor changes
+
+
+4.04           2004-07-28
+-------------------------
+- More compatibility with some C++ compilers
+
+
+4.03           2004-06-18
+-------------------------
+- "Benchmark" command was added. It measures compressing 
+  and decompressing speed and shows rating values. 
+  Also it checks hardware errors.
+
+
+4.02           2004-06-10
+-------------------------
+- C++ LZMA Encoder/Decoder code now is more portable
+  and it can be compiled by GCC on Linux.
+
+
+4.01           2004-02-15
+-------------------------
+- Some detection of data corruption was enabled.
+    LzmaDecode.c / RangeDecoderReadByte
+    .....
+    {
+      rd->ExtraBytes = 1;
+      return 0xFF;
+    }
+
+
+4.00           2004-02-13
+-------------------------
+- Original version of LZMA SDK
+
+
+
+HISTORY of the LZMA
+-------------------
+  2001-2008:  Improvements to LZMA compressing/decompressing code, 
+              keeping compatibility with original LZMA format
+  1996-2001:  Development of LZMA compression format
+
+  Some milestones:
+
+  2001-08-30: LZMA compression was added to 7-Zip
+  1999-01-02: First version of 7-Zip was released
+  
+
+End of document
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/lzma.txt squashfs-tools-patched/LZMA/lzma465/lzma.txt
--- squashfs-tools/LZMA/lzma465/lzma.txt	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/lzma.txt	2022-01-01 15:08:47.873171447 +0800
@@ -0,0 +1,594 @@
+LZMA SDK 4.65
+-------------
+
+LZMA SDK provides the documentation, samples, header files, libraries, 
+and tools you need to develop applications that use LZMA compression.
+
+LZMA is default and general compression method of 7z format
+in 7-Zip compression program (www.7-zip.org). LZMA provides high 
+compression ratio and very fast decompression.
+
+LZMA is an improved version of famous LZ77 compression algorithm. 
+It was improved in way of maximum increasing of compression ratio,
+keeping high decompression speed and low memory requirements for 
+decompressing.
+
+
+
+LICENSE
+-------
+
+LZMA SDK is written and placed in the public domain by Igor Pavlov.
+
+
+LZMA SDK Contents
+-----------------
+
+LZMA SDK includes:
+
+  - ANSI-C/C++/C#/Java source code for LZMA compressing and decompressing
+  - Compiled file->file LZMA compressing/decompressing program for Windows system
+
+
+UNIX/Linux version 
+------------------
+To compile C++ version of file->file LZMA encoding, go to directory
+C++/7zip/Compress/LZMA_Alone 
+and call make to recompile it:
+  make -f makefile.gcc clean all
+
+In some UNIX/Linux versions you must compile LZMA with static libraries.
+To compile with static libraries, you can use 
+LIB = -lm -static
+
+
+Files
+---------------------
+lzma.txt     - LZMA SDK description (this file)
+7zFormat.txt - 7z Format description
+7zC.txt      - 7z ANSI-C Decoder description
+methods.txt  - Compression method IDs for .7z
+lzma.exe     - Compiled file->file LZMA encoder/decoder for Windows
+history.txt  - history of the LZMA SDK
+
+
+Source code structure
+---------------------
+
+C/  - C files
+        7zCrc*.*   - CRC code
+        Alloc.*    - Memory allocation functions
+        Bra*.*     - Filters for x86, IA-64, ARM, ARM-Thumb, PowerPC and SPARC code
+        LzFind.*   - Match finder for LZ (LZMA) encoders 
+        LzFindMt.* - Match finder for LZ (LZMA) encoders for multithreading encoding
+        LzHash.h   - Additional file for LZ match finder
+        LzmaDec.*  - LZMA decoding
+        LzmaEnc.*  - LZMA encoding
+        LzmaLib.*  - LZMA Library for DLL calling
+        Types.h    - Basic types for another .c files
+	Threads.*  - The code for multithreading.
+
+    LzmaLib  - LZMA Library (.DLL for Windows)
+    
+    LzmaUtil - LZMA Utility (file->file LZMA encoder/decoder).
+
+    Archive - files related to archiving
+      7z     - 7z ANSI-C Decoder
+
+CPP/ -- CPP files
+
+  Common  - common files for C++ projects
+  Windows - common files for Windows related code
+
+  7zip    - files related to 7-Zip Project
+
+    Common   - common files for 7-Zip
+
+    Compress - files related to compression/decompression
+
+      Copy         - Copy coder
+      RangeCoder   - Range Coder (special code of compression/decompression)
+      LZMA         - LZMA compression/decompression on C++
+      LZMA_Alone   - file->file LZMA compression/decompression
+      Branch       - Filters for x86, IA-64, ARM, ARM-Thumb, PowerPC and SPARC code
+
+    Archive - files related to archiving
+
+      Common   - common files for archive handling
+      7z       - 7z C++ Encoder/Decoder
+
+    Bundles    - Modules that are bundles of other modules
+  
+      Alone7z           - 7zr.exe: Standalone version of 7z.exe that supports only 7z/LZMA/BCJ/BCJ2
+      Format7zR         - 7zr.dll: Reduced version of 7za.dll: extracting/compressing to 7z/LZMA/BCJ/BCJ2
+      Format7zExtractR  - 7zxr.dll: Reduced version of 7zxa.dll: extracting from 7z/LZMA/BCJ/BCJ2.
+
+    UI        - User Interface files
+         
+      Client7z - Test application for 7za.dll,  7zr.dll, 7zxr.dll
+      Common   - Common UI files
+      Console  - Code for console archiver
+
+
+
+CS/ - C# files
+  7zip
+    Common   - some common files for 7-Zip
+    Compress - files related to compression/decompression
+      LZ     - files related to LZ (Lempel-Ziv) compression algorithm
+      LZMA         - LZMA compression/decompression
+      LzmaAlone    - file->file LZMA compression/decompression
+      RangeCoder   - Range Coder (special code of compression/decompression)
+
+Java/  - Java files
+  SevenZip
+    Compression    - files related to compression/decompression
+      LZ           - files related to LZ (Lempel-Ziv) compression algorithm
+      LZMA         - LZMA compression/decompression
+      RangeCoder   - Range Coder (special code of compression/decompression)
+
+
+C/C++ source code of LZMA SDK is part of 7-Zip project.
+7-Zip source code can be downloaded from 7-Zip's SourceForge page:
+
+  http://sourceforge.net/projects/sevenzip/
+
+
+
+LZMA features
+-------------
+  - Variable dictionary size (up to 1 GB)
+  - Estimated compressing speed: about 2 MB/s on 2 GHz CPU
+  - Estimated decompressing speed: 
+      - 20-30 MB/s on 2 GHz Core 2 or AMD Athlon 64
+      - 1-2 MB/s on 200 MHz ARM, MIPS, PowerPC or other simple RISC
+  - Small memory requirements for decompressing (16 KB + DictionarySize)
+  - Small code size for decompressing: 5-8 KB
+
+LZMA decoder uses only integer operations and can be 
+implemented in any modern 32-bit CPU (or on 16-bit CPU with some conditions).
+
+Some critical operations that affect the speed of LZMA decompression:
+  1) 32*16 bit integer multiply
+  2) Misspredicted branches (penalty mostly depends from pipeline length)
+  3) 32-bit shift and arithmetic operations
+
+The speed of LZMA decompressing mostly depends from CPU speed.
+Memory speed has no big meaning. But if your CPU has small data cache, 
+overall weight of memory speed will slightly increase.
+
+
+How To Use
+----------
+
+Using LZMA encoder/decoder executable
+--------------------------------------
+
+Usage:  LZMA <e|d> inputFile outputFile [<switches>...]
+
+  e: encode file
+
+  d: decode file
+
+  b: Benchmark. There are two tests: compressing and decompressing 
+     with LZMA method. Benchmark shows rating in MIPS (million 
+     instructions per second). Rating value is calculated from 
+     measured speed and it is normalized with Intel's Core 2 results.
+     Also Benchmark checks possible hardware errors (RAM 
+     errors in most cases). Benchmark uses these settings:
+     (-a1, -d21, -fb32, -mfbt4). You can change only -d parameter. 
+     Also you can change the number of iterations. Example for 30 iterations:
+       LZMA b 30
+     Default number of iterations is 10.
+
+<Switches>
+  
+
+  -a{N}:  set compression mode 0 = fast, 1 = normal
+          default: 1 (normal)
+
+  d{N}:   Sets Dictionary size - [0, 30], default: 23 (8MB)
+          The maximum value for dictionary size is 1 GB = 2^30 bytes.
+          Dictionary size is calculated as DictionarySize = 2^N bytes. 
+          For decompressing file compressed by LZMA method with dictionary 
+          size D = 2^N you need about D bytes of memory (RAM).
+
+  -fb{N}: set number of fast bytes - [5, 273], default: 128
+          Usually big number gives a little bit better compression ratio 
+          and slower compression process.
+
+  -lc{N}: set number of literal context bits - [0, 8], default: 3
+          Sometimes lc=4 gives gain for big files.
+
+  -lp{N}: set number of literal pos bits - [0, 4], default: 0
+          lp switch is intended for periodical data when period is 
+          equal 2^N. For example, for 32-bit (4 bytes) 
+          periodical data you can use lp=2. Often it's better to set lc0, 
+          if you change lp switch.
+
+  -pb{N}: set number of pos bits - [0, 4], default: 2
+          pb switch is intended for periodical data 
+          when period is equal 2^N.
+
+  -mf{MF_ID}: set Match Finder. Default: bt4. 
+              Algorithms from hc* group doesn't provide good compression 
+              ratio, but they often works pretty fast in combination with 
+              fast mode (-a0).
+
+              Memory requirements depend from dictionary size 
+              (parameter "d" in table below). 
+
+               MF_ID     Memory                   Description
+
+                bt2    d *  9.5 + 4MB  Binary Tree with 2 bytes hashing.
+                bt3    d * 11.5 + 4MB  Binary Tree with 3 bytes hashing.
+                bt4    d * 11.5 + 4MB  Binary Tree with 4 bytes hashing.
+                hc4    d *  7.5 + 4MB  Hash Chain with 4 bytes hashing.
+
+  -eos:   write End Of Stream marker. By default LZMA doesn't write 
+          eos marker, since LZMA decoder knows uncompressed size 
+          stored in .lzma file header.
+
+  -si:    Read data from stdin (it will write End Of Stream marker).
+  -so:    Write data to stdout
+
+
+Examples:
+
+1) LZMA e file.bin file.lzma -d16 -lc0 
+
+compresses file.bin to file.lzma with 64 KB dictionary (2^16=64K)  
+and 0 literal context bits. -lc0 allows to reduce memory requirements 
+for decompression.
+
+
+2) LZMA e file.bin file.lzma -lc0 -lp2
+
+compresses file.bin to file.lzma with settings suitable 
+for 32-bit periodical data (for example, ARM or MIPS code).
+
+3) LZMA d file.lzma file.bin
+
+decompresses file.lzma to file.bin.
+
+
+Compression ratio hints
+-----------------------
+
+Recommendations
+---------------
+
+To increase the compression ratio for LZMA compressing it's desirable 
+to have aligned data (if it's possible) and also it's desirable to locate
+data in such order, where code is grouped in one place and data is 
+grouped in other place (it's better than such mixing: code, data, code,
+data, ...).
+
+
+Filters
+-------
+You can increase the compression ratio for some data types, using
+special filters before compressing. For example, it's possible to 
+increase the compression ratio on 5-10% for code for those CPU ISAs: 
+x86, IA-64, ARM, ARM-Thumb, PowerPC, SPARC.
+
+You can find C source code of such filters in C/Bra*.* files
+
+You can check the compression ratio gain of these filters with such 
+7-Zip commands (example for ARM code):
+No filter:
+  7z a a1.7z a.bin -m0=lzma
+
+With filter for little-endian ARM code:
+  7z a a2.7z a.bin -m0=arm -m1=lzma        
+
+It works in such manner:
+Compressing    = Filter_encoding + LZMA_encoding
+Decompressing  = LZMA_decoding + Filter_decoding
+
+Compressing and decompressing speed of such filters is very high,
+so it will not increase decompressing time too much.
+Moreover, it reduces decompression time for LZMA_decoding, 
+since compression ratio with filtering is higher.
+
+These filters convert CALL (calling procedure) instructions 
+from relative offsets to absolute addresses, so such data becomes more 
+compressible.
+
+For some ISAs (for example, for MIPS) it's impossible to get gain from such filter.
+
+
+LZMA compressed file format
+---------------------------
+Offset Size Description
+  0     1   Special LZMA properties (lc,lp, pb in encoded form)
+  1     4   Dictionary size (little endian)
+  5     8   Uncompressed size (little endian). -1 means unknown size
+ 13         Compressed data
+
+
+ANSI-C LZMA Decoder
+~~~~~~~~~~~~~~~~~~~
+
+Please note that interfaces for ANSI-C code were changed in LZMA SDK 4.58.
+If you want to use old interfaces you can download previous version of LZMA SDK
+from sourceforge.net site.
+
+To use ANSI-C LZMA Decoder you need the following files:
+1) LzmaDec.h + LzmaDec.c + Types.h
+LzmaUtil/LzmaUtil.c is example application that uses these files.
+
+
+Memory requirements for LZMA decoding
+-------------------------------------
+
+Stack usage of LZMA decoding function for local variables is not 
+larger than 200-400 bytes.
+
+LZMA Decoder uses dictionary buffer and internal state structure.
+Internal state structure consumes
+  state_size = (4 + (1.5 << (lc + lp))) KB
+by default (lc=3, lp=0), state_size = 16 KB.
+
+
+How To decompress data
+----------------------
+
+LZMA Decoder (ANSI-C version) now supports 2 interfaces:
+1) Single-call Decompressing
+2) Multi-call State Decompressing (zlib-like interface)
+
+You must use external allocator:
+Example:
+void *SzAlloc(void *p, size_t size) { p = p; return malloc(size); }
+void SzFree(void *p, void *address) { p = p; free(address); }
+ISzAlloc alloc = { SzAlloc, SzFree };
+
+You can use p = p; operator to disable compiler warnings.
+
+
+Single-call Decompressing
+-------------------------
+When to use: RAM->RAM decompressing
+Compile files: LzmaDec.h + LzmaDec.c + Types.h
+Compile defines: no defines
+Memory Requirements:
+  - Input buffer: compressed size
+  - Output buffer: uncompressed size
+  - LZMA Internal Structures: state_size (16 KB for default settings) 
+
+Interface:
+  int LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+      const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode, 
+      ELzmaStatus *status, ISzAlloc *alloc);
+  In: 
+    dest     - output data
+    destLen  - output data size
+    src      - input data
+    srcLen   - input data size
+    propData - LZMA properties  (5 bytes)
+    propSize - size of propData buffer (5 bytes)
+    finishMode - It has meaning only if the decoding reaches output limit (*destLen).
+	 LZMA_FINISH_ANY - Decode just destLen bytes.
+	 LZMA_FINISH_END - Stream must be finished after (*destLen).
+                           You can use LZMA_FINISH_END, when you know that 
+                           current output buffer covers last bytes of stream. 
+    alloc    - Memory allocator.
+
+  Out: 
+    destLen  - processed output size 
+    srcLen   - processed input size 
+
+  Output:
+    SZ_OK
+      status:
+        LZMA_STATUS_FINISHED_WITH_MARK
+        LZMA_STATUS_NOT_FINISHED 
+        LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
+    SZ_ERROR_DATA - Data error
+    SZ_ERROR_MEM  - Memory allocation error
+    SZ_ERROR_UNSUPPORTED - Unsupported properties
+    SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
+
+  If LZMA decoder sees end_marker before reaching output limit, it returns OK result,
+  and output value of destLen will be less than output buffer size limit.
+
+  You can use multiple checks to test data integrity after full decompression:
+    1) Check Result and "status" variable.
+    2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
+    3) Check that output(srcLen) = compressedSize, if you know real compressedSize. 
+       You must use correct finish mode in that case. */ 
+
+
+Multi-call State Decompressing (zlib-like interface)
+----------------------------------------------------
+
+When to use: file->file decompressing 
+Compile files: LzmaDec.h + LzmaDec.c + Types.h
+
+Memory Requirements:
+ - Buffer for input stream: any size (for example, 16 KB)
+ - Buffer for output stream: any size (for example, 16 KB)
+ - LZMA Internal Structures: state_size (16 KB for default settings) 
+ - LZMA dictionary (dictionary size is encoded in LZMA properties header)
+
+1) read LZMA properties (5 bytes) and uncompressed size (8 bytes, little-endian) to header:
+   unsigned char header[LZMA_PROPS_SIZE + 8];
+   ReadFile(inFile, header, sizeof(header)
+
+2) Allocate CLzmaDec structures (state + dictionary) using LZMA properties
+
+  CLzmaDec state;
+  LzmaDec_Constr(&state);
+  res = LzmaDec_Allocate(&state, header, LZMA_PROPS_SIZE, &g_Alloc);
+  if (res != SZ_OK)
+    return res;
+
+3) Init LzmaDec structure before any new LZMA stream. And call LzmaDec_DecodeToBuf in loop
+
+  LzmaDec_Init(&state);
+  for (;;)
+  {
+    ... 
+    int res = LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, 
+    	const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode);
+    ...
+  }
+
+
+4) Free all allocated structures
+  LzmaDec_Free(&state, &g_Alloc);
+
+For full code example, look at C/LzmaUtil/LzmaUtil.c code.
+
+
+How To compress data
+--------------------
+
+Compile files: LzmaEnc.h + LzmaEnc.c + Types.h +
+LzFind.c + LzFind.h + LzFindMt.c + LzFindMt.h + LzHash.h
+
+Memory Requirements:
+  - (dictSize * 11.5 + 6 MB) + state_size
+
+Lzma Encoder can use two memory allocators:
+1) alloc - for small arrays.
+2) allocBig - for big arrays.
+
+For example, you can use Large RAM Pages (2 MB) in allocBig allocator for 
+better compression speed. Note that Windows has bad implementation for 
+Large RAM Pages. 
+It's OK to use same allocator for alloc and allocBig.
+
+
+Single-call Compression with callbacks
+--------------------------------------
+
+Check C/LzmaUtil/LzmaUtil.c as example, 
+
+When to use: file->file decompressing 
+
+1) you must implement callback structures for interfaces:
+ISeqInStream
+ISeqOutStream
+ICompressProgress
+ISzAlloc
+
+static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
+static void SzFree(void *p, void *address) {  p = p; MyFree(address); }
+static ISzAlloc g_Alloc = { SzAlloc, SzFree };
+
+  CFileSeqInStream inStream;
+  CFileSeqOutStream outStream;
+
+  inStream.funcTable.Read = MyRead;
+  inStream.file = inFile;
+  outStream.funcTable.Write = MyWrite;
+  outStream.file = outFile;
+
+
+2) Create CLzmaEncHandle object;
+
+  CLzmaEncHandle enc;
+
+  enc = LzmaEnc_Create(&g_Alloc);
+  if (enc == 0)
+    return SZ_ERROR_MEM;
+
+
+3) initialize CLzmaEncProps properties;
+
+  LzmaEncProps_Init(&props);
+
+  Then you can change some properties in that structure.
+
+4) Send LZMA properties to LZMA Encoder
+
+  res = LzmaEnc_SetProps(enc, &props);
+
+5) Write encoded properties to header
+
+    Byte header[LZMA_PROPS_SIZE + 8];
+    size_t headerSize = LZMA_PROPS_SIZE;
+    UInt64 fileSize;
+    int i;
+
+    res = LzmaEnc_WriteProperties(enc, header, &headerSize);
+    fileSize = MyGetFileLength(inFile);
+    for (i = 0; i < 8; i++)
+      header[headerSize++] = (Byte)(fileSize >> (8 * i));
+    MyWriteFileAndCheck(outFile, header, headerSize)
+
+6) Call encoding function:
+      res = LzmaEnc_Encode(enc, &outStream.funcTable, &inStream.funcTable, 
+        NULL, &g_Alloc, &g_Alloc);
+
+7) Destroy LZMA Encoder Object
+  LzmaEnc_Destroy(enc, &g_Alloc, &g_Alloc);
+
+
+If callback function return some error code, LzmaEnc_Encode also returns that code.
+
+
+Single-call RAM->RAM Compression
+--------------------------------
+
+Single-call RAM->RAM Compression is similar to Compression with callbacks,
+but you provide pointers to buffers instead of pointers to stream callbacks:
+
+HRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+    CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark, 
+    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+
+Return code:
+  SZ_OK               - OK
+  SZ_ERROR_MEM        - Memory allocation error 
+  SZ_ERROR_PARAM      - Incorrect paramater
+  SZ_ERROR_OUTPUT_EOF - output buffer overflow
+  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
+
+
+
+LZMA Defines
+------------
+
+_LZMA_SIZE_OPT - Enable some optimizations in LZMA Decoder to get smaller executable code.
+
+_LZMA_PROB32   - It can increase the speed on some 32-bit CPUs, but memory usage for 
+                 some structures will be doubled in that case.
+
+_LZMA_UINT32_IS_ULONG  - Define it if int is 16-bit on your compiler and long is 32-bit.
+
+_LZMA_NO_SYSTEM_SIZE_T  - Define it if you don't want to use size_t type.
+
+
+C++ LZMA Encoder/Decoder 
+~~~~~~~~~~~~~~~~~~~~~~~~
+C++ LZMA code use COM-like interfaces. So if you want to use it, 
+you can study basics of COM/OLE.
+C++ LZMA code is just wrapper over ANSI-C code.
+
+
+C++ Notes
+~~~~~~~~~~~~~~~~~~~~~~~~
+If you use some C++ code folders in 7-Zip (for example, C++ code for .7z handling),
+you must check that you correctly work with "new" operator.
+7-Zip can be compiled with MSVC 6.0 that doesn't throw "exception" from "new" operator.
+So 7-Zip uses "CPP\Common\NewHandler.cpp" that redefines "new" operator:
+operator new(size_t size)
+{
+  void *p = ::malloc(size);
+  if (p == 0)
+    throw CNewException();
+  return p;
+}
+If you use MSCV that throws exception for "new" operator, you can compile without 
+"NewHandler.cpp". So standard exception will be used. Actually some code of 
+7-Zip catches any exception in internal code and converts it to HRESULT code.
+So you don't need to catch CNewException, if you call COM interfaces of 7-Zip.
+
+---
+
+http://www.7-zip.org
+http://www.7-zip.org/sdk.html
+http://www.7-zip.org/support.html
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzma465/Methods.txt squashfs-tools-patched/LZMA/lzma465/Methods.txt
--- squashfs-tools/LZMA/lzma465/Methods.txt	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzma465/Methods.txt	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,137 @@
+7-Zip method IDs (4.65)
+-----------------------
+
+Each compression or crypto method in 7z has unique binary value (ID).
+The length of ID in bytes is arbitrary but it can not exceed 63 bits (8 bytes).
+
+If you want to add some new ID, you have two ways:
+1) Write request for allocating IDs to 7-zip developers.
+2) Generate 8-bytes ID:
+
+    3F ZZ ZZ ZZ ZZ ZZ MM MM 
+
+    3F              - Prefix for random IDs (1 byte)
+    ZZ ZZ ZZ ZZ ZZ  - Developer ID (5 bytes). Use real random bytes. 
+                      
+    MM MM           - Method ID (2 bytes)
+
+    You can notify 7-Zip developers about your Developer ID / Method ID.
+
+    Note: Use new ID only if old codec can not decode data encoded with new version.
+
+
+List of defined IDs
+-------------------
+      
+00 - Copy
+
+02 - Common
+   03 Swap
+      - 2 Swap2
+      - 4 Swap4
+
+03 - 7z
+   01 - LZMA
+      01 - Version
+  
+   03 - Branch
+      01 - x86
+         03  - BCJ
+         1B  - BCJ2
+      02 - PPC
+         05 - PPC (Big Endian)
+      03 - Alpha
+         01 - Alpha
+      04 - IA64
+         01 - IA64
+      05 - ARM
+         01 - ARM
+      06 - M68
+         05 - M68 (Big Endian)
+      07 - ARM Thumb
+         01 - ARMT
+      08 - SPARC
+         05 - SPARC
+
+   04 - PPMD
+      01 - Version
+
+   7F -
+      01 - experimental methods.
+
+
+04 - Misc
+   00 - Reserved
+   01 - Zip
+      00 - Copy (not used). Use {00} instead
+      01 - Shrink
+      06 - Implode
+      08 - Deflate
+      09 - Deflate64
+      12 - BZip2 (not used). Use {04 02 02} instead
+   02 - BZip
+      02 - BZip2
+   03 - Rar
+      01 - Rar15
+      02 - Rar20
+      03 - Rar29
+   04 - Arj
+      01 - Arj (1,2,3)
+      02 - Arj 4
+   05 - Z
+   06 - Lzh
+   07 - Reserved for 7z
+   08 - Cab
+   09 - NSIS
+      01 - DeflateNSIS
+      02 - BZip2NSIS
+
+
+06 - Crypto 
+   00 - 
+   01 - AES
+      0x - AES-128
+      4x - AES-192
+      8x - AES-256
+      Cx - AES
+
+      x0 - ECB
+      x1 - CBC
+      x2 - CFB
+      x3 - OFB
+
+   07 - Reserved
+   0F - Reserved
+
+   F0 - Misc Ciphers (Real Ciphers without hashing algo)
+
+   F1 - Misc Ciphers (Combine)
+      01 - Zip
+         01 - Main Zip crypto algo
+      03 - RAR
+         02 - 
+         03 - Rar29 AES-128 + (modified SHA-1)
+      07 - 7z
+         01 - AES-256 + SHA-256
+
+07 - Hash (subject to change)
+   00 - 
+   01 - CRC
+   02 - SHA-1
+   03 - SHA-256
+   04 - SHA-384
+   05 - SHA-512
+
+   F0 - Misc Hash
+
+   F1 - Misc
+      03 - RAR
+         03 - Rar29 Password Hashing (modified SHA1)
+      07 - 7z 
+         01 - SHA-256 Password Hashing
+    
+   
+
+
+---
+End of document
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/7zC.txt squashfs-tools-patched/LZMA/lzmadaptive/7zC.txt
--- squashfs-tools/LZMA/lzmadaptive/7zC.txt	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/7zC.txt	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,235 @@
+7z ANSI-C Decoder 4.23
+----------------------
+
+7z ANSI-C Decoder 4.23 Copyright (C) 1999-2005 Igor Pavlov
+
+7z ANSI-C provides 7z/LZMA decoding.
+7z ANSI-C version is simplified version ported from C++ code.
+
+LZMA is default and general compression method of 7z format
+in 7-Zip compression program (www.7-zip.org). LZMA provides high 
+compression ratio and very fast decompression.
+
+
+LICENSE
+-------
+
+Read lzma.txt for information about license.
+
+
+Files
+---------------------
+
+7zAlloc.*    - Allocate and Free
+7zBuffer.*   - Buffer structure
+7zCrc.*      - CRC32 code
+7zDecode.*   - Low level memory->memory decoding
+7zExtract.*  - High level stream->memory decoding
+7zHeader.*   - .7z format constants
+7zIn.*       - .7z archive opening
+7zItem.*     - .7z structures
+7zMain.c     - Test application
+7zMethodID.* - MethodID structure
+7zTypes.h    - Base types and constants
+
+
+How To Use
+----------
+
+You must download 7-Zip program from www.7-zip.org.
+
+You can create .7z archive with 7z.exe or 7za.exe:
+
+  7za.exe a archive.7z *.htm -r -mx -m0fb=255
+
+If you have big number of files in archive, and you need fast extracting, 
+you can use partly-solid archives:
+  
+  7za.exe a archive.7z *.htm -ms=512K -r -mx -m0fb=255 -m0d=512K
+
+In that example 7-Zip will use 512KB solid blocks. So it needs to decompress only 
+512KB for extracting one file from such archive.
+
+
+Limitations of current version of 7z ANSI-C Decoder
+---------------------------------------------------
+
+ - It reads only "FileName", "Size", and "CRC" information for each file in archive.
+ - It supports only LZMA and Copy (no compression) methods.
+ - It converts original UTF-16 Unicode file names to UTF-8 Unicode file names.
+ 
+These limitations will be fixed in future versions.
+
+
+Using 7z ANSI-C Decoder Test application:
+-----------------------------------------
+
+Usage: 7zDec <command> <archive_name>
+
+<Command>:
+  e: Extract files from archive
+  l: List contents of archive
+  t: Test integrity of archive
+
+Example: 
+
+  7zDec l archive.7z
+
+lists contents of archive.7z
+
+  7zDec e archive.7z
+
+extracts files from archive.7z to current folder.
+
+
+How to use .7z Decoder
+----------------------
+
+.7z Decoder can be compiled in one of two modes:
+
+1) Default mode. In that mode 7z Decoder will read full compressed 
+   block to RAM before decompressing.
+  
+2) Mode with defined _LZMA_IN_CB. In that mode 7z Decoder can read
+   compressed block by parts. And you can specify desired buffer size. 
+   So memory requirements can be reduced. But decompressing speed will 
+   be 5-10% lower and code size is slightly larger.
+
+   
+Memory allocation
+~~~~~~~~~~~~~~~~~
+
+7z Decoder uses two memory pools:
+1) Temporary pool
+2) Main pool
+Such scheme can allow you to avoid fragmentation of allocated blocks.
+
+Steps for using 7z decoder
+--------------------------
+
+Use code at 7zMain.c as example.
+
+1) Declare variables:
+  inStream                     /* implements ISzInStream interface */
+  CArchiveDatabaseEx db;       /* 7z archive database structure */
+  ISzAlloc allocImp;           /* memory functions for main pool */
+  ISzAlloc allocTempImp;       /* memory functions for temporary pool */
+
+2) call InitCrcTable(); function to initialize CRC structures.
+
+3) call SzArDbExInit(&db); function to initialize db structures.
+
+4) call SzArchiveOpen(inStream, &db, &allocMain, &allocTemp) to open archive
+
+This function opens archive "inStream" and reads headers to "db".
+All items in "db" will be allocated with "allocMain" functions.
+SzArchiveOpen function allocates and frees temporary structures by "allocTemp" functions.
+
+5) List items or Extract items
+
+  Listing code:
+  ~~~~~~~~~~~~~
+    {
+      UInt32 i;
+      for (i = 0; i < db.Database.NumFiles; i++)
+      {
+        CFileItem *f = db.Database.Files + i;
+        printf("%10d  %s\n", (int)f->Size, f->Name);
+      }
+    }
+
+  Extracting code:
+  ~~~~~~~~~~~~~~~~
+
+  SZ_RESULT SzExtract(
+    ISzInStream *inStream, 
+    CArchiveDatabaseEx *db,
+    UInt32 fileIndex,         /* index of file */
+    UInt32 *blockIndex,       /* index of solid block */
+    Byte **outBuffer,         /* pointer to pointer to output buffer (allocated with allocMain) */
+    size_t *outBufferSize,    /* buffer size for output buffer */
+    size_t *offset,           /* offset of stream for required file in *outBuffer */
+    size_t *outSizeProcessed, /* size of file in *outBuffer */
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp);
+
+  If you need to decompress more than one file, you can send these values from previous call:
+    blockIndex, 
+    outBuffer, 
+    outBufferSize,
+  You can consider "outBuffer" as cache of solid block. If your archive is solid, 
+  it will increase decompression speed.
+
+  After decompressing you must free "outBuffer":
+  allocImp.Free(outBuffer);
+
+6) call SzArDbExFree(&db, allocImp.Free) to free allocated items in "db".
+
+
+
+
+Memory requirements for .7z decoding 
+------------------------------------
+
+Memory usage for Archive opening:
+  - Temporary pool:
+     - Memory for compressed .7z headers (if _LZMA_IN_CB is not defined)
+     - Memory for uncompressed .7z headers
+     - some other temporary blocks
+  - Main pool:
+     - Memory for database: 
+       Estimated size of one file structures in solid archive:
+         - Size (4 or 8 Bytes)
+         - CRC32 (4 bytes)
+         - Some file information (4 bytes)
+         - File Name (variable length) + pointer + allocation structures
+
+Memory usage for archive Decompressing:
+  - Temporary pool:
+     - Memory for compressed solid block (if _LZMA_IN_CB is not defined)
+     - Memory for LZMA decompressing structures
+  - Main pool:
+     - Memory for decompressed solid block
+  
+
+If _LZMA_IN_CB is defined, 7z Decoder will not allocate memory for 
+compressed blocks. Instead of this, you must allocate buffer with desired 
+size before calling 7z Decoder. Use 7zMain.c as example.
+
+
+
+EXIT codes
+-----------
+
+7z Decoder functions can return one of the following codes:
+
+#define SZ_OK (0)
+#define SZE_DATA_ERROR (1)
+#define SZE_OUTOFMEMORY (2)
+#define SZE_CRC_ERROR (3)
+
+#define SZE_NOTIMPL (4)
+#define SZE_FAIL (5)
+
+#define SZE_ARCHIVE_ERROR (6)
+
+
+
+LZMA Defines
+------------
+
+_LZMA_IN_CB       - Use special callback mode for input stream to reduce memory requirements
+
+_SZ_FILE_SIZE_64  - define it if you need support for files larger than 4 GB
+_SZ_NO_INT_64     - define it if your compiler doesn't support long long int
+
+_LZMA_PROB32      - it can increase LZMA decompressing speed on some 32-bit CPUs.
+
+_SZ_ONE_DIRECTORY - define it if you want to locate all source files to one directory
+_SZ_ALLOC_DEBUG   - define it if you want to debug alloc/free operations to stderr.
+
+
+---
+
+http://www.7-zip.org
+http://www.7-zip.org/support.html
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/7zFormat.txt squashfs-tools-patched/LZMA/lzmadaptive/7zFormat.txt
--- squashfs-tools/LZMA/lzmadaptive/7zFormat.txt	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/7zFormat.txt	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,471 @@
+7z Format description (2.30 Beta 25)
+-----------------------------------
+
+This file contains description of 7z archive format. 
+7z archive can contain files compressed with any method.
+See "Methods.txt" for description for defined compressing methods.
+
+
+Format structure Overview
+-------------------------
+
+Some fields can be optional.
+
+Archive structure
+~~~~~~~~~~~~~~~~~  
+SignatureHeader
+[PackedStreams]
+[PackedStreamsForHeaders]
+[
+  Header 
+  or 
+  {
+    Packed Header
+    HeaderInfo
+  }
+]
+
+
+
+Header structure
+~~~~~~~~~~~~~~~~  
+{
+  ArchiveProperties
+  AdditionalStreams
+  {
+    PackInfo
+    {
+      PackPos
+      NumPackStreams
+      Sizes[NumPackStreams]
+      CRCs[NumPackStreams]
+    }
+    CodersInfo
+    {
+      NumFolders
+      Folders[NumFolders]
+      {
+        NumCoders
+        CodersInfo[NumCoders]
+        {
+          ID
+          NumInStreams;
+          NumOutStreams;
+          PropertiesSize
+          Properties[PropertiesSize]
+        }
+        NumBindPairs
+        BindPairsInfo[NumBindPairs]
+        {
+          InIndex;
+          OutIndex;
+        }
+        PackedIndices
+      }
+      UnPackSize[Folders][Folders.NumOutstreams]
+      CRCs[NumFolders]
+    }
+    SubStreamsInfo
+    {
+      NumUnPackStreamsInFolders[NumFolders];
+      UnPackSizes[]
+      CRCs[]
+    }
+  }
+  MainStreamsInfo
+  {
+    (Same as in AdditionalStreams)
+  }
+  FilesInfo
+  {
+    NumFiles
+    Properties[]
+    {
+      ID
+      Size
+      Data
+    }
+  }
+}
+
+HeaderInfo structure
+~~~~~~~~~~~~~~~~~~~~
+{
+  (Same as in AdditionalStreams)
+}
+
+
+
+Notes about Notation and encoding
+---------------------------------
+
+7z uses little endian encoding.
+
+7z archive format has optional headers that are marked as
+[]
+Header
+[]
+
+REAL_UINT64 means real UINT64.
+
+UINT64 means real UINT64 encoded with the following scheme:
+
+  Size of encoding sequence depends from first byte:
+  First_Byte  Extra_Bytes        Value
+  (binary)   
+  0xxxxxxx               : ( xxxxxxx           )
+  10xxxxxx    BYTE y[1]  : (  xxxxxx << (8 * 1)) + y
+  110xxxxx    BYTE y[2]  : (   xxxxx << (8 * 2)) + y
+  ...
+  1111110x    BYTE y[6]  : (       x << (8 * 6)) + y
+  11111110    BYTE y[7]  :                         y
+  11111111    BYTE y[8]  :                         y
+
+
+
+Property IDs
+------------
+
+0x00 = kEnd,
+
+0x01 = kHeader,
+
+0x02 = kArchiveProperties,
+    
+0x03 = kAdditionalStreamsInfo,
+0x04 = kMainStreamsInfo,
+0x05 = kFilesInfo,
+    
+0x06 = kPackInfo,
+0x07 = kUnPackInfo,
+0x08 = kSubStreamsInfo,
+
+0x09 = kSize,
+0x0A = kCRC,
+
+0x0B = kFolder,
+
+0x0C = kCodersUnPackSize,
+0x0D = kNumUnPackStream,
+
+0x0E = kEmptyStream,
+0x0F = kEmptyFile,
+0x10 = kAnti,
+
+0x11 = kName,
+0x12 = kCreationTime,
+0x13 = kLastAccessTime,
+0x14 = kLastWriteTime,
+0x15 = kWinAttributes,
+0x16 = kComment,
+
+0x17 = kEncodedHeader,
+
+
+7z format headers
+-----------------
+
+SignatureHeader
+~~~~~~~~~~~~~~~
+  BYTE kSignature[6] = {'7', 'z', 0xBC, 0xAF, 0x27, 0x1C};
+
+  ArchiveVersion
+  {
+    BYTE Major;   // now = 0
+    BYTE Minor;   // now = 2
+  };
+
+  UINT32 StartHeaderCRC;
+
+  StartHeader
+  {
+    REAL_UINT64 NextHeaderOffset
+    REAL_UINT64 NextHeaderSize
+    UINT32 NextHeaderCRC
+  }
+
+
+...........................
+
+
+ArchiveProperties
+~~~~~~~~~~~~~~~~~
+BYTE NID::kArchiveProperties (0x02)
+while(true)
+{
+  BYTE PropertyType;
+  if (aType == 0)
+    break;
+  UINT64 PropertySize;
+  BYTE PropertyData[PropertySize];
+}
+
+
+Digests (NumStreams)
+~~~~~~~~~~~~~~~~~~~~~
+  BYTE AllAreDefined
+  if (AllAreDefined == 0)
+  {
+    for(NumStreams)
+      BIT Defined
+  }
+  UINT32 CRCs[NumDefined]
+
+
+PackInfo
+~~~~~~~~~~~~
+  BYTE NID::kPackInfo  (0x06)
+  UINT64 PackPos
+  UINT64 NumPackStreams
+
+  []
+  BYTE NID::kSize    (0x09)
+  UINT64 PackSizes[NumPackStreams]
+  []
+
+  []
+  BYTE NID::kCRC      (0x0A)
+  PackStreamDigests[NumPackStreams]
+  []
+
+  BYTE NID::kEnd
+
+
+Folder
+~~~~~~
+  UINT64 NumCoders;
+  for (NumCoders)
+  {
+    BYTE 
+    {
+      0:3 DecompressionMethod.IDSize
+      4:
+        0 - IsSimple
+        1 - Is not simple
+      5:
+        0 - No Attributes
+        1 - There Are Attributes
+      7:
+        0 - Last Method in Alternative_Method_List
+        1 - There are more alternative methods
+    } 
+    BYTE DecompressionMethod.ID[DecompressionMethod.IDSize]
+    if (!IsSimple)
+    {
+      UINT64 NumInStreams;
+      UINT64 NumOutStreams;
+    }
+    if (DecompressionMethod[0] != 0)
+    {
+      UINT64 PropertiesSize
+      BYTE Properties[PropertiesSize]
+    }
+  }
+    
+  NumBindPairs = NumOutStreamsTotal - 1;
+
+  for (NumBindPairs)
+  {
+    UINT64 InIndex;
+    UINT64 OutIndex;
+  }
+
+  NumPackedStreams = NumInStreamsTotal - NumBindPairs;
+  if (NumPackedStreams > 1)
+    for(NumPackedStreams)
+    {
+      UINT64 Index;
+    };
+
+
+
+
+Coders Info
+~~~~~~~~~~~
+
+  BYTE NID::kUnPackInfo  (0x07)
+
+
+  BYTE NID::kFolder  (0x0B)
+  UINT64 NumFolders
+  BYTE External
+  switch(External)
+  {
+    case 0:
+      Folders[NumFolders]
+    case 1:
+      UINT64 DataStreamIndex
+  }
+
+
+  BYTE ID::kCodersUnPackSize  (0x0C)
+  for(Folders)
+    for(Folder.NumOutStreams)
+     UINT64 UnPackSize;
+
+
+  []
+  BYTE NID::kCRC   (0x0A)
+  UnPackDigests[NumFolders]
+  []
+
+  
+
+  BYTE NID::kEnd
+
+
+
+SubStreams Info
+~~~~~~~~~~~~~~
+  BYTE NID::kSubStreamsInfo; (0x08)
+
+  []
+  BYTE NID::kNumUnPackStream; (0x0D)
+  UINT64 NumUnPackStreamsInFolders[NumFolders];
+  []
+
+
+  []
+  BYTE NID::kSize  (0x09)
+  UINT64 UnPackSizes[]
+  []
+
+
+  []
+  BYTE NID::kCRC  (0x0A)
+  Digests[Number of streams with unknown CRC]
+  []
+
+  
+  BYTE NID::kEnd
+
+
+Streams Info
+~~~~~~~~~~~~
+
+  []
+  PackInfo
+  []
+
+
+  []
+  CodersInfo
+  []
+
+
+  []
+  SubStreamsInfo
+  []
+
+  BYTE NID::kEnd
+
+
+FilesInfo
+~~~~~~~~~
+  BYTE NID::kFilesInfo;  (0x05)
+  UINT64 NumFiles
+
+  while(true)
+  {
+    BYTE PropertyType;
+    if (aType == 0)
+      break;
+
+    UINT64 Size;
+
+    switch(PropertyType)
+    {
+      kEmptyStream:   (0x0E)
+        for(NumFiles)
+          BIT IsEmptyStream
+
+      kEmptyFile:     (0x0F)
+        for(EmptyStreams)
+          BIT IsEmptyFile
+
+      kAnti:          (0x10)
+        for(EmptyStreams)
+          BIT IsAntiFile
+      
+      case kCreationTime:   (0x12)
+      case kLastAccessTime: (0x13)
+      case kLastWriteTime:  (0x14)
+        BYTE AllAreDefined
+        if (AllAreDefined == 0)
+        {
+          for(NumFiles)
+            BIT TimeDefined
+        }
+        BYTE External;
+        if(External != 0)
+          UINT64 DataIndex
+        []
+        for(Definded Items)
+          UINT32 Time
+        []
+      
+      kNames:     (0x11)
+        BYTE External;
+        if(External != 0)
+          UINT64 DataIndex
+        []
+        for(Files)
+        {
+          wchar_t Names[NameSize];
+          wchar_t 0;
+        }
+        []
+
+      kAttributes:  (0x15)
+        BYTE AllAreDefined
+        if (AllAreDefined == 0)
+        {
+          for(NumFiles)
+            BIT AttributesAreDefined
+        }
+        BYTE External;
+        if(External != 0)
+          UINT64 DataIndex
+        []
+        for(Definded Attributes)
+          UINT32 Attributes
+        []
+    }
+  }
+
+
+Header
+~~~~~~
+  BYTE NID::kHeader (0x01)
+
+  []
+  ArchiveProperties
+  []
+
+  []
+  BYTE NID::kAdditionalStreamsInfo; (0x03)
+  StreamsInfo
+  []
+
+  []
+  BYTE NID::kMainStreamsInfo;    (0x04)
+  StreamsInfo
+  []
+
+  []
+  FilesInfo
+  []
+
+  BYTE NID::kEnd
+
+
+HeaderInfo
+~~~~~~~~~~
+  []
+  BYTE NID::kEncodedHeader; (0x17)
+  StreamsInfo for Encoded Header
+  []
+
+
+---
+End of document
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zAlloc.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zAlloc.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zAlloc.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zAlloc.c	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,70 @@
+/* 7zAlloc.c */
+
+#include <stdlib.h>
+#include "7zAlloc.h"
+
+/* #define _SZ_ALLOC_DEBUG */
+/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
+
+#ifdef _SZ_ALLOC_DEBUG
+
+#ifdef _WIN32
+#include <windows.h>
+#endif
+#include <stdio.h>
+int g_allocCount = 0;
+int g_allocCountTemp = 0;
+#endif
+
+void *SzAlloc(size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, "\nAlloc %10d bytes; count = %10d", size, g_allocCount);
+  g_allocCount++;
+  #endif
+  return malloc(size);
+}
+
+void SzFree(void *address)
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+  {
+    g_allocCount--;
+    fprintf(stderr, "\nFree; count = %10d", g_allocCount);
+  }
+  #endif
+  free(address);
+}
+
+void *SzAllocTemp(size_t size)
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, "\nAlloc_temp %10d bytes;  count = %10d", size, g_allocCountTemp);
+  g_allocCountTemp++;
+  #ifdef _WIN32
+  return HeapAlloc(GetProcessHeap(), 0, size);
+  #endif
+  #endif
+  return malloc(size);
+}
+
+void SzFreeTemp(void *address)
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+  {
+    g_allocCountTemp--;
+    fprintf(stderr, "\nFree_temp; count = %10d", g_allocCountTemp);
+  }
+  #ifdef _WIN32
+  HeapFree(GetProcessHeap(), 0, address);
+  return;
+  #endif
+  #endif
+  free(address);
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zAlloc.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zAlloc.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zAlloc.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zAlloc.h	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,20 @@
+/* 7zAlloc.h */
+
+#ifndef __7Z_ALLOC_H
+#define __7Z_ALLOC_H
+
+#include <stddef.h>
+
+typedef struct _ISzAlloc
+{
+  void *(*Alloc)(size_t size);
+  void (*Free)(void *address); /* address can be 0 */
+} ISzAlloc;
+
+void *SzAlloc(size_t size);
+void SzFree(void *address);
+
+void *SzAllocTemp(size_t size);
+void SzFreeTemp(void *address);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zBuffer.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zBuffer.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zBuffer.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zBuffer.c	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,29 @@
+/* 7zBuffer.c */
+
+#include "7zBuffer.h"
+#include "7zAlloc.h"
+
+void SzByteBufferInit(CSzByteBuffer *buffer)
+{
+  buffer->Capacity = 0;
+  buffer->Items = 0;
+}
+
+int SzByteBufferCreate(CSzByteBuffer *buffer, size_t newCapacity, void * (*allocFunc)(size_t size))
+{
+  buffer->Capacity = newCapacity;
+  if (newCapacity == 0)
+  {
+    buffer->Items = 0;
+    return 1;
+  }
+  buffer->Items = (Byte *)allocFunc(newCapacity);
+  return (buffer->Items != 0);
+}
+
+void SzByteBufferFree(CSzByteBuffer *buffer, void (*freeFunc)(void *))
+{
+  freeFunc(buffer->Items);
+  buffer->Items = 0;
+  buffer->Capacity = 0;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zBuffer.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zBuffer.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zBuffer.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zBuffer.h	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,19 @@
+/* 7zBuffer.h */
+
+#ifndef __7Z_BUFFER_H
+#define __7Z_BUFFER_H
+
+#include <stddef.h>
+#include "7zTypes.h"
+
+typedef struct _CSzByteBuffer
+{    
+	size_t Capacity;
+  Byte *Items;
+}CSzByteBuffer;
+
+void SzByteBufferInit(CSzByteBuffer *buffer);
+int SzByteBufferCreate(CSzByteBuffer *buffer, size_t newCapacity, void * (*allocFunc)(size_t size));
+void SzByteBufferFree(CSzByteBuffer *buffer, void (*freeFunc)(void *));
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7z_C.dsp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7z_C.dsp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7z_C.dsp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7z_C.dsp	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,178 @@
+# Microsoft Developer Studio Project File - Name="7z_C" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=7z_C - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "7z_C.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "7z_C.mak" CFG="7z_C - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "7z_C - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "7z_C - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "7z_C - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /W4 /GX /O2 /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "_LZMA_PROB32" /D "_LZMA_IN_CB" /YX /FD /c
+# ADD BASE RSC /l 0x419 /d "NDEBUG"
+# ADD RSC /l 0x419 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:"Release/7zDec.exe"
+
+!ELSEIF  "$(CFG)" == "7z_C - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "_DEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "_LZMA_PROB32" /D "_LZMA_IN_CB" /YX /FD /GZ /c
+# ADD BASE RSC /l 0x419 /d "_DEBUG"
+# ADD RSC /l 0x419 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:"Debug/7zDec.exe" /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "7z_C - Win32 Release"
+# Name "7z_C - Win32 Debug"
+# Begin Group "LZMA"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\Compress\LZMA_C\LzmaDecode.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Compress\LZMA_C\LzmaDecode.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=.\7zAlloc.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zAlloc.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zBuffer.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zBuffer.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zCrc.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zCrc.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zDecode.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zDecode.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zExtract.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zExtract.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zHeader.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zHeader.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zIn.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zIn.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zItem.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zItem.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zMain.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zMethodID.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zMethodID.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\7zTypes.h
+# End Source File
+# End Target
+# End Project
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7z_C.dsw squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7z_C.dsw
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7z_C.dsw	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7z_C.dsw	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,29 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "7z_C"=.\7z_C.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zCrc.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zCrc.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zCrc.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zCrc.c	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,76 @@
+/* 7zCrc.c */
+
+#include "7zCrc.h"
+
+#define kCrcPoly 0xEDB88320
+
+UInt32 g_CrcTable[256];
+
+void InitCrcTable()
+{
+  UInt32 i;
+  for (i = 0; i < 256; i++)
+  {
+    UInt32 r = i;
+    int j;
+    for (j = 0; j < 8; j++)
+      if (r & 1) 
+        r = (r >> 1) ^ kCrcPoly;
+      else     
+        r >>= 1;
+    g_CrcTable[i] = r;
+  }
+}
+
+void CrcInit(UInt32 *crc) { *crc = 0xFFFFFFFF; }
+UInt32 CrcGetDigest(UInt32 *crc) { return *crc ^ 0xFFFFFFFF; } 
+
+void CrcUpdateByte(UInt32 *crc, Byte b)
+{
+  *crc = g_CrcTable[((Byte)(*crc)) ^ b] ^ (*crc >> 8);
+}
+
+void CrcUpdateUInt16(UInt32 *crc, UInt16 v)
+{
+  CrcUpdateByte(crc, (Byte)v);
+  CrcUpdateByte(crc, (Byte)(v >> 8));
+}
+
+void CrcUpdateUInt32(UInt32 *crc, UInt32 v)
+{
+  int i;
+  for (i = 0; i < 4; i++)
+    CrcUpdateByte(crc, (Byte)(v >> (8 * i)));
+}
+
+void CrcUpdateUInt64(UInt32 *crc, UInt64 v)
+{
+  int i;
+  for (i = 0; i < 8; i++)
+  {
+    CrcUpdateByte(crc, (Byte)(v));
+    v >>= 8;
+  }
+}
+
+void CrcUpdate(UInt32 *crc, const void *data, size_t size)
+{
+  UInt32 v = *crc;
+  const Byte *p = (const Byte *)data;
+  for (; size > 0 ; size--, p++)
+    v = g_CrcTable[((Byte)(v)) ^ *p] ^ (v >> 8);
+  *crc = v;
+}
+
+UInt32 CrcCalculateDigest(const void *data, size_t size)
+{
+  UInt32 crc;
+  CrcInit(&crc);
+  CrcUpdate(&crc, data, size);
+  return CrcGetDigest(&crc);
+}
+
+int CrcVerifyDigest(UInt32 digest, const void *data, size_t size)
+{
+  return (CrcCalculateDigest(data, size) == digest);
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zCrc.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zCrc.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zCrc.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zCrc.h	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,24 @@
+/* 7zCrc.h */
+
+#ifndef __7Z_CRC_H
+#define __7Z_CRC_H
+
+#include <stddef.h>
+
+#include "7zTypes.h"
+
+extern UInt32 g_CrcTable[256];
+void InitCrcTable();
+
+void CrcInit(UInt32 *crc);
+UInt32 CrcGetDigest(UInt32 *crc);
+void CrcUpdateByte(UInt32 *crc, Byte v);
+void CrcUpdateUInt16(UInt32 *crc, UInt16 v);
+void CrcUpdateUInt32(UInt32 *crc, UInt32 v);
+void CrcUpdateUInt64(UInt32 *crc, UInt64 v);
+void CrcUpdate(UInt32 *crc, const void *data, size_t size);
+ 
+UInt32 CrcCalculateDigest(const void *data, size_t size);
+int CrcVerifyDigest(UInt32 digest, const void *data, size_t size);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zDecode.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zDecode.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zDecode.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zDecode.c	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,150 @@
+/* 7zDecode.c */
+
+#include "7zDecode.h"
+#ifdef _SZ_ONE_DIRECTORY
+#include "LzmaDecode.h"
+#else
+#include "../../Compress/LZMA_C/LzmaDecode.h"
+#endif
+
+CMethodID k_Copy = { { 0x0 }, 1 };
+CMethodID k_LZMA = { { 0x3, 0x1, 0x1 }, 3 };
+
+#ifdef _LZMA_IN_CB
+
+typedef struct _CLzmaInCallbackImp
+{
+  ILzmaInCallback InCallback;
+  ISzInStream *InStream;
+  size_t Size;
+} CLzmaInCallbackImp;
+
+int LzmaReadImp(void *object, const unsigned char **buffer, SizeT *size)
+{
+  CLzmaInCallbackImp *cb = (CLzmaInCallbackImp *)object;
+  size_t processedSize;
+  SZ_RESULT res;
+  *size = 0;
+  res = cb->InStream->Read((void *)cb->InStream, (void **)buffer, cb->Size, &processedSize);
+  *size = (SizeT)processedSize;
+  if (processedSize > cb->Size)
+    return (int)SZE_FAIL;
+  cb->Size -= processedSize;
+  if (res == SZ_OK)
+    return 0;
+  return (int)res;
+}
+
+#endif
+
+SZ_RESULT SzDecode(const CFileSize *packSizes, const CFolder *folder,
+    #ifdef _LZMA_IN_CB
+    ISzInStream *inStream,
+    #else
+    const Byte *inBuffer,
+    #endif
+    Byte *outBuffer, size_t outSize, 
+    size_t *outSizeProcessed, ISzAlloc *allocMain)
+{
+  UInt32 si;
+  size_t inSize = 0;
+  CCoderInfo *coder;
+  if (folder->NumPackStreams != 1)
+    return SZE_NOTIMPL;
+  if (folder->NumCoders != 1)
+    return SZE_NOTIMPL;
+  coder = folder->Coders;
+  *outSizeProcessed = 0;
+
+  for (si = 0; si < folder->NumPackStreams; si++)
+    inSize += (size_t)packSizes[si];
+
+  if (AreMethodsEqual(&coder->MethodID, &k_Copy))
+  {
+    size_t i;
+    if (inSize != outSize)
+      return SZE_DATA_ERROR;
+    #ifdef _LZMA_IN_CB
+    for (i = 0; i < inSize;)
+    {
+      size_t j;
+      Byte *inBuffer;
+      size_t bufferSize;
+      RINOK(inStream->Read((void *)inStream,  (void **)&inBuffer, inSize - i, &bufferSize));
+      if (bufferSize == 0)
+        return SZE_DATA_ERROR;
+      if (bufferSize > inSize - i)
+        return SZE_FAIL;
+      *outSizeProcessed += bufferSize;
+      for (j = 0; j < bufferSize && i < inSize; j++, i++)
+        outBuffer[i] = inBuffer[j];
+    }
+    #else
+    for (i = 0; i < inSize; i++)
+      outBuffer[i] = inBuffer[i];
+    *outSizeProcessed = inSize;
+    #endif
+    return SZ_OK;
+  }
+
+  if (AreMethodsEqual(&coder->MethodID, &k_LZMA))
+  {
+    #ifdef _LZMA_IN_CB
+    CLzmaInCallbackImp lzmaCallback;
+    #else
+    SizeT inProcessed;
+    #endif
+
+    CLzmaDecoderState state;  /* it's about 24-80 bytes structure, if int is 32-bit */
+    int result;
+    SizeT outSizeProcessedLoc;
+
+    #ifdef _LZMA_IN_CB
+    lzmaCallback.Size = inSize;
+    lzmaCallback.InStream = inStream;
+    lzmaCallback.InCallback.Read = LzmaReadImp;
+    #endif
+
+    if (LzmaDecodeProperties(&state.Properties, coder->Properties.Items, 
+        coder->Properties.Capacity) != LZMA_RESULT_OK)
+      return SZE_FAIL;
+
+    state.Probs = (CProb *)allocMain->Alloc(LzmaGetNumProbs(&state.Properties) * sizeof(CProb));
+    if (state.Probs == 0)
+      return SZE_OUTOFMEMORY;
+
+    #ifdef _LZMA_OUT_READ
+    if (state.Properties.DictionarySize == 0)
+      state.Dictionary = 0;
+    else
+    {
+      state.Dictionary = (unsigned char *)allocMain->Alloc(state.Properties.DictionarySize);
+      if (state.Dictionary == 0)
+      {
+        allocMain->Free(state.Probs);
+        return SZE_OUTOFMEMORY;
+      }
+    }
+    LzmaDecoderInit(&state);
+    #endif
+
+    result = LzmaDecode(&state,
+        #ifdef _LZMA_IN_CB
+        &lzmaCallback.InCallback,
+        #else
+        inBuffer, (SizeT)inSize, &inProcessed,
+        #endif
+        outBuffer, (SizeT)outSize, &outSizeProcessedLoc);
+    *outSizeProcessed = (size_t)outSizeProcessedLoc;
+    allocMain->Free(state.Probs);
+    #ifdef _LZMA_OUT_READ
+    allocMain->Free(state.Dictionary);
+    #endif
+    if (result == LZMA_RESULT_DATA_ERROR)
+      return SZE_DATA_ERROR;
+    if (result != LZMA_RESULT_OK)
+      return SZE_FAIL;
+    return SZ_OK;
+  }
+  return SZE_NOTIMPL;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zDecode.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zDecode.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zDecode.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zDecode.h	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,21 @@
+/* 7zDecode.h */
+
+#ifndef __7Z_DECODE_H
+#define __7Z_DECODE_H
+
+#include "7zItem.h"
+#include "7zAlloc.h"
+#ifdef _LZMA_IN_CB
+#include "7zIn.h"
+#endif
+
+SZ_RESULT SzDecode(const CFileSize *packSizes, const CFolder *folder,
+    #ifdef _LZMA_IN_CB
+    ISzInStream *stream,
+    #else
+    const Byte *inBuffer,
+    #endif
+    Byte *outBuffer, size_t outSize, 
+    size_t *outSizeProcessed, ISzAlloc *allocMain);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zExtract.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zExtract.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zExtract.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zExtract.c	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,116 @@
+/* 7zExtract.c */
+
+#include "7zExtract.h"
+#include "7zDecode.h"
+#include "7zCrc.h"
+
+SZ_RESULT SzExtract(
+    ISzInStream *inStream, 
+    CArchiveDatabaseEx *db,
+    UInt32 fileIndex,
+    UInt32 *blockIndex,
+    Byte **outBuffer, 
+    size_t *outBufferSize,
+    size_t *offset, 
+    size_t *outSizeProcessed, 
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp)
+{
+  UInt32 folderIndex = db->FileIndexToFolderIndexMap[fileIndex];
+  SZ_RESULT res = SZ_OK;
+  *offset = 0;
+  *outSizeProcessed = 0;
+  if (folderIndex == (UInt32)-1)
+  {
+    allocMain->Free(*outBuffer);
+    *blockIndex = folderIndex;
+    *outBuffer = 0;
+    *outBufferSize = 0;
+    return SZ_OK;
+  }
+
+  if (*outBuffer == 0 || *blockIndex != folderIndex)
+  {
+    CFolder *folder = db->Database.Folders + folderIndex;
+    CFileSize unPackSize = SzFolderGetUnPackSize(folder);
+    #ifndef _LZMA_IN_CB
+    CFileSize packSize = SzArDbGetFolderFullPackSize(db, folderIndex);
+    Byte *inBuffer = 0;
+    size_t processedSize;
+    #endif
+    *blockIndex = folderIndex;
+    allocMain->Free(*outBuffer);
+    *outBuffer = 0;
+    
+    RINOK(inStream->Seek(inStream, SzArDbGetFolderStreamPos(db, folderIndex, 0)));
+    
+    #ifndef _LZMA_IN_CB
+    if (packSize != 0)
+    {
+      inBuffer = (Byte *)allocTemp->Alloc((size_t)packSize);
+      if (inBuffer == 0)
+        return SZE_OUTOFMEMORY;
+    }
+    res = inStream->Read(inStream, inBuffer, (size_t)packSize, &processedSize);
+    if (res == SZ_OK && processedSize != (size_t)packSize)
+      res = SZE_FAIL;
+    #endif
+    if (res == SZ_OK)
+    {
+      *outBufferSize = (size_t)unPackSize;
+      if (unPackSize != 0)
+      {
+        *outBuffer = (Byte *)allocMain->Alloc((size_t)unPackSize);
+        if (*outBuffer == 0)
+          res = SZE_OUTOFMEMORY;
+      }
+      if (res == SZ_OK)
+      {
+        size_t outRealSize;
+        res = SzDecode(db->Database.PackSizes + 
+          db->FolderStartPackStreamIndex[folderIndex], folder, 
+          #ifdef _LZMA_IN_CB
+          inStream,
+          #else
+          inBuffer, 
+          #endif
+          *outBuffer, (size_t)unPackSize, &outRealSize, allocTemp);
+        if (res == SZ_OK)
+        {
+          if (outRealSize == (size_t)unPackSize)
+          {
+            if (folder->UnPackCRCDefined)
+            {
+              if (!CrcVerifyDigest(folder->UnPackCRC, *outBuffer, (size_t)unPackSize))
+                res = SZE_FAIL;
+            }
+          }
+          else
+            res = SZE_FAIL;
+        }
+      }
+    }
+    #ifndef _LZMA_IN_CB
+    allocTemp->Free(inBuffer);
+    #endif
+  }
+  if (res == SZ_OK)
+  {
+    UInt32 i; 
+    CFileItem *fileItem = db->Database.Files + fileIndex;
+    *offset = 0;
+    for(i = db->FolderStartFileIndex[folderIndex]; i < fileIndex; i++)
+      *offset += (UInt32)db->Database.Files[i].Size;
+    *outSizeProcessed = (size_t)fileItem->Size;
+    if (*offset + *outSizeProcessed > *outBufferSize)
+      return SZE_FAIL;
+    {
+      if (fileItem->IsFileCRCDefined)
+      {
+        if (!CrcVerifyDigest(fileItem->FileCRC, *outBuffer + *offset, *outSizeProcessed))
+          res = SZE_FAIL;
+      }
+    }
+  }
+  return res;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zExtract.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zExtract.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zExtract.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zExtract.h	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,40 @@
+/* 7zExtract.h */
+
+#ifndef __7Z_EXTRACT_H
+#define __7Z_EXTRACT_H
+
+#include "7zIn.h"
+
+/*
+  SzExtract extracts file from archive
+
+  *outBuffer must be 0 before first call for each new archive. 
+
+  Extracting cache:
+    If you need to decompress more than one file, you can send 
+    these values from previous call:
+      *blockIndex, 
+      *outBuffer, 
+      *outBufferSize
+    You can consider "*outBuffer" as cache of solid block. If your archive is solid, 
+    it will increase decompression speed.
+  
+    If you use external function, you can declare these 3 cache variables 
+    (blockIndex, outBuffer, outBufferSize) as static in that external function.
+    
+    Free *outBuffer and set *outBuffer to 0, if you want to flush cache.
+*/
+
+SZ_RESULT SzExtract(
+    ISzInStream *inStream, 
+    CArchiveDatabaseEx *db,
+    UInt32 fileIndex,         /* index of file */
+    UInt32 *blockIndex,       /* index of solid block */
+    Byte **outBuffer,         /* pointer to pointer to output buffer (allocated with allocMain) */
+    size_t *outBufferSize,    /* buffer size for output buffer */
+    size_t *offset,           /* offset of stream for required file in *outBuffer */
+    size_t *outSizeProcessed, /* size of file in *outBuffer */
+    ISzAlloc *allocMain,
+    ISzAlloc *allocTemp);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zHeader.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zHeader.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zHeader.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zHeader.c	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,5 @@
+/*  7zHeader.c */
+
+#include "7zHeader.h"
+
+Byte k7zSignature[k7zSignatureSize] = {'7', 'z', 0xBC, 0xAF, 0x27, 0x1C};
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zHeader.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zHeader.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zHeader.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zHeader.h	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,55 @@
+/* 7zHeader.h */
+
+#ifndef __7Z_HEADER_H
+#define __7Z_HEADER_H
+
+#include "7zTypes.h"
+
+#define k7zSignatureSize 6
+extern Byte k7zSignature[k7zSignatureSize];
+
+#define k7zMajorVersion 0
+
+#define k7zStartHeaderSize 0x20
+
+enum EIdEnum
+{
+  k7zIdEnd,
+    
+  k7zIdHeader,
+    
+  k7zIdArchiveProperties,
+    
+  k7zIdAdditionalStreamsInfo,
+  k7zIdMainStreamsInfo,
+  k7zIdFilesInfo,
+  
+  k7zIdPackInfo,
+  k7zIdUnPackInfo,
+  k7zIdSubStreamsInfo,
+  
+  k7zIdSize,
+  k7zIdCRC,
+  
+  k7zIdFolder,
+  
+  k7zIdCodersUnPackSize,
+  k7zIdNumUnPackStream,
+  
+  k7zIdEmptyStream,
+  k7zIdEmptyFile,
+  k7zIdAnti,
+  
+  k7zIdName,
+  k7zIdCreationTime,
+  k7zIdLastAccessTime,
+  k7zIdLastWriteTime,
+  k7zIdWinAttributes,
+  k7zIdComment,
+  
+  k7zIdEncodedHeader,
+  
+  k7zIdStartPos
+};
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zIn.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zIn.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zIn.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zIn.c	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,1292 @@
+/* 7zIn.c */
+
+#include "7zIn.h"
+#include "7zCrc.h"
+#include "7zDecode.h"
+
+#define RINOM(x) { if((x) == 0) return SZE_OUTOFMEMORY; }
+
+void SzArDbExInit(CArchiveDatabaseEx *db)
+{
+  SzArchiveDatabaseInit(&db->Database);
+  db->FolderStartPackStreamIndex = 0;
+  db->PackStreamStartPositions = 0;
+  db->FolderStartFileIndex = 0;
+  db->FileIndexToFolderIndexMap = 0;
+}
+
+void SzArDbExFree(CArchiveDatabaseEx *db, void (*freeFunc)(void *))
+{
+  freeFunc(db->FolderStartPackStreamIndex);
+  freeFunc(db->PackStreamStartPositions);
+  freeFunc(db->FolderStartFileIndex);
+  freeFunc(db->FileIndexToFolderIndexMap);
+  SzArchiveDatabaseFree(&db->Database, freeFunc);
+  SzArDbExInit(db);
+}
+
+/*
+CFileSize GetFolderPackStreamSize(int folderIndex, int streamIndex) const 
+{
+  return PackSizes[FolderStartPackStreamIndex[folderIndex] + streamIndex];
+}
+
+CFileSize GetFilePackSize(int fileIndex) const
+{
+  int folderIndex = FileIndexToFolderIndexMap[fileIndex];
+  if (folderIndex >= 0)
+  {
+    const CFolder &folderInfo = Folders[folderIndex];
+    if (FolderStartFileIndex[folderIndex] == fileIndex)
+    return GetFolderFullPackSize(folderIndex);
+  }
+  return 0;
+}
+*/
+
+
+SZ_RESULT MySzInAlloc(void **p, size_t size, void * (*allocFunc)(size_t size))
+{
+  if (size == 0)
+    *p = 0;
+  else
+  {
+    *p = allocFunc(size);
+    RINOM(*p);
+  }
+  return SZ_OK;
+}
+
+SZ_RESULT SzArDbExFill(CArchiveDatabaseEx *db, void * (*allocFunc)(size_t size))
+{
+  UInt32 startPos = 0;
+  CFileSize startPosSize = 0;
+  UInt32 i;
+  UInt32 folderIndex = 0;
+  UInt32 indexInFolder = 0;
+  RINOK(MySzInAlloc((void **)&db->FolderStartPackStreamIndex, db->Database.NumFolders * sizeof(UInt32), allocFunc));
+  for(i = 0; i < db->Database.NumFolders; i++)
+  {
+    db->FolderStartPackStreamIndex[i] = startPos;
+    startPos += db->Database.Folders[i].NumPackStreams;
+  }
+
+  RINOK(MySzInAlloc((void **)&db->PackStreamStartPositions, db->Database.NumPackStreams * sizeof(CFileSize), allocFunc));
+
+  for(i = 0; i < db->Database.NumPackStreams; i++)
+  {
+    db->PackStreamStartPositions[i] = startPosSize;
+    startPosSize += db->Database.PackSizes[i];
+  }
+
+  RINOK(MySzInAlloc((void **)&db->FolderStartFileIndex, db->Database.NumFolders * sizeof(UInt32), allocFunc));
+  RINOK(MySzInAlloc((void **)&db->FileIndexToFolderIndexMap, db->Database.NumFiles * sizeof(UInt32), allocFunc));
+
+  for (i = 0; i < db->Database.NumFiles; i++)
+  {
+    CFileItem *file = db->Database.Files + i;
+    int emptyStream = !file->HasStream;
+    if (emptyStream && indexInFolder == 0)
+    {
+      db->FileIndexToFolderIndexMap[i] = (UInt32)-1;
+      continue;
+    }
+    if (indexInFolder == 0)
+    {
+      /*
+      v3.13 incorrectly worked with empty folders
+      v4.07: Loop for skipping empty folders
+      */
+      while(1)
+      {
+        if (folderIndex >= db->Database.NumFolders)
+          return SZE_ARCHIVE_ERROR;
+        db->FolderStartFileIndex[folderIndex] = i;
+        if (db->Database.Folders[folderIndex].NumUnPackStreams != 0)
+          break;
+        folderIndex++;
+      }
+    }
+    db->FileIndexToFolderIndexMap[i] = folderIndex;
+    if (emptyStream)
+      continue;
+    indexInFolder++;
+    if (indexInFolder >= db->Database.Folders[folderIndex].NumUnPackStreams)
+    {
+      folderIndex++;
+      indexInFolder = 0;
+    }
+  }
+  return SZ_OK;
+}
+
+
+CFileSize SzArDbGetFolderStreamPos(CArchiveDatabaseEx *db, UInt32 folderIndex, UInt32 indexInFolder)
+{
+  return db->ArchiveInfo.DataStartPosition + 
+    db->PackStreamStartPositions[db->FolderStartPackStreamIndex[folderIndex] + indexInFolder];
+}
+
+CFileSize SzArDbGetFolderFullPackSize(CArchiveDatabaseEx *db, UInt32 folderIndex)
+{
+  UInt32 packStreamIndex = db->FolderStartPackStreamIndex[folderIndex];
+  CFolder *folder = db->Database.Folders + folderIndex;
+  CFileSize size = 0;
+  UInt32 i;
+  for (i = 0; i < folder->NumPackStreams; i++)
+    size += db->Database.PackSizes[packStreamIndex + i];
+  return size;
+}
+
+
+/*
+SZ_RESULT SzReadTime(const CObjectVector<CSzByteBuffer> &dataVector,
+    CObjectVector<CFileItem> &files, UInt64 type)
+{
+  CBoolVector boolVector;
+  RINOK(ReadBoolVector2(files.Size(), boolVector))
+
+  CStreamSwitch streamSwitch;
+  RINOK(streamSwitch.Set(this, &dataVector));
+
+  for(int i = 0; i < files.Size(); i++)
+  {
+    CFileItem &file = files[i];
+    CArchiveFileTime fileTime;
+    bool defined = boolVector[i];
+    if (defined)
+    {
+      UInt32 low, high;
+      RINOK(SzReadUInt32(low));
+      RINOK(SzReadUInt32(high));
+      fileTime.dwLowDateTime = low;
+      fileTime.dwHighDateTime = high;
+    }
+    switch(type)
+    {
+      case k7zIdCreationTime:
+        file.IsCreationTimeDefined = defined;
+        if (defined)
+          file.CreationTime = fileTime;
+        break;
+      case k7zIdLastWriteTime:
+        file.IsLastWriteTimeDefined = defined;
+        if (defined)
+          file.LastWriteTime = fileTime;
+        break;
+      case k7zIdLastAccessTime:
+        file.IsLastAccessTimeDefined = defined;
+        if (defined)
+          file.LastAccessTime = fileTime;
+        break;
+    }
+  }
+  return SZ_OK;
+}
+*/
+
+SZ_RESULT SafeReadDirect(ISzInStream *inStream, Byte *data, size_t size)
+{
+  #ifdef _LZMA_IN_CB
+  while (size > 0)
+  {
+    Byte *inBuffer;
+    size_t processedSize;
+    RINOK(inStream->Read(inStream, (void **)&inBuffer, size, &processedSize));
+    if (processedSize == 0 || processedSize > size)
+      return SZE_FAIL;
+    size -= processedSize;
+    do
+    {
+      *data++ = *inBuffer++;
+    }
+    while (--processedSize != 0);
+  }
+  #else
+  size_t processedSize;
+  RINOK(inStream->Read(inStream, data, size, &processedSize));
+  if (processedSize != size)
+    return SZE_FAIL;
+  #endif
+  return SZ_OK;
+}
+
+SZ_RESULT SafeReadDirectByte(ISzInStream *inStream, Byte *data)
+{
+  return SafeReadDirect(inStream, data, 1);
+}
+
+SZ_RESULT SafeReadDirectUInt32(ISzInStream *inStream, UInt32 *value)
+{
+  int i;
+  *value = 0;
+  for (i = 0; i < 4; i++)
+  {
+    Byte b;
+    RINOK(SafeReadDirectByte(inStream, &b));
+    *value |= ((UInt32)b << (8 * i));
+  }
+  return SZ_OK;
+}
+
+SZ_RESULT SafeReadDirectUInt64(ISzInStream *inStream, UInt64 *value)
+{
+  int i;
+  *value = 0;
+  for (i = 0; i < 8; i++)
+  {
+    Byte b;
+    RINOK(SafeReadDirectByte(inStream, &b));
+    *value |= ((UInt32)b << (8 * i));
+  }
+  return SZ_OK;
+}
+
+int TestSignatureCandidate(Byte *testBytes)
+{
+  size_t i;
+  for (i = 0; i < k7zSignatureSize; i++)
+    if (testBytes[i] != k7zSignature[i])
+      return 0;
+  return 1;
+}
+
+typedef struct _CSzState
+{
+  Byte *Data;
+  size_t Size;
+}CSzData;
+
+SZ_RESULT SzReadByte(CSzData *sd, Byte *b)
+{
+  if (sd->Size == 0)
+    return SZE_ARCHIVE_ERROR;
+  sd->Size--;
+  *b = *sd->Data++;
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadBytes(CSzData *sd, Byte *data, size_t size)
+{
+  size_t i;
+  for (i = 0; i < size; i++)
+  {
+    RINOK(SzReadByte(sd, data + i));
+  }
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadUInt32(CSzData *sd, UInt32 *value)
+{
+  int i;
+  *value = 0;
+  for (i = 0; i < 4; i++)
+  {
+    Byte b;
+    RINOK(SzReadByte(sd, &b));
+    *value |= ((UInt32)(b) << (8 * i));
+  }
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadNumber(CSzData *sd, UInt64 *value)
+{
+  Byte firstByte;
+  Byte mask = 0x80;
+  int i;
+  RINOK(SzReadByte(sd, &firstByte));
+  *value = 0;
+  for (i = 0; i < 8; i++)
+  {
+    Byte b;
+    if ((firstByte & mask) == 0)
+    {
+      UInt64 highPart = firstByte & (mask - 1);
+      *value += (highPart << (8 * i));
+      return SZ_OK;
+    }
+    RINOK(SzReadByte(sd, &b));
+    *value |= ((UInt64)b << (8 * i));
+    mask >>= 1;
+  }
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadSize(CSzData *sd, CFileSize *value)
+{
+  UInt64 value64;
+  RINOK(SzReadNumber(sd, &value64));
+  *value = (CFileSize)value64;
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadNumber32(CSzData *sd, UInt32 *value)
+{
+  UInt64 value64;
+  RINOK(SzReadNumber(sd, &value64));
+  if (value64 >= 0x80000000)
+    return SZE_NOTIMPL;
+  if (value64 >= ((UInt64)(1) << ((sizeof(size_t) - 1) * 8 + 2)))
+    return SZE_NOTIMPL;
+  *value = (UInt32)value64;
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadID(CSzData *sd, UInt64 *value) 
+{ 
+  return SzReadNumber(sd, value); 
+}
+
+SZ_RESULT SzSkeepDataSize(CSzData *sd, UInt64 size)
+{
+  if (size > sd->Size)
+    return SZE_ARCHIVE_ERROR;
+  sd->Size -= (size_t)size;
+  sd->Data += (size_t)size;
+  return SZ_OK;
+}
+
+SZ_RESULT SzSkeepData(CSzData *sd)
+{
+  UInt64 size;
+  RINOK(SzReadNumber(sd, &size));
+  return SzSkeepDataSize(sd, size);
+}
+
+SZ_RESULT SzReadArchiveProperties(CSzData *sd)
+{
+  while(1)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &type));
+    if (type == k7zIdEnd)
+      break;
+    SzSkeepData(sd);
+  }
+  return SZ_OK;
+}
+
+SZ_RESULT SzWaitAttribute(CSzData *sd, UInt64 attribute)
+{
+  while(1)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &type));
+    if (type == attribute)
+      return SZ_OK;
+    if (type == k7zIdEnd)
+      return SZE_ARCHIVE_ERROR;
+    RINOK(SzSkeepData(sd));
+  }
+}
+
+SZ_RESULT SzReadBoolVector(CSzData *sd, size_t numItems, Byte **v, void * (*allocFunc)(size_t size))
+{
+  Byte b = 0;
+  Byte mask = 0;
+  size_t i;
+  RINOK(MySzInAlloc((void **)v, numItems * sizeof(Byte), allocFunc));
+  for(i = 0; i < numItems; i++)
+  {
+    if (mask == 0)
+    {
+      RINOK(SzReadByte(sd, &b));
+      mask = 0x80;
+    }
+    (*v)[i] = (Byte)(((b & mask) != 0) ? 1 : 0);
+    mask >>= 1;
+  }
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadBoolVector2(CSzData *sd, size_t numItems, Byte **v, void * (*allocFunc)(size_t size))
+{
+  Byte allAreDefined;
+  size_t i;
+  RINOK(SzReadByte(sd, &allAreDefined));
+  if (allAreDefined == 0)
+    return SzReadBoolVector(sd, numItems, v, allocFunc);
+  RINOK(MySzInAlloc((void **)v, numItems * sizeof(Byte), allocFunc));
+  for(i = 0; i < numItems; i++)
+    (*v)[i] = 1;
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadHashDigests(
+    CSzData *sd, 
+    size_t numItems,
+    Byte **digestsDefined, 
+    UInt32 **digests, 
+    void * (*allocFunc)(size_t size))
+{
+  size_t i;
+  RINOK(SzReadBoolVector2(sd, numItems, digestsDefined, allocFunc));
+  RINOK(MySzInAlloc((void **)digests, numItems * sizeof(UInt32), allocFunc));
+  for(i = 0; i < numItems; i++)
+    if ((*digestsDefined)[i])
+    {
+      RINOK(SzReadUInt32(sd, (*digests) + i));
+    }
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadPackInfo(
+    CSzData *sd, 
+    CFileSize *dataOffset,
+    UInt32 *numPackStreams,
+    CFileSize **packSizes,
+    Byte **packCRCsDefined,
+    UInt32 **packCRCs,
+    void * (*allocFunc)(size_t size))
+{
+  UInt32 i;
+  RINOK(SzReadSize(sd, dataOffset));
+  RINOK(SzReadNumber32(sd, numPackStreams));
+
+  RINOK(SzWaitAttribute(sd, k7zIdSize));
+
+  RINOK(MySzInAlloc((void **)packSizes, (size_t)*numPackStreams * sizeof(CFileSize), allocFunc));
+
+  for(i = 0; i < *numPackStreams; i++)
+  {
+    RINOK(SzReadSize(sd, (*packSizes) + i));
+  }
+
+  while(1)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &type));
+    if (type == k7zIdEnd)
+      break;
+    if (type == k7zIdCRC)
+    {
+      RINOK(SzReadHashDigests(sd, (size_t)*numPackStreams, packCRCsDefined, packCRCs, allocFunc)); 
+      continue;
+    }
+    RINOK(SzSkeepData(sd));
+  }
+  if (*packCRCsDefined == 0)
+  {
+    RINOK(MySzInAlloc((void **)packCRCsDefined, (size_t)*numPackStreams * sizeof(Byte), allocFunc));
+    RINOK(MySzInAlloc((void **)packCRCs, (size_t)*numPackStreams * sizeof(UInt32), allocFunc));
+    for(i = 0; i < *numPackStreams; i++)
+    {
+      (*packCRCsDefined)[i] = 0;
+      (*packCRCs)[i] = 0;
+    }
+  }
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadSwitch(CSzData *sd)
+{
+  Byte external;
+  RINOK(SzReadByte(sd, &external));
+  return (external == 0) ? SZ_OK: SZE_ARCHIVE_ERROR;
+}
+
+SZ_RESULT SzGetNextFolderItem(CSzData *sd, CFolder *folder, void * (*allocFunc)(size_t size))
+{
+  UInt32 numCoders;
+  UInt32 numBindPairs;
+  UInt32 numPackedStreams;
+  UInt32 i;
+  UInt32 numInStreams = 0;
+  UInt32 numOutStreams = 0;
+  RINOK(SzReadNumber32(sd, &numCoders));
+  folder->NumCoders = numCoders;
+
+  RINOK(MySzInAlloc((void **)&folder->Coders, (size_t)numCoders * sizeof(CCoderInfo), allocFunc));
+
+  for (i = 0; i < numCoders; i++)
+    SzCoderInfoInit(folder->Coders + i);
+
+  for (i = 0; i < numCoders; i++)
+  {
+    Byte mainByte;
+    CCoderInfo *coder = folder->Coders + i;
+    {
+      RINOK(SzReadByte(sd, &mainByte));
+      coder->MethodID.IDSize = (Byte)(mainByte & 0xF);
+      RINOK(SzReadBytes(sd, coder->MethodID.ID, coder->MethodID.IDSize));
+      if ((mainByte & 0x10) != 0)
+      {
+        RINOK(SzReadNumber32(sd, &coder->NumInStreams));
+        RINOK(SzReadNumber32(sd, &coder->NumOutStreams));
+      }
+      else
+      {
+        coder->NumInStreams = 1;
+        coder->NumOutStreams = 1;
+      }
+      if ((mainByte & 0x20) != 0)
+      {
+        UInt64 propertiesSize = 0;
+        RINOK(SzReadNumber(sd, &propertiesSize));
+        if (!SzByteBufferCreate(&coder->Properties, (size_t)propertiesSize, allocFunc))
+          return SZE_OUTOFMEMORY;
+        RINOK(SzReadBytes(sd, coder->Properties.Items, (size_t)propertiesSize));
+      }
+    }
+    while ((mainByte & 0x80) != 0)
+    {
+      RINOK(SzReadByte(sd, &mainByte));
+      RINOK(SzSkeepDataSize(sd, (mainByte & 0xF)));
+      if ((mainByte & 0x10) != 0)
+      {
+        UInt32 n;
+        RINOK(SzReadNumber32(sd, &n));
+        RINOK(SzReadNumber32(sd, &n));
+      }
+      if ((mainByte & 0x20) != 0)
+      {
+        UInt64 propertiesSize = 0;
+        RINOK(SzReadNumber(sd, &propertiesSize));
+        RINOK(SzSkeepDataSize(sd, propertiesSize));
+      }
+    }
+    numInStreams += (UInt32)coder->NumInStreams;
+    numOutStreams += (UInt32)coder->NumOutStreams;
+  }
+
+  numBindPairs = numOutStreams - 1;
+  folder->NumBindPairs = numBindPairs;
+
+
+  RINOK(MySzInAlloc((void **)&folder->BindPairs, (size_t)numBindPairs * sizeof(CBindPair), allocFunc));
+
+  for (i = 0; i < numBindPairs; i++)
+  {
+    CBindPair *bindPair = folder->BindPairs + i;;
+    RINOK(SzReadNumber32(sd, &bindPair->InIndex));
+    RINOK(SzReadNumber32(sd, &bindPair->OutIndex)); 
+  }
+
+  numPackedStreams = numInStreams - (UInt32)numBindPairs;
+
+  folder->NumPackStreams = numPackedStreams;
+  RINOK(MySzInAlloc((void **)&folder->PackStreams, (size_t)numPackedStreams * sizeof(UInt32), allocFunc));
+
+  if (numPackedStreams == 1)
+  {
+    UInt32 j;
+    UInt32 pi = 0;
+    for (j = 0; j < numInStreams; j++)
+      if (SzFolderFindBindPairForInStream(folder, j) < 0)
+      {
+        folder->PackStreams[pi++] = j;
+        break;
+      }
+  }
+  else
+    for(i = 0; i < numPackedStreams; i++)
+    {
+      RINOK(SzReadNumber32(sd, folder->PackStreams + i));
+    }
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadUnPackInfo(
+    CSzData *sd, 
+    UInt32 *numFolders,
+    CFolder **folders,  /* for allocFunc */
+    void * (*allocFunc)(size_t size),
+    ISzAlloc *allocTemp)
+{
+  UInt32 i;
+  RINOK(SzWaitAttribute(sd, k7zIdFolder));
+  RINOK(SzReadNumber32(sd, numFolders));
+  {
+    RINOK(SzReadSwitch(sd));
+
+
+    RINOK(MySzInAlloc((void **)folders, (size_t)*numFolders * sizeof(CFolder), allocFunc));
+
+    for(i = 0; i < *numFolders; i++)
+      SzFolderInit((*folders) + i);
+
+    for(i = 0; i < *numFolders; i++)
+    {
+      RINOK(SzGetNextFolderItem(sd, (*folders) + i, allocFunc));
+    }
+  }
+
+  RINOK(SzWaitAttribute(sd, k7zIdCodersUnPackSize));
+
+  for(i = 0; i < *numFolders; i++)
+  {
+    UInt32 j;
+    CFolder *folder = (*folders) + i;
+    UInt32 numOutStreams = SzFolderGetNumOutStreams(folder);
+
+    RINOK(MySzInAlloc((void **)&folder->UnPackSizes, (size_t)numOutStreams * sizeof(CFileSize), allocFunc));
+
+    for(j = 0; j < numOutStreams; j++)
+    {
+      RINOK(SzReadSize(sd, folder->UnPackSizes + j));
+    }
+  }
+
+  while(1)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &type));
+    if (type == k7zIdEnd)
+      return SZ_OK;
+    if (type == k7zIdCRC)
+    {
+      SZ_RESULT res;
+      Byte *crcsDefined = 0;
+      UInt32 *crcs = 0;
+      res = SzReadHashDigests(sd, *numFolders, &crcsDefined, &crcs, allocTemp->Alloc); 
+      if (res == SZ_OK)
+      {
+        for(i = 0; i < *numFolders; i++)
+        {
+          CFolder *folder = (*folders) + i;
+          folder->UnPackCRCDefined = crcsDefined[i];
+          folder->UnPackCRC = crcs[i];
+        }
+      }
+      allocTemp->Free(crcs);
+      allocTemp->Free(crcsDefined);
+      RINOK(res);
+      continue;
+    }
+    RINOK(SzSkeepData(sd));
+  }
+}
+
+SZ_RESULT SzReadSubStreamsInfo(
+    CSzData *sd, 
+    UInt32 numFolders,
+    CFolder *folders,
+    UInt32 *numUnPackStreams,
+    CFileSize **unPackSizes,
+    Byte **digestsDefined,
+    UInt32 **digests,
+    ISzAlloc *allocTemp)
+{
+  UInt64 type = 0;
+  UInt32 i;
+  UInt32 si = 0;
+  UInt32 numDigests = 0;
+
+  for(i = 0; i < numFolders; i++)
+    folders[i].NumUnPackStreams = 1;
+  *numUnPackStreams = numFolders;
+
+  while(1)
+  {
+    RINOK(SzReadID(sd, &type));
+    if (type == k7zIdNumUnPackStream)
+    {
+      *numUnPackStreams = 0;
+      for(i = 0; i < numFolders; i++)
+      {
+        UInt32 numStreams;
+        RINOK(SzReadNumber32(sd, &numStreams));
+        folders[i].NumUnPackStreams = numStreams;
+        *numUnPackStreams += numStreams;
+      }
+      continue;
+    }
+    if (type == k7zIdCRC || type == k7zIdSize)
+      break;
+    if (type == k7zIdEnd)
+      break;
+    RINOK(SzSkeepData(sd));
+  }
+
+  if (*numUnPackStreams == 0)
+  {
+    *unPackSizes = 0;
+    *digestsDefined = 0;
+    *digests = 0;
+  }
+  else
+  {
+    *unPackSizes = (CFileSize *)allocTemp->Alloc((size_t)*numUnPackStreams * sizeof(CFileSize));
+    RINOM(*unPackSizes);
+    *digestsDefined = (Byte *)allocTemp->Alloc((size_t)*numUnPackStreams * sizeof(Byte));
+    RINOM(*digestsDefined);
+    *digests = (UInt32 *)allocTemp->Alloc((size_t)*numUnPackStreams * sizeof(UInt32));
+    RINOM(*digests);
+  }
+
+  for(i = 0; i < numFolders; i++)
+  {
+    /*
+    v3.13 incorrectly worked with empty folders
+    v4.07: we check that folder is empty
+    */
+    CFileSize sum = 0;
+    UInt32 j;
+    UInt32 numSubstreams = folders[i].NumUnPackStreams;
+    if (numSubstreams == 0)
+      continue;
+    if (type == k7zIdSize)
+    for (j = 1; j < numSubstreams; j++)
+    {
+      CFileSize size;
+      RINOK(SzReadSize(sd, &size));
+      (*unPackSizes)[si++] = size;
+      sum += size;
+    }
+    (*unPackSizes)[si++] = SzFolderGetUnPackSize(folders + i) - sum;
+  }
+  if (type == k7zIdSize)
+  {
+    RINOK(SzReadID(sd, &type));
+  }
+
+  for(i = 0; i < *numUnPackStreams; i++)
+  {
+    (*digestsDefined)[i] = 0;
+    (*digests)[i] = 0;
+  }
+
+
+  for(i = 0; i < numFolders; i++)
+  {
+    UInt32 numSubstreams = folders[i].NumUnPackStreams;
+    if (numSubstreams != 1 || !folders[i].UnPackCRCDefined)
+      numDigests += numSubstreams;
+  }
+
+ 
+  si = 0;
+  while(1)
+  {
+    if (type == k7zIdCRC)
+    {
+      int digestIndex = 0;
+      Byte *digestsDefined2 = 0; 
+      UInt32 *digests2 = 0;
+      SZ_RESULT res = SzReadHashDigests(sd, numDigests, &digestsDefined2, &digests2, allocTemp->Alloc);
+      if (res == SZ_OK)
+      {
+        for (i = 0; i < numFolders; i++)
+        {
+          CFolder *folder = folders + i;
+          UInt32 numSubstreams = folder->NumUnPackStreams;
+          if (numSubstreams == 1 && folder->UnPackCRCDefined)
+          {
+            (*digestsDefined)[si] = 1;
+            (*digests)[si] = folder->UnPackCRC;
+            si++;
+          }
+          else
+          {
+            UInt32 j;
+            for (j = 0; j < numSubstreams; j++, digestIndex++)
+            {
+              (*digestsDefined)[si] = digestsDefined2[digestIndex];
+              (*digests)[si] = digests2[digestIndex];
+              si++;
+            }
+          }
+        }
+      }
+      allocTemp->Free(digestsDefined2);
+      allocTemp->Free(digests2);
+      RINOK(res);
+    }
+    else if (type == k7zIdEnd)
+      return SZ_OK;
+    else
+    {
+      RINOK(SzSkeepData(sd));
+    }
+    RINOK(SzReadID(sd, &type));
+  }
+}
+
+
+SZ_RESULT SzReadStreamsInfo(
+    CSzData *sd, 
+    CFileSize *dataOffset,
+    CArchiveDatabase *db,
+    UInt32 *numUnPackStreams,
+    CFileSize **unPackSizes, /* allocTemp */
+    Byte **digestsDefined,   /* allocTemp */
+    UInt32 **digests,        /* allocTemp */
+    void * (*allocFunc)(size_t size),
+    ISzAlloc *allocTemp)
+{
+  while(1)
+  {
+    UInt64 type;
+    RINOK(SzReadID(sd, &type));
+    if ((UInt64)(int)type != type)
+      return SZE_FAIL;
+    switch((int)type)
+    {
+      case k7zIdEnd:
+        return SZ_OK;
+      case k7zIdPackInfo:
+      {
+        RINOK(SzReadPackInfo(sd, dataOffset, &db->NumPackStreams, 
+            &db->PackSizes, &db->PackCRCsDefined, &db->PackCRCs, allocFunc));
+        break;
+      }
+      case k7zIdUnPackInfo:
+      {
+        RINOK(SzReadUnPackInfo(sd, &db->NumFolders, &db->Folders, allocFunc, allocTemp));
+        break;
+      }
+      case k7zIdSubStreamsInfo:
+      {
+        RINOK(SzReadSubStreamsInfo(sd, db->NumFolders, db->Folders, 
+            numUnPackStreams, unPackSizes, digestsDefined, digests, allocTemp));
+        break;
+      }
+      default:
+        return SZE_FAIL;
+    }
+  }
+}
+
+Byte kUtf8Limits[5] = { 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+SZ_RESULT SzReadFileNames(CSzData *sd, UInt32 numFiles, CFileItem *files, 
+    void * (*allocFunc)(size_t size))
+{
+  UInt32 i;
+  for(i = 0; i < numFiles; i++)
+  {
+    UInt32 len = 0;
+    UInt32 pos = 0;
+    CFileItem *file = files + i;
+    while(pos + 2 <= sd->Size)
+    {
+      int numAdds;
+      UInt32 value = (UInt32)(sd->Data[pos] | (((UInt32)sd->Data[pos + 1]) << 8));
+      pos += 2;
+      len++;
+      if (value == 0)
+        break;
+      if (value < 0x80)
+        continue;
+      if (value >= 0xD800 && value < 0xE000)
+      {
+        UInt32 c2;
+        if (value >= 0xDC00)
+          return SZE_ARCHIVE_ERROR;
+        if (pos + 2 > sd->Size)
+          return SZE_ARCHIVE_ERROR;
+        c2 = (UInt32)(sd->Data[pos] | (((UInt32)sd->Data[pos + 1]) << 8));
+        pos += 2;
+        if (c2 < 0xDC00 || c2 >= 0xE000)
+          return SZE_ARCHIVE_ERROR;
+        value = ((value - 0xD800) << 10) | (c2 - 0xDC00);
+      }
+      for (numAdds = 1; numAdds < 5; numAdds++)
+        if (value < (((UInt32)1) << (numAdds * 5 + 6)))
+          break;
+      len += numAdds;
+    }
+
+    RINOK(MySzInAlloc((void **)&file->Name, (size_t)len * sizeof(char), allocFunc));
+
+    len = 0;
+    while(2 <= sd->Size)
+    {
+      int numAdds;
+      UInt32 value = (UInt32)(sd->Data[0] | (((UInt32)sd->Data[1]) << 8));
+      SzSkeepDataSize(sd, 2);
+      if (value < 0x80)
+      {
+        file->Name[len++] = (char)value;
+        if (value == 0)
+          break;
+        continue;
+      }
+      if (value >= 0xD800 && value < 0xE000)
+      {
+        UInt32 c2 = (UInt32)(sd->Data[0] | (((UInt32)sd->Data[1]) << 8));
+        SzSkeepDataSize(sd, 2);
+        value = ((value - 0xD800) << 10) | (c2 - 0xDC00);
+      }
+      for (numAdds = 1; numAdds < 5; numAdds++)
+        if (value < (((UInt32)1) << (numAdds * 5 + 6)))
+          break;
+      file->Name[len++] = (char)(kUtf8Limits[numAdds - 1] + (value >> (6 * numAdds)));
+      do
+      {
+        numAdds--;
+        file->Name[len++] = (char)(0x80 + ((value >> (6 * numAdds)) & 0x3F));
+      }
+      while(numAdds > 0);
+
+      len += numAdds;
+    }
+  }
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadHeader2(
+    CSzData *sd, 
+    CArchiveDatabaseEx *db,   /* allocMain */
+    CFileSize **unPackSizes,  /* allocTemp */
+    Byte **digestsDefined,    /* allocTemp */
+    UInt32 **digests,         /* allocTemp */
+    Byte **emptyStreamVector, /* allocTemp */
+    Byte **emptyFileVector,   /* allocTemp */
+    ISzAlloc *allocMain, 
+    ISzAlloc *allocTemp)
+{
+  UInt64 type;
+  UInt32 numUnPackStreams = 0;
+  UInt32 numFiles = 0;
+  CFileItem *files = 0;
+  UInt32 numEmptyStreams = 0;
+  UInt32 i;
+
+  RINOK(SzReadID(sd, &type));
+
+  if (type == k7zIdArchiveProperties)
+  {
+    RINOK(SzReadArchiveProperties(sd));
+    RINOK(SzReadID(sd, &type));
+  }
+ 
+ 
+  if (type == k7zIdMainStreamsInfo)
+  {
+    RINOK(SzReadStreamsInfo(sd,
+        &db->ArchiveInfo.DataStartPosition,
+        &db->Database, 
+        &numUnPackStreams,
+        unPackSizes,
+        digestsDefined,
+        digests, allocMain->Alloc, allocTemp));
+    db->ArchiveInfo.DataStartPosition += db->ArchiveInfo.StartPositionAfterHeader;
+    RINOK(SzReadID(sd, &type));
+  }
+
+  if (type == k7zIdEnd)
+    return SZ_OK;
+  if (type != k7zIdFilesInfo)
+    return SZE_ARCHIVE_ERROR;
+  
+  RINOK(SzReadNumber32(sd, &numFiles));
+  db->Database.NumFiles = numFiles;
+
+  RINOK(MySzInAlloc((void **)&files, (size_t)numFiles * sizeof(CFileItem), allocMain->Alloc));
+
+  db->Database.Files = files;
+  for(i = 0; i < numFiles; i++)
+    SzFileInit(files + i);
+
+  while(1)
+  {
+    UInt64 type;
+    UInt64 size;
+    RINOK(SzReadID(sd, &type));
+    if (type == k7zIdEnd)
+      break;
+    RINOK(SzReadNumber(sd, &size));
+
+    if ((UInt64)(int)type != type)
+    {
+      RINOK(SzSkeepDataSize(sd, size));
+    }
+    else
+    switch((int)type)
+    {
+      case k7zIdName:
+      {
+        RINOK(SzReadSwitch(sd));
+        RINOK(SzReadFileNames(sd, numFiles, files, allocMain->Alloc))
+        break;
+      }
+      case k7zIdEmptyStream:
+      {
+        RINOK(SzReadBoolVector(sd, numFiles, emptyStreamVector, allocTemp->Alloc));
+        numEmptyStreams = 0;
+        for (i = 0; i < numFiles; i++)
+          if ((*emptyStreamVector)[i])
+            numEmptyStreams++;
+        break;
+      }
+      case k7zIdEmptyFile:
+      {
+        RINOK(SzReadBoolVector(sd, numEmptyStreams, emptyFileVector, allocTemp->Alloc));
+        break;
+      }
+      default:
+      {
+        RINOK(SzSkeepDataSize(sd, size));
+      }
+    }
+  }
+
+  {
+    UInt32 emptyFileIndex = 0;
+    UInt32 sizeIndex = 0;
+    for(i = 0; i < numFiles; i++)
+    {
+      CFileItem *file = files + i;
+      file->IsAnti = 0;
+      if (*emptyStreamVector == 0)
+        file->HasStream = 1;
+      else
+        file->HasStream = (Byte)((*emptyStreamVector)[i] ? 0 : 1);
+      if(file->HasStream)
+      {
+        file->IsDirectory = 0;
+        file->Size = (*unPackSizes)[sizeIndex];
+        file->FileCRC = (*digests)[sizeIndex];
+        file->IsFileCRCDefined = (Byte)(*digestsDefined)[sizeIndex];
+        sizeIndex++;
+      }
+      else
+      {
+        if (*emptyFileVector == 0)
+          file->IsDirectory = 1;
+        else
+          file->IsDirectory = (Byte)((*emptyFileVector)[emptyFileIndex] ? 0 : 1);
+        emptyFileIndex++;
+        file->Size = 0;
+        file->IsFileCRCDefined = 0;
+      }
+    }
+  }
+  return SzArDbExFill(db, allocMain->Alloc);
+}
+
+SZ_RESULT SzReadHeader(
+    CSzData *sd, 
+    CArchiveDatabaseEx *db, 
+    ISzAlloc *allocMain, 
+    ISzAlloc *allocTemp)
+{
+  CFileSize *unPackSizes = 0;
+  Byte *digestsDefined = 0;
+  UInt32 *digests = 0;
+  Byte *emptyStreamVector = 0;
+  Byte *emptyFileVector = 0;
+  SZ_RESULT res = SzReadHeader2(sd, db, 
+      &unPackSizes, &digestsDefined, &digests,
+      &emptyStreamVector, &emptyFileVector,
+      allocMain, allocTemp);
+  allocTemp->Free(unPackSizes);
+  allocTemp->Free(digestsDefined);
+  allocTemp->Free(digests);
+  allocTemp->Free(emptyStreamVector);
+  allocTemp->Free(emptyFileVector);
+  return res;
+} 
+
+SZ_RESULT SzReadAndDecodePackedStreams2(
+    ISzInStream *inStream, 
+    CSzData *sd,
+    CSzByteBuffer *outBuffer,
+    CFileSize baseOffset, 
+    CArchiveDatabase *db,
+    CFileSize **unPackSizes,
+    Byte **digestsDefined,
+    UInt32 **digests,
+    #ifndef _LZMA_IN_CB
+    Byte **inBuffer,
+    #endif
+    ISzAlloc *allocTemp)
+{
+
+  UInt32 numUnPackStreams = 0;
+  CFileSize dataStartPos;
+  CFolder *folder;
+  #ifndef _LZMA_IN_CB
+  CFileSize packSize = 0;
+  UInt32 i = 0;
+  #endif
+  CFileSize unPackSize;
+  size_t outRealSize;
+  SZ_RESULT res;
+
+  RINOK(SzReadStreamsInfo(sd, &dataStartPos, db,
+      &numUnPackStreams,  unPackSizes, digestsDefined, digests, 
+      allocTemp->Alloc, allocTemp));
+  
+  dataStartPos += baseOffset;
+  if (db->NumFolders != 1)
+    return SZE_ARCHIVE_ERROR;
+
+  folder = db->Folders;
+  unPackSize = SzFolderGetUnPackSize(folder);
+  
+  RINOK(inStream->Seek(inStream, dataStartPos));
+
+  #ifndef _LZMA_IN_CB
+  for (i = 0; i < db->NumPackStreams; i++)
+    packSize += db->PackSizes[i];
+
+  RINOK(MySzInAlloc((void **)inBuffer, (size_t)packSize, allocTemp->Alloc));
+
+  RINOK(SafeReadDirect(inStream, *inBuffer, (size_t)packSize));
+  #endif
+
+  if (!SzByteBufferCreate(outBuffer, (size_t)unPackSize, allocTemp->Alloc))
+    return SZE_OUTOFMEMORY;
+  
+  res = SzDecode(db->PackSizes, folder, 
+          #ifdef _LZMA_IN_CB
+          inStream,
+          #else
+          *inBuffer, 
+          #endif
+          outBuffer->Items, (size_t)unPackSize,
+          &outRealSize, allocTemp);
+  RINOK(res)
+  if (outRealSize != (UInt32)unPackSize)
+    return SZE_FAIL;
+  if (folder->UnPackCRCDefined)
+    if (!CrcVerifyDigest(folder->UnPackCRC, outBuffer->Items, (size_t)unPackSize))
+      return SZE_FAIL;
+  return SZ_OK;
+}
+
+SZ_RESULT SzReadAndDecodePackedStreams(
+    ISzInStream *inStream, 
+    CSzData *sd,
+    CSzByteBuffer *outBuffer,
+    CFileSize baseOffset, 
+    ISzAlloc *allocTemp)
+{
+  CArchiveDatabase db;
+  CFileSize *unPackSizes = 0;
+  Byte *digestsDefined = 0;
+  UInt32 *digests = 0;
+  #ifndef _LZMA_IN_CB
+  Byte *inBuffer = 0;
+  #endif
+  SZ_RESULT res;
+  SzArchiveDatabaseInit(&db);
+  res = SzReadAndDecodePackedStreams2(inStream, sd, outBuffer, baseOffset, 
+    &db, &unPackSizes, &digestsDefined, &digests, 
+    #ifndef _LZMA_IN_CB
+    &inBuffer,
+    #endif
+    allocTemp);
+  SzArchiveDatabaseFree(&db, allocTemp->Free);
+  allocTemp->Free(unPackSizes);
+  allocTemp->Free(digestsDefined);
+  allocTemp->Free(digests);
+  #ifndef _LZMA_IN_CB
+  allocTemp->Free(inBuffer);
+  #endif
+  return res;
+}
+
+SZ_RESULT SzArchiveOpen2(
+    ISzInStream *inStream, 
+    CArchiveDatabaseEx *db,
+    ISzAlloc *allocMain, 
+    ISzAlloc *allocTemp)
+{
+  Byte signature[k7zSignatureSize];
+  Byte version;
+  UInt32 crcFromArchive;
+  UInt64 nextHeaderOffset;
+  UInt64 nextHeaderSize;
+  UInt32 nextHeaderCRC;
+  UInt32 crc;
+  CFileSize pos = 0;
+  CSzByteBuffer buffer;
+  CSzData sd;
+  SZ_RESULT res;
+
+  RINOK(SafeReadDirect(inStream, signature, k7zSignatureSize));
+
+  if (!TestSignatureCandidate(signature))
+    return SZE_ARCHIVE_ERROR;
+
+  /*
+  db.Clear();
+  db.ArchiveInfo.StartPosition = _arhiveBeginStreamPosition;
+  */
+  RINOK(SafeReadDirectByte(inStream, &version));
+  if (version != k7zMajorVersion)
+    return SZE_ARCHIVE_ERROR;
+  RINOK(SafeReadDirectByte(inStream, &version));
+
+  RINOK(SafeReadDirectUInt32(inStream, &crcFromArchive));
+
+  CrcInit(&crc);
+  RINOK(SafeReadDirectUInt64(inStream, &nextHeaderOffset));
+  CrcUpdateUInt64(&crc, nextHeaderOffset);
+  RINOK(SafeReadDirectUInt64(inStream, &nextHeaderSize));
+  CrcUpdateUInt64(&crc, nextHeaderSize);
+  RINOK(SafeReadDirectUInt32(inStream, &nextHeaderCRC));
+  CrcUpdateUInt32(&crc, nextHeaderCRC);
+
+  pos = k7zStartHeaderSize;
+  db->ArchiveInfo.StartPositionAfterHeader = pos;
+  
+  if (CrcGetDigest(&crc) != crcFromArchive)
+    return SZE_ARCHIVE_ERROR;
+
+  if (nextHeaderSize == 0)
+    return SZ_OK;
+
+  RINOK(inStream->Seek(inStream, (CFileSize)(pos + nextHeaderOffset)));
+
+  if (!SzByteBufferCreate(&buffer, (size_t)nextHeaderSize, allocTemp->Alloc))
+    return SZE_OUTOFMEMORY;
+
+  res = SafeReadDirect(inStream, buffer.Items, (size_t)nextHeaderSize);
+  if (res == SZ_OK)
+  {
+    if (CrcVerifyDigest(nextHeaderCRC, buffer.Items, (UInt32)nextHeaderSize))
+    {
+      while (1)
+      {
+        UInt64 type;
+        sd.Data = buffer.Items;
+        sd.Size = buffer.Capacity;
+        res = SzReadID(&sd, &type);
+        if (res != SZ_OK)
+          break;
+        if (type == k7zIdHeader)
+        {
+          res = SzReadHeader(&sd, db, allocMain, allocTemp);
+          break;
+        }
+        if (type != k7zIdEncodedHeader)
+        {
+          res = SZE_ARCHIVE_ERROR;
+          break;
+        }
+        {
+          CSzByteBuffer outBuffer;
+          res = SzReadAndDecodePackedStreams(inStream, &sd, &outBuffer, 
+              db->ArchiveInfo.StartPositionAfterHeader, 
+              allocTemp);
+          if (res != SZ_OK)
+          {
+            SzByteBufferFree(&outBuffer, allocTemp->Free);
+            break;
+          }
+          SzByteBufferFree(&buffer, allocTemp->Free);
+          buffer.Items = outBuffer.Items;
+          buffer.Capacity = outBuffer.Capacity;
+        }
+      }
+    }
+  }
+  SzByteBufferFree(&buffer, allocTemp->Free);
+  return res;
+}
+
+SZ_RESULT SzArchiveOpen(
+    ISzInStream *inStream, 
+    CArchiveDatabaseEx *db,
+    ISzAlloc *allocMain, 
+    ISzAlloc *allocTemp)
+{
+  SZ_RESULT res = SzArchiveOpen2(inStream, db, allocMain, allocTemp);
+  if (res != SZ_OK)
+    SzArDbExFree(db, allocMain->Free);
+  return res;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zIn.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zIn.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zIn.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zIn.h	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,55 @@
+/* 7zIn.h */
+
+#ifndef __7Z_IN_H
+#define __7Z_IN_H
+
+#include "7zHeader.h"
+#include "7zItem.h"
+#include "7zAlloc.h"
+ 
+typedef struct _CInArchiveInfo
+{
+  CFileSize StartPositionAfterHeader; 
+  CFileSize DataStartPosition;
+}CInArchiveInfo;
+
+typedef struct _CArchiveDatabaseEx
+{
+  CArchiveDatabase Database;
+  CInArchiveInfo ArchiveInfo;
+  UInt32 *FolderStartPackStreamIndex;
+  CFileSize *PackStreamStartPositions;
+  UInt32 *FolderStartFileIndex;
+  UInt32 *FileIndexToFolderIndexMap;
+}CArchiveDatabaseEx;
+
+void SzArDbExInit(CArchiveDatabaseEx *db);
+void SzArDbExFree(CArchiveDatabaseEx *db, void (*freeFunc)(void *));
+CFileSize SzArDbGetFolderStreamPos(CArchiveDatabaseEx *db, UInt32 folderIndex, UInt32 indexInFolder);
+CFileSize SzArDbGetFolderFullPackSize(CArchiveDatabaseEx *db, UInt32 folderIndex);
+
+typedef struct _ISzInStream
+{
+  #ifdef _LZMA_IN_CB
+  SZ_RESULT (*Read)(
+      void *object,           /* pointer to ISzInStream itself */
+      void **buffer,          /* out: pointer to buffer with data */
+      size_t maxRequiredSize, /* max required size to read */
+      size_t *processedSize); /* real processed size. 
+                                 processedSize can be less than maxRequiredSize.
+                                 If processedSize == 0, then there are no more 
+                                 bytes in stream. */
+  #else
+  SZ_RESULT (*Read)(void *object, void *buffer, size_t size, size_t *processedSize);
+  #endif
+  SZ_RESULT (*Seek)(void *object, CFileSize pos);
+} ISzInStream;
+
+ 
+int SzArchiveOpen(
+    ISzInStream *inStream, 
+    CArchiveDatabaseEx *db,
+    ISzAlloc *allocMain, 
+    ISzAlloc *allocTemp);
+ 
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zItem.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zItem.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zItem.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zItem.c	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,133 @@
+/* 7zItem.c */
+
+#include "7zItem.h"
+#include "7zAlloc.h"
+
+void SzCoderInfoInit(CCoderInfo *coder)
+{
+  SzByteBufferInit(&coder->Properties);
+}
+
+void SzCoderInfoFree(CCoderInfo *coder, void (*freeFunc)(void *p))
+{
+  SzByteBufferFree(&coder->Properties, freeFunc);
+  SzCoderInfoInit(coder);
+}
+
+void SzFolderInit(CFolder *folder)
+{
+  folder->NumCoders = 0;
+  folder->Coders = 0;
+  folder->NumBindPairs = 0;
+  folder->BindPairs = 0;
+  folder->NumPackStreams = 0;
+  folder->PackStreams = 0;
+  folder->UnPackSizes = 0;
+  folder->UnPackCRCDefined = 0;
+  folder->UnPackCRC = 0;
+  folder->NumUnPackStreams = 0;
+}
+
+void SzFolderFree(CFolder *folder, void (*freeFunc)(void *p))
+{
+  UInt32 i;
+  for (i = 0; i < folder->NumCoders; i++)
+    SzCoderInfoFree(&folder->Coders[i], freeFunc);
+  freeFunc(folder->Coders);
+  freeFunc(folder->BindPairs);
+  freeFunc(folder->PackStreams);
+  freeFunc(folder->UnPackSizes);
+  SzFolderInit(folder);
+}
+
+UInt32 SzFolderGetNumOutStreams(CFolder *folder)
+{
+  UInt32 result = 0;
+  UInt32 i;
+  for (i = 0; i < folder->NumCoders; i++)
+    result += folder->Coders[i].NumOutStreams;
+  return result;
+}
+
+int SzFolderFindBindPairForInStream(CFolder *folder, UInt32 inStreamIndex)
+{
+  UInt32 i;
+  for(i = 0; i < folder->NumBindPairs; i++)
+    if (folder->BindPairs[i].InIndex == inStreamIndex)
+      return i;
+  return -1;
+}
+
+
+int SzFolderFindBindPairForOutStream(CFolder *folder, UInt32 outStreamIndex)
+{
+  UInt32 i;
+  for(i = 0; i < folder->NumBindPairs; i++)
+    if (folder->BindPairs[i].OutIndex == outStreamIndex)
+      return i;
+  return -1;
+}
+
+CFileSize SzFolderGetUnPackSize(CFolder *folder)
+{ 
+  int i = (int)SzFolderGetNumOutStreams(folder);
+  if (i == 0)
+    return 0;
+  for (i--; i >= 0; i--)
+    if (SzFolderFindBindPairForOutStream(folder, i) < 0)
+      return folder->UnPackSizes[i];
+  /* throw 1; */
+  return 0;
+}
+
+/*
+int FindPackStreamArrayIndex(int inStreamIndex) const
+{
+  for(int i = 0; i < PackStreams.Size(); i++)
+  if (PackStreams[i] == inStreamIndex)
+    return i;
+  return -1;
+}
+*/
+
+void SzFileInit(CFileItem *fileItem)
+{
+  fileItem->IsFileCRCDefined = 0;
+  fileItem->HasStream = 1;
+  fileItem->IsDirectory = 0;
+  fileItem->IsAnti = 0;
+  fileItem->Name = 0;
+}
+
+void SzFileFree(CFileItem *fileItem, void (*freeFunc)(void *p))
+{
+  freeFunc(fileItem->Name);
+  SzFileInit(fileItem);
+}
+
+void SzArchiveDatabaseInit(CArchiveDatabase *db)
+{
+  db->NumPackStreams = 0;
+  db->PackSizes = 0;
+  db->PackCRCsDefined = 0;
+  db->PackCRCs = 0;
+  db->NumFolders = 0;
+  db->Folders = 0;
+  db->NumFiles = 0;
+  db->Files = 0;
+}
+
+void SzArchiveDatabaseFree(CArchiveDatabase *db, void (*freeFunc)(void *))
+{
+  UInt32 i;
+  for (i = 0; i < db->NumFolders; i++)
+    SzFolderFree(&db->Folders[i], freeFunc);
+  for (i = 0; i < db->NumFiles; i++)
+    SzFileFree(&db->Files[i], freeFunc);
+  freeFunc(db->PackSizes);
+  freeFunc(db->PackCRCsDefined);
+  freeFunc(db->PackCRCs);
+  freeFunc(db->Folders);
+  freeFunc(db->Files);
+  SzArchiveDatabaseInit(db);
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zItem.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zItem.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zItem.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zItem.h	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,90 @@
+/* 7zItem.h */
+
+#ifndef __7Z_ITEM_H
+#define __7Z_ITEM_H
+
+#include "7zMethodID.h"
+#include "7zHeader.h"
+#include "7zBuffer.h"
+
+typedef struct _CCoderInfo
+{
+  UInt32 NumInStreams;
+  UInt32 NumOutStreams;
+  CMethodID MethodID;
+  CSzByteBuffer Properties;
+}CCoderInfo;
+
+void SzCoderInfoInit(CCoderInfo *coder);
+void SzCoderInfoFree(CCoderInfo *coder, void (*freeFunc)(void *p));
+
+typedef struct _CBindPair
+{
+  UInt32 InIndex;
+  UInt32 OutIndex;
+}CBindPair;
+
+typedef struct _CFolder
+{
+  UInt32 NumCoders;
+  CCoderInfo *Coders;
+  UInt32 NumBindPairs;
+  CBindPair *BindPairs;
+  UInt32 NumPackStreams; 
+  UInt32 *PackStreams;
+  CFileSize *UnPackSizes;
+  int UnPackCRCDefined;
+  UInt32 UnPackCRC;
+
+  UInt32 NumUnPackStreams;
+}CFolder;
+
+void SzFolderInit(CFolder *folder);
+CFileSize SzFolderGetUnPackSize(CFolder *folder);
+int SzFolderFindBindPairForInStream(CFolder *folder, UInt32 inStreamIndex);
+UInt32 SzFolderGetNumOutStreams(CFolder *folder);
+CFileSize SzFolderGetUnPackSize(CFolder *folder);
+
+/* #define CArchiveFileTime UInt64 */
+
+typedef struct _CFileItem
+{
+  /*
+  CArchiveFileTime LastWriteTime;
+  CFileSize StartPos;
+  UInt32 Attributes; 
+  */
+  CFileSize Size;
+  UInt32 FileCRC;
+  char *Name;
+
+  Byte IsFileCRCDefined;
+  Byte HasStream;
+  Byte IsDirectory;
+  Byte IsAnti;
+  /*
+  int AreAttributesDefined;
+  int IsLastWriteTimeDefined;
+  int IsStartPosDefined;
+  */
+}CFileItem;
+
+void SzFileInit(CFileItem *fileItem);
+
+typedef struct _CArchiveDatabase
+{
+  UInt32 NumPackStreams;
+  CFileSize *PackSizes;
+  Byte *PackCRCsDefined;
+  UInt32 *PackCRCs;
+  UInt32 NumFolders;
+  CFolder *Folders;
+  UInt32 NumFiles;
+  CFileItem *Files;
+}CArchiveDatabase;
+
+void SzArchiveDatabaseInit(CArchiveDatabase *db);
+void SzArchiveDatabaseFree(CArchiveDatabase *db, void (*freeFunc)(void *));
+
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zMain.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zMain.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zMain.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zMain.c	2022-01-01 15:08:47.877171448 +0800
@@ -0,0 +1,223 @@
+/* 
+7zMain.c
+Test application for 7z Decoder
+LZMA SDK 4.26 Copyright (c) 1999-2005 Igor Pavlov (2005-08-02)
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "7zCrc.h"
+#include "7zIn.h"
+#include "7zExtract.h"
+
+typedef struct _CFileInStream
+{
+  ISzInStream InStream;
+  FILE *File;
+} CFileInStream;
+
+#ifdef _LZMA_IN_CB
+
+#define kBufferSize (1 << 12)
+Byte g_Buffer[kBufferSize];
+
+SZ_RESULT SzFileReadImp(void *object, void **buffer, size_t maxRequiredSize, size_t *processedSize)
+{
+  CFileInStream *s = (CFileInStream *)object;
+  size_t processedSizeLoc;
+  if (maxRequiredSize > kBufferSize)
+    maxRequiredSize = kBufferSize;
+  processedSizeLoc = fread(g_Buffer, 1, maxRequiredSize, s->File);
+  *buffer = g_Buffer;
+  if (processedSize != 0)
+    *processedSize = processedSizeLoc;
+  return SZ_OK;
+}
+
+#else
+
+SZ_RESULT SzFileReadImp(void *object, void *buffer, size_t size, size_t *processedSize)
+{
+  CFileInStream *s = (CFileInStream *)object;
+  size_t processedSizeLoc = fread(buffer, 1, size, s->File);
+  if (processedSize != 0)
+    *processedSize = processedSizeLoc;
+  return SZ_OK;
+}
+
+#endif
+
+SZ_RESULT SzFileSeekImp(void *object, CFileSize pos)
+{
+  CFileInStream *s = (CFileInStream *)object;
+  int res = fseek(s->File, (long)pos, SEEK_SET);
+  if (res == 0)
+    return SZ_OK;
+  return SZE_FAIL;
+}
+
+void PrintError(char *sz)
+{
+  printf("\nERROR: %s\n", sz);
+}
+
+int main(int numargs, char *args[])
+{
+  CFileInStream archiveStream;
+  CArchiveDatabaseEx db;
+  SZ_RESULT res;
+  ISzAlloc allocImp;
+  ISzAlloc allocTempImp;
+
+  printf("\n7z ANSI-C Decoder 4.30  Copyright (c) 1999-2005 Igor Pavlov  2005-11-20\n");
+  if (numargs == 1)
+  {
+    printf(
+      "\nUsage: 7zDec <command> <archive_name>\n\n"
+      "<Commands>\n"
+      "  e: Extract files from archive\n"
+      "  l: List contents of archive\n"
+      "  t: Test integrity of archive\n");
+    return 0;
+  }
+  if (numargs < 3)
+  {
+    PrintError("incorrect command");
+    return 1;
+  }
+
+  archiveStream.File = fopen(args[2], "rb");
+  if (archiveStream.File == 0)
+  {
+    PrintError("can not open input file");
+    return 1;
+  }
+
+  archiveStream.InStream.Read = SzFileReadImp;
+  archiveStream.InStream.Seek = SzFileSeekImp;
+
+  allocImp.Alloc = SzAlloc;
+  allocImp.Free = SzFree;
+
+  allocTempImp.Alloc = SzAllocTemp;
+  allocTempImp.Free = SzFreeTemp;
+
+  InitCrcTable();
+  SzArDbExInit(&db);
+  res = SzArchiveOpen(&archiveStream.InStream, &db, &allocImp, &allocTempImp);
+  if (res == SZ_OK)
+  {
+    char *command = args[1];
+    int listCommand = 0;
+    int testCommand = 0;
+    int extractCommand = 0;
+    if (strcmp(command, "l") == 0)
+      listCommand = 1;
+    if (strcmp(command, "t") == 0)
+      testCommand = 1;
+    else if (strcmp(command, "e") == 0)
+      extractCommand = 1;
+
+    if (listCommand)
+    {
+      UInt32 i;
+      for (i = 0; i < db.Database.NumFiles; i++)
+      {
+        CFileItem *f = db.Database.Files + i;
+        printf("%10d  %s\n", (int)f->Size, f->Name);
+      }
+    }
+    else if (testCommand || extractCommand)
+    {
+      UInt32 i;
+
+      // if you need cache, use these 3 variables.
+      // if you use external function, you can make these variable as static.
+      UInt32 blockIndex = 0xFFFFFFFF; // it can have any value before first call (if outBuffer = 0) 
+      Byte *outBuffer = 0; // it must be 0 before first call for each new archive. 
+      size_t outBufferSize = 0;  // it can have any value before first call (if outBuffer = 0) 
+
+      printf("\n");
+      for (i = 0; i < db.Database.NumFiles; i++)
+      {
+        size_t offset;
+        size_t outSizeProcessed;
+        CFileItem *f = db.Database.Files + i;
+        if (f->IsDirectory)
+          printf("Directory ");
+        else
+          printf(testCommand ? 
+            "Testing   ":
+            "Extracting");
+        printf(" %s", f->Name);
+        if (f->IsDirectory)
+        {
+          printf("\n");
+          continue;
+        }
+        res = SzExtract(&archiveStream.InStream, &db, i, 
+            &blockIndex, &outBuffer, &outBufferSize, 
+            &offset, &outSizeProcessed, 
+            &allocImp, &allocTempImp);
+        if (res != SZ_OK)
+          break;
+        if (!testCommand)
+        {
+          FILE *outputHandle;
+          UInt32 processedSize;
+          char *fileName = f->Name;
+          size_t nameLen = strlen(f->Name);
+          for (; nameLen > 0; nameLen--)
+            if (f->Name[nameLen - 1] == '/')
+            {
+              fileName = f->Name + nameLen;
+              break;
+            }
+            
+          outputHandle = fopen(fileName, "wb+");
+          if (outputHandle == 0)
+          {
+            PrintError("can not open output file");
+            res = SZE_FAIL;
+            break;
+          }
+          processedSize = fwrite(outBuffer + offset, 1, outSizeProcessed, outputHandle);
+          if (processedSize != outSizeProcessed)
+          {
+            PrintError("can not write output file");
+            res = SZE_FAIL;
+            break;
+          }
+          if (fclose(outputHandle))
+          {
+            PrintError("can not close output file");
+            res = SZE_FAIL;
+            break;
+          }
+        }
+        printf("\n");
+      }
+      allocImp.Free(outBuffer);
+    }
+    else
+    {
+      PrintError("incorrect command");
+      res = SZE_FAIL;
+    }
+  }
+  SzArDbExFree(&db, allocImp.Free);
+
+  fclose(archiveStream.File);
+  if (res == SZ_OK)
+  {
+    printf("\nEverything is Ok\n");
+    return 0;
+  }
+  if (res == SZE_OUTOFMEMORY)
+    PrintError("can not allocate memory");
+  else     
+    printf("\nERROR #%d\n", res);
+  return 1;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zMethodID.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zMethodID.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zMethodID.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zMethodID.c	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,14 @@
+/* 7zMethodID.c */
+
+#include "7zMethodID.h"
+
+int AreMethodsEqual(CMethodID *a1, CMethodID *a2)
+{
+  int i;
+  if (a1->IDSize != a2->IDSize)
+    return 0;
+  for (i = 0; i < a1->IDSize; i++)
+    if (a1->ID[i] != a2->ID[i])
+      return 0;
+  return 1;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zMethodID.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zMethodID.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zMethodID.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zMethodID.h	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,18 @@
+/* 7zMethodID.h */
+
+#ifndef __7Z_METHOD_ID_H
+#define __7Z_METHOD_ID_H
+
+#include "7zTypes.h"
+
+#define kMethodIDSize 15
+  
+typedef struct _CMethodID
+{
+  Byte ID[kMethodIDSize];
+  Byte IDSize;
+} CMethodID;
+
+int AreMethodsEqual(CMethodID *a1, CMethodID *a2);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zTypes.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zTypes.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zTypes.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/7zTypes.h	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,61 @@
+/* 7zTypes.h */
+
+#ifndef __COMMON_TYPES_H
+#define __COMMON_TYPES_H
+
+#ifndef UInt32
+#ifdef _LZMA_UINT32_IS_ULONG
+#define UInt32 unsigned long
+#else
+#define UInt32 unsigned int
+#endif
+#endif
+
+#ifndef Byte
+#define Byte unsigned char
+#endif
+
+#ifndef UInt16
+#define UInt16 unsigned short
+#endif
+
+/* #define _SZ_NO_INT_64 */
+/* define it your compiler doesn't support long long int */
+
+#ifdef _SZ_NO_INT_64
+#define UInt64 unsigned long
+#else
+#ifdef _MSC_VER
+#define UInt64 unsigned __int64
+#else
+#define UInt64 unsigned long long int
+#endif
+#endif
+
+
+/* #define _SZ_FILE_SIZE_64 */
+/* Use _SZ_FILE_SIZE_64 if you need support for files larger than 4 GB*/
+
+#ifndef CFileSize
+#ifdef _SZ_FILE_SIZE_64
+#define CFileSize UInt64
+#else
+#define CFileSize UInt32
+#endif
+#endif
+
+#define SZ_RESULT int
+
+#define SZ_OK (0)
+#define SZE_DATA_ERROR (1)
+#define SZE_OUTOFMEMORY (2)
+#define SZE_CRC_ERROR (3)
+
+#define SZE_NOTIMPL (4)
+#define SZE_FAIL (5)
+
+#define SZE_ARCHIVE_ERROR (6)
+
+#define RINOK(x) { int __result_ = (x); if(__result_ != 0) return __result_; }
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/makefile squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/makefile
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/makefile	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/makefile	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,55 @@
+PROG = 7zDec.exe
+
+!IFNDEF O
+!IFDEF CPU
+O=$(CPU)
+!ELSE
+O=O
+!ENDIF
+!ENDIF
+
+CFLAGS = $(CFLAGS) -nologo -c -Fo$O/ -GS- 
+CFLAGS_O1 = $(CFLAGS) -O1
+CFLAGS_O2 = $(CFLAGS) -O2
+
+LFLAGS = $(LFLAGS) -nologo -OPT:NOWIN98
+
+PROGPATH = $O\$(PROG)
+
+COMPL_O1   = $(CPP) $(CFLAGS_O1) $**
+COMPL_O2   = $(CPP) $(CFLAGS_O2) $**
+COMPL      = $(CPP) $(CFLAGS_O1) $**
+
+
+7Z_OBJS = \
+  $O\7zAlloc.obj \
+  $O\7zBuffer.obj \
+  $O\7zCrc.obj \
+  $O\7zDecode.obj \
+  $O\7zExtract.obj \
+  $O\7zHeader.obj \
+  $O\7zIn.obj \
+  $O\7zItem.obj \
+  $O\7zMain.obj \
+  $O\7zMethodID.obj \
+
+OBJS = \
+  $(7Z_OBJS) \
+  $O\LzmaDecode.obj \
+
+all: $(PROGPATH) 
+
+clean:
+	-del /Q $(PROGPATH) $O\*.exe $O\*.dll $O\*.obj $O\*.lib $O\*.exp $O\*.res $O\*.pch 
+
+$O:
+	if not exist "$O" mkdir "$O"
+
+$(PROGPATH): $O $(OBJS)
+	link $(LFLAGS) -out:$(PROGPATH) $(OBJS) $(LIBS)
+
+
+$(7Z_OBJS): $(*B).c
+	$(COMPL)
+$O\LzmaDecode.obj: ../../Compress/LZMA_C/$(*B).c
+	$(COMPL_O2)
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/makefile.gcc squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/makefile.gcc
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Archive/7z_C/makefile.gcc	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Archive/7z_C/makefile.gcc	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,50 @@
+PROG = 7zDec
+CXX = g++
+LIB = 
+RM = rm -f
+CFLAGS = -c -O2 -Wall
+
+OBJS = 7zAlloc.o 7zBuffer.o 7zCrc.o 7zDecode.o 7zExtract.o 7zHeader.o 7zIn.o 7zItem.o 7zMain.o 7zMethodID.o LzmaDecode.o 
+
+all: $(PROG)
+
+$(PROG): $(OBJS)
+	$(CXX) -o $(PROG) $(LDFLAGS) $(OBJS) $(LIB)
+
+7zAlloc.o: 7zAlloc.c
+	$(CXX) $(CFLAGS) 7zAlloc.c
+
+7zBuffer.o: 7zBuffer.c
+	$(CXX) $(CFLAGS) 7zBuffer.c
+
+7zCrc.o: 7zCrc.c
+	$(CXX) $(CFLAGS) 7zCrc.c
+
+7zDecode.o: 7zDecode.c
+	$(CXX) $(CFLAGS) 7zDecode.c
+
+7zExtract.o: 7zExtract.c
+	$(CXX) $(CFLAGS) 7zExtract.c
+
+7zHeader.o: 7zHeader.c
+	$(CXX) $(CFLAGS) 7zHeader.c
+
+7zIn.o: 7zIn.c
+	$(CXX) $(CFLAGS) 7zIn.c
+
+7zItem.o: 7zItem.c
+	$(CXX) $(CFLAGS) 7zItem.c
+
+7zMain.o: 7zMain.c
+	$(CXX) $(CFLAGS) 7zMain.c
+
+7zMethodID.o: 7zMethodID.c
+	$(CXX) $(CFLAGS) 7zMethodID.c
+
+LzmaDecode.o: ../../Compress/LZMA_C/LzmaDecode.c
+	$(CXX) $(CFLAGS) ../../Compress/LZMA_C/LzmaDecode.c
+
+
+clean:
+	-$(RM) $(PROG) $(OBJS)
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Common/FileStreams.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Common/FileStreams.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Common/FileStreams.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Common/FileStreams.cpp	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,251 @@
+// FileStreams.cpp
+
+#include "StdAfx.h"
+
+#ifndef _WIN32
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+#endif
+
+#include "FileStreams.h"
+
+static inline HRESULT ConvertBoolToHRESULT(bool result)
+{
+  // return result ? S_OK: E_FAIL;
+  #ifdef _WIN32
+  return result ? S_OK: (::GetLastError());
+  #else
+  return result ? S_OK: E_FAIL;
+  #endif
+}
+
+bool CInFileStream::Open(LPCTSTR fileName)
+{
+  return File.Open(fileName);
+}
+
+#ifdef _WIN32
+#ifndef _UNICODE
+bool CInFileStream::Open(LPCWSTR fileName)
+{
+  return File.Open(fileName);
+}
+#endif
+#endif
+
+STDMETHODIMP CInFileStream::Read(void *data, UInt32 size, UInt32 *processedSize)
+{
+  #ifdef _WIN32
+  
+  UInt32 realProcessedSize;
+  bool result = File.ReadPart(data, size, realProcessedSize);
+  if(processedSize != NULL)
+    *processedSize = realProcessedSize;
+  return ConvertBoolToHRESULT(result);
+  
+  #else
+  
+  if(processedSize != NULL)
+    *processedSize = 0;
+  ssize_t res = File.Read(data, (size_t)size);
+  if (res == -1)
+    return E_FAIL;
+  if(processedSize != NULL)
+    *processedSize = (UInt32)res;
+  return S_OK;
+
+  #endif
+}
+
+#ifndef _WIN32_WCE
+STDMETHODIMP CStdInFileStream::Read(void *data, UInt32 size, UInt32 *processedSize)
+{
+  #ifdef _WIN32
+  UInt32 realProcessedSize;
+  BOOL res = ::ReadFile(GetStdHandle(STD_INPUT_HANDLE), 
+      data, size, (DWORD *)&realProcessedSize, NULL);
+  if(processedSize != NULL)
+    *processedSize = realProcessedSize;
+  if (res == FALSE && GetLastError() == ERROR_BROKEN_PIPE)
+    return S_OK;
+  return ConvertBoolToHRESULT(res != FALSE);
+  
+  #else
+
+  if(processedSize != NULL)
+    *processedSize = 0;
+  ssize_t res;
+  do 
+  {
+    res = read(0, data, (size_t)size);
+  } 
+  while (res < 0 && (errno == EINTR));
+  if (res == -1)
+    return E_FAIL;
+  if(processedSize != NULL)
+    *processedSize = (UInt32)res;
+  return S_OK;
+  
+  #endif
+}
+  
+#endif
+
+STDMETHODIMP CInFileStream::Seek(Int64 offset, UInt32 seekOrigin, 
+    UInt64 *newPosition)
+{
+  if(seekOrigin >= 3)
+    return STG_E_INVALIDFUNCTION;
+
+  #ifdef _WIN32
+
+  UInt64 realNewPosition;
+  bool result = File.Seek(offset, seekOrigin, realNewPosition);
+  if(newPosition != NULL)
+    *newPosition = realNewPosition;
+  return ConvertBoolToHRESULT(result);
+  
+  #else
+  
+  off_t res = File.Seek(offset, seekOrigin);
+  if (res == -1)
+    return E_FAIL;
+  if(newPosition != NULL)
+    *newPosition = (UInt64)res;
+  return S_OK;
+  
+  #endif
+}
+
+STDMETHODIMP CInFileStream::GetSize(UInt64 *size)
+{
+  return ConvertBoolToHRESULT(File.GetLength(*size));
+}
+
+
+//////////////////////////
+// COutFileStream
+
+bool COutFileStream::Create(LPCTSTR fileName, bool createAlways)
+{
+  return File.Create(fileName, createAlways);
+}
+
+#ifdef _WIN32
+#ifndef _UNICODE
+bool COutFileStream::Create(LPCWSTR fileName, bool createAlways)
+{
+  return File.Create(fileName, createAlways);
+}
+#endif
+#endif
+
+STDMETHODIMP COutFileStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
+{
+  #ifdef _WIN32
+
+  UInt32 realProcessedSize;
+  bool result = File.WritePart(data, size, realProcessedSize);
+  if(processedSize != NULL)
+    *processedSize = realProcessedSize;
+  return ConvertBoolToHRESULT(result);
+  
+  #else
+  
+  if(processedSize != NULL)
+    *processedSize = 0;
+  ssize_t res = File.Write(data, (size_t)size);
+  if (res == -1)
+    return E_FAIL;
+  if(processedSize != NULL)
+    *processedSize = (UInt32)res;
+  return S_OK;
+  
+  #endif
+}
+  
+STDMETHODIMP COutFileStream::Seek(Int64 offset, UInt32 seekOrigin, 
+    UInt64 *newPosition)
+{
+  if(seekOrigin >= 3)
+    return STG_E_INVALIDFUNCTION;
+  #ifdef _WIN32
+
+  UInt64 realNewPosition;
+  bool result = File.Seek(offset, seekOrigin, realNewPosition);
+  if(newPosition != NULL)
+    *newPosition = realNewPosition;
+  return ConvertBoolToHRESULT(result);
+  
+  #else
+  
+  off_t res = File.Seek(offset, seekOrigin);
+  if (res == -1)
+    return E_FAIL;
+  if(newPosition != NULL)
+    *newPosition = (UInt64)res;
+  return S_OK;
+  
+  #endif
+}
+
+STDMETHODIMP COutFileStream::SetSize(Int64 newSize)
+{
+  #ifdef _WIN32
+  UInt64 currentPos;
+  if(!File.Seek(0, FILE_CURRENT, currentPos))
+    return E_FAIL;
+  bool result = File.SetLength(newSize);
+  UInt64 currentPos2;
+  result = result && File.Seek(currentPos, currentPos2);
+  return result ? S_OK : E_FAIL;
+  #else
+  return E_FAIL;
+  #endif
+}
+
+#ifndef _WIN32_WCE
+STDMETHODIMP CStdOutFileStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
+{
+  if(processedSize != NULL)
+    *processedSize = 0;
+
+  #ifdef _WIN32
+  UInt32 realProcessedSize;
+  BOOL res = TRUE;
+  if (size > 0)
+  {
+    // Seems that Windows doesn't like big amounts writing to stdout.
+    // So we limit portions by 32KB.
+    UInt32 sizeTemp = (1 << 15); 
+    if (sizeTemp > size)
+      sizeTemp = size;
+    res = ::WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), 
+        data, sizeTemp, (DWORD *)&realProcessedSize, NULL);
+    size -= realProcessedSize;
+    data = (const void *)((const Byte *)data + realProcessedSize);
+    if(processedSize != NULL)
+      *processedSize += realProcessedSize;
+  }
+  return ConvertBoolToHRESULT(res != FALSE);
+
+  #else
+  
+  ssize_t res;
+  do 
+  {
+    res = write(1, data, (size_t)size);
+  } 
+  while (res < 0 && (errno == EINTR));
+  if (res == -1)
+    return E_FAIL;
+  if(processedSize != NULL)
+    *processedSize = (UInt32)res;
+  return S_OK;
+  
+  return S_OK;
+  #endif
+}
+  
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Common/FileStreams.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Common/FileStreams.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Common/FileStreams.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Common/FileStreams.h	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,98 @@
+// FileStreams.h
+
+#ifndef __FILESTREAMS_H
+#define __FILESTREAMS_H
+
+#ifdef _WIN32
+#include "../../Windows/FileIO.h"
+#else
+#include "../../Common/C_FileIO.h"
+#endif
+
+#include "../IStream.h"
+#include "../../Common/MyCom.h"
+
+class CInFileStream: 
+  public IInStream,
+  public IStreamGetSize,
+  public CMyUnknownImp
+{
+public:
+  #ifdef _WIN32
+  NWindows::NFile::NIO::CInFile File;
+  #else
+  NC::NFile::NIO::CInFile File;
+  #endif
+  CInFileStream() {}
+  virtual ~CInFileStream() {}
+
+  bool Open(LPCTSTR fileName);
+  #ifdef _WIN32
+  #ifndef _UNICODE
+  bool Open(LPCWSTR fileName);
+  #endif
+  #endif
+
+  MY_UNKNOWN_IMP2(IInStream, IStreamGetSize)
+
+  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
+  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);
+
+  STDMETHOD(GetSize)(UInt64 *size);
+};
+
+#ifndef _WIN32_WCE
+class CStdInFileStream: 
+  public ISequentialInStream,
+  public CMyUnknownImp
+{
+public:
+  // HANDLE File;
+  // CStdInFileStream() File(INVALID_HANDLE_VALUE): {}
+  // void Open() { File = GetStdHandle(STD_INPUT_HANDLE); };
+  MY_UNKNOWN_IMP
+
+  virtual ~CStdInFileStream() {}
+  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
+};
+#endif
+
+class COutFileStream: 
+  public IOutStream,
+  public CMyUnknownImp
+{
+public:
+  #ifdef _WIN32
+  NWindows::NFile::NIO::COutFile File;
+  #else
+  NC::NFile::NIO::COutFile File;
+  #endif
+  virtual ~COutFileStream() {}
+  bool Create(LPCTSTR fileName, bool createAlways);
+  #ifdef _WIN32
+  #ifndef _UNICODE
+  bool Create(LPCWSTR fileName, bool createAlways);
+  #endif
+  #endif
+  
+  MY_UNKNOWN_IMP1(IOutStream)
+
+  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
+  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition);
+  STDMETHOD(SetSize)(Int64 newSize);
+};
+
+#ifndef _WIN32_WCE
+class CStdOutFileStream: 
+  public ISequentialOutStream,
+  public CMyUnknownImp
+{
+public:
+  MY_UNKNOWN_IMP
+
+  virtual ~CStdOutFileStream() {}
+  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
+};
+#endif
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Common/InBuffer.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Common/InBuffer.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Common/InBuffer.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Common/InBuffer.cpp	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,80 @@
+// InBuffer.cpp
+
+#include "StdAfx.h"
+
+#include "InBuffer.h"
+
+#include "../../Common/Alloc.h"
+
+CInBuffer::CInBuffer(): 
+  _buffer(0), 
+  _bufferLimit(0), 
+  _bufferBase(0), 
+  _stream(0),
+  _bufferSize(0)
+{}
+
+bool CInBuffer::Create(UInt32 bufferSize)
+{
+  const UInt32 kMinBlockSize = 1;
+  if (bufferSize < kMinBlockSize)
+    bufferSize = kMinBlockSize;
+  if (_bufferBase != 0 && _bufferSize == bufferSize)
+    return true;
+  Free();
+  _bufferSize = bufferSize;
+  _bufferBase = (Byte *)::MidAlloc(bufferSize);
+  return (_bufferBase != 0);
+}
+
+void CInBuffer::Free()
+{
+  ::MidFree(_bufferBase);
+  _bufferBase = 0;
+}
+
+void CInBuffer::SetStream(ISequentialInStream *stream)
+{
+  _stream = stream;
+}
+
+void CInBuffer::Init()
+{
+  _processedSize = 0;
+  _buffer = _bufferBase;
+  _bufferLimit = _buffer;
+  _wasFinished = false;
+  #ifdef _NO_EXCEPTIONS
+  ErrorCode = S_OK;
+  #endif
+}
+
+bool CInBuffer::ReadBlock()
+{
+  #ifdef _NO_EXCEPTIONS
+  if (ErrorCode != S_OK)
+    return false;
+  #endif
+  if (_wasFinished)
+    return false;
+  _processedSize += (_buffer - _bufferBase);
+  UInt32 numProcessedBytes;
+  HRESULT result = _stream->Read(_bufferBase, _bufferSize, &numProcessedBytes);
+  #ifdef _NO_EXCEPTIONS
+  ErrorCode = result;
+  #else
+  if (result != S_OK)
+    throw CInBufferException(result);
+  #endif
+  _buffer = _bufferBase;
+  _bufferLimit = _buffer + numProcessedBytes;
+  _wasFinished = (numProcessedBytes == 0);
+  return (!_wasFinished);
+}
+
+Byte CInBuffer::ReadBlock2()
+{
+  if(!ReadBlock())
+    return 0xFF;
+  return *_buffer++;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Common/InBuffer.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Common/InBuffer.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Common/InBuffer.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Common/InBuffer.h	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,76 @@
+// InBuffer.h
+
+#ifndef __INBUFFER_H
+#define __INBUFFER_H
+
+#include "../IStream.h"
+#include "../../Common/MyCom.h"
+
+#ifndef _NO_EXCEPTIONS
+class CInBufferException
+{
+public:
+  HRESULT ErrorCode;
+  CInBufferException(HRESULT errorCode): ErrorCode(errorCode) {}
+};
+#endif
+
+class CInBuffer
+{
+  Byte *_buffer;
+  Byte *_bufferLimit;
+  Byte *_bufferBase;
+  CMyComPtr<ISequentialInStream> _stream;
+  UInt64 _processedSize;
+  UInt32 _bufferSize;
+  bool _wasFinished;
+
+  bool ReadBlock();
+  Byte ReadBlock2();
+
+public:
+  #ifdef _NO_EXCEPTIONS
+  HRESULT ErrorCode;
+  #endif
+
+  CInBuffer();
+  ~CInBuffer() { Free(); }
+
+  bool Create(UInt32 bufferSize);
+  void Free();
+  
+  void SetStream(ISequentialInStream *stream);
+  void Init();
+  void ReleaseStream() { _stream.Release(); }
+
+  bool ReadByte(Byte &b)
+  {
+    if(_buffer >= _bufferLimit)
+      if(!ReadBlock())
+        return false;
+    b = *_buffer++;
+    return true;
+  }
+  Byte ReadByte()
+  {
+    if(_buffer >= _bufferLimit)
+      return ReadBlock2();
+    return *_buffer++;
+  }
+  void ReadBytes(void *data, UInt32 size, UInt32 &processedSize)
+  {
+    for(processedSize = 0; processedSize < size; processedSize++)
+      if (!ReadByte(((Byte *)data)[processedSize]))
+        return;
+  }
+  bool ReadBytes(void *data, UInt32 size)
+  {
+    UInt32 processedSize;
+    ReadBytes(data, size, processedSize);
+    return (processedSize == size);
+  }
+  UInt64 GetProcessedSize() const { return _processedSize + (_buffer - _bufferBase); }
+  bool WasFinished() const { return _wasFinished; }
+};
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Common/OutBuffer.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Common/OutBuffer.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Common/OutBuffer.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Common/OutBuffer.cpp	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,117 @@
+// OutByte.cpp
+
+#include "StdAfx.h"
+
+#include "OutBuffer.h"
+
+#include "../../Common/Alloc.h"
+
+bool COutBuffer::Create(UInt32 bufferSize)
+{
+  const UInt32 kMinBlockSize = 1;
+  if (bufferSize < kMinBlockSize)
+    bufferSize = kMinBlockSize;
+  if (_buffer != 0 && _bufferSize == bufferSize)
+    return true;
+  Free();
+  _bufferSize = bufferSize;
+  _buffer = (Byte *)::MidAlloc(bufferSize);
+  return (_buffer != 0);
+}
+
+void COutBuffer::Free()
+{
+  ::MidFree(_buffer);
+  _buffer = 0;
+}
+
+void COutBuffer::SetStream(ISequentialOutStream *stream)
+{
+  _stream = stream;
+}
+
+void COutBuffer::Init()
+{
+  _streamPos = 0;
+  _limitPos = _bufferSize;
+  _pos = 0;
+  _processedSize = 0;
+  _overDict = false;
+  #ifdef _NO_EXCEPTIONS
+  ErrorCode = S_OK;
+  #endif
+}
+
+UInt64 COutBuffer::GetProcessedSize() const
+{ 
+  UInt64 res = _processedSize + _pos - _streamPos;
+  if (_streamPos > _pos) 
+    res += _bufferSize;
+  return res;
+}
+
+
+HRESULT COutBuffer::FlushPart()
+{
+  // _streamPos < _bufferSize
+  UInt32 size = (_streamPos >= _pos) ? (_bufferSize - _streamPos) : (_pos - _streamPos);
+  HRESULT result = S_OK;
+  #ifdef _NO_EXCEPTIONS
+  if (ErrorCode != S_OK)
+    result = ErrorCode;
+  #endif
+  if (_buffer2 != 0)
+  {
+    memmove(_buffer2, _buffer + _streamPos, size);
+    _buffer2 += size;
+  }
+
+  if (_stream != 0
+      #ifdef _NO_EXCEPTIONS
+      && (ErrorCode != S_OK)
+      #endif
+     )
+  {
+    UInt32 processedSize = 0;
+    result = _stream->Write(_buffer + _streamPos, size, &processedSize);
+    size = processedSize;
+  }
+  _streamPos += size;
+  if (_streamPos == _bufferSize)
+    _streamPos = 0;
+  if (_pos == _bufferSize)
+  {
+    _overDict = true;
+    _pos = 0;
+  }
+  _limitPos = (_streamPos > _pos) ? _streamPos : _bufferSize;
+  _processedSize += size;
+  return result;
+}
+
+HRESULT COutBuffer::Flush()
+{
+  #ifdef _NO_EXCEPTIONS
+  if (ErrorCode != S_OK)
+    return ErrorCode;
+  #endif
+
+  while(_streamPos != _pos)
+  {
+    HRESULT result = FlushPart();
+    if (result != S_OK)
+      return result;
+  }
+  return S_OK;
+}
+
+void COutBuffer::FlushWithCheck()
+{
+  HRESULT result = FlushPart();
+  #ifdef _NO_EXCEPTIONS
+  ErrorCode = result;
+  #else
+  if (result != S_OK)
+    throw COutBufferException(result);
+  #endif
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Common/OutBuffer.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Common/OutBuffer.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Common/OutBuffer.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Common/OutBuffer.h	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,64 @@
+// OutBuffer.h
+
+#ifndef __OUTBUFFER_H
+#define __OUTBUFFER_H
+
+#include "../IStream.h"
+#include "../../Common/MyCom.h"
+
+#ifndef _NO_EXCEPTIONS
+struct COutBufferException
+{
+  HRESULT ErrorCode;
+  COutBufferException(HRESULT errorCode): ErrorCode(errorCode) {}
+};
+#endif
+
+class COutBuffer
+{
+protected:
+  Byte *_buffer;
+  UInt32 _pos;
+  UInt32 _limitPos;
+  UInt32 _streamPos;
+  UInt32 _bufferSize;
+  CMyComPtr<ISequentialOutStream> _stream;
+  UInt64 _processedSize;
+  Byte  *_buffer2;
+  bool _overDict;
+
+  HRESULT FlushPart();
+  void FlushWithCheck();
+public:
+  #ifdef _NO_EXCEPTIONS
+  HRESULT ErrorCode;
+  #endif
+
+  COutBuffer(): _buffer(0), _pos(0), _stream(0), _buffer2(0) {}
+  ~COutBuffer() { Free(); }
+  
+  bool Create(UInt32 bufferSize);
+  void Free();
+
+  void SetMemStream(Byte *buffer) { _buffer2 = buffer; }
+  void SetStream(ISequentialOutStream *stream);
+  void Init();
+  HRESULT Flush();
+  void ReleaseStream() {  _stream.Release(); }
+
+  void WriteByte(Byte b)
+  {
+    _buffer[_pos++] = b;
+    if(_pos == _limitPos)
+      FlushWithCheck();
+  }
+  void WriteBytes(const void *data, size_t size)
+  {
+    for (size_t i = 0; i < size; i++)
+      WriteByte(((const Byte *)data)[i]);
+  }
+
+  UInt64 GetProcessedSize() const;
+};
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Common/StdAfx.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Common/StdAfx.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Common/StdAfx.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Common/StdAfx.h	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,9 @@
+// StdAfx.h
+
+#ifndef __STDAFX_H
+#define __STDAFX_H
+
+#include "../../Common/MyWindows.h"
+#include "../../Common/NewHandler.h"
+
+#endif 
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Common/StreamUtils.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Common/StreamUtils.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Common/StreamUtils.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Common/StreamUtils.cpp	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,44 @@
+// StreamUtils.cpp
+
+#include "StdAfx.h"
+
+#include "../../Common/MyCom.h"
+#include "StreamUtils.h"
+
+HRESULT ReadStream(ISequentialInStream *stream, void *data, UInt32 size, UInt32 *processedSize)
+{
+  if (processedSize != 0)
+    *processedSize = 0;
+  while(size != 0)
+  {
+    UInt32 processedSizeLoc; 
+    HRESULT res = stream->Read(data, size, &processedSizeLoc);
+    if (processedSize != 0)
+      *processedSize += processedSizeLoc;
+    data = (Byte *)((Byte *)data + processedSizeLoc);
+    size -= processedSizeLoc;
+    RINOK(res);
+    if (processedSizeLoc == 0)
+      return S_OK;
+  }
+  return S_OK;
+}
+
+HRESULT WriteStream(ISequentialOutStream *stream, const void *data, UInt32 size, UInt32 *processedSize)
+{
+  if (processedSize != 0)
+    *processedSize = 0;
+  while(size != 0)
+  {
+    UInt32 processedSizeLoc; 
+    HRESULT res = stream->Write(data, size, &processedSizeLoc);
+    if (processedSize != 0)
+      *processedSize += processedSizeLoc;
+    data = (const void *)((const Byte *)data + processedSizeLoc);
+    size -= processedSizeLoc;
+    RINOK(res);
+    if (processedSizeLoc == 0)
+      break;
+  }
+  return S_OK;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Common/StreamUtils.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Common/StreamUtils.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Common/StreamUtils.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Common/StreamUtils.h	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,11 @@
+// StreamUtils.h
+
+#ifndef __STREAMUTILS_H
+#define __STREAMUTILS_H
+
+#include "../IStream.h"
+
+HRESULT ReadStream(ISequentialInStream *stream, void *data, UInt32 size, UInt32 *processedSize);
+HRESULT WriteStream(ISequentialOutStream *stream, const void *data, UInt32 size, UInt32 *processedSize);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/ARM.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/ARM.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/ARM.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/ARM.cpp	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,16 @@
+// ARM.cpp
+
+#include "StdAfx.h"
+#include "ARM.h"
+
+#include "BranchARM.c"
+
+UInt32 CBC_ARM_Encoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::ARM_Convert(data, size, _bufferPos, 1);
+}
+
+UInt32 CBC_ARM_Decoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::ARM_Convert(data, size, _bufferPos, 0);
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/ARM.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/ARM.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/ARM.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/ARM.h	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,10 @@
+// ARM.h
+
+#ifndef __ARM_H
+#define __ARM_H
+
+#include "BranchCoder.h"
+
+MyClassA(BC_ARM, 0x05, 1)
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/ARMThumb.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/ARMThumb.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/ARMThumb.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/ARMThumb.cpp	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,16 @@
+// ARMThumb.cpp
+
+#include "StdAfx.h"
+#include "ARMThumb.h"
+
+#include "BranchARMThumb.c"
+
+UInt32 CBC_ARMThumb_Encoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::ARMThumb_Convert(data, size, _bufferPos, 1);
+}
+
+UInt32 CBC_ARMThumb_Decoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::ARMThumb_Convert(data, size, _bufferPos, 0);
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/ARMThumb.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/ARMThumb.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/ARMThumb.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/ARMThumb.h	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,10 @@
+// ARMThumb.h
+
+#ifndef __ARMTHUMB_H
+#define __ARMTHUMB_H
+
+#include "BranchCoder.h"
+
+MyClassA(BC_ARMThumb, 0x07, 1)
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARM.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARM.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARM.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARM.c	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,26 @@
+// BranchARM.c
+
+#include "BranchARM.h"
+
+UInt32 ARM_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding)
+{
+  UInt32 i;
+  for (i = 0; i + 4 <= size; i += 4)
+  {
+    if (data[i + 3] == 0xEB)
+    {
+      UInt32 src = (data[i + 2] << 16) | (data[i + 1] << 8) | (data[i + 0]);
+      src <<= 2;
+      UInt32 dest;
+      if (encoding)
+        dest = nowPos + i + 8 + src;
+      else
+        dest = src - (nowPos + i + 8);
+      dest >>= 2;
+      data[i + 2] = (dest >> 16);
+      data[i + 1] = (dest >> 8);
+      data[i + 0] = dest;
+    }
+  }
+  return i;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARM.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARM.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARM.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARM.h	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,10 @@
+// BranchARM.h
+
+#ifndef __BRANCH_ARM_H
+#define __BRANCH_ARM_H
+
+#include "Common/Types.h"
+
+UInt32 ARM_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARMThumb.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARMThumb.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARMThumb.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARMThumb.c	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,35 @@
+// BranchARMThumb.c
+
+#include "BranchARMThumb.h"
+
+UInt32 ARMThumb_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding)
+{
+  UInt32 i;
+  for (i = 0; i + 4 <= size; i += 2)
+  {
+    if ((data[i + 1] & 0xF8) == 0xF0 && 
+        (data[i + 3] & 0xF8) == 0xF8)
+    {
+      UInt32 src = 
+        ((data[i + 1] & 0x7) << 19) |
+        (data[i + 0] << 11) |
+        ((data[i + 3] & 0x7) << 8) |
+        (data[i + 2]);
+      
+      src <<= 1;
+      UInt32 dest;
+      if (encoding)
+        dest = nowPos + i + 4 + src;
+      else
+        dest = src - (nowPos + i + 4);
+      dest >>= 1;
+      
+      data[i + 1] = 0xF0 | ((dest >> 19) & 0x7);
+      data[i + 0] = (dest >> 11);
+      data[i + 3] = 0xF8 | ((dest >> 8) & 0x7);
+      data[i + 2] = (dest);
+      i += 2;
+    }
+  }
+  return i;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARMThumb.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARMThumb.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARMThumb.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchARMThumb.h	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,10 @@
+// BranchARMThumb.h
+
+#ifndef __BRANCH_ARM_THUMB_H
+#define __BRANCH_ARM_THUMB_H
+
+#include "Common/Types.h"
+
+UInt32 ARMThumb_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchCoder.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchCoder.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchCoder.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchCoder.cpp	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,18 @@
+// BranchCoder.cpp
+
+#include "StdAfx.h"
+#include "BranchCoder.h"
+
+STDMETHODIMP CBranchConverter::Init()
+{
+  _bufferPos = 0;
+  SubInit();
+  return S_OK;
+}
+
+STDMETHODIMP_(UInt32) CBranchConverter::Filter(Byte *data, UInt32 size)
+{
+  UInt32 processedSize = SubFilter(data, size);
+  _bufferPos += processedSize;
+  return processedSize;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchCoder.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchCoder.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchCoder.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchCoder.h	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,54 @@
+// BranchCoder.h
+
+#ifndef __BRANCH_CODER_H
+#define __BRANCH_CODER_H
+
+#include "Common/MyCom.h"
+#include "Common/Types.h"
+#include "Common/Alloc.h"
+
+#include "../../ICoder.h"
+
+class CBranchConverter:
+  public ICompressFilter,
+  public CMyUnknownImp
+{
+protected:
+  UInt32 _bufferPos;
+  virtual void SubInit() {}
+  virtual UInt32 SubFilter(Byte *data, UInt32 size) = 0;
+public:
+  MY_UNKNOWN_IMP;
+  STDMETHOD(Init)();
+  STDMETHOD_(UInt32, Filter)(Byte *data, UInt32 size);
+};
+
+#define MyClassEncoderA(Name) class C ## Name: public CBranchConverter \
+  { public: UInt32 SubFilter(Byte *data, UInt32 size); }; 
+
+#define MyClassDecoderA(Name) class C ## Name: public CBranchConverter \
+  { public: UInt32 SubFilter(Byte *data, UInt32 size); }; 
+
+#define MyClassEncoderB(Name, ADD_ITEMS, ADD_INIT) class C ## Name: public CBranchConverter, public ADD_ITEMS \
+  { public: UInt32 SubFilter(Byte *data, UInt32 size); ADD_INIT}; 
+
+#define MyClassDecoderB(Name, ADD_ITEMS, ADD_INIT) class C ## Name: public CBranchConverter, public ADD_ITEMS \
+  { public: UInt32 SubFilter(Byte *data, UInt32 size); ADD_INIT}; 
+
+#define MyClass2b(Name, id, subId, encodingId)  \
+DEFINE_GUID(CLSID_CCompressConvert ## Name,  \
+0x23170F69, 0x40C1, 0x278B, 0x03, 0x03, id, subId, 0x00, 0x00, encodingId, 0x00); 
+
+#define MyClassA(Name, id, subId)  \
+MyClass2b(Name ## _Encoder, id, subId, 0x01) \
+MyClassEncoderA(Name ## _Encoder) \
+MyClass2b(Name ## _Decoder, id, subId, 0x00) \
+MyClassDecoderA(Name ## _Decoder)
+
+#define MyClassB(Name, id, subId, ADD_ITEMS, ADD_INIT)  \
+MyClass2b(Name ## _Encoder, id, subId, 0x01) \
+MyClassEncoderB(Name ## _Encoder, ADD_ITEMS, ADD_INIT) \
+MyClass2b(Name ## _Decoder, id, subId, 0x00) \
+MyClassDecoderB(Name ## _Decoder, ADD_ITEMS, ADD_INIT)
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchIA64.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchIA64.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchIA64.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchIA64.c	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,65 @@
+// BranchIA64.c
+
+#include "BranchIA64.h"
+
+const Byte kBranchTable[32] = 
+{ 
+  0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,
+  4, 4, 6, 6, 0, 0, 7, 7,
+  4, 4, 0, 0, 4, 4, 0, 0 
+};
+
+UInt32 IA64_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding)
+{
+  UInt32 i;
+  for (i = 0; i + 16 <= size; i += 16)
+  {
+    UInt32 instrTemplate = data[i] & 0x1F;
+    UInt32 mask = kBranchTable[instrTemplate];
+    UInt32 bitPos = 5;
+    for (int slot = 0; slot < 3; slot++, bitPos += 41)
+    {
+      if (((mask >> slot) & 1) == 0)
+        continue;
+      UInt32 bytePos = (bitPos >> 3);
+      UInt32 bitRes = bitPos & 0x7;
+      // UInt64 instruction = *(UInt64 *)(data + i + bytePos);
+      UInt64 instruction = 0;
+      int j;
+      for (j = 0; j < 6; j++)
+        instruction += (UInt64)(data[i + j + bytePos]) << (8 * j);
+
+      UInt64 instNorm = instruction >> bitRes;
+      if (((instNorm >> 37) & 0xF) == 0x5 
+        &&  ((instNorm >> 9) & 0x7) == 0 
+        // &&  (instNorm & 0x3F)== 0 
+        )
+      {
+        UInt32 src = UInt32((instNorm >> 13) & 0xFFFFF);
+        src |= ((instNorm >> 36) & 1) << 20;
+        
+        src <<= 4;
+        
+        UInt32 dest;
+        if (encoding)
+          dest = nowPos + i + src;
+        else
+          dest = src - (nowPos + i);
+        
+        dest >>= 4;
+        
+        instNorm &= ~(UInt64(0x8FFFFF) << 13);
+        instNorm |= (UInt64(dest & 0xFFFFF) << 13);
+        instNorm |= (UInt64(dest & 0x100000) << (36 - 20));
+        
+        instruction &= (1 << bitRes) - 1;
+        instruction |= (instNorm << bitRes);
+        // *(UInt64 *)(data + i + bytePos) = instruction;
+        for (j = 0; j < 6; j++)
+          data[i + j + bytePos] = Byte(instruction >> (8 * j));
+      }
+    }
+  }
+  return i;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchIA64.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchIA64.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchIA64.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchIA64.h	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,10 @@
+// BranchIA64.h
+
+#ifndef __BRANCH_IA64_H
+#define __BRANCH_IA64_H
+
+#include "Common/Types.h"
+
+UInt32 IA64_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchPPC.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchPPC.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchPPC.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchPPC.c	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,36 @@
+// BranchPPC.c
+
+#include "BranchPPC.h"
+
+UInt32 PPC_B_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding)
+{
+  UInt32 i;
+  for (i = 0; i + 4 <= size; i += 4)
+  {
+    // PowerPC branch 6(48) 24(Offset) 1(Abs) 1(Link)
+    if ((data[i] >> 2) == 0x12 && 
+    (
+      (data[i + 3] & 3) == 1 
+      // || (data[i+3] & 3) == 3
+      )
+    )
+    {
+      UInt32 src = ((data[i + 0] & 3) << 24) |
+        (data[i + 1] << 16) |
+        (data[i + 2] << 8) |
+        (data[i + 3] & (~3));
+      
+      UInt32 dest;
+      if (encoding)
+        dest = nowPos + i + src;
+      else
+        dest = src - (nowPos + i);
+      data[i + 0] = 0x48 | ((dest >> 24) &  0x3);
+      data[i + 1] = (dest >> 16);
+      data[i + 2] = (dest >> 8);
+      data[i + 3] &= 0x3;
+      data[i + 3] |= dest;
+    }
+  }
+  return i;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchPPC.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchPPC.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchPPC.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchPPC.h	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,10 @@
+// BranchPPC.h
+
+#ifndef __BRANCH_PPC_H
+#define __BRANCH_PPC_H
+
+#include "Common/Types.h"
+
+UInt32 PPC_B_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchSPARC.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchSPARC.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchSPARC.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchSPARC.c	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,36 @@
+// BranchSPARC.c
+
+#include "BranchSPARC.h"
+
+UInt32 SPARC_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding)
+{
+  UInt32 i;
+  for (i = 0; i + 4 <= size; i += 4)
+  {
+    if (data[i] == 0x40 && (data[i + 1] & 0xC0) == 0x00 || 
+        data[i] == 0x7F && (data[i + 1] & 0xC0) == 0xC0)
+    {
+      UInt32 src = 
+        ((UInt32)data[i + 0] << 24) |
+        ((UInt32)data[i + 1] << 16) |
+        ((UInt32)data[i + 2] << 8) |
+        ((UInt32)data[i + 3]);
+      
+      src <<= 2;
+      UInt32 dest;
+      if (encoding)
+        dest = nowPos + i + src;
+      else
+        dest = src - (nowPos + i);
+      dest >>= 2;
+      
+      dest = (((0 - ((dest >> 22) & 1)) << 22) & 0x3FFFFFFF) | (dest & 0x3FFFFF) | 0x40000000;
+
+      data[i + 0] = (Byte)(dest >> 24);
+      data[i + 1] = (Byte)(dest >> 16);
+      data[i + 2] = (Byte)(dest >> 8);
+      data[i + 3] = (Byte)dest;
+    }
+  }
+  return i;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchSPARC.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchSPARC.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchSPARC.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchSPARC.h	2022-01-01 15:08:47.881171448 +0800
@@ -0,0 +1,10 @@
+// BranchSPARC.h
+
+#ifndef __BRANCH_SPARC_H
+#define __BRANCH_SPARC_H
+
+#include "Common/Types.h"
+
+UInt32 SPARC_B_Convert(Byte *data, UInt32 size, UInt32 nowPos, int encoding);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchX86.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchX86.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchX86.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchX86.c	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,101 @@
+/* BranchX86.c */
+
+#include "BranchX86.h"
+
+/*
+static int inline Test86MSByte(Byte b)
+{
+  return (b == 0 || b == 0xFF);
+}
+*/
+#define Test86MSByte(b) ((b) == 0 || (b) == 0xFF)
+
+const int kMaskToAllowedStatus[8] = {1, 1, 1, 0, 1, 0, 0, 0};
+const Byte kMaskToBitNumber[8] = {0, 1, 2, 2, 3, 3, 3, 3};
+
+/*
+void x86_Convert_Init(UInt32 *prevMask, UInt32 *prevPos)
+{
+  *prevMask = 0;
+  *prevPos = (UInt32)(-5);
+}
+*/
+
+UInt32 x86_Convert(Byte *buffer, UInt32 endPos, UInt32 nowPos, 
+    UInt32 *prevMask, UInt32 *prevPos, int encoding)
+{
+  UInt32 bufferPos = 0;
+  UInt32 limit;
+
+  if (endPos < 5)
+    return 0;
+  
+  if (nowPos - *prevPos > 5)
+    *prevPos = nowPos - 5;
+  
+  limit = endPos - 5;
+  while(bufferPos <= limit)
+  {
+    Byte b = buffer[bufferPos];
+    UInt32 offset;
+    if (b != 0xE8 && b != 0xE9)
+    {
+      bufferPos++;
+      continue;
+    }
+    offset = (nowPos + bufferPos - *prevPos);
+    *prevPos = (nowPos + bufferPos);
+    if (offset > 5)
+      *prevMask = 0;
+    else
+    {
+      UInt32 i;
+      for (i = 0; i < offset; i++)
+      {
+        *prevMask &= 0x77;
+        *prevMask <<= 1;
+      }
+    }
+    b = buffer[bufferPos + 4];
+    if (Test86MSByte(b) && kMaskToAllowedStatus[(*prevMask >> 1) & 0x7] && 
+      (*prevMask >> 1) < 0x10)
+    {
+      UInt32 src = 
+        ((UInt32)(b) << 24) |
+        ((UInt32)(buffer[bufferPos + 3]) << 16) |
+        ((UInt32)(buffer[bufferPos + 2]) << 8) |
+        (buffer[bufferPos + 1]);
+      
+      UInt32 dest;
+      while(1)
+      {
+        UInt32 index;
+        if (encoding)
+          dest = (nowPos + bufferPos + 5) + src;
+        else
+          dest = src - (nowPos + bufferPos + 5);
+        if (*prevMask == 0)
+          break;
+        index = kMaskToBitNumber[*prevMask >> 1];
+        b = (Byte)(dest >> (24 - index * 8));
+        if (!Test86MSByte(b))
+          break;
+        src = dest ^ ((1 << (32 - index * 8)) - 1);
+      }
+      buffer[bufferPos + 4] = (Byte)(~(((dest >> 24) & 1) - 1));
+      buffer[bufferPos + 3] = (Byte)(dest >> 16);
+      buffer[bufferPos + 2] = (Byte)(dest >> 8);
+      buffer[bufferPos + 1] = (Byte)dest;
+      bufferPos += 5;
+      *prevMask = 0;
+    }
+    else
+    {
+      bufferPos++;
+      *prevMask |= 1;
+      if (Test86MSByte(b))
+        *prevMask |= 0x10;
+    }
+  }
+  return bufferPos;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchX86.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchX86.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchX86.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/BranchX86.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,19 @@
+/* BranchX86.h */
+
+#ifndef __BRANCHX86_H
+#define __BRANCHX86_H
+
+#ifndef UInt32
+#define UInt32 unsigned int
+#endif
+
+#ifndef Byte
+#define Byte unsigned char
+#endif
+
+#define x86_Convert_Init(prevMask, prevPos) { prevMask = 0; prevPos = (UInt32)(-5); }
+
+UInt32 x86_Convert(Byte *buffer, UInt32 endPos, UInt32 nowPos, 
+    UInt32 *prevMask, UInt32 *prevPos, int encoding);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/IA64.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/IA64.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/IA64.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/IA64.cpp	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,16 @@
+// IA64.cpp
+
+#include "StdAfx.h"
+#include "IA64.h"
+
+#include "BranchIA64.c"
+
+UInt32 CBC_IA64_Encoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::IA64_Convert(data, size, _bufferPos, 1);
+}
+
+UInt32 CBC_IA64_Decoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::IA64_Convert(data, size, _bufferPos, 0);
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/IA64.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/IA64.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/IA64.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/IA64.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,10 @@
+// IA64.h
+
+#ifndef __IA64_H
+#define __IA64_H
+
+#include "BranchCoder.h"
+
+MyClassA(BC_IA64, 0x04, 1)
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/PPC.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/PPC.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/PPC.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/PPC.cpp	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,17 @@
+// PPC.cpp
+
+#include "StdAfx.h"
+#include "PPC.h"
+
+#include "Windows/Defs.h"
+#include "BranchPPC.c"
+
+UInt32 CBC_PPC_B_Encoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::PPC_B_Convert(data, size, _bufferPos, 1);
+}
+
+UInt32 CBC_PPC_B_Decoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::PPC_B_Convert(data, size, _bufferPos, 0);
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/PPC.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/PPC.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/PPC.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/PPC.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,10 @@
+// PPC.h
+
+#ifndef __PPC_H
+#define __PPC_H
+
+#include "BranchCoder.h"
+
+MyClassA(BC_PPC_B, 0x02, 5)
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/SPARC.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/SPARC.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/SPARC.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/SPARC.cpp	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,17 @@
+// SPARC.cpp
+
+#include "StdAfx.h"
+#include "SPARC.h"
+
+#include "Windows/Defs.h"
+#include "BranchSPARC.c"
+
+UInt32 CBC_SPARC_Encoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::SPARC_Convert(data, size, _bufferPos, 1);
+}
+
+UInt32 CBC_SPARC_Decoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::SPARC_Convert(data, size, _bufferPos, 0);
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/SPARC.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/SPARC.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/SPARC.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/SPARC.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,10 @@
+// SPARC.h
+
+#ifndef __SPARC_H
+#define __SPARC_H
+
+#include "BranchCoder.h"
+
+MyClassA(BC_SPARC, 0x08, 5)
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/StdAfx.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/StdAfx.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/StdAfx.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/StdAfx.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,8 @@
+// StdAfx.h
+
+#ifndef __STDAFX_H
+#define __STDAFX_H
+
+#include "../../../Common/MyWindows.h"
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/x86_2.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/x86_2.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/x86_2.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/x86_2.cpp	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,412 @@
+// x86_2.cpp
+
+#include "StdAfx.h"
+#include "x86_2.h"
+
+#include "../../../Common/Alloc.h"
+
+static const int kBufferSize = 1 << 17;
+
+inline bool IsJcc(Byte b0, Byte b1)
+{
+  return (b0 == 0x0F && (b1 & 0xF0) == 0x80);
+}
+
+#ifndef EXTRACT_ONLY
+
+static bool inline Test86MSByte(Byte b)
+{
+  return (b == 0 || b == 0xFF);
+}
+
+bool CBCJ2_x86_Encoder::Create()
+{
+  if (!_mainStream.Create(1 << 16))
+    return false;
+  if (!_callStream.Create(1 << 20))
+    return false;
+  if (!_jumpStream.Create(1 << 20))
+    return false;
+  if (!_rangeEncoder.Create(1 << 20))
+    return false;
+  if (_buffer == 0)
+  {
+    _buffer = (Byte *)MidAlloc(kBufferSize);
+    if (_buffer == 0)
+      return false;
+  }
+  return true;
+}
+
+CBCJ2_x86_Encoder::~CBCJ2_x86_Encoder()
+{
+  ::MidFree(_buffer);
+}
+
+HRESULT CBCJ2_x86_Encoder::Flush()
+{
+  RINOK(_mainStream.Flush());
+  RINOK(_callStream.Flush());
+  RINOK(_jumpStream.Flush());
+  _rangeEncoder.FlushData();
+  return _rangeEncoder.FlushStream();
+}
+
+const UInt32 kDefaultLimit = (1 << 24);
+
+HRESULT CBCJ2_x86_Encoder::CodeReal(ISequentialInStream **inStreams,
+      const UInt64 **inSizes,
+      UInt32 numInStreams,
+      ISequentialOutStream **outStreams,
+      const UInt64 **outSizes,
+      UInt32 numOutStreams,
+      ICompressProgressInfo *progress)
+{
+  if (numInStreams != 1 || numOutStreams != 4)
+    return E_INVALIDARG;
+
+  if (!Create())
+    return E_OUTOFMEMORY;
+
+  bool sizeIsDefined = false;
+  UInt64 inSize;
+  if (inSizes != NULL)
+    if (inSizes[0] != NULL)
+    {
+      inSize = *inSizes[0];
+      if (inSize <= kDefaultLimit)
+        sizeIsDefined = true;
+    }
+
+  ISequentialInStream *inStream = inStreams[0];
+
+  _mainStream.SetStream(outStreams[0]);
+  _mainStream.Init();
+  _callStream.SetStream(outStreams[1]);
+  _callStream.Init();
+  _jumpStream.SetStream(outStreams[2]);
+  _jumpStream.Init();
+  _rangeEncoder.SetStream(outStreams[3]);
+  _rangeEncoder.Init();
+  for (int i = 0; i < 256; i++)
+    _statusE8Encoder[i].Init();
+  _statusE9Encoder.Init();
+  _statusJccEncoder.Init();
+  CCoderReleaser releaser(this);
+
+  CMyComPtr<ICompressGetSubStreamSize> getSubStreamSize;
+  {
+    inStream->QueryInterface(IID_ICompressGetSubStreamSize, (void **)&getSubStreamSize);
+  }
+
+  UInt32 nowPos = 0;
+  UInt64 nowPos64 = 0;
+  UInt32 bufferPos = 0;
+
+  Byte prevByte = 0;
+
+  UInt64 subStreamIndex = 0;
+  UInt64 subStreamStartPos  = 0;
+  UInt64 subStreamEndPos = 0;
+
+  while(true)
+  {
+    UInt32 processedSize = 0;
+    while(true)
+    {
+      UInt32 size = kBufferSize - (bufferPos + processedSize);
+      UInt32 processedSizeLoc;
+      if (size == 0)
+        break;
+      RINOK(inStream->Read(_buffer + bufferPos + processedSize, size, &processedSizeLoc));
+      if (processedSizeLoc == 0)
+        break;
+      processedSize += processedSizeLoc;
+    }
+    UInt32 endPos = bufferPos + processedSize;
+    
+    if (endPos < 5)
+    {
+      // change it 
+      for (bufferPos = 0; bufferPos < endPos; bufferPos++)
+      {
+        Byte b = _buffer[bufferPos];
+        _mainStream.WriteByte(b);
+        if (b == 0xE8)
+          _statusE8Encoder[prevByte].Encode(&_rangeEncoder, 0);
+        else if (b == 0xE9)
+          _statusE9Encoder.Encode(&_rangeEncoder, 0);
+        else if (IsJcc(prevByte, b))
+          _statusJccEncoder.Encode(&_rangeEncoder, 0);
+        prevByte = b;
+      }
+      return Flush();
+    }
+
+    bufferPos = 0;
+
+    UInt32 limit = endPos - 5;
+    while(bufferPos <= limit)
+    {
+      Byte b = _buffer[bufferPos];
+      _mainStream.WriteByte(b);
+      if (b != 0xE8 && b != 0xE9 && !IsJcc(prevByte, b))
+      {
+        bufferPos++;
+        prevByte = b;
+        continue;
+      }
+      Byte nextByte = _buffer[bufferPos + 4];
+      UInt32 src = 
+        (UInt32(nextByte) << 24) |
+        (UInt32(_buffer[bufferPos + 3]) << 16) |
+        (UInt32(_buffer[bufferPos + 2]) << 8) |
+        (_buffer[bufferPos + 1]);
+      UInt32 dest = (nowPos + bufferPos + 5) + src;
+      // if (Test86MSByte(nextByte))
+      bool convert;
+      if (getSubStreamSize != NULL)
+      {
+        UInt64 currentPos = (nowPos64 + bufferPos);
+        while (subStreamEndPos < currentPos)
+        {
+          UInt64 subStreamSize;
+          HRESULT result = getSubStreamSize->GetSubStreamSize(subStreamIndex, &subStreamSize);
+          if (result == S_OK)
+          {
+            subStreamStartPos = subStreamEndPos;
+            subStreamEndPos += subStreamSize;          
+            subStreamIndex++;
+          }
+          else if (result == S_FALSE || result == E_NOTIMPL)
+          {
+            getSubStreamSize.Release();
+            subStreamStartPos = 0;
+            subStreamEndPos = subStreamStartPos - 1;          
+          }
+          else
+            return result;
+        }
+        if (getSubStreamSize == NULL)
+        {
+          if (sizeIsDefined)
+            convert = (dest < inSize);
+          else
+            convert = Test86MSByte(nextByte);
+        }
+        else if (subStreamEndPos - subStreamStartPos > kDefaultLimit)
+          convert = Test86MSByte(nextByte);
+        else
+        {
+          UInt64 dest64 = (currentPos + 5) + Int64(Int32(src));
+          convert = (dest64 >= subStreamStartPos && dest64 < subStreamEndPos);
+        }
+      }
+      else if (sizeIsDefined)
+        convert = (dest < inSize);
+      else
+        convert = Test86MSByte(nextByte);
+      if (convert)
+      {
+        if (b == 0xE8)
+          _statusE8Encoder[prevByte].Encode(&_rangeEncoder, 1);
+        else if (b == 0xE9)
+          _statusE9Encoder.Encode(&_rangeEncoder, 1);
+        else 
+          _statusJccEncoder.Encode(&_rangeEncoder, 1);
+
+        bufferPos += 5;
+        if (b == 0xE8)
+        {
+          _callStream.WriteByte((Byte)(dest >> 24));
+          _callStream.WriteByte((Byte)(dest >> 16));
+          _callStream.WriteByte((Byte)(dest >> 8));
+          _callStream.WriteByte((Byte)(dest));
+        }
+        else 
+        {
+          _jumpStream.WriteByte((Byte)(dest >> 24));
+          _jumpStream.WriteByte((Byte)(dest >> 16));
+          _jumpStream.WriteByte((Byte)(dest >> 8));
+          _jumpStream.WriteByte((Byte)(dest));
+        }
+        prevByte = nextByte;
+      }
+      else
+      {
+        if (b == 0xE8)
+          _statusE8Encoder[prevByte].Encode(&_rangeEncoder, 0);
+        else if (b == 0xE9)
+          _statusE9Encoder.Encode(&_rangeEncoder, 0);
+        else
+          _statusJccEncoder.Encode(&_rangeEncoder, 0);
+        bufferPos++;
+        prevByte = b;
+      }
+    }
+    nowPos += bufferPos;
+    nowPos64 += bufferPos;
+
+    if (progress != NULL)
+    {
+      RINOK(progress->SetRatioInfo(&nowPos64, NULL));
+    }
+ 
+    UInt32 i = 0;
+    while(bufferPos < endPos)
+      _buffer[i++] = _buffer[bufferPos++];
+    bufferPos = i;
+  }
+}
+
+STDMETHODIMP CBCJ2_x86_Encoder::Code(ISequentialInStream **inStreams,
+      const UInt64 **inSizes,
+      UInt32 numInStreams,
+      ISequentialOutStream **outStreams,
+      const UInt64 **outSizes,
+      UInt32 numOutStreams,
+      ICompressProgressInfo *progress)
+{
+  try
+  {
+    return CodeReal(inStreams, inSizes, numInStreams,
+      outStreams, outSizes,numOutStreams, progress);
+  }
+  catch(const COutBufferException &e) { return e.ErrorCode; }
+  catch(...) { return S_FALSE; }
+}
+
+#endif
+
+HRESULT CBCJ2_x86_Decoder::CodeReal(ISequentialInStream **inStreams,
+      const UInt64 **inSizes,
+      UInt32 numInStreams,
+      ISequentialOutStream **outStreams,
+      const UInt64 **outSizes,
+      UInt32 numOutStreams,
+      ICompressProgressInfo *progress)
+{
+  if (numInStreams != 4 || numOutStreams != 1)
+    return E_INVALIDARG;
+
+  if (!_mainInStream.Create(1 << 16))
+    return E_OUTOFMEMORY;
+  if (!_callStream.Create(1 << 20))
+    return E_OUTOFMEMORY;
+  if (!_jumpStream.Create(1 << 16))
+    return E_OUTOFMEMORY;
+  if (!_rangeDecoder.Create(1 << 20))
+    return E_OUTOFMEMORY;
+  if (!_outStream.Create(1 << 16))
+    return E_OUTOFMEMORY;
+
+  _mainInStream.SetStream(inStreams[0]);
+  _callStream.SetStream(inStreams[1]);
+  _jumpStream.SetStream(inStreams[2]);
+  _rangeDecoder.SetStream(inStreams[3]);
+  _outStream.SetStream(outStreams[0]);
+
+  _mainInStream.Init();
+  _callStream.Init();
+  _jumpStream.Init();
+  _rangeDecoder.Init();
+  _outStream.Init();
+
+  for (int i = 0; i < 256; i++)
+    _statusE8Decoder[i].Init();
+  _statusE9Decoder.Init();
+  _statusJccDecoder.Init();
+
+  CCoderReleaser releaser(this);
+
+  Byte prevByte = 0;
+  UInt32 processedBytes = 0;
+  while(true)
+  {
+    if (processedBytes > (1 << 20) && progress != NULL)
+    {
+      UInt64 nowPos64 = _outStream.GetProcessedSize();
+      RINOK(progress->SetRatioInfo(NULL, &nowPos64));
+      processedBytes = 0;
+    }
+    processedBytes++;
+    Byte b;
+    if (!_mainInStream.ReadByte(b))
+      return Flush();
+    _outStream.WriteByte(b);
+    if (b != 0xE8 && b != 0xE9 && !IsJcc(prevByte, b))
+    {
+      prevByte = b;
+      continue;
+    }
+    bool status;
+    if (b == 0xE8)
+      status = (_statusE8Decoder[prevByte].Decode(&_rangeDecoder) == 1);
+    else if (b == 0xE9)
+      status = (_statusE9Decoder.Decode(&_rangeDecoder) == 1);
+    else
+      status = (_statusJccDecoder.Decode(&_rangeDecoder) == 1);
+    if (status)
+    {
+      UInt32 src;
+      if (b == 0xE8)
+      {
+        Byte b0;
+        if(!_callStream.ReadByte(b0))
+          return S_FALSE;
+        src = ((UInt32)b0) << 24;
+        if(!_callStream.ReadByte(b0))
+          return S_FALSE;
+        src |= ((UInt32)b0) << 16;
+        if(!_callStream.ReadByte(b0))
+          return S_FALSE;
+        src |= ((UInt32)b0) << 8;
+        if(!_callStream.ReadByte(b0))
+          return S_FALSE;
+        src |= ((UInt32)b0);
+      }
+      else
+      {
+        Byte b0;
+        if(!_jumpStream.ReadByte(b0))
+          return S_FALSE;
+        src = ((UInt32)b0) << 24;
+        if(!_jumpStream.ReadByte(b0))
+          return S_FALSE;
+        src |= ((UInt32)b0) << 16;
+        if(!_jumpStream.ReadByte(b0))
+          return S_FALSE;
+        src |= ((UInt32)b0) << 8;
+        if(!_jumpStream.ReadByte(b0))
+          return S_FALSE;
+        src |= ((UInt32)b0);
+      }
+      UInt32 dest = src - (UInt32(_outStream.GetProcessedSize()) + 4) ;
+      _outStream.WriteByte((Byte)(dest));
+      _outStream.WriteByte((Byte)(dest >> 8));
+      _outStream.WriteByte((Byte)(dest >> 16));
+      _outStream.WriteByte((Byte)(dest >> 24));
+      prevByte = (dest >> 24);
+      processedBytes += 4;
+    }
+    else
+      prevByte = b;
+  }
+}
+
+STDMETHODIMP CBCJ2_x86_Decoder::Code(ISequentialInStream **inStreams,
+      const UInt64 **inSizes,
+      UInt32 numInStreams,
+      ISequentialOutStream **outStreams,
+      const UInt64 **outSizes,
+      UInt32 numOutStreams,
+      ICompressProgressInfo *progress)
+{
+  try
+  {
+    return CodeReal(inStreams, inSizes, numInStreams,
+        outStreams, outSizes,numOutStreams, progress);
+  }
+  catch(const COutBufferException &e) { return e.ErrorCode; }
+  catch(...) { return S_FALSE; }
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/x86_2.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/x86_2.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/x86_2.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/x86_2.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,133 @@
+// x86_2.h
+
+#ifndef __BRANCH_X86_2_H
+#define __BRANCH_X86_2_H
+
+#include "../../../Common/MyCom.h"
+#include "../RangeCoder/RangeCoderBit.h"
+#include "../../ICoder.h"
+
+// {23170F69-40C1-278B-0303-010100000100}
+#define MyClass2_a(Name, id, subId, encodingId)  \
+DEFINE_GUID(CLSID_CCompressConvert ## Name,  \
+0x23170F69, 0x40C1, 0x278B, 0x03, 0x03, id, subId, 0x00, 0x00, encodingId, 0x00);
+
+#define MyClass_a(Name, id, subId)  \
+MyClass2_a(Name ## _Encoder, id, subId, 0x01) \
+MyClass2_a(Name ## _Decoder, id, subId, 0x00) 
+
+MyClass_a(BCJ2_x86, 0x01, 0x1B)
+
+const int kNumMoveBits = 5;
+
+#ifndef EXTRACT_ONLY
+
+class CBCJ2_x86_Encoder:
+  public ICompressCoder2,
+  public CMyUnknownImp
+{
+  Byte *_buffer;
+public:
+  CBCJ2_x86_Encoder(): _buffer(0) {};
+  ~CBCJ2_x86_Encoder();
+  bool Create();
+
+  COutBuffer _mainStream;
+  COutBuffer _callStream;
+  COutBuffer _jumpStream;
+  NCompress::NRangeCoder::CEncoder _rangeEncoder;
+  NCompress::NRangeCoder::CBitEncoder<kNumMoveBits> _statusE8Encoder[256];
+  NCompress::NRangeCoder::CBitEncoder<kNumMoveBits> _statusE9Encoder;
+  NCompress::NRangeCoder::CBitEncoder<kNumMoveBits> _statusJccEncoder;
+
+  HRESULT Flush();
+  void ReleaseStreams()
+  {
+    _mainStream.ReleaseStream();
+    _callStream.ReleaseStream();
+    _jumpStream.ReleaseStream();
+    _rangeEncoder.ReleaseStream();
+  }
+
+  class CCoderReleaser
+  {
+    CBCJ2_x86_Encoder *_coder;
+  public:
+    CCoderReleaser(CBCJ2_x86_Encoder *coder): _coder(coder) {}
+    ~CCoderReleaser() {  _coder->ReleaseStreams(); }
+  };
+
+public: 
+
+  MY_UNKNOWN_IMP
+
+  HRESULT CodeReal(ISequentialInStream **inStreams,
+      const UInt64 **inSizes,
+      UInt32 numInStreams,
+      ISequentialOutStream **outStreams,
+      const UInt64 **outSizes,
+      UInt32 numOutStreams,
+      ICompressProgressInfo *progress);
+  STDMETHOD(Code)(ISequentialInStream **inStreams,
+      const UInt64 **inSizes,
+      UInt32 numInStreams,
+      ISequentialOutStream **outStreams,
+      const UInt64 **outSizes,
+      UInt32 numOutStreams,
+      ICompressProgressInfo *progress);
+}; 
+
+#endif
+
+class CBCJ2_x86_Decoder:
+  public ICompressCoder2,
+  public CMyUnknownImp
+{ 
+public:
+  CInBuffer _mainInStream;
+  CInBuffer _callStream;
+  CInBuffer _jumpStream;
+  NCompress::NRangeCoder::CDecoder _rangeDecoder;
+  NCompress::NRangeCoder::CBitDecoder<kNumMoveBits> _statusE8Decoder[256];
+  NCompress::NRangeCoder::CBitDecoder<kNumMoveBits> _statusE9Decoder;
+  NCompress::NRangeCoder::CBitDecoder<kNumMoveBits> _statusJccDecoder;
+
+  COutBuffer _outStream;
+
+  void ReleaseStreams()
+  {
+    _mainInStream.ReleaseStream();
+    _callStream.ReleaseStream();
+    _jumpStream.ReleaseStream();
+    _rangeDecoder.ReleaseStream();
+    _outStream.ReleaseStream();
+  }
+
+  HRESULT Flush() { return _outStream.Flush(); }
+  class CCoderReleaser
+  {
+    CBCJ2_x86_Decoder *_coder;
+  public:
+    CCoderReleaser(CBCJ2_x86_Decoder *coder): _coder(coder) {}
+    ~CCoderReleaser()  { _coder->ReleaseStreams(); }
+  };
+
+public: 
+  MY_UNKNOWN_IMP
+  HRESULT CodeReal(ISequentialInStream **inStreams,
+      const UInt64 **inSizes,
+      UInt32 numInStreams,
+      ISequentialOutStream **outStreams,
+      const UInt64 **outSizes,
+      UInt32 numOutStreams,
+      ICompressProgressInfo *progress);
+  STDMETHOD(Code)(ISequentialInStream **inStreams,
+      const UInt64 **inSizes,
+      UInt32 numInStreams,
+      ISequentialOutStream **outStreams,
+      const UInt64 **outSizes,
+      UInt32 numOutStreams,
+      ICompressProgressInfo *progress);
+}; 
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/x86.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/x86.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/x86.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/x86.cpp	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,18 @@
+// x86.cpp
+
+#include "StdAfx.h"
+#include "x86.h"
+
+#include "Windows/Defs.h"
+
+#include "BranchX86.c"
+
+UInt32 CBCJ_x86_Encoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::x86_Convert(data, size, _bufferPos, &_prevMask, &_prevPos, 1);
+}
+
+UInt32 CBCJ_x86_Decoder::SubFilter(Byte *data, UInt32 size)
+{
+  return ::x86_Convert(data, size, _bufferPos, &_prevMask, &_prevPos, 0);
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/x86.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/x86.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/Branch/x86.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/Branch/x86.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,19 @@
+// x86.h
+
+#ifndef __X86_H
+#define __X86_H
+
+#include "BranchCoder.h"
+#include "BranchX86.h"
+
+struct CBranch86
+{
+  UInt32 _prevMask;
+  UInt32 _prevPos;
+  void x86Init() { x86_Convert_Init(_prevMask, _prevPos); }
+};
+
+MyClassB(BCJ_x86, 0x01, 3, CBranch86 , 
+    virtual void SubInit() { x86Init(); })
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree2.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree2.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree2.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree2.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,12 @@
+// BinTree2.h
+
+#ifndef __BINTREE2_H
+#define __BINTREE2_H
+
+#undef BT_NAMESPACE
+#define BT_NAMESPACE NBT2
+
+#include "BinTree.h"
+#include "BinTreeMain.h"
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree3.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree3.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree3.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree3.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,16 @@
+// BinTree3.h
+
+#ifndef __BINTREE3_H
+#define __BINTREE3_H
+
+#undef BT_NAMESPACE
+#define BT_NAMESPACE NBT3
+
+#define HASH_ARRAY_2
+
+#include "BinTree.h"
+#include "BinTreeMain.h"
+
+#undef HASH_ARRAY_2
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree3Z.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree3Z.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree3Z.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree3Z.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,16 @@
+// BinTree3Z.h
+
+#ifndef __BINTREE3Z_H
+#define __BINTREE3Z_H
+
+#undef BT_NAMESPACE
+#define BT_NAMESPACE NBT3Z
+
+#define HASH_ZIP
+
+#include "BinTree.h"
+#include "BinTreeMain.h"
+
+#undef HASH_ZIP
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree4b.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree4b.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree4b.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree4b.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,20 @@
+// BinTree4b.h
+
+#ifndef __BINTREE4B_H
+#define __BINTREE4B_H
+
+#undef BT_NAMESPACE
+#define BT_NAMESPACE NBT4B
+
+#define HASH_ARRAY_2
+#define HASH_ARRAY_3
+#define HASH_BIG
+
+#include "BinTree.h"
+#include "BinTreeMain.h"
+
+#undef HASH_ARRAY_2
+#undef HASH_ARRAY_3
+#undef HASH_BIG
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree4.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree4.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree4.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree4.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,18 @@
+// BinTree4.h
+
+#ifndef __BINTREE4_H
+#define __BINTREE4_H
+
+#undef BT_NAMESPACE
+#define BT_NAMESPACE NBT4
+
+#define HASH_ARRAY_2
+#define HASH_ARRAY_3
+
+#include "BinTree.h"
+#include "BinTreeMain.h"
+
+#undef HASH_ARRAY_2
+#undef HASH_ARRAY_3
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTree.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,55 @@
+// BinTree.h
+
+#include "../LZInWindow.h"
+#include "../IMatchFinder.h"
+ 
+namespace BT_NAMESPACE {
+
+typedef UInt32 CIndex;
+const UInt32 kMaxValForNormalize = (UInt32(1) << 31) - 1;
+
+class CMatchFinderBinTree: 
+  public IMatchFinder,
+  public IMatchFinderSetCallback,
+  public CLZInWindow,
+  public CMyUnknownImp
+{
+  UInt32 _cyclicBufferPos;
+  UInt32 _cyclicBufferSize; // it must be historySize + 1
+  UInt32 _matchMaxLen;
+  CIndex *_hash;
+  UInt32 _cutValue;
+
+  CMyComPtr<IMatchFinderCallback> m_Callback;
+
+  void Normalize();
+  void FreeThisClassMemory();
+  void FreeMemory();
+
+  MY_UNKNOWN_IMP1(IMatchFinderSetCallback)
+
+  STDMETHOD(Init)(ISequentialInStream *inStream);
+  STDMETHOD_(void, ReleaseStream)();
+  STDMETHOD(MovePos)();
+  STDMETHOD_(Byte, GetIndexByte)(Int32 index);
+  STDMETHOD_(UInt32, GetMatchLen)(Int32 index, UInt32 back, UInt32 limit);
+  STDMETHOD_(UInt32, GetNumAvailableBytes)();
+  STDMETHOD_(const Byte *, GetPointerToCurrentPos)();
+  STDMETHOD(Create)(UInt32 historySize, UInt32 keepAddBufferBefore, 
+      UInt32 matchMaxLen, UInt32 keepAddBufferAfter);
+  STDMETHOD_(UInt32, GetLongestMatch)(UInt32 *distances);
+  STDMETHOD_(void, DummyLongestMatch)();
+
+  // IMatchFinderSetCallback
+  STDMETHOD(SetCallback)(IMatchFinderCallback *callback);
+
+  virtual void BeforeMoveBlock();
+  virtual void AfterMoveBlock();
+
+public:
+  CMatchFinderBinTree();
+  virtual ~CMatchFinderBinTree();
+  void SetCutValue(UInt32 cutValue) { _cutValue = cutValue; }
+};
+
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTreeMain.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTreeMain.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTreeMain.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/BinTree/BinTreeMain.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,444 @@
+// BinTreeMain.h
+
+#include "../../../../Common/Defs.h"
+#include "../../../../Common/CRC.h"
+#include "../../../../Common/Alloc.h"
+
+namespace BT_NAMESPACE {
+
+#ifdef HASH_ARRAY_2
+  static const UInt32 kHash2Size = 1 << 10;
+  #ifdef HASH_ARRAY_3
+    static const UInt32 kNumHashDirectBytes = 0;
+    static const UInt32 kNumHashBytes = 4;
+    static const UInt32 kHash3Size = 1 << 18;
+    #ifdef HASH_BIG
+    static const UInt32 kHashSize = 1 << 23;
+    #else
+    static const UInt32 kHashSize = 1 << 20;
+    #endif
+  #else
+    static const UInt32 kNumHashDirectBytes = 3;
+    static const UInt32 kNumHashBytes = 3;
+    static const UInt32 kHashSize = 1 << (8 * kNumHashBytes);
+  #endif
+#else
+  #ifdef HASH_ZIP 
+    static const UInt32 kNumHashDirectBytes = 0;
+    static const UInt32 kNumHashBytes = 3;
+    static const UInt32 kHashSize = 1 << 16;
+  #else
+    #define THERE_ARE_DIRECT_HASH_BYTES
+    static const UInt32 kNumHashDirectBytes = 2;
+    static const UInt32 kNumHashBytes = 2;
+    static const UInt32 kHashSize = 1 << (8 * kNumHashBytes);
+  #endif
+#endif
+
+static const UInt32 kHashSizeSum = kHashSize
+    #ifdef HASH_ARRAY_2
+    + kHash2Size
+    #ifdef HASH_ARRAY_3
+    + kHash3Size
+    #endif
+    #endif
+    ;
+
+#ifdef HASH_ARRAY_2
+static const UInt32 kHash2Offset = kHashSize;
+#ifdef HASH_ARRAY_3
+static const UInt32 kHash3Offset = kHashSize + kHash2Size;
+#endif
+#endif
+
+CMatchFinderBinTree::CMatchFinderBinTree():
+  _hash(0),
+  _cutValue(0xFF)
+{
+}
+
+void CMatchFinderBinTree::FreeThisClassMemory()
+{
+  BigFree(_hash);
+  _hash = 0;
+}
+
+void CMatchFinderBinTree::FreeMemory()
+{
+  FreeThisClassMemory();
+  CLZInWindow::Free();
+}
+
+CMatchFinderBinTree::~CMatchFinderBinTree()
+{ 
+  FreeMemory();
+}
+
+STDMETHODIMP CMatchFinderBinTree::Create(UInt32 historySize, UInt32 keepAddBufferBefore, 
+    UInt32 matchMaxLen, UInt32 keepAddBufferAfter)
+{
+  UInt32 sizeReserv = (historySize + keepAddBufferBefore + 
+      matchMaxLen + keepAddBufferAfter) / 2 + 256;
+  if (CLZInWindow::Create(historySize + keepAddBufferBefore, 
+      matchMaxLen + keepAddBufferAfter, sizeReserv))
+  {
+    if (historySize + 256 > kMaxValForNormalize)
+    {
+      FreeMemory();
+      return E_INVALIDARG;
+    }
+    _matchMaxLen = matchMaxLen;
+    UInt32 newCyclicBufferSize = historySize + 1;
+    if (_hash != 0 && newCyclicBufferSize == _cyclicBufferSize)
+      return S_OK;
+    FreeThisClassMemory();
+    _cyclicBufferSize = newCyclicBufferSize; // don't change it
+    _hash = (CIndex *)BigAlloc((kHashSizeSum + _cyclicBufferSize * 2) * sizeof(CIndex));
+    if (_hash != 0)
+      return S_OK;
+  }
+  FreeMemory();
+  return E_OUTOFMEMORY;
+}
+
+static const UInt32 kEmptyHashValue = 0;
+
+STDMETHODIMP CMatchFinderBinTree::Init(ISequentialInStream *stream)
+{
+  RINOK(CLZInWindow::Init(stream));
+  for(UInt32 i = 0; i < kHashSizeSum; i++)
+    _hash[i] = kEmptyHashValue;
+  _cyclicBufferPos = 0;
+  ReduceOffsets(-1);
+  return S_OK;
+}
+
+STDMETHODIMP_(void) CMatchFinderBinTree::ReleaseStream()
+{ 
+  // ReleaseStream(); 
+}
+
+#ifdef HASH_ARRAY_2
+#ifdef HASH_ARRAY_3
+inline UInt32 Hash(const Byte *pointer, UInt32 &hash2Value, UInt32 &hash3Value)
+{
+  UInt32 temp = CCRC::Table[pointer[0]] ^ pointer[1];
+  hash2Value = temp & (kHash2Size - 1);
+  hash3Value = (temp ^ (UInt32(pointer[2]) << 8)) & (kHash3Size - 1);
+  return (temp ^ (UInt32(pointer[2]) << 8) ^ (CCRC::Table[pointer[3]] << 5)) & 
+      (kHashSize - 1);
+}
+#else // no HASH_ARRAY_3
+inline UInt32 Hash(const Byte *pointer, UInt32 &hash2Value)
+{
+  hash2Value = (CCRC::Table[pointer[0]] ^ pointer[1]) & (kHash2Size - 1);
+  return ((UInt32(pointer[0]) << 16)) | ((UInt32(pointer[1]) << 8)) | pointer[2];
+}
+#endif // HASH_ARRAY_3
+#else // no HASH_ARRAY_2
+#ifdef HASH_ZIP 
+inline UInt32 Hash(const Byte *pointer)
+{
+  return ((UInt32(pointer[0]) << 8) ^ 
+      CCRC::Table[pointer[1]] ^ pointer[2]) & (kHashSize - 1);
+}
+#else // no HASH_ZIP 
+inline UInt32 Hash(const Byte *pointer)
+{
+  return pointer[0] ^ (UInt32(pointer[1]) << 8);
+}
+#endif // HASH_ZIP
+#endif // HASH_ARRAY_2
+
+STDMETHODIMP_(UInt32) CMatchFinderBinTree::GetLongestMatch(UInt32 *distances)
+{
+  UInt32 lenLimit;
+  if (_pos + _matchMaxLen <= _streamPos)
+    lenLimit = _matchMaxLen;
+  else
+  {
+    lenLimit = _streamPos - _pos;
+    if(lenLimit < kNumHashBytes)
+      return 0; 
+  }
+
+  UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;
+  Byte *cur = _buffer + _pos;
+
+  UInt32 maxLen = 0;
+
+  #ifdef HASH_ARRAY_2
+  UInt32 hash2Value;
+  #ifdef HASH_ARRAY_3
+  UInt32 hash3Value;
+  UInt32 hashValue = Hash(cur, hash2Value, hash3Value);
+  #else
+  UInt32 hashValue = Hash(cur, hash2Value);
+  #endif
+  #else
+  UInt32 hashValue = Hash(cur);
+  #endif
+
+  UInt32 curMatch = _hash[hashValue];
+  #ifdef HASH_ARRAY_2
+  UInt32 curMatch2 = _hash[kHash2Offset + hash2Value];
+  #ifdef HASH_ARRAY_3
+  UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];
+  #endif
+  _hash[kHash2Offset + hash2Value] = _pos;
+  distances[2] = 0xFFFFFFFF;
+  if(curMatch2 > matchMinPos)
+    if (_buffer[curMatch2] == cur[0])
+    {
+      distances[2] = _pos - curMatch2 - 1;
+      maxLen = 2;
+    }
+
+  #ifdef HASH_ARRAY_3
+  _hash[kHash3Offset + hash3Value] = _pos;
+  distances[3] = 0xFFFFFFFF;
+  if(curMatch3 > matchMinPos)
+    if (_buffer[curMatch3] == cur[0])
+    {
+      distances[3] = _pos - curMatch3 - 1;
+      maxLen = 3;
+    }
+  #endif
+  #endif
+
+  _hash[hashValue] = _pos;
+
+  CIndex *son = _hash + kHashSizeSum;
+  CIndex *ptr0 = son + (_cyclicBufferPos << 1) + 1;
+  CIndex *ptr1 = son + (_cyclicBufferPos << 1);
+
+  distances[kNumHashBytes] = 0xFFFFFFFF;
+
+  #ifdef THERE_ARE_DIRECT_HASH_BYTES
+  if (lenLimit == kNumHashDirectBytes)
+  {
+    if(curMatch > matchMinPos)
+      while (maxLen < kNumHashDirectBytes)
+        distances[++maxLen] = _pos - curMatch - 1;
+    // We don't need tree in this case
+  }
+  else
+  #endif
+  {
+    UInt32 len0, len1;
+    len0 = len1 = kNumHashDirectBytes;
+    UInt32 count = _cutValue;
+    while(true)
+    {
+      if(curMatch <= matchMinPos || count-- == 0)
+      {
+        *ptr0 = kEmptyHashValue;
+        *ptr1 = kEmptyHashValue;
+        break;
+      }
+      Byte *pb = _buffer + curMatch;
+      UInt32 len = MyMin(len0, len1);
+      do
+      {
+        if (pb[len] != cur[len])
+          break;
+      }
+      while(++len != lenLimit);
+      
+      UInt32 delta = _pos - curMatch;
+      while (maxLen < len)
+        distances[++maxLen] = delta - 1;
+      
+      UInt32 cyclicPos = (delta <= _cyclicBufferPos) ?
+          (_cyclicBufferPos - delta):
+          (_cyclicBufferPos - delta + _cyclicBufferSize);
+      CIndex *pair = son + (cyclicPos << 1);
+      
+      if (len != lenLimit)
+      {
+        if (pb[len] < cur[len])
+        {
+          *ptr1 = curMatch;
+          ptr1 = pair + 1;
+          curMatch = *ptr1;
+          len1 = len;
+        }
+        else
+        {
+          *ptr0 = curMatch;
+          ptr0 = pair;
+          curMatch = *ptr0;
+          len0 = len;
+        }
+      }
+      else
+      {
+        *ptr1 = pair[0];
+        *ptr0 = pair[1];
+        break;
+      }
+    }
+  }
+  #ifdef HASH_ARRAY_2
+  #ifdef HASH_ARRAY_3
+  if (distances[4] < distances[3])
+    distances[3] = distances[4];
+  #endif
+  if (distances[3] < distances[2])
+    distances[2] = distances[3];
+  #endif
+  return maxLen;
+}
+
+STDMETHODIMP_(void) CMatchFinderBinTree::DummyLongestMatch()
+{
+  UInt32 lenLimit;
+  if (_pos + _matchMaxLen <= _streamPos)
+    lenLimit = _matchMaxLen;
+  else
+  {
+    lenLimit = _streamPos - _pos;
+    if(lenLimit < kNumHashBytes)
+      return; 
+  }
+  UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;
+  Byte *cur = _buffer + _pos;
+
+  #ifdef HASH_ARRAY_2
+  UInt32 hash2Value;
+  #ifdef HASH_ARRAY_3
+  UInt32 hash3Value;
+  UInt32 hashValue = Hash(cur, hash2Value, hash3Value);
+  _hash[kHash3Offset + hash3Value] = _pos;
+  #else
+  UInt32 hashValue = Hash(cur, hash2Value);
+  #endif
+  _hash[kHash2Offset + hash2Value] = _pos;
+  #else
+  UInt32 hashValue = Hash(cur);
+  #endif
+
+  UInt32 curMatch = _hash[hashValue];
+  _hash[hashValue] = _pos;
+
+  CIndex *son = _hash + kHashSizeSum;
+  CIndex *ptr0 = son + (_cyclicBufferPos << 1) + 1;
+  CIndex *ptr1 = son + (_cyclicBufferPos << 1);
+
+  #ifdef THERE_ARE_DIRECT_HASH_BYTES
+  if (lenLimit != kNumHashDirectBytes)
+  #endif
+  {
+    UInt32 len0, len1;
+    len0 = len1 = kNumHashDirectBytes;
+    UInt32 count = _cutValue;
+    while(true)
+    {
+      if(curMatch <= matchMinPos || count-- == 0)
+        break;
+      Byte *pb = _buffer + curMatch;
+      UInt32 len = MyMin(len0, len1);
+      do
+      {
+        if (pb[len] != cur[len])
+          break;
+      }
+      while(++len != lenLimit);
+      
+      UInt32 delta = _pos - curMatch;
+      UInt32 cyclicPos = (delta <= _cyclicBufferPos) ?
+        (_cyclicBufferPos - delta):
+      (_cyclicBufferPos - delta + _cyclicBufferSize);
+      CIndex *pair = son + (cyclicPos << 1);
+      
+      if (len != lenLimit)
+      {
+        if (pb[len] < cur[len])
+        {
+          *ptr1 = curMatch;
+          ptr1 = pair + 1;
+          curMatch = *ptr1;
+          len1 = len;
+        }
+        else 
+        {
+          *ptr0 = curMatch;
+          ptr0 = pair;
+          curMatch = *ptr0;
+          len0 = len;
+        }
+      }
+      else
+      {
+        *ptr1 = pair[0];
+        *ptr0 = pair[1];
+        return;
+      }
+    }
+  }
+  *ptr0 = kEmptyHashValue;
+  *ptr1 = kEmptyHashValue;
+}
+
+void CMatchFinderBinTree::Normalize()
+{
+  UInt32 subValue = _pos - _cyclicBufferSize;
+  CIndex *items = _hash;
+  UInt32 numItems = (kHashSizeSum + _cyclicBufferSize * 2);
+  for (UInt32 i = 0; i < numItems; i++)
+  {
+    UInt32 value = items[i];
+    if (value <= subValue)
+      value = kEmptyHashValue;
+    else
+      value -= subValue;
+    items[i] = value;
+  }
+  ReduceOffsets(subValue);
+}
+
+STDMETHODIMP CMatchFinderBinTree::MovePos()
+{
+  if (++_cyclicBufferPos == _cyclicBufferSize)
+    _cyclicBufferPos = 0;
+  RINOK(CLZInWindow::MovePos());
+  if (_pos == kMaxValForNormalize)
+    Normalize();
+  return S_OK;
+}
+
+STDMETHODIMP_(Byte) CMatchFinderBinTree::GetIndexByte(Int32 index)
+  { return CLZInWindow::GetIndexByte(index); }
+
+STDMETHODIMP_(UInt32) CMatchFinderBinTree::GetMatchLen(Int32 index, 
+    UInt32 back, UInt32 limit)
+  { return CLZInWindow::GetMatchLen(index, back, limit); }
+
+STDMETHODIMP_(UInt32) CMatchFinderBinTree::GetNumAvailableBytes()
+  { return CLZInWindow::GetNumAvailableBytes(); }
+
+STDMETHODIMP_(const Byte *) CMatchFinderBinTree::GetPointerToCurrentPos()
+  { return CLZInWindow::GetPointerToCurrentPos(); }
+
+// IMatchFinderSetCallback
+STDMETHODIMP CMatchFinderBinTree::SetCallback(IMatchFinderCallback *callback)
+{
+  m_Callback = callback;
+  return S_OK;
+}
+
+void CMatchFinderBinTree::BeforeMoveBlock()
+{
+  if (m_Callback)
+    m_Callback->BeforeChangingBufferPos();
+  CLZInWindow::BeforeMoveBlock();
+}
+
+void CMatchFinderBinTree::AfterMoveBlock()
+{
+  if (m_Callback)
+    m_Callback->AfterChangingBufferPos();
+  CLZInWindow::AfterMoveBlock();
+}
+ 
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC2.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC2.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC2.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC2.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,13 @@
+// HC2.h
+
+#ifndef __HC2_H
+#define __HC2_H
+
+#undef HC_NAMESPACE
+#define HC_NAMESPACE NHC2
+
+#include "HCMF.h"
+#include "HCMFMain.h"
+
+#endif
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC3.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC3.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC3.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC3.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,17 @@
+// HC3.h
+
+#ifndef __HC3_H
+#define __HC3_H
+
+#undef HC_NAMESPACE
+#define HC_NAMESPACE NHC3
+
+#define HASH_ARRAY_2
+
+#include "HC.h"
+#include "HCMain.h"
+
+#undef HASH_ARRAY_2
+
+#endif
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC4b.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC4b.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC4b.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC4b.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,21 @@
+// HC4b.h
+
+#ifndef __HC4B__H
+#define __HC4B__H
+
+#undef HC_NAMESPACE
+#define HC_NAMESPACE NHC4b
+
+#define HASH_ARRAY_2
+#define HASH_ARRAY_3
+#define HASH_BIG
+
+#include "HC.h"
+#include "HCMain.h"
+
+#undef HASH_ARRAY_2
+#undef HASH_ARRAY_3
+#undef HASH_BIG
+
+#endif
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC4.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC4.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC4.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC4.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,19 @@
+// HC4.h
+
+#ifndef __HC4_H
+#define __HC4_H
+
+#undef HC_NAMESPACE
+#define HC_NAMESPACE NHC4
+
+#define HASH_ARRAY_2
+#define HASH_ARRAY_3
+
+#include "HC.h"
+#include "HCMain.h"
+
+#undef HASH_ARRAY_2
+#undef HASH_ARRAY_3
+
+#endif
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HC.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,55 @@
+// HC.h
+
+#include "../LZInWindow.h"
+#include "../IMatchFinder.h"
+ 
+namespace HC_NAMESPACE {
+
+typedef UInt32 CIndex;
+const UInt32 kMaxValForNormalize = (UInt32(1) << 31) - 1;
+
+class CMatchFinderHC: 
+  public IMatchFinder,
+  public IMatchFinderSetCallback,
+  public CLZInWindow,
+  public CMyUnknownImp
+{
+  UInt32 _cyclicBufferPos;
+  UInt32 _cyclicBufferSize; // it must be historySize + 1
+  UInt32 _matchMaxLen;
+  CIndex *_hash;
+  UInt32 _cutValue;
+
+  CMyComPtr<IMatchFinderCallback> m_Callback;
+
+  void Normalize();
+  void FreeThisClassMemory();
+  void FreeMemory();
+
+  MY_UNKNOWN_IMP1(IMatchFinderSetCallback)
+
+  STDMETHOD(Init)(ISequentialInStream *inStream);
+  STDMETHOD_(void, ReleaseStream)();
+  STDMETHOD(MovePos)();
+  STDMETHOD_(Byte, GetIndexByte)(Int32 index);
+  STDMETHOD_(UInt32, GetMatchLen)(Int32 index, UInt32 back, UInt32 limit);
+  STDMETHOD_(UInt32, GetNumAvailableBytes)();
+  STDMETHOD_(const Byte *, GetPointerToCurrentPos)();
+  STDMETHOD(Create)(UInt32 historySize, UInt32 keepAddBufferBefore, 
+      UInt32 matchMaxLen, UInt32 keepAddBufferAfter);
+  STDMETHOD_(UInt32, GetLongestMatch)(UInt32 *distances);
+  STDMETHOD_(void, DummyLongestMatch)();
+
+  // IMatchFinderSetCallback
+  STDMETHOD(SetCallback)(IMatchFinderCallback *callback);
+
+  virtual void BeforeMoveBlock();
+  virtual void AfterMoveBlock();
+
+public:
+  CMatchFinderHC();
+  virtual ~CMatchFinderHC();
+  void SetCutValue(UInt32 cutValue) { _cutValue = cutValue; }
+};
+
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HCMain.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HCMain.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HCMain.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/HashChain/HCMain.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,350 @@
+// HC.h
+
+#include "../../../../Common/Defs.h"
+#include "../../../../Common/CRC.h"
+#include "../../../../Common/Alloc.h"
+
+namespace HC_NAMESPACE {
+
+#ifdef HASH_ARRAY_2
+  static const UInt32 kHash2Size = 1 << 10;
+  #ifdef HASH_ARRAY_3
+    static const UInt32 kNumHashDirectBytes = 0;
+    static const UInt32 kNumHashBytes = 4;
+    static const UInt32 kHash3Size = 1 << 18;
+    #ifdef HASH_BIG
+    static const UInt32 kHashSize = 1 << 23;
+    #else
+    static const UInt32 kHashSize = 1 << 20;
+    #endif
+  #else
+    static const UInt32 kNumHashDirectBytes = 0;
+    static const UInt32 kNumHashBytes = 3;
+    static const UInt32 kHashSize = 1 << (16);
+  #endif
+#else
+  #ifdef HASH_ZIP 
+    static const UInt32 kNumHashDirectBytes = 0;
+    static const UInt32 kNumHashBytes = 3;
+    static const UInt32 kHashSize = 1 << 16;
+  #else
+    #define THERE_ARE_DIRECT_HASH_BYTES
+    static const UInt32 kNumHashDirectBytes = 2;
+    static const UInt32 kNumHashBytes = 2;
+    static const UInt32 kHashSize = 1 << (8 * kNumHashBytes);
+  #endif
+#endif
+
+static const UInt32 kHashSizeSum = kHashSize
+    #ifdef HASH_ARRAY_2
+    + kHash2Size
+    #ifdef HASH_ARRAY_3
+    + kHash3Size
+    #endif
+    #endif
+    ;
+
+#ifdef HASH_ARRAY_2
+static const UInt32 kHash2Offset = kHashSize;
+#ifdef HASH_ARRAY_3
+static const UInt32 kHash3Offset = kHashSize + kHash2Size;
+#endif
+#endif
+
+CMatchFinderHC::CMatchFinderHC():
+  _hash(0),
+  _cutValue(16)
+{
+}
+
+void CMatchFinderHC::FreeThisClassMemory()
+{
+  BigFree(_hash);
+  _hash = 0;
+}
+
+void CMatchFinderHC::FreeMemory()
+{
+  FreeThisClassMemory();
+  CLZInWindow::Free();
+}
+
+CMatchFinderHC::~CMatchFinderHC()
+{ 
+  FreeMemory();
+}
+
+STDMETHODIMP CMatchFinderHC::Create(UInt32 historySize, UInt32 keepAddBufferBefore, 
+    UInt32 matchMaxLen, UInt32 keepAddBufferAfter)
+{
+  UInt32 sizeReserv = (historySize + keepAddBufferBefore + 
+      matchMaxLen + keepAddBufferAfter) / 2 + 256;
+  if (CLZInWindow::Create(historySize + keepAddBufferBefore, 
+      matchMaxLen + keepAddBufferAfter, sizeReserv))
+  {
+    if (historySize + 256 > kMaxValForNormalize)
+    {
+      FreeMemory();
+      return E_INVALIDARG;
+    }
+    _matchMaxLen = matchMaxLen;
+    UInt32 newCyclicBufferSize = historySize + 1;
+    if (_hash != 0 && newCyclicBufferSize == _cyclicBufferSize)
+      return S_OK;
+    FreeThisClassMemory();
+    _cyclicBufferSize = newCyclicBufferSize; // don't change it
+    _hash = (CIndex *)BigAlloc((kHashSizeSum + _cyclicBufferSize) * sizeof(CIndex));
+    if (_hash != 0)
+      return S_OK;
+  }
+  FreeMemory();
+  return E_OUTOFMEMORY;
+}
+
+static const UInt32 kEmptyHashValue = 0;
+
+STDMETHODIMP CMatchFinderHC::Init(ISequentialInStream *stream)
+{
+  RINOK(CLZInWindow::Init(stream));
+  for(UInt32 i = 0; i < kHashSizeSum; i++)
+    _hash[i] = kEmptyHashValue;
+  _cyclicBufferPos = 0;
+  ReduceOffsets(-1);
+  return S_OK;
+}
+
+STDMETHODIMP_(void) CMatchFinderHC::ReleaseStream()
+{ 
+  // ReleaseStream(); 
+}
+
+#ifdef HASH_ARRAY_2
+#ifdef HASH_ARRAY_3
+inline UInt32 Hash(const Byte *pointer, UInt32 &hash2Value, UInt32 &hash3Value)
+{
+  UInt32 temp = CCRC::Table[pointer[0]] ^ pointer[1];
+  hash2Value = temp & (kHash2Size - 1);
+  hash3Value = (temp ^ (UInt32(pointer[2]) << 8)) & (kHash3Size - 1);
+  return (temp ^ (UInt32(pointer[2]) << 8) ^ (CCRC::Table[pointer[3]] << 5)) & 
+      (kHashSize - 1);
+}
+#else // no HASH_ARRAY_3
+inline UInt32 Hash(const Byte *pointer, UInt32 &hash2Value)
+{
+  UInt32 temp = CCRC::Table[pointer[0]] ^ pointer[1];
+  hash2Value = temp & (kHash2Size - 1);
+  return (temp ^ (UInt32(pointer[2]) << 8)) & (kHashSize - 1);;
+}
+#endif // HASH_ARRAY_3
+#else // no HASH_ARRAY_2
+#ifdef HASH_ZIP 
+inline UInt32 Hash(const Byte *pointer)
+{
+  return ((UInt32(pointer[0]) << 8) ^ 
+      CCRC::Table[pointer[1]] ^ pointer[2]) & (kHashSize - 1);
+}
+#else // no HASH_ZIP 
+inline UInt32 Hash(const Byte *pointer)
+{
+  return pointer[0] ^ (UInt32(pointer[1]) << 8);
+}
+#endif // HASH_ZIP
+#endif // HASH_ARRAY_2
+
+
+STDMETHODIMP_(UInt32) CMatchFinderHC::GetLongestMatch(UInt32 *distances)
+{
+  UInt32 lenLimit;
+  if (_pos + _matchMaxLen <= _streamPos)
+    lenLimit = _matchMaxLen;
+  else
+  {
+    lenLimit = _streamPos - _pos;
+    if(lenLimit < kNumHashBytes)
+      return 0; 
+  }
+
+  UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;
+  Byte *cur = _buffer + _pos;
+  
+  UInt32 maxLen = 0;
+
+  #ifdef HASH_ARRAY_2
+  UInt32 hash2Value;
+  #ifdef HASH_ARRAY_3
+  UInt32 hash3Value;
+  UInt32 hashValue = Hash(cur, hash2Value, hash3Value);
+  #else
+  UInt32 hashValue = Hash(cur, hash2Value);
+  #endif
+  #else
+  UInt32 hashValue = Hash(cur);
+  #endif
+  #ifdef HASH_ARRAY_2
+
+  UInt32 curMatch2 = _hash[kHash2Offset + hash2Value];
+  _hash[kHash2Offset + hash2Value] = _pos;
+  distances[2] = 0xFFFFFFFF;
+  if(curMatch2 > matchMinPos)
+    if (_buffer[curMatch2] == cur[0])
+    {
+      distances[2] = _pos - curMatch2 - 1;
+      maxLen = 2;
+    }
+
+  #ifdef HASH_ARRAY_3
+  
+  UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];
+  _hash[kHash3Offset + hash3Value] = _pos;
+  distances[3] = 0xFFFFFFFF;
+  if(curMatch3 > matchMinPos)
+    if (_buffer[curMatch3] == cur[0])
+    {
+      distances[3] = _pos - curMatch3 - 1;
+      maxLen = 3;
+    }
+  
+  #endif
+  #endif
+
+  UInt32 curMatch = _hash[hashValue];
+  _hash[hashValue] = _pos;
+  CIndex *chain = _hash + kHashSizeSum;
+  chain[_cyclicBufferPos] = curMatch;
+  distances[kNumHashBytes] = 0xFFFFFFFF;
+  #ifdef THERE_ARE_DIRECT_HASH_BYTES
+  if (lenLimit == kNumHashDirectBytes)
+  {
+    if(curMatch > matchMinPos)
+      while (maxLen < kNumHashDirectBytes)
+        distances[++maxLen] = _pos - curMatch - 1;
+  }
+  else
+  #endif
+  {
+    UInt32 count = _cutValue;
+    do
+    {
+      if(curMatch <= matchMinPos)
+        break;
+      Byte *pby1 = _buffer + curMatch;
+      UInt32 currentLen = kNumHashDirectBytes;
+      do 
+      {
+        if (pby1[currentLen] != cur[currentLen])
+          break;
+      }
+      while(++currentLen != lenLimit);
+      
+      UInt32 delta = _pos - curMatch;
+      while (maxLen < currentLen)
+        distances[++maxLen] = delta - 1;
+      if(currentLen == lenLimit)
+        break;
+      
+      UInt32 cyclicPos = (delta <= _cyclicBufferPos) ?
+        (_cyclicBufferPos - delta):
+      (_cyclicBufferPos - delta + _cyclicBufferSize);
+      
+      curMatch = chain[cyclicPos];
+    }
+    while(--count != 0);
+  }
+  #ifdef HASH_ARRAY_2
+  #ifdef HASH_ARRAY_3
+  if (distances[4] < distances[3])
+    distances[3] = distances[4];
+  #endif
+  if (distances[3] < distances[2])
+    distances[2] = distances[3];
+  #endif
+  return maxLen;
+}
+
+STDMETHODIMP_(void) CMatchFinderHC::DummyLongestMatch()
+{
+  if (_streamPos - _pos < kNumHashBytes)
+    return; 
+  
+  Byte *cur = _buffer + _pos;
+  
+  #ifdef HASH_ARRAY_2
+  UInt32 hash2Value;
+  #ifdef HASH_ARRAY_3
+  UInt32 hash3Value;
+  UInt32 hashValue = Hash(cur, hash2Value, hash3Value);
+  _hash[kHash3Offset + hash3Value] = _pos;
+  #else
+  UInt32 hashValue = Hash(cur, hash2Value);
+  #endif
+  _hash[kHash2Offset + hash2Value] = _pos;
+  #else
+  UInt32 hashValue = Hash(cur);
+  #endif
+
+  _hash[kHashSizeSum + _cyclicBufferPos] = _hash[hashValue];
+  _hash[hashValue] = _pos;
+}
+
+void CMatchFinderHC::Normalize()
+{
+  UInt32 subValue = _pos - _cyclicBufferSize;
+  CIndex *items = _hash;
+  UInt32 numItems = kHashSizeSum + _cyclicBufferSize;
+  for (UInt32 i = 0; i < numItems; i++)
+  {
+    UInt32 value = items[i];
+    if (value <= subValue)
+      value = kEmptyHashValue;
+    else
+      value -= subValue;
+    items[i] = value;
+  }
+  ReduceOffsets(subValue);
+}
+
+STDMETHODIMP CMatchFinderHC::MovePos()
+{
+  if (++_cyclicBufferPos == _cyclicBufferSize)
+    _cyclicBufferPos = 0;
+  RINOK(CLZInWindow::MovePos());
+  if (_pos == kMaxValForNormalize)
+    Normalize();
+  return S_OK;
+}
+
+STDMETHODIMP_(Byte) CMatchFinderHC::GetIndexByte(Int32 index)
+  { return CLZInWindow::GetIndexByte(index); }
+
+STDMETHODIMP_(UInt32) CMatchFinderHC::GetMatchLen(Int32 index, 
+    UInt32 back, UInt32 limit)
+  { return CLZInWindow::GetMatchLen(index, back, limit); }
+
+STDMETHODIMP_(UInt32) CMatchFinderHC::GetNumAvailableBytes()
+  { return CLZInWindow::GetNumAvailableBytes(); }
+
+STDMETHODIMP_(const Byte *) CMatchFinderHC::GetPointerToCurrentPos()
+  { return CLZInWindow::GetPointerToCurrentPos(); }
+
+// IMatchFinderSetCallback
+STDMETHODIMP CMatchFinderHC::SetCallback(IMatchFinderCallback *callback)
+{
+  m_Callback = callback;
+  return S_OK;
+}
+
+void CMatchFinderHC::BeforeMoveBlock()
+{
+  if (m_Callback)
+    m_Callback->BeforeChangingBufferPos();
+  CLZInWindow::BeforeMoveBlock();
+}
+
+void CMatchFinderHC::AfterMoveBlock()
+{
+  if (m_Callback)
+    m_Callback->AfterChangingBufferPos();
+  CLZInWindow::AfterMoveBlock();
+}
+ 
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/IMatchFinder.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/IMatchFinder.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/IMatchFinder.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/IMatchFinder.h	2022-01-01 15:08:47.885171448 +0800
@@ -0,0 +1,63 @@
+// MatchFinders/IMatchFinder.h
+
+#ifndef __IMATCHFINDER_H
+#define __IMATCHFINDER_H
+
+// {23170F69-40C1-278A-0000-000200010000}
+DEFINE_GUID(IID_IInWindowStream, 
+0x23170F69, 0x40C1, 0x278A, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00);
+MIDL_INTERFACE("23170F69-40C1-278A-0000-000200010000")
+IInWindowStream: public IUnknown
+{
+  STDMETHOD(Init)(ISequentialInStream *inStream) PURE;
+  STDMETHOD_(void, ReleaseStream)() PURE;
+  STDMETHOD(MovePos)() PURE;
+  STDMETHOD_(Byte, GetIndexByte)(Int32 index) PURE;
+  STDMETHOD_(UInt32, GetMatchLen)(Int32 index, UInt32 distance, UInt32 limit) PURE;
+  STDMETHOD_(UInt32, GetNumAvailableBytes)() PURE;
+  STDMETHOD_(const Byte *, GetPointerToCurrentPos)() PURE;
+};
+ 
+// {23170F69-40C1-278A-0000-000200020000}
+DEFINE_GUID(IID_IMatchFinder, 
+0x23170F69, 0x40C1, 0x278A, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00);
+MIDL_INTERFACE("23170F69-40C1-278A-0000-000200020000")
+IMatchFinder: public IInWindowStream
+{
+  STDMETHOD(Create)(UInt32 historySize, UInt32 keepAddBufferBefore, 
+      UInt32 matchMaxLen, UInt32 keepAddBufferAfter) PURE;
+  STDMETHOD_(UInt32, GetLongestMatch)(UInt32 *distances) PURE;
+  STDMETHOD_(void, DummyLongestMatch)() PURE;
+};
+
+// {23170F69-40C1-278A-0000-000200020100}
+DEFINE_GUID(IID_IMatchFinderCallback, 
+0x23170F69, 0x40C1, 0x278A, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x01, 0x00);
+MIDL_INTERFACE("23170F69-40C1-278A-0000-000200020100")
+IMatchFinderCallback: public IUnknown
+{
+  STDMETHOD(BeforeChangingBufferPos)() PURE;
+  STDMETHOD(AfterChangingBufferPos)() PURE;
+};
+
+// {23170F69-40C1-278A-0000-000200020200}
+DEFINE_GUID(IID_IMatchFinderSetCallback, 
+0x23170F69, 0x40C1, 0x278A, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00);
+MIDL_INTERFACE("23170F69-40C1-278A-0000-000200020200")
+IMatchFinderSetCallback: public IUnknown
+{
+  STDMETHOD(SetCallback)(IMatchFinderCallback *callback) PURE;
+};
+
+/*
+// {23170F69-40C1-278A-0000-000200030000}
+DEFINE_GUID(IID_IInitMatchFinder, 
+0x23170F69, 0x40C1, 0x278A, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00);
+MIDL_INTERFACE("23170F69-40C1-278A-0000-000200030000")
+IMatchFinderInit: public IUnknown
+{
+  STDMETHOD(InitMatchFinder)(IMatchFinder *matchFinder) PURE;
+};
+*/
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/LZInWindow.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/LZInWindow.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/LZInWindow.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/LZInWindow.cpp	2022-01-01 15:08:47.889171448 +0800
@@ -0,0 +1,102 @@
+// LZInWindow.cpp
+
+#include "StdAfx.h"
+
+#include "LZInWindow.h"
+#include "../../../Common/MyCom.h"
+#include "../../../Common/Alloc.h"
+
+void CLZInWindow::Free()
+{
+  ::BigFree(_bufferBase);
+  _bufferBase = 0;
+}
+
+bool CLZInWindow::Create(UInt32 keepSizeBefore, UInt32 keepSizeAfter, UInt32 keepSizeReserv)
+{
+  _keepSizeBefore = keepSizeBefore;
+  _keepSizeAfter = keepSizeAfter;
+  _keepSizeReserv = keepSizeReserv;
+  UInt32 blockSize = keepSizeBefore + keepSizeAfter + keepSizeReserv;
+  if (_bufferBase == 0 || _blockSize != blockSize)
+  {
+    Free();
+    _blockSize = blockSize;
+    if (_blockSize != 0)
+      _bufferBase = (Byte *)::BigAlloc(_blockSize);
+  }
+  _pointerToLastSafePosition = _bufferBase + _blockSize - keepSizeAfter;
+  if (_blockSize == 0)
+    return true;
+  return (_bufferBase != 0);
+}
+
+
+HRESULT CLZInWindow::Init(ISequentialInStream *stream)
+{
+  _stream = stream;
+  _buffer = _bufferBase;
+  _pos = 0;
+  _streamPos = 0;
+  _streamEndWasReached = false;
+  return ReadBlock();
+}
+
+/*
+void CLZInWindow::ReleaseStream()
+{
+  _stream.Release();
+}
+*/
+
+///////////////////////////////////////////
+// ReadBlock
+
+// In State:
+//   (_buffer + _streamPos) <= (_bufferBase + _blockSize)
+// Out State:
+//   _posLimit <= _blockSize - _keepSizeAfter;
+//   if(_streamEndWasReached == false):
+//     _streamPos >= _pos + _keepSizeAfter
+//     _posLimit = _streamPos - _keepSizeAfter;
+//   else
+//          
+  
+HRESULT CLZInWindow::ReadBlock()
+{
+  if(_streamEndWasReached)
+    return S_OK;
+  while(true)
+  {
+    UInt32 size = UInt32(_bufferBase - _buffer) + _blockSize - _streamPos;
+    if(size == 0)
+      return S_OK;
+    UInt32 numReadBytes;
+    RINOK(_stream->Read(_buffer + _streamPos, size, &numReadBytes));
+    if(numReadBytes == 0)
+    {
+      _posLimit = _streamPos;
+      const Byte *pointerToPostion = _buffer + _posLimit;
+      if(pointerToPostion > _pointerToLastSafePosition)
+        _posLimit = (UInt32)(_pointerToLastSafePosition - _buffer);
+      _streamEndWasReached = true;
+      return S_OK;
+    }
+    _streamPos += numReadBytes;
+    if(_streamPos >= _pos + _keepSizeAfter)
+    {
+      _posLimit = _streamPos - _keepSizeAfter;
+      return S_OK;
+    }
+  }
+}
+
+void CLZInWindow::MoveBlock()
+{
+  BeforeMoveBlock();
+  UInt32 offset = UInt32(_buffer - _bufferBase) + _pos - _keepSizeBefore;
+  UInt32 numBytes = UInt32(_buffer - _bufferBase) + _streamPos -  offset;
+  memmove(_bufferBase, _bufferBase + offset, numBytes);
+  _buffer -= offset;
+  AfterMoveBlock();
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/LZInWindow.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/LZInWindow.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/LZInWindow.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/LZInWindow.h	2022-01-01 15:08:47.889171448 +0800
@@ -0,0 +1,84 @@
+// LZInWindow.h
+
+#ifndef __LZ_IN_WINDOW_H
+#define __LZ_IN_WINDOW_H
+
+#include "../../IStream.h"
+
+class CLZInWindow
+{
+  Byte *_bufferBase; // pointer to buffer with data
+  ISequentialInStream *_stream;
+  UInt32 _posLimit;  // offset (from _buffer) of first byte when new block reading must be done
+  bool _streamEndWasReached; // if (true) then _streamPos shows real end of stream
+  const Byte *_pointerToLastSafePosition;
+protected:
+  Byte  *_buffer;   // Pointer to virtual Buffer begin
+  UInt32 _blockSize;  // Size of Allocated memory block
+  UInt32 _pos;             // offset (from _buffer) of curent byte
+  UInt32 _keepSizeBefore;  // how many BYTEs must be kept in buffer before _pos
+  UInt32 _keepSizeAfter;   // how many BYTEs must be kept buffer after _pos
+  UInt32 _keepSizeReserv;  // how many BYTEs must be kept as reserv
+  UInt32 _streamPos;   // offset (from _buffer) of first not read byte from Stream
+
+  virtual void BeforeMoveBlock() {};
+  virtual void AfterMoveBlock() {};
+  void MoveBlock();
+  virtual HRESULT ReadBlock();
+  void Free();
+public:
+  CLZInWindow(): _bufferBase(0) {}
+  virtual ~CLZInWindow() { Free(); }
+
+  bool Create(UInt32 keepSizeBefore, UInt32 keepSizeAfter, 
+      UInt32 keepSizeReserv = (1<<17));
+
+  HRESULT Init(ISequentialInStream *stream);
+  // void ReleaseStream();
+
+  Byte *GetBuffer() const { return _buffer; }
+
+  const Byte *GetPointerToCurrentPos() const { return _buffer + _pos; }
+
+  HRESULT MovePos()
+  {
+    _pos++;
+    if (_pos > _posLimit)
+    {
+      const Byte *pointerToPostion = _buffer + _pos;
+      if(pointerToPostion > _pointerToLastSafePosition)
+        MoveBlock();
+      return ReadBlock();
+    }
+    else
+      return S_OK;
+  }
+  Byte GetIndexByte(Int32 index)const
+    {  return _buffer[(size_t)_pos + index]; }
+
+  // index + limit have not to exceed _keepSizeAfter;
+  UInt32 GetMatchLen(Int32 index, UInt32 distance, UInt32 limit) const
+  {  
+    if(_streamEndWasReached)
+      if ((_pos + index) + limit > _streamPos)
+        limit = _streamPos - (_pos + index);
+    distance++;
+    Byte *pby = _buffer + (size_t)_pos + index;
+    UInt32 i;
+    for(i = 0; i < limit && pby[i] == pby[(size_t)i - distance]; i++);
+    return i;
+  }
+
+  UInt32 GetNumAvailableBytes() const { return _streamPos - _pos; }
+
+  void ReduceOffsets(Int32 subValue)
+  {
+    _buffer += subValue;
+    _posLimit -= subValue;
+    _pos -= subValue;
+    _streamPos -= subValue;
+  }
+
+};
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/LZOutWindow.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/LZOutWindow.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/LZOutWindow.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/LZOutWindow.cpp	2022-01-01 15:08:47.889171448 +0800
@@ -0,0 +1,17 @@
+// LZOutWindow.cpp
+
+#include "StdAfx.h"
+
+#include "../../../Common/Alloc.h"
+#include "LZOutWindow.h"
+
+void CLZOutWindow::Init(bool solid)
+{
+  if(!solid)
+    COutBuffer::Init();
+  #ifdef _NO_EXCEPTIONS
+  ErrorCode = S_OK;
+  #endif
+}
+
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/LZOutWindow.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/LZOutWindow.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/LZOutWindow.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/LZOutWindow.h	2022-01-01 15:08:47.889171448 +0800
@@ -0,0 +1,64 @@
+// LZOutWindow.h
+
+#ifndef __LZ_OUT_WINDOW_H
+#define __LZ_OUT_WINDOW_H
+
+#include "../../IStream.h"
+#include "../../Common/OutBuffer.h"
+
+/*
+#ifndef _NO_EXCEPTIONS
+class CLZOutWindowException
+{
+public:
+  HRESULT ErrorCode;
+  CLZOutWindowException(HRESULT errorCode): ErrorCode(errorCode) {}
+};
+#endif
+*/
+typedef COutBufferException CLZOutWindowException;
+
+class CLZOutWindow: public COutBuffer
+{
+public:
+  void Init(bool solid = false);
+  
+  // distance >= 0, len > 0, 
+  bool CopyBlock(UInt32 distance, UInt32 len)
+  {
+    UInt32 pos = _pos - distance - 1;
+    if (pos >= _bufferSize)
+    {
+      if (!_overDict)
+        return false;
+      pos += _bufferSize;
+    }
+    do
+    {
+      if (pos == _bufferSize)
+        pos = 0;
+      _buffer[_pos++] = _buffer[pos++];
+      if (_pos == _limitPos)
+        FlushWithCheck();  
+    }
+    while(--len != 0);
+    return true;
+  }
+  
+  void PutByte(Byte b)
+  {
+    _buffer[_pos++] = b;
+    if (_pos == _limitPos)
+      FlushWithCheck();  
+  }
+  
+  Byte GetByte(UInt32 distance) const
+  {
+    UInt32 pos = _pos - distance - 1;
+    if (pos >= _bufferSize)
+      pos += _bufferSize;
+    return _buffer[pos]; 
+  }
+};
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat2.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat2.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat2.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat2.h	2022-01-01 15:08:47.889171448 +0800
@@ -0,0 +1,22 @@
+// Pat2.h
+
+#ifndef __PAT2__H
+#define __PAT2__H
+
+#undef PAT_CLSID
+#define PAT_CLSID CLSID_CMatchFinderPat2
+
+#undef PAT_NAMESPACE
+#define PAT_NAMESPACE NPat2
+
+#define __AUTO_REMOVE
+#define __NODE_2_BITS
+
+#include "Pat.h"
+#include "PatMain.h"
+
+#undef __AUTO_REMOVE
+#undef  __NODE_2_BITS
+
+#endif
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat2H.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat2H.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat2H.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat2H.h	2022-01-01 15:08:47.889171448 +0800
@@ -0,0 +1,24 @@
+// Pat2H.h
+
+#ifndef __PAT2H__H
+#define __PAT2H__H
+
+#undef PAT_CLSID
+#define PAT_CLSID CLSID_CMatchFinderPat2H
+
+#undef PAT_NAMESPACE
+#define PAT_NAMESPACE NPat2H
+
+#define __AUTO_REMOVE
+#define __NODE_2_BITS
+#define __HASH_3
+
+#include "Pat.h"
+#include "PatMain.h"
+
+#undef __AUTO_REMOVE
+#undef __NODE_2_BITS
+#undef __HASH_3
+
+#endif
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat2R.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat2R.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat2R.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat2R.h	2022-01-01 15:08:47.889171448 +0800
@@ -0,0 +1,20 @@
+// Pat2R.h
+
+#ifndef __PAT2R__H
+#define __PAT2R__H
+
+#undef PAT_CLSID
+#define PAT_CLSID CLSID_CMatchFinderPat2R
+
+#undef PAT_NAMESPACE
+#define PAT_NAMESPACE NPat2R
+
+#define __NODE_2_BITS
+
+#include "Pat.h"
+#include "PatMain.h"
+
+#undef  __NODE_2_BITS
+
+#endif
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat3H.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat3H.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat3H.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat3H.h	2022-01-01 15:08:47.889171448 +0800
@@ -0,0 +1,24 @@
+// Pat3H.h
+
+#ifndef __PAT3H__H
+#define __PAT3H__H
+
+#undef PAT_CLSID
+#define PAT_CLSID CLSID_CMatchFinderPat3H
+
+#undef PAT_NAMESPACE
+#define PAT_NAMESPACE NPat3H
+
+#define __AUTO_REMOVE
+#define __NODE_3_BITS
+#define __HASH_3
+
+#include "Pat.h"
+#include "PatMain.h"
+
+#undef __AUTO_REMOVE
+#undef __NODE_3_BITS
+#undef __HASH_3
+
+#endif
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat4H.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat4H.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat4H.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat4H.h	2022-01-01 15:08:47.889171448 +0800
@@ -0,0 +1,24 @@
+// Pat4H.h
+
+#ifndef __PAT4H__H
+#define __PAT4H__H
+
+#undef PAT_CLSID
+#define PAT_CLSID CLSID_CMatchFinderPat4H
+
+#undef PAT_NAMESPACE
+#define PAT_NAMESPACE NPat4H
+
+#define __AUTO_REMOVE
+#define __NODE_4_BITS
+#define __HASH_3
+
+#include "Pat.h"
+#include "PatMain.h"
+
+#undef __AUTO_REMOVE
+#undef __NODE_4_BITS
+#undef __HASH_3
+
+#endif
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/Pat.h	2022-01-01 15:08:47.889171448 +0800
@@ -0,0 +1,318 @@
+// Pat.h
+
+// #ifndef __PATRICIA__H
+// #define __PATRICIA__H
+
+#include "../../../../Common/MyCom.h"
+#include "../../../../Common/Types.h"
+#include "../LZInWindow.h"
+
+namespace PAT_NAMESPACE {
+
+struct CNode;
+
+typedef CNode *CNodePointer;
+
+// #define __AUTO_REMOVE
+
+// #define __NODE_4_BITS
+// #define __NODE_3_BITS
+// #define __NODE_2_BITS
+// #define __NODE_2_BITS_PADDING
+
+// #define __HASH_3
+
+
+typedef UInt32 CIndex;
+
+#ifdef __NODE_4_BITS
+  typedef UInt32 CIndex2;
+  typedef UInt32 CSameBitsType;
+#else
+#ifdef __NODE_3_BITS
+  typedef UInt32 CIndex2;
+  typedef UInt32 CSameBitsType;
+#else
+
+  typedef UInt32 CIndex;
+  typedef UInt32 CSameBitsType;
+
+  typedef CIndex CIndex2;
+#endif
+#endif
+
+const UInt32 kNumBitsInIndex = sizeof(CIndex) * 8;
+const UInt32 kMatchStartValue = UInt32(1) << (kNumBitsInIndex - 1);
+// don't change kMatchStartValue definition, since it is used in 
+// PatMain.h: 
+
+typedef CIndex CMatchPointer;
+
+const UInt32 kDescendantEmptyValue = kMatchStartValue - 1;
+
+union CDescendant 
+{
+  CIndex NodePointer;
+  CMatchPointer MatchPointer;
+  bool IsEmpty() const { return NodePointer == kDescendantEmptyValue; }
+  bool IsNode() const { return NodePointer < kDescendantEmptyValue; }
+  bool IsMatch() const { return NodePointer > kDescendantEmptyValue; }
+  void MakeEmpty() { NodePointer = kDescendantEmptyValue; }
+};
+
+#undef MY_BYTE_SIZE
+
+#ifdef __NODE_4_BITS
+  #define MY_BYTE_SIZE 8
+  const UInt32 kNumSubBits = 4;
+#else
+#ifdef __NODE_3_BITS
+  #define MY_BYTE_SIZE 9
+  const UInt32 kNumSubBits = 3;
+#else
+  #define MY_BYTE_SIZE 8
+  #ifdef __NODE_2_BITS
+    const UInt32 kNumSubBits = 2;
+  #else
+    const UInt32 kNumSubBits = 1;
+  #endif
+#endif
+#endif
+
+const UInt32 kNumSubNodes = 1 << kNumSubBits;
+const UInt32 kSubNodesMask = kNumSubNodes - 1;
+
+struct CNode
+{
+  CIndex2 LastMatch;
+  CSameBitsType NumSameBits;
+  union
+  {
+    CDescendant  Descendants[kNumSubNodes];
+    UInt32 NextFreeNode;
+  };
+  #ifdef __NODE_2_BITS
+  #ifdef __NODE_2_BITS_PADDING
+  UInt32 Padding[2];
+  #endif
+  #endif
+};
+
+#undef kIDNumBitsByte
+#undef kIDNumBitsString
+
+#ifdef __NODE_4_BITS
+  #define kIDNumBitsByte 0x30
+  #define kIDNumBitsString TEXT("4")
+#else
+#ifdef __NODE_3_BITS
+  #define kIDNumBitsByte 0x20
+  #define kIDNumBitsString TEXT("3")
+#else
+#ifdef __NODE_2_BITS
+  #define kIDNumBitsByte 0x10
+  #define kIDNumBitsString TEXT("2")
+#else
+  #define kIDNumBitsByte 0x00
+  #define kIDNumBitsString TEXT("1")
+#endif
+#endif
+#endif
+
+#undef kIDManualRemoveByte
+#undef kIDManualRemoveString
+
+#ifdef __AUTO_REMOVE
+  #define kIDManualRemoveByte 0x00
+  #define kIDManualRemoveString TEXT("")
+#else
+  #define kIDManualRemoveByte 0x08
+  #define kIDManualRemoveString TEXT("R")
+#endif
+
+#undef kIDHash3Byte
+#undef kIDHash3String
+
+#ifdef __HASH_3
+  #define kIDHash3Byte 0x04
+  #define kIDHash3String TEXT("H")
+#else
+  #define kIDHash3Byte 0x00
+  #define kIDHash3String TEXT("")
+#endif
+
+#undef kIDUse3BytesByte
+#undef kIDUse3BytesString
+
+#define kIDUse3BytesByte 0x00
+#define kIDUse3BytesString TEXT("")
+
+#undef kIDPaddingByte
+#undef kIDPaddingString
+
+#ifdef __NODE_2_BITS_PADDING
+  #define kIDPaddingByte 0x01
+  #define kIDPaddingString TEXT("P")
+#else
+  #define kIDPaddingByte 0x00
+  #define kIDPaddingString TEXT("")
+#endif
+
+
+// #undef kIDString
+// #define kIDString TEXT("Compress.MatchFinderPat") kIDNumBitsString kIDManualRemoveString kIDUse3BytesString kIDPaddingString kIDHash3String
+
+// {23170F69-40C1-278C-01XX-0000000000}
+
+DEFINE_GUID(PAT_CLSID, 
+0x23170F69, 0x40C1, 0x278C, 0x01, 
+kIDNumBitsByte | 
+kIDManualRemoveByte | kIDHash3Byte | kIDUse3BytesByte | kIDPaddingByte, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+
+// III(PAT_NAMESPACE)
+
+class CPatricia: 
+  public IMatchFinder,
+  public IMatchFinderSetCallback,
+  public CMyUnknownImp,
+  CLZInWindow
+{ 
+  MY_UNKNOWN_IMP1(IMatchFinderSetCallback)
+
+  STDMETHOD(Init)(ISequentialInStream *aStream);
+  STDMETHOD_(void, ReleaseStream)();
+  STDMETHOD(MovePos)();
+  STDMETHOD_(Byte, GetIndexByte)(Int32 index);
+  STDMETHOD_(UInt32, GetMatchLen)(Int32 index, UInt32 back, UInt32 limit);
+  STDMETHOD_(UInt32, GetNumAvailableBytes)();
+  STDMETHOD(Create)(UInt32 historySize, 
+      UInt32 keepAddBufferBefore, UInt32 matchMaxLen, 
+      UInt32 keepAddBufferAfter);
+  STDMETHOD_(UInt32, GetLongestMatch)(UInt32 *distances);
+  STDMETHOD_(void, DummyLongestMatch)();
+  STDMETHOD_(const Byte *, GetPointerToCurrentPos)();
+
+  void FreeMemory();
+public:
+  CPatricia();
+  ~CPatricia();
+
+  UInt32 _sizeHistory;
+  UInt32 _matchMaxLen;
+
+  CDescendant *m_HashDescendants;
+  #ifdef __HASH_3
+  CDescendant *m_Hash2Descendants;
+  #endif
+
+  CNode *m_Nodes;
+
+  UInt32 m_FreeNode;
+  UInt32 m_FreeNodeMax;
+
+  #ifdef __AUTO_REMOVE
+  UInt32 m_NumUsedNodes;
+  UInt32 m_NumNodes;
+  #else
+  bool  m_SpecialRemoveMode;
+  #endif
+
+  bool  m_SpecialMode;
+  UInt32 m_NumNotChangedCycles;
+  UInt32 *m_TmpBacks;
+
+  CMyComPtr<IMatchFinderCallback> m_Callback;
+
+  virtual void BeforeMoveBlock();
+  virtual void AfterMoveBlock();
+
+  // IMatchFinderSetCallback
+  STDMETHOD(SetCallback)(IMatchFinderCallback *callback);
+
+  void ChangeLastMatch(UInt32 hashValue);
+  
+  #ifdef __AUTO_REMOVE
+  void TestRemoveDescendant(CDescendant &descendant, UInt32 limitPos);
+  void TestRemoveNodes();
+  void RemoveNode(UInt32 index);
+  void TestRemoveAndNormalizeDescendant(CDescendant &descendant, 
+      UInt32 limitPos, UInt32 subValue);
+  void TestRemoveNodesAndNormalize();
+  #else
+  void NormalizeDescendant(CDescendant &descendant, UInt32 subValue);
+  void Normalize();
+  void RemoveMatch();
+  #endif
+private:
+  void AddInternalNode(CNodePointer aNode, CIndex *aNodePointerPointer, 
+      Byte aByte, Byte aByteXOR, UInt32 aNumSameBits, UInt32 aPos)
+  {
+    while((aByteXOR & kSubNodesMask) == 0)
+    {
+      aByteXOR >>= kNumSubBits;
+      aByte >>= kNumSubBits;
+      aNumSameBits -= kNumSubBits;
+    }
+    // Insert New Node
+    CNodePointer aNewNode = &m_Nodes[m_FreeNode];
+    UInt32 aNodeIndex = *aNodePointerPointer;
+    *aNodePointerPointer = m_FreeNode;
+    m_FreeNode = aNewNode->NextFreeNode;
+    #ifdef __AUTO_REMOVE
+    m_NumUsedNodes++;
+    #endif
+    if (m_FreeNode > m_FreeNodeMax)
+    {
+      m_FreeNodeMax = m_FreeNode;
+      m_Nodes[m_FreeNode].NextFreeNode = m_FreeNode + 1;
+    }
+
+    UInt32 aBitsNew = aByte & kSubNodesMask;
+    UInt32 aBitsOld = (aByte ^ aByteXOR) & kSubNodesMask;
+    for (UInt32 i = 0; i < kNumSubNodes; i++)
+      aNewNode->Descendants[i].NodePointer = kDescendantEmptyValue;
+    aNewNode->Descendants[aBitsNew].MatchPointer = aPos + kMatchStartValue;
+    aNewNode->Descendants[aBitsOld].NodePointer = aNodeIndex;
+    aNewNode->NumSameBits = CSameBitsType(aNode->NumSameBits - aNumSameBits);
+    aNewNode->LastMatch = aPos;
+    
+    aNode->NumSameBits = CSameBitsType(aNumSameBits - kNumSubBits);
+  }
+
+  void AddLeafNode(CNodePointer aNode, Byte aByte, Byte aByteXOR, 
+      UInt32 aNumSameBits, UInt32 aPos, UInt32 aDescendantIndex)
+  {
+    for(;(aByteXOR & kSubNodesMask) == 0; aNumSameBits += kNumSubBits)
+    {
+      aByte >>= kNumSubBits;
+      aByteXOR >>= kNumSubBits;
+    }
+    UInt32 aNewNodeIndex = m_FreeNode;
+    CNodePointer aNewNode = &m_Nodes[m_FreeNode];
+    m_FreeNode = aNewNode->NextFreeNode;
+    #ifdef __AUTO_REMOVE
+    m_NumUsedNodes++;
+    #endif
+    if (m_FreeNode > m_FreeNodeMax)
+    {
+      m_FreeNodeMax = m_FreeNode;
+      m_Nodes[m_FreeNode].NextFreeNode = m_FreeNode + 1;
+    }
+
+    UInt32 aBitsNew = (aByte & kSubNodesMask);
+    UInt32 aBitsOld = (aByte ^ aByteXOR) & kSubNodesMask;
+    for (UInt32 i = 0; i < kNumSubNodes; i++)
+      aNewNode->Descendants[i].NodePointer = kDescendantEmptyValue;
+    aNewNode->Descendants[aBitsNew].MatchPointer = aPos + kMatchStartValue;
+    aNewNode->Descendants[aBitsOld].MatchPointer = 
+      aNode->Descendants[aDescendantIndex].MatchPointer;
+    aNewNode->NumSameBits = CSameBitsType(aNumSameBits);
+    aNewNode->LastMatch = aPos;
+    aNode->Descendants[aDescendantIndex].NodePointer = aNewNodeIndex;
+  }
+};
+
+}
+
+// #endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/PatMain.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/PatMain.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/PatMain.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/Patricia/PatMain.h	2022-01-01 15:08:47.889171448 +0800
@@ -0,0 +1,989 @@
+// PatMain.h
+
+#include "../../../../Common/Defs.h"
+#include "../../../../Common/Alloc.h"
+
+namespace PAT_NAMESPACE {
+
+STDMETHODIMP CPatricia::SetCallback(IMatchFinderCallback *callback)
+{
+  m_Callback = callback;
+  return S_OK;
+}
+
+void CPatricia::BeforeMoveBlock()
+{
+  if (m_Callback)
+    m_Callback->BeforeChangingBufferPos();
+  CLZInWindow::BeforeMoveBlock();
+}
+
+void CPatricia::AfterMoveBlock()
+{
+  if (m_Callback)
+    m_Callback->AfterChangingBufferPos();
+  CLZInWindow::AfterMoveBlock();
+}
+
+const UInt32 kMatchStartValue2 = 2;
+const UInt32 kDescendantEmptyValue2 = kMatchStartValue2 - 1;
+const UInt32 kDescendantsNotInitilized2 = kDescendantEmptyValue2 - 1;
+
+#ifdef __HASH_3
+
+static const UInt32 kNumHashBytes = 3;
+static const UInt32 kHashSize = 1 << (8 * kNumHashBytes);
+
+static const UInt32 kNumHash2Bytes = 2;
+static const UInt32 kHash2Size = 1 << (8 * kNumHash2Bytes);
+static const UInt32 kPrevHashSize = kNumHash2Bytes;
+
+#else
+
+static const UInt32 kNumHashBytes = 2;
+static const UInt32 kHashSize = 1 << (8 * kNumHashBytes);
+static const UInt32 kPrevHashSize = 0;
+
+#endif
+
+
+CPatricia::CPatricia():
+  m_HashDescendants(0),
+  #ifdef __HASH_3
+  m_Hash2Descendants(0),
+  #endif
+  m_Nodes(0),
+  m_TmpBacks(0)
+{
+}
+
+CPatricia::~CPatricia()
+{
+  FreeMemory();
+}
+
+void CPatricia::FreeMemory()
+{
+  MyFree(m_TmpBacks);
+  m_TmpBacks = 0;
+
+  ::BigFree(m_Nodes);
+  m_Nodes = 0;
+
+  ::BigFree(m_HashDescendants);
+  m_HashDescendants = 0;
+
+  #ifdef __HASH_3
+
+  ::BigFree(m_Hash2Descendants);
+  m_Hash2Descendants = 0;
+
+  CLZInWindow::Free();
+
+  #endif
+}
+  
+STDMETHODIMP CPatricia::Create(UInt32 historySize, UInt32 keepAddBufferBefore, 
+    UInt32 matchMaxLen, UInt32 keepAddBufferAfter)
+{
+  FreeMemory();
+  int kNumBitsInNumSameBits = sizeof(CSameBitsType) * 8;
+  if (kNumBitsInNumSameBits < 32 && ((matchMaxLen * MY_BYTE_SIZE) > ((UInt32)1 << kNumBitsInNumSameBits)))
+    return E_INVALIDARG;
+
+  const UInt32 kAlignMask = (1 << 16) - 1;
+  UInt32 windowReservSize = historySize;
+  windowReservSize += kAlignMask;
+  windowReservSize &= ~(kAlignMask);
+
+  const UInt32 kMinReservSize = (1 << 19);
+  if (windowReservSize < kMinReservSize)
+    windowReservSize = kMinReservSize;
+  windowReservSize += 256;
+
+  if (!CLZInWindow::Create(historySize + keepAddBufferBefore, 
+      matchMaxLen + keepAddBufferAfter, windowReservSize))
+    return E_OUTOFMEMORY;
+
+  _sizeHistory = historySize;
+  _matchMaxLen = matchMaxLen;
+  m_HashDescendants = (CDescendant *)BigAlloc(kHashSize * sizeof(CDescendant));
+  if (m_HashDescendants == 0)
+  {
+    FreeMemory();
+    return E_OUTOFMEMORY;
+  }
+
+  #ifdef __HASH_3
+  m_Hash2Descendants = (CDescendant *)BigAlloc(kHash2Size  * sizeof(CDescendant));
+  if (m_Hash2Descendants == 0)
+  {
+    FreeMemory();
+    return E_OUTOFMEMORY;
+  }
+  #endif
+  
+  #ifdef __AUTO_REMOVE
+  
+  #ifdef __HASH_3
+  m_NumNodes = historySize + _sizeHistory * 4 / 8 + (1 << 19);
+  #else
+  m_NumNodes = historySize + _sizeHistory * 4 / 8 + (1 << 10);
+  #endif
+  
+  #else
+  
+  UInt32 m_NumNodes = historySize;
+  
+  #endif
+  
+  const UInt32 kMaxNumNodes = UInt32(1) << (sizeof(CIndex) * 8 - 1);
+  if (m_NumNodes + 32 > kMaxNumNodes)
+    return E_INVALIDARG;
+  
+  // m_Nodes = (CNode *)::BigAlloc((m_NumNodes + 2) * sizeof(CNode));
+  m_Nodes = (CNode *)::BigAlloc((m_NumNodes + 12) * sizeof(CNode));
+  if (m_Nodes == 0)
+  {
+    FreeMemory();
+    return E_OUTOFMEMORY;
+  }
+  
+  m_TmpBacks = (UInt32 *)MyAlloc((_matchMaxLen + 1) * sizeof(UInt32));
+  if (m_TmpBacks == 0)
+  {
+    FreeMemory();
+    return E_OUTOFMEMORY;
+  }
+  return S_OK;
+}
+
+STDMETHODIMP CPatricia::Init(ISequentialInStream *aStream)
+{
+  RINOK(CLZInWindow::Init(aStream));
+
+  // memset(m_HashDescendants, 0xFF, kHashSize * sizeof(m_HashDescendants[0]));
+
+  #ifdef __HASH_3
+  for (UInt32 i = 0; i < kHash2Size; i++)
+    m_Hash2Descendants[i].MatchPointer = kDescendantsNotInitilized2;
+  #else
+  for (UInt32 i = 0; i < kHashSize; i++)
+    m_HashDescendants[i].MakeEmpty();
+  #endif
+
+  m_Nodes[0].NextFreeNode = 1;
+  m_FreeNode = 0;
+  m_FreeNodeMax = 0;
+  #ifdef __AUTO_REMOVE
+  m_NumUsedNodes = 0;
+  #else
+  m_SpecialRemoveMode = false;
+  #endif
+  m_SpecialMode = false;
+  return S_OK;
+}
+
+STDMETHODIMP_(void) CPatricia::ReleaseStream()
+{
+  // CLZInWindow::ReleaseStream();
+}
+
+// pos = _pos + kNumHashBytes
+// fullCurrentLimit = currentLimit + kNumHashBytes
+// fullMatchLen = matchLen + kNumHashBytes
+
+void CPatricia::ChangeLastMatch(UInt32 hashValue)
+{
+  UInt32 pos = _pos + kNumHashBytes - 1;
+  UInt32 descendantIndex;
+  const Byte *currentBytePointer = _buffer + pos;
+  UInt32 numLoadedBits = 0;
+  Byte curByte = 0;  // = 0 to disable warning of GCC
+  CNodePointer node = &m_Nodes[m_HashDescendants[hashValue].NodePointer];
+
+  while(true)
+  {
+    UInt32 numSameBits = node->NumSameBits;
+    if(numSameBits > 0)
+    {
+      if (numLoadedBits < numSameBits)
+      {
+        numSameBits -= numLoadedBits;
+        currentBytePointer += (numSameBits / MY_BYTE_SIZE);
+        numSameBits %= MY_BYTE_SIZE;
+        curByte = *currentBytePointer++;
+        numLoadedBits = MY_BYTE_SIZE; 
+      }
+      curByte >>= numSameBits;
+      numLoadedBits -= numSameBits;
+    }
+    if(numLoadedBits == 0)
+    {
+      curByte = *currentBytePointer++;
+      numLoadedBits = MY_BYTE_SIZE; 
+    }
+    descendantIndex = (curByte & kSubNodesMask);
+    node->LastMatch = pos;
+    numLoadedBits -= kNumSubBits;
+    curByte >>= kNumSubBits;
+    if(node->Descendants[descendantIndex].IsNode())
+      node = &m_Nodes[node->Descendants[descendantIndex].NodePointer];
+    else
+      break;
+  }
+  node->Descendants[descendantIndex].MatchPointer = pos + kMatchStartValue;
+}
+
+UInt32 CPatricia::GetLongestMatch(UInt32 *distances)
+{
+  UInt32 fullCurrentLimit;
+  if (_pos + _matchMaxLen <= _streamPos)
+    fullCurrentLimit = _matchMaxLen;
+  else
+  {
+    fullCurrentLimit = _streamPos - _pos;
+    if(fullCurrentLimit < kNumHashBytes)
+      return 0; 
+  }
+  UInt32 pos = _pos + kNumHashBytes;
+
+  #ifdef __HASH_3
+  UInt32 hash2Value = ((UInt32(_buffer[_pos])) << 8) | _buffer[_pos + 1];
+  UInt32 hashValue = (hash2Value << 8) | _buffer[_pos + 2];
+  CDescendant &hash2Descendant = m_Hash2Descendants[hash2Value];
+  CDescendant &hashDescendant = m_HashDescendants[hashValue];
+  if(hash2Descendant.MatchPointer <= kDescendantEmptyValue2)
+  {
+    if(hash2Descendant.MatchPointer == kDescendantsNotInitilized2)
+    {
+      UInt32 base = hashValue & 0xFFFF00;
+      for (UInt32 i = 0; i < 0x100; i++)
+        m_HashDescendants[base + i].MakeEmpty();
+    }
+    hash2Descendant.MatchPointer = pos + kMatchStartValue2;
+    hashDescendant.MatchPointer = pos + kMatchStartValue;
+    return 0;
+  }
+
+  distances[kNumHash2Bytes] = pos - (hash2Descendant.MatchPointer - kMatchStartValue2) - 1;
+  hash2Descendant.MatchPointer = pos + kMatchStartValue2;
+  #ifdef __AUTO_REMOVE
+  if (distances[kNumHash2Bytes] >= _sizeHistory)
+  {
+    if (hashDescendant.IsNode())
+      RemoveNode(hashDescendant.NodePointer);
+    hashDescendant.MatchPointer = pos + kMatchStartValue;
+    return 0;
+  }
+  #endif
+  if (fullCurrentLimit == kNumHash2Bytes)
+    return kNumHash2Bytes;
+
+  #else
+  UInt32 hashValue = UInt32(GetIndexByte(1))  | (UInt32(GetIndexByte(0)) << 8);
+  CDescendant &hashDescendant = m_HashDescendants[hashValue];
+  #endif
+
+
+  if(m_SpecialMode)
+  {
+    if(hashDescendant.IsMatch())
+      m_NumNotChangedCycles = 0;
+    if(m_NumNotChangedCycles >= _sizeHistory - 1)
+    {
+      ChangeLastMatch(hashValue);
+      m_NumNotChangedCycles = 0;
+    }
+    if(GetIndexByte(fullCurrentLimit - 1) == GetIndexByte(fullCurrentLimit - 2)) 
+    {
+      if(hashDescendant.IsMatch())
+        hashDescendant.MatchPointer = pos + kMatchStartValue;
+      else
+        m_NumNotChangedCycles++;
+      for(UInt32 i = kNumHashBytes; i <= fullCurrentLimit; i++)
+        distances[i] = 0;
+      return fullCurrentLimit;
+    }
+    else if(m_NumNotChangedCycles > 0)
+      ChangeLastMatch(hashValue);
+    m_SpecialMode = false;
+  }
+
+  if(hashDescendant.IsEmpty())
+  {
+    hashDescendant.MatchPointer = pos + kMatchStartValue;
+    return kPrevHashSize;
+  }
+
+  UInt32 currentLimit = fullCurrentLimit - kNumHashBytes;
+
+  if(hashDescendant.IsMatch())
+  {
+    CMatchPointer matchPointer = hashDescendant.MatchPointer;
+    UInt32 backReal = pos - (matchPointer - kMatchStartValue);
+    UInt32 back = backReal - 1;
+    #ifdef __AUTO_REMOVE
+    if (back >= _sizeHistory)
+    {
+      hashDescendant.MatchPointer = pos + kMatchStartValue;
+      return kPrevHashSize;
+    }
+    #endif
+
+    UInt32 matchLen;
+    distances += kNumHashBytes;
+    Byte *buffer = _buffer + pos;
+    for(matchLen = 0; true; matchLen++)
+    {
+      *distances++ = back;
+      if (matchLen == currentLimit)
+      {
+        hashDescendant.MatchPointer = pos + kMatchStartValue;
+        return kNumHashBytes + matchLen;
+      }
+      if (buffer[matchLen] != buffer[(size_t)matchLen - backReal])
+        break;
+    }
+     
+    // UInt32 matchLen = GetMatchLen(kNumHashBytes, back, currentLimit);
+    
+    UInt32 fullMatchLen = matchLen + kNumHashBytes; 
+    hashDescendant.NodePointer = m_FreeNode;
+    CNodePointer node = &m_Nodes[m_FreeNode];
+    m_FreeNode = node->NextFreeNode;
+    #ifdef __AUTO_REMOVE
+    m_NumUsedNodes++;
+    #endif
+    if (m_FreeNode > m_FreeNodeMax)
+    {
+      m_FreeNodeMax = m_FreeNode;
+      m_Nodes[m_FreeNode].NextFreeNode = m_FreeNode + 1;
+    }
+      
+    for (UInt32 i = 0; i < kNumSubNodes; i++)
+      node->Descendants[i].NodePointer = kDescendantEmptyValue;
+    node->LastMatch = pos;
+      
+    Byte byteNew = GetIndexByte(fullMatchLen);
+    Byte byteOld = GetIndexByte(fullMatchLen - backReal);
+    Byte bitsNew, bitsOld;
+    UInt32 numSameBits = matchLen * MY_BYTE_SIZE;
+    while (true)
+    {
+      bitsNew = (byteNew & kSubNodesMask);
+      bitsOld = (byteOld & kSubNodesMask);
+      if(bitsNew != bitsOld) 
+        break;
+      byteNew >>= kNumSubBits;
+      byteOld >>= kNumSubBits;
+      numSameBits += kNumSubBits;
+    }
+    node->NumSameBits = CSameBitsType(numSameBits);
+    node->Descendants[bitsNew].MatchPointer = pos + kMatchStartValue;
+    node->Descendants[bitsOld].MatchPointer = matchPointer;
+    return fullMatchLen;
+  }
+  const Byte *baseCurrentBytePointer = _buffer + pos;
+  const Byte *currentBytePointer = baseCurrentBytePointer;
+  UInt32 numLoadedBits = 0;
+  Byte curByte = 0;
+  CIndex *nodePointerPointer = &hashDescendant.NodePointer;
+  CNodePointer node = &m_Nodes[*nodePointerPointer];
+  distances += kNumHashBytes;
+  const Byte *bytePointerLimit = baseCurrentBytePointer + currentLimit;
+  const Byte *currentAddingOffset = _buffer;
+
+  #ifdef __AUTO_REMOVE
+  UInt32 lowPos;
+  if (pos > _sizeHistory)
+    lowPos = pos - _sizeHistory;
+  else
+    lowPos = 0;
+  #endif
+
+  while(true)
+  {
+    #ifdef __AUTO_REMOVE
+    if (node->LastMatch < lowPos)
+    {
+      RemoveNode(*nodePointerPointer);
+      *nodePointerPointer = pos + kMatchStartValue;
+      if (currentBytePointer == baseCurrentBytePointer)
+        return kPrevHashSize;
+      return kNumHashBytes + (UInt32)(currentBytePointer - baseCurrentBytePointer - 1);
+    }
+    #endif
+    if(numLoadedBits == 0)
+    {
+      *distances++ = pos - node->LastMatch - 1;
+      if(currentBytePointer >= bytePointerLimit)
+      {
+        for (UInt32 i = 0; i < kNumSubNodes; i++)
+          node->Descendants[i].MatchPointer = pos + kMatchStartValue;
+        node->LastMatch = pos;
+        node->NumSameBits = 0;
+        return fullCurrentLimit;
+      }
+      curByte = (*currentBytePointer++);
+      currentAddingOffset++;
+      numLoadedBits = MY_BYTE_SIZE; 
+    }
+    UInt32 numSameBits = node->NumSameBits;
+    if(numSameBits > 0)
+    {
+      Byte byteXOR = ((*(currentAddingOffset + node->LastMatch -1)) >> 
+          (MY_BYTE_SIZE - numLoadedBits)) ^ curByte;
+      while(numLoadedBits <= numSameBits)
+      {
+        if(byteXOR != 0)
+        {
+          AddInternalNode(node, nodePointerPointer, curByte, byteXOR,
+              numSameBits, pos);
+          return kNumHashBytes + (UInt32)(currentBytePointer - baseCurrentBytePointer - 1);
+        }
+        *distances++ = pos - node->LastMatch - 1;
+        numSameBits -= numLoadedBits;
+        if(currentBytePointer >= bytePointerLimit)
+        {
+          for (UInt32 i = 0; i < kNumSubNodes; i++)
+            node->Descendants[i].MatchPointer = pos + kMatchStartValue;
+          node->LastMatch = pos;
+          node->NumSameBits = CSameBitsType(node->NumSameBits - numSameBits);
+          return fullCurrentLimit;
+        }
+        numLoadedBits = MY_BYTE_SIZE; 
+        curByte = (*currentBytePointer++);
+        byteXOR = curByte ^ (*(currentAddingOffset + node->LastMatch));
+        currentAddingOffset++;
+      }
+      if((byteXOR & ((1 << numSameBits) - 1)) != 0)
+      {
+        AddInternalNode(node, nodePointerPointer, curByte, byteXOR,
+            numSameBits, pos);
+        return kNumHashBytes + (UInt32)(currentBytePointer - baseCurrentBytePointer - 1);
+      }
+      curByte >>= numSameBits;
+      numLoadedBits -= numSameBits;
+    }
+    UInt32 descendantIndex = (curByte & kSubNodesMask);
+    numLoadedBits -= kNumSubBits;
+    nodePointerPointer = &node->Descendants[descendantIndex].NodePointer;
+    UInt32 nextNodeIndex = *nodePointerPointer;
+    node->LastMatch = pos;
+    if (nextNodeIndex < kDescendantEmptyValue)
+    {
+      curByte >>= kNumSubBits;
+      node = &m_Nodes[nextNodeIndex];
+    }
+    else if (nextNodeIndex == kDescendantEmptyValue)
+    {
+      node->Descendants[descendantIndex].MatchPointer = pos + kMatchStartValue;
+      return kNumHashBytes + (UInt32)(currentBytePointer - baseCurrentBytePointer - 1);
+    }
+    else 
+      break;
+  }
+ 
+  UInt32 descendantIndex = (curByte & kSubNodesMask);
+  curByte >>= kNumSubBits;
+  CMatchPointer matchPointer = node->Descendants[descendantIndex].MatchPointer;
+  CMatchPointer realMatchPointer;
+  realMatchPointer = matchPointer - kMatchStartValue;
+
+  #ifdef __AUTO_REMOVE
+  if (realMatchPointer < lowPos)
+  {
+    node->Descendants[descendantIndex].MatchPointer = pos + kMatchStartValue;
+    return kNumHashBytes + (UInt32)(currentBytePointer - baseCurrentBytePointer - 1);
+  }
+  #endif
+
+  Byte byteXOR;
+  UInt32 numSameBits = 0;
+  if(numLoadedBits != 0)
+  {
+    Byte matchByte = *(currentAddingOffset + realMatchPointer -1);  
+    matchByte >>= (MY_BYTE_SIZE - numLoadedBits);
+    byteXOR = matchByte ^ curByte;
+    if(byteXOR != 0)
+    {
+      AddLeafNode(node, curByte, byteXOR, numSameBits, pos, descendantIndex);
+      return kNumHashBytes + (UInt32)(currentBytePointer - baseCurrentBytePointer - 1);
+    }
+    numSameBits += numLoadedBits;
+  }
+
+  const Byte *matchBytePointer = _buffer + realMatchPointer + 
+      (currentBytePointer - baseCurrentBytePointer);
+  for(; currentBytePointer < bytePointerLimit; numSameBits += MY_BYTE_SIZE)
+  {
+    curByte = (*currentBytePointer++);
+    *distances++ = pos - realMatchPointer - 1;
+    byteXOR = curByte ^ (*matchBytePointer++);
+    if(byteXOR != 0)
+    {
+      AddLeafNode(node, curByte, byteXOR, numSameBits, pos, descendantIndex);
+      return kNumHashBytes + (UInt32)(currentBytePointer - baseCurrentBytePointer - 1);
+    }
+  }
+  *distances = pos - realMatchPointer - 1;
+  node->Descendants[descendantIndex].MatchPointer = pos + kMatchStartValue;
+
+  if(*distances == 0)
+  {
+    m_SpecialMode = true;
+    m_NumNotChangedCycles = 0;
+  }
+  return fullCurrentLimit;
+}
+
+STDMETHODIMP_(void) CPatricia::DummyLongestMatch()
+{
+  GetLongestMatch(m_TmpBacks);
+}
+
+
+// ------------------------------------
+// Remove Match
+
+typedef Byte CRemoveDataWord;
+
+static const int kSizeRemoveDataWordInBits = MY_BYTE_SIZE * sizeof(CRemoveDataWord);
+
+#ifndef __AUTO_REMOVE
+
+void CPatricia::RemoveMatch()
+{
+  if(m_SpecialRemoveMode)
+  {
+    if(GetIndexByte(_matchMaxLen - 1 - _sizeHistory) ==
+        GetIndexByte(_matchMaxLen - _sizeHistory))
+      return;
+    m_SpecialRemoveMode = false;
+  }
+  UInt32 pos = _pos + kNumHashBytes - _sizeHistory;
+
+  #ifdef __HASH_3
+  const Byte *pp = _buffer + _pos - _sizeHistory;
+  UInt32 hash2Value = ((UInt32(pp[0])) << 8) | pp[1];
+  UInt32 hashValue = (hash2Value << 8) | pp[2];
+  CDescendant &hashDescendant = m_HashDescendants[hashValue];
+  CDescendant &hash2Descendant = m_Hash2Descendants[hash2Value];
+  if (hash2Descendant >= kMatchStartValue2)
+    if(hash2Descendant.MatchPointer == pos + kMatchStartValue2)
+      hash2Descendant.MatchPointer = kDescendantEmptyValue2;
+  #else
+  UInt32 hashValue = UInt32(GetIndexByte(1 - _sizeHistory))  | 
+      (UInt32(GetIndexByte(0 - _sizeHistory)) << 8);
+  CDescendant &hashDescendant = m_HashDescendants[hashValue];
+  #endif
+    
+  if(hashDescendant.IsEmpty())
+    return;
+  if(hashDescendant.IsMatch())
+  {
+    if(hashDescendant.MatchPointer == pos + kMatchStartValue)
+      hashDescendant.MakeEmpty();
+    return;
+  }
+  
+  UInt32 descendantIndex;
+  const CRemoveDataWord *currentPointer = (const CRemoveDataWord *)(_buffer + pos);
+  UInt32 numLoadedBits = 0;
+  CRemoveDataWord curWord = 0; // = 0 to disable GCC warning
+
+  CIndex *nodePointerPointer = &hashDescendant.NodePointer;
+
+  CNodePointer node = &m_Nodes[hashDescendant.NodePointer];
+  
+  while(true)
+  {
+    if(numLoadedBits == 0)
+    {
+      curWord = *currentPointer++;
+      numLoadedBits = kSizeRemoveDataWordInBits; 
+    }
+    UInt32 numSameBits = node->NumSameBits;
+    if(numSameBits > 0)
+    {
+      if (numLoadedBits <= numSameBits)
+      {
+        numSameBits -= numLoadedBits;
+        currentPointer += (numSameBits / kSizeRemoveDataWordInBits);
+        numSameBits %= kSizeRemoveDataWordInBits;
+        curWord = *currentPointer++;
+        numLoadedBits = kSizeRemoveDataWordInBits; 
+      }
+      curWord >>= numSameBits;
+      numLoadedBits -= numSameBits;
+    }
+    descendantIndex = (curWord & kSubNodesMask);
+    numLoadedBits -= kNumSubBits;
+    curWord >>= kNumSubBits;
+    UInt32 nextNodeIndex = node->Descendants[descendantIndex].NodePointer;
+    if (nextNodeIndex < kDescendantEmptyValue)
+    {
+      nodePointerPointer = &node->Descendants[descendantIndex].NodePointer;
+      node = &m_Nodes[nextNodeIndex];
+    }
+    else
+      break;
+  }
+  if (node->Descendants[descendantIndex].MatchPointer != pos + kMatchStartValue)
+  {
+    const Byte *currentBytePointer = _buffer + _pos - _sizeHistory;
+    const Byte *currentBytePointerLimit = currentBytePointer + _matchMaxLen;
+    for(;currentBytePointer < currentBytePointerLimit; currentBytePointer++)
+      if(*currentBytePointer != *(currentBytePointer+1))
+        return;
+    m_SpecialRemoveMode = true;
+    return;
+  }
+
+  UInt32 numNodes = 0, numMatches = 0;
+
+  UInt32 i;
+  for (i = 0; i < kNumSubNodes; i++)
+  {
+    UInt32 nodeIndex = node->Descendants[i].NodePointer;
+    if (nodeIndex < kDescendantEmptyValue)
+      numNodes++;
+    else if (nodeIndex > kDescendantEmptyValue)
+      numMatches++;
+  }
+  numMatches -= 1;
+  if (numNodes + numMatches > 1)
+  {
+    node->Descendants[descendantIndex].MakeEmpty();
+    return;
+  }
+  if(numNodes == 1)
+  {
+    UInt32 i;
+    for (i = 0; i < kNumSubNodes; i++)
+      if (node->Descendants[i].IsNode())
+        break;
+    UInt32 nextNodeIndex = node->Descendants[i].NodePointer;
+    CNodePointer nextNode = &m_Nodes[nextNodeIndex];
+    nextNode->NumSameBits += node->NumSameBits + kNumSubBits;
+    *node = *nextNode;
+
+    nextNode->NextFreeNode = m_FreeNode;
+    m_FreeNode = nextNodeIndex;
+    return;
+  }
+  UInt32 matchPointer = 0; // = 0 to disable GCC warning
+  for (i = 0; i < kNumSubNodes; i++)
+    if (node->Descendants[i].IsMatch() && i != descendantIndex)
+    {
+      matchPointer = node->Descendants[i].MatchPointer;
+      break;
+    }
+  node->NextFreeNode = m_FreeNode;
+  m_FreeNode = *nodePointerPointer;
+  *nodePointerPointer = matchPointer;
+}
+#endif
+
+
+// Commented code is more correct, but it gives warning 
+// on GCC: (1 << 32)
+// So we use kMatchStartValue twice:
+// kMatchStartValue = UInt32(1) << (kNumBitsInIndex - 1);
+// must be defined in Pat.h
+/*
+const UInt32 kNormalizeStartPos = (UInt32(1) << (kNumBitsInIndex)) - 
+    kMatchStartValue - kNumHashBytes - 1;
+*/
+const UInt32 kNormalizeStartPos = kMatchStartValue - kNumHashBytes - 1;
+
+STDMETHODIMP CPatricia::MovePos()
+{
+  #ifndef __AUTO_REMOVE
+  if(_pos >= _sizeHistory)
+    RemoveMatch();
+  #endif
+  RINOK(CLZInWindow::MovePos());
+  #ifdef __AUTO_REMOVE
+  if (m_NumUsedNodes >= m_NumNodes)
+    TestRemoveNodes();
+  #endif
+  if (_pos >= kNormalizeStartPos)
+  {
+    #ifdef __AUTO_REMOVE
+    TestRemoveNodesAndNormalize();
+    #else
+    Normalize();
+    #endif
+  }
+  return S_OK;
+}
+
+#ifndef __AUTO_REMOVE
+
+void CPatricia::NormalizeDescendant(CDescendant &descendant, UInt32 subValue)
+{
+  if (descendant.IsEmpty())
+    return;
+  if (descendant.IsMatch())
+    descendant.MatchPointer = descendant.MatchPointer - subValue;
+  else
+  {
+    CNode &node = m_Nodes[descendant.NodePointer];
+    node.LastMatch = node.LastMatch - subValue;
+    for (UInt32 i = 0; i < kNumSubNodes; i++)
+       NormalizeDescendant(node.Descendants[i], subValue);
+  }
+}
+
+void CPatricia::Normalize()
+{
+  UInt32 subValue = _pos - _sizeHistory;
+  CLZInWindow::ReduceOffsets(subValue);
+  
+  #ifdef __HASH_3
+
+  for(UInt32 hash = 0; hash < kHash2Size; hash++)
+  {
+    CDescendant &descendant = m_Hash2Descendants[hash];
+    if (descendant.MatchPointer != kDescendantsNotInitilized2)
+    {
+      UInt32 base = hash << 8;
+      for (UInt32 i = 0; i < 0x100; i++)
+        NormalizeDescendant(m_HashDescendants[base + i], subValue);
+    }
+    if (descendant.MatchPointer < kMatchStartValue2)
+      continue;
+    descendant.MatchPointer = descendant.MatchPointer - subValue;
+  }
+  
+  #else
+  
+  for(UInt32 hash = 0; hash < kHashSize; hash++)
+    NormalizeDescendant(m_HashDescendants[hash], subValue);
+  
+  #endif
+
+}
+
+#else
+
+void CPatricia::TestRemoveDescendant(CDescendant &descendant, UInt32 limitPos)
+{
+  CNode &node = m_Nodes[descendant.NodePointer];
+  UInt32 numChilds = 0;
+  UInt32 childIndex = 0; // = 0 to disable GCC warning
+  for (UInt32 i = 0; i < kNumSubNodes; i++)
+  {
+    CDescendant &descendant2 = node.Descendants[i];
+    if (descendant2.IsEmpty())
+      continue;
+    if (descendant2.IsMatch())
+    {
+      if (descendant2.MatchPointer < limitPos)
+        descendant2.MakeEmpty();
+      else
+      {
+        numChilds++;
+        childIndex = i;
+      }
+    }
+    else
+    {
+      TestRemoveDescendant(descendant2, limitPos);
+      if (!descendant2.IsEmpty())
+      {
+        numChilds++;
+        childIndex = i;
+      }
+    }
+  }
+  if (numChilds > 1)
+    return;
+
+  CIndex nodePointerTemp = descendant.NodePointer;
+  if (numChilds == 1)
+  {
+    const CDescendant &descendant2 = node.Descendants[childIndex];
+    if (descendant2.IsNode())
+      m_Nodes[descendant2.NodePointer].NumSameBits += node.NumSameBits + kNumSubBits;
+    descendant = descendant2;
+  }
+  else
+    descendant.MakeEmpty();
+  node.NextFreeNode = m_FreeNode;
+  m_FreeNode = nodePointerTemp;
+  m_NumUsedNodes--;
+}
+
+void CPatricia::RemoveNode(UInt32 index)
+{
+  CNode &node = m_Nodes[index];
+  for (UInt32 i = 0; i < kNumSubNodes; i++)
+  {
+    CDescendant &descendant2 = node.Descendants[i];
+    if (descendant2.IsNode())
+      RemoveNode(descendant2.NodePointer);
+  }
+  node.NextFreeNode = m_FreeNode;
+  m_FreeNode = index;
+  m_NumUsedNodes--;
+}
+
+void CPatricia::TestRemoveNodes()
+{
+  UInt32 limitPos = kMatchStartValue + _pos - _sizeHistory + kNumHashBytes;
+  
+  #ifdef __HASH_3
+  
+  UInt32 limitPos2 = kMatchStartValue2 + _pos - _sizeHistory + kNumHashBytes;
+  for(UInt32 hash = 0; hash < kHash2Size; hash++)
+  {
+    CDescendant &descendant = m_Hash2Descendants[hash];
+    if (descendant.MatchPointer != kDescendantsNotInitilized2)
+    {
+      UInt32 base = hash << 8;
+      for (UInt32 i = 0; i < 0x100; i++)
+      {
+        CDescendant &descendant = m_HashDescendants[base + i];
+        if (descendant.IsEmpty())
+          continue;
+        if (descendant.IsMatch())
+        {
+          if (descendant.MatchPointer < limitPos)
+            descendant.MakeEmpty();
+        }
+        else
+          TestRemoveDescendant(descendant, limitPos);
+      }
+    }
+    if (descendant.MatchPointer < kMatchStartValue2)
+      continue;
+    if (descendant.MatchPointer < limitPos2)
+      descendant.MatchPointer = kDescendantEmptyValue2;
+  }
+  
+  #else
+  
+  for(UInt32 hash = 0; hash < kHashSize; hash++)
+  {
+    CDescendant &descendant = m_HashDescendants[hash];
+    if (descendant.IsEmpty())
+      continue;
+    if (descendant.IsMatch())
+    {
+      if (descendant.MatchPointer < limitPos)
+        descendant.MakeEmpty();
+    }
+    else
+      TestRemoveDescendant(descendant, limitPos);
+  }
+  
+  #endif
+}
+
+void CPatricia::TestRemoveAndNormalizeDescendant(CDescendant &descendant, 
+    UInt32 limitPos, UInt32 subValue)
+{
+  if (descendant.IsEmpty())
+    return;
+  if (descendant.IsMatch())
+  {
+    if (descendant.MatchPointer < limitPos)
+      descendant.MakeEmpty();
+    else
+      descendant.MatchPointer = descendant.MatchPointer - subValue;
+    return;
+  }
+  CNode &node = m_Nodes[descendant.NodePointer];
+  UInt32 numChilds = 0;
+  UInt32 childIndex = 0; // = 0 to disable GCC warning
+  for (UInt32 i = 0; i < kNumSubNodes; i++)
+  {
+    CDescendant &descendant2 = node.Descendants[i];
+    TestRemoveAndNormalizeDescendant(descendant2, limitPos, subValue);
+    if (!descendant2.IsEmpty())
+    {
+      numChilds++;
+      childIndex = i;
+    }
+  }
+  if (numChilds > 1)
+  {
+    node.LastMatch = node.LastMatch - subValue;
+    return;
+  }
+
+  CIndex nodePointerTemp = descendant.NodePointer;
+  if (numChilds == 1)
+  {
+    const CDescendant &descendant2 = node.Descendants[childIndex];
+    if (descendant2.IsNode())
+      m_Nodes[descendant2.NodePointer].NumSameBits += node.NumSameBits + kNumSubBits;
+    descendant = descendant2;
+  }
+  else
+    descendant.MakeEmpty();
+  node.NextFreeNode = m_FreeNode;
+  m_FreeNode = nodePointerTemp;
+  m_NumUsedNodes--;
+}
+
+void CPatricia::TestRemoveNodesAndNormalize()
+{
+  UInt32 subValue = _pos - _sizeHistory;
+  UInt32 limitPos = kMatchStartValue + _pos - _sizeHistory + kNumHashBytes;
+  CLZInWindow::ReduceOffsets(subValue);
+
+  #ifdef __HASH_3
+  
+  UInt32 limitPos2 = kMatchStartValue2 + _pos - _sizeHistory + kNumHashBytes;
+  for(UInt32 hash = 0; hash < kHash2Size; hash++)
+  {
+    CDescendant &descendant = m_Hash2Descendants[hash];
+    if (descendant.MatchPointer != kDescendantsNotInitilized2)
+    {
+      UInt32 base = hash << 8;
+      for (UInt32 i = 0; i < 0x100; i++)
+        TestRemoveAndNormalizeDescendant(m_HashDescendants[base + i], limitPos, subValue);
+    }
+    if (descendant.MatchPointer < kMatchStartValue2)
+      continue;
+    if (descendant.MatchPointer < limitPos2)
+      descendant.MatchPointer = kDescendantEmptyValue2;
+    else
+      descendant.MatchPointer = descendant.MatchPointer - subValue;
+  }
+  
+  #else
+
+  for(UInt32 hash = 0; hash < kHashSize; hash++)
+    TestRemoveAndNormalizeDescendant(m_HashDescendants[hash], limitPos, subValue);
+
+  #endif
+}
+
+#endif
+
+STDMETHODIMP_(Byte) CPatricia::GetIndexByte(Int32 index)
+{
+  return CLZInWindow::GetIndexByte(index);
+}
+
+STDMETHODIMP_(UInt32) CPatricia::GetMatchLen(Int32 index, UInt32 back, UInt32 limit)
+{
+  return CLZInWindow::GetMatchLen(index, back, limit);
+}
+
+STDMETHODIMP_(UInt32) CPatricia::GetNumAvailableBytes()
+{
+  return CLZInWindow::GetNumAvailableBytes();
+}
+
+STDMETHODIMP_(const Byte *) CPatricia::GetPointerToCurrentPos()
+{
+  return CLZInWindow::GetPointerToCurrentPos();
+}
+
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/StdAfx.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/StdAfx.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZ/StdAfx.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZ/StdAfx.h	2022-01-01 15:08:47.889171448 +0800
@@ -0,0 +1,6 @@
+// StdAfx.h
+
+#ifndef __STDAFX_H
+#define __STDAFX_H
+
+#endif 
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMADecoder.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMADecoder.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMADecoder.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMADecoder.cpp	2022-01-01 15:08:47.889171448 +0800
@@ -0,0 +1,342 @@
+// LZMADecoder.cpp
+
+#include "StdAfx.h"
+
+#include "LZMADecoder.h"
+#include "../../../Common/Defs.h"
+
+namespace NCompress {
+namespace NLZMA {
+
+const int kLenIdFinished = -1;
+const int kLenIdNeedInit = -2;
+
+void CDecoder::Init()
+{
+  { 
+    for(int i = 0; i < kNumStates; i++)
+    {
+      for (UInt32 j = 0; j <= _posStateMask; j++)
+      {
+        _isMatch[i][j].Init();
+        _isRep0Long[i][j].Init();
+      }
+      _isRep[i].Init();
+      _isRepG0[i].Init();
+      _isRepG1[i].Init();
+      _isRepG2[i].Init();
+    }
+  }
+  { 
+    for (UInt32 i = 0; i < kNumLenToPosStates; i++)
+    _posSlotDecoder[i].Init();
+  }
+  { 
+    for(UInt32 i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
+      _posDecoders[i].Init();
+  }
+  _posAlignDecoder.Init();
+  _lenDecoder.Init(_posStateMask + 1);
+  _repMatchLenDecoder.Init(_posStateMask + 1);
+  _literalDecoder.Init();
+
+  _state.Init();
+  _reps[0] = _reps[1] = _reps[2] = _reps[3] = 0;
+}
+
+HRESULT CDecoder::CodeSpec(UInt32 curSize)
+{
+  if (_outSizeDefined)
+  {
+    const UInt64 rem = _outSize - _outWindowStream.GetProcessedSize();
+    if (curSize > rem)
+      curSize = (UInt32)rem;
+  }
+
+  if (_remainLen == kLenIdFinished)
+    return S_OK;
+  if (_remainLen == kLenIdNeedInit)
+  {
+    _rangeDecoder.Init();
+    Init();
+    _remainLen = 0;
+  }
+  if (curSize == 0)
+    return S_OK;
+
+  UInt32 rep0 = _reps[0];
+  UInt32 rep1 = _reps[1];
+  UInt32 rep2 = _reps[2];
+  UInt32 rep3 = _reps[3];
+  CState state = _state;
+  Byte previousByte;
+
+  while(_remainLen > 0 && curSize > 0)
+  {
+    previousByte = _outWindowStream.GetByte(rep0);
+    _outWindowStream.PutByte(previousByte);
+    _remainLen--;
+    curSize--;
+  }
+  UInt64 nowPos64 = _outWindowStream.GetProcessedSize();
+  if (nowPos64 == 0)
+    previousByte = 0;
+  else
+    previousByte = _outWindowStream.GetByte(0);
+
+  while(curSize > 0)
+  {
+    {
+      #ifdef _NO_EXCEPTIONS
+      if (_rangeDecoder.Stream.ErrorCode != S_OK)
+        return _rangeDecoder.Stream.ErrorCode;
+      #endif
+      if (_rangeDecoder.Stream.WasFinished())
+        return S_FALSE;
+      UInt32 posState = UInt32(nowPos64) & _posStateMask;
+      if (_isMatch[state.Index][posState].Decode(&_rangeDecoder) == 0)
+      {
+        if(!state.IsCharState())
+          previousByte = _literalDecoder.DecodeWithMatchByte(&_rangeDecoder, 
+              (UInt32)nowPos64, previousByte, _outWindowStream.GetByte(rep0));
+        else
+          previousByte = _literalDecoder.DecodeNormal(&_rangeDecoder, 
+              (UInt32)nowPos64, previousByte);
+        _outWindowStream.PutByte(previousByte);
+        state.UpdateChar();
+        curSize--;
+        nowPos64++;
+      }
+      else             
+      {
+        UInt32 len;
+        if(_isRep[state.Index].Decode(&_rangeDecoder) == 1)
+        {
+          len = 0;
+          if(_isRepG0[state.Index].Decode(&_rangeDecoder) == 0)
+          {
+            if(_isRep0Long[state.Index][posState].Decode(&_rangeDecoder) == 0)
+            {
+              state.UpdateShortRep();
+              len = 1;
+            }
+          }
+          else
+          {
+            UInt32 distance;
+            if(_isRepG1[state.Index].Decode(&_rangeDecoder) == 0)
+              distance = rep1;
+            else 
+            {
+              if (_isRepG2[state.Index].Decode(&_rangeDecoder) == 0)
+                distance = rep2;
+              else
+              {
+                distance = rep3;
+                rep3 = rep2;
+              }
+              rep2 = rep1;
+            }
+            rep1 = rep0;
+            rep0 = distance;
+          }
+          if (len == 0)
+          {
+            len = _repMatchLenDecoder.Decode(&_rangeDecoder, posState) + kMatchMinLen;
+            state.UpdateRep();
+          }
+        }
+        else
+        {
+          rep3 = rep2;
+          rep2 = rep1;
+          rep1 = rep0;
+          len = kMatchMinLen + _lenDecoder.Decode(&_rangeDecoder, posState);
+          state.UpdateMatch();
+          UInt32 posSlot = _posSlotDecoder[GetLenToPosState(len)].Decode(&_rangeDecoder);
+          if (posSlot >= kStartPosModelIndex)
+          {
+            UInt32 numDirectBits = (posSlot >> 1) - 1;
+            rep0 = ((2 | (posSlot & 1)) << numDirectBits);
+
+            if (posSlot < kEndPosModelIndex)
+              rep0 += NRangeCoder::ReverseBitTreeDecode(_posDecoders + 
+                  rep0 - posSlot - 1, &_rangeDecoder, numDirectBits);
+            else
+            {
+              rep0 += (_rangeDecoder.DecodeDirectBits(
+                  numDirectBits - kNumAlignBits) << kNumAlignBits);
+              rep0 += _posAlignDecoder.ReverseDecode(&_rangeDecoder);
+              if (rep0 == 0xFFFFFFFF)
+              {
+                _remainLen = kLenIdFinished;
+                return S_OK;
+              }
+            }
+          }
+          else
+            rep0 = posSlot;
+        }
+        UInt32 locLen = len;
+        if (len > curSize)
+          locLen = (UInt32)curSize;
+        if (!_outWindowStream.CopyBlock(rep0, locLen))
+          return S_FALSE;
+        previousByte = _outWindowStream.GetByte(0);
+        curSize -= locLen;
+        nowPos64 += locLen;
+        len -= locLen;
+        if (len != 0)
+        {
+          _remainLen = (Int32)len;
+          break;
+        }
+
+        #ifdef _NO_EXCEPTIONS
+        if (_outWindowStream.ErrorCode != S_OK)
+          return _outWindowStream.ErrorCode;
+        #endif
+      }
+    }
+  }
+  if (_rangeDecoder.Stream.WasFinished())
+    return S_FALSE;
+  _reps[0] = rep0;
+  _reps[1] = rep1;
+  _reps[2] = rep2;
+  _reps[3] = rep3;
+  _state = state;
+
+  return S_OK;
+}
+
+STDMETHODIMP CDecoder::CodeReal(ISequentialInStream *inStream,
+    ISequentialOutStream *outStream, 
+    const UInt64 *, const UInt64 *outSize,
+    ICompressProgressInfo *progress)
+{
+  SetInStream(inStream);
+  _outWindowStream.SetStream(outStream);
+  SetOutStreamSize(outSize);
+  CDecoderFlusher flusher(this);
+
+  while (true)
+  {
+    UInt32 curSize = 1 << 18;
+    RINOK(CodeSpec(curSize));
+    if (_remainLen == kLenIdFinished)
+      break;
+    if (progress != NULL)
+    {
+      UInt64 inSize = _rangeDecoder.GetProcessedSize();
+      UInt64 nowPos64 = _outWindowStream.GetProcessedSize();
+      RINOK(progress->SetRatioInfo(&inSize, &nowPos64));
+    }
+    if (_outSizeDefined)
+      if (_outWindowStream.GetProcessedSize() >= _outSize)
+        break;
+  } 
+  flusher.NeedFlush = false;
+  return Flush();
+}
+
+
+#ifdef _NO_EXCEPTIONS
+
+#define LZMA_TRY_BEGIN
+#define LZMA_TRY_END
+
+#else
+
+#define LZMA_TRY_BEGIN try { 
+#define LZMA_TRY_END } \
+  catch(const CInBufferException &e)  { return e.ErrorCode; } \
+  catch(const CLZOutWindowException &e)  { return e.ErrorCode; } \
+  catch(...) { return S_FALSE; }
+
+#endif
+
+
+STDMETHODIMP CDecoder::Code(ISequentialInStream *inStream,
+      ISequentialOutStream *outStream, const UInt64 *inSize, const UInt64 *outSize,
+      ICompressProgressInfo *progress)
+{
+  LZMA_TRY_BEGIN
+  return CodeReal(inStream, outStream, inSize, outSize, progress); 
+  LZMA_TRY_END
+}
+
+STDMETHODIMP CDecoder::SetDecoderProperties2(const Byte *properties, UInt32 size)
+{
+  if (size < 5)
+    return E_INVALIDARG;
+  int lc = properties[0] % 9;
+  Byte remainder = (Byte)(properties[0] / 9);
+  int lp = remainder % 5;
+  int pb = remainder / 5;
+  UInt32 dictionarySize = 0;
+  for (int i = 0; i < 4; i++)
+    dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
+  return SetDecoderPropertiesRaw(lc, lp, pb, dictionarySize);
+}
+
+STDMETHODIMP CDecoder::SetDecoderPropertiesRaw(int lc, int lp, int pb, UInt32 dictionarySize)
+{
+  if (pb > NLength::kNumPosStatesBitsMax)
+    return E_INVALIDARG;
+  _posStateMask = (1 << pb) - 1;
+  if (!_outWindowStream.Create(dictionarySize))
+    return E_OUTOFMEMORY;
+  if (!_literalDecoder.Create(lp, lc))
+    return E_OUTOFMEMORY;
+  if (!_rangeDecoder.Create(1 << 20))
+    return E_OUTOFMEMORY;
+  return S_OK;
+}
+
+STDMETHODIMP CDecoder::GetInStreamProcessedSize(UInt64 *value)
+{
+  *value = _rangeDecoder.GetProcessedSize();
+  return S_OK;
+}
+
+STDMETHODIMP CDecoder::SetInStream(ISequentialInStream *inStream)
+{
+  _rangeDecoder.SetStream(inStream);
+  return S_OK;
+}
+
+STDMETHODIMP CDecoder::ReleaseInStream()
+{
+  _rangeDecoder.ReleaseStream();
+  return S_OK;
+}
+
+STDMETHODIMP CDecoder::SetOutStreamSize(const UInt64 *outSize)
+{
+  if ((_outSizeDefined = (outSize != NULL)))
+    _outSize = *outSize;
+  _remainLen = kLenIdNeedInit;
+  _outWindowStream.Init();
+  return S_OK;
+}
+
+#ifdef _ST_MODE
+
+STDMETHODIMP CDecoder::Read(void *data, UInt32 size, UInt32 *processedSize)
+{
+  LZMA_TRY_BEGIN
+  if (processedSize)
+    *processedSize = 0;
+  const UInt64 startPos = _outWindowStream.GetProcessedSize();
+  _outWindowStream.SetMemStream((Byte *)data);
+  RINOK(CodeSpec(size));
+  if (processedSize)
+    *processedSize = (UInt32)(_outWindowStream.GetProcessedSize() - startPos);
+  return Flush();
+  LZMA_TRY_END
+}
+
+#endif
+
+}}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMADecoder.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMADecoder.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMADecoder.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMADecoder.h	2022-01-01 15:08:47.889171448 +0800
@@ -0,0 +1,249 @@
+// LZMA/Decoder.h
+
+#ifndef __LZMA_DECODER_H
+#define __LZMA_DECODER_H
+
+#include "../../../Common/MyCom.h"
+#include "../../../Common/Alloc.h"
+#include "../../ICoder.h"
+#include "../LZ/LZOutWindow.h"
+#include "../RangeCoder/RangeCoderBitTree.h"
+
+#include "LZMA.h"
+
+namespace NCompress {
+namespace NLZMA {
+
+typedef NRangeCoder::CBitDecoder<kNumMoveBits> CMyBitDecoder;
+
+class CLiteralDecoder2
+{
+  CMyBitDecoder _decoders[0x300];
+public:
+  void Init()
+  {
+    for (int i = 0; i < 0x300; i++)
+      _decoders[i].Init();
+  }
+  Byte DecodeNormal(NRangeCoder::CDecoder *rangeDecoder)
+  {
+    UInt32 symbol = 1;
+    RC_INIT_VAR
+    do
+    {
+      // symbol = (symbol << 1) | _decoders[0][symbol].Decode(rangeDecoder);
+      RC_GETBIT(kNumMoveBits, _decoders[symbol].Prob, symbol)
+    }
+    while (symbol < 0x100);
+    RC_FLUSH_VAR
+    return (Byte)symbol;
+  }
+  Byte DecodeWithMatchByte(NRangeCoder::CDecoder *rangeDecoder, Byte matchByte)
+  {
+    UInt32 symbol = 1;
+    RC_INIT_VAR
+    do
+    {
+      UInt32 matchBit = (matchByte >> 7) & 1;
+      matchByte <<= 1;
+      // UInt32 bit = _decoders[1 + matchBit][symbol].Decode(rangeDecoder);
+      // symbol = (symbol << 1) | bit;
+      UInt32 bit;
+      RC_GETBIT2(kNumMoveBits, _decoders[0x100 + (matchBit << 8) + symbol].Prob, symbol, 
+          bit = 0, bit = 1)
+      if (matchBit != bit)
+      {
+        while (symbol < 0x100)
+        {
+          // symbol = (symbol << 1) | _decoders[0][symbol].Decode(rangeDecoder);
+          RC_GETBIT(kNumMoveBits, _decoders[symbol].Prob, symbol)
+        }
+        break;
+      }
+    }
+    while (symbol < 0x100);
+    RC_FLUSH_VAR
+    return (Byte)symbol;
+  }
+};
+
+class CLiteralDecoder
+{
+  CLiteralDecoder2 *_coders;
+  int _numPrevBits;
+  int _numPosBits;
+  UInt32 _posMask;
+public:
+  CLiteralDecoder(): _coders(0) {}
+  ~CLiteralDecoder()  { Free(); }
+  void Free()
+  { 
+    MyFree(_coders);
+    _coders = 0;
+  }
+  bool Create(int numPosBits, int numPrevBits)
+  {
+    if (_coders == 0 || (numPosBits + numPrevBits) != 
+        (_numPrevBits + _numPosBits) )
+    {
+      Free();
+      UInt32 numStates = 1 << (numPosBits + numPrevBits);
+      _coders = (CLiteralDecoder2 *)MyAlloc(numStates * sizeof(CLiteralDecoder2));
+    }
+    _numPosBits = numPosBits;
+    _posMask = (1 << numPosBits) - 1;
+    _numPrevBits = numPrevBits;
+    return (_coders != 0);
+  }
+  void Init()
+  {
+    UInt32 numStates = 1 << (_numPrevBits + _numPosBits);
+    for (UInt32 i = 0; i < numStates; i++)
+      _coders[i].Init();
+  }
+  UInt32 GetState(UInt32 pos, Byte prevByte) const
+    { return ((pos & _posMask) << _numPrevBits) + (prevByte >> (8 - _numPrevBits)); }
+  Byte DecodeNormal(NRangeCoder::CDecoder *rangeDecoder, UInt32 pos, Byte prevByte)
+    { return _coders[GetState(pos, prevByte)].DecodeNormal(rangeDecoder); }
+  Byte DecodeWithMatchByte(NRangeCoder::CDecoder *rangeDecoder, UInt32 pos, Byte prevByte, Byte matchByte)
+    { return _coders[GetState(pos, prevByte)].DecodeWithMatchByte(rangeDecoder, matchByte); }
+};
+
+namespace NLength {
+
+class CDecoder
+{
+  CMyBitDecoder _choice;
+  CMyBitDecoder _choice2;
+  NRangeCoder::CBitTreeDecoder<kNumMoveBits, kNumLowBits>  _lowCoder[kNumPosStatesMax];
+  NRangeCoder::CBitTreeDecoder<kNumMoveBits, kNumMidBits>  _midCoder[kNumPosStatesMax];
+  NRangeCoder::CBitTreeDecoder<kNumMoveBits, kNumHighBits> _highCoder; 
+public:
+  void Init(UInt32 numPosStates)
+  {
+    _choice.Init();
+    _choice2.Init();
+    for (UInt32 posState = 0; posState < numPosStates; posState++)
+    {
+      _lowCoder[posState].Init();
+      _midCoder[posState].Init();
+    }
+    _highCoder.Init();
+  }
+  UInt32 Decode(NRangeCoder::CDecoder *rangeDecoder, UInt32 posState)
+  {
+    if(_choice.Decode(rangeDecoder) == 0)
+      return _lowCoder[posState].Decode(rangeDecoder);
+    if(_choice2.Decode(rangeDecoder) == 0)
+      return kNumLowSymbols + _midCoder[posState].Decode(rangeDecoder);
+    return kNumLowSymbols + kNumMidSymbols + _highCoder.Decode(rangeDecoder);
+  }
+};
+
+}
+
+class CDecoder: 
+  public ICompressCoder,
+  public ICompressSetDecoderProperties2,
+  #ifdef _ST_MODE
+  public ICompressSetInStream,
+  public ICompressSetOutStreamSize,
+  public ISequentialInStream,
+  #endif
+  public CMyUnknownImp
+{
+  CLZOutWindow _outWindowStream;
+  NRangeCoder::CDecoder _rangeDecoder;
+
+  CMyBitDecoder _isMatch[kNumStates][NLength::kNumPosStatesMax];
+  CMyBitDecoder _isRep[kNumStates];
+  CMyBitDecoder _isRepG0[kNumStates];
+  CMyBitDecoder _isRepG1[kNumStates];
+  CMyBitDecoder _isRepG2[kNumStates];
+  CMyBitDecoder _isRep0Long[kNumStates][NLength::kNumPosStatesMax];
+
+  NRangeCoder::CBitTreeDecoder<kNumMoveBits, kNumPosSlotBits> _posSlotDecoder[kNumLenToPosStates];
+
+  CMyBitDecoder _posDecoders[kNumFullDistances - kEndPosModelIndex];
+  NRangeCoder::CBitTreeDecoder<kNumMoveBits, kNumAlignBits> _posAlignDecoder;
+  
+  NLength::CDecoder _lenDecoder;
+  NLength::CDecoder _repMatchLenDecoder;
+
+  CLiteralDecoder _literalDecoder;
+
+  UInt32 _posStateMask;
+
+  ///////////////////
+  // State
+  UInt32 _reps[4];
+  CState _state;
+  Int32 _remainLen; // -1 means end of stream. // -2 means need Init
+  UInt64 _outSize;
+  bool _outSizeDefined;
+
+  void Init();
+  HRESULT CodeSpec(UInt32 size);
+public:
+
+  #ifdef _ST_MODE
+  MY_UNKNOWN_IMP4(
+      ICompressSetDecoderProperties2, 
+      ICompressSetInStream, 
+      ICompressSetOutStreamSize, 
+      ISequentialInStream)
+  #else
+  MY_UNKNOWN_IMP1(
+      ICompressSetDecoderProperties2)
+  #endif
+
+  void ReleaseStreams()
+  {
+    _outWindowStream.ReleaseStream();
+    ReleaseInStream();
+  }
+
+  class CDecoderFlusher
+  {
+    CDecoder *_decoder;
+  public:
+    bool NeedFlush;
+    CDecoderFlusher(CDecoder *decoder): _decoder(decoder), NeedFlush(true) {}
+    ~CDecoderFlusher() 
+    { 
+      if (NeedFlush)
+        _decoder->Flush();
+      _decoder->ReleaseStreams(); 
+    }
+  };
+
+  HRESULT Flush() {  return _outWindowStream.Flush(); }  
+
+  STDMETHOD(CodeReal)(ISequentialInStream *inStream,
+      ISequentialOutStream *outStream, const UInt64 *inSize, const UInt64 *outSize,
+      ICompressProgressInfo *progress);
+  
+  STDMETHOD(Code)(ISequentialInStream *inStream,
+      ISequentialOutStream *outStream, const UInt64 *inSize, const UInt64 *outSize,
+      ICompressProgressInfo *progress);
+
+  STDMETHOD(SetDecoderProperties2)(const Byte *data, UInt32 size);
+  STDMETHOD(SetDecoderPropertiesRaw)(int lc, int lp, int pb, UInt32 dictionarySize);
+
+  STDMETHOD(GetInStreamProcessedSize)(UInt64 *value);
+
+  STDMETHOD(SetInStream)(ISequentialInStream *inStream);
+  STDMETHOD(ReleaseInStream)();
+  STDMETHOD(SetOutStreamSize)(const UInt64 *outSize);
+
+  #ifdef _ST_MODE
+  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
+  #endif
+
+  CDecoder(): _outSizeDefined(false) {}
+  virtual ~CDecoder() {}
+};
+
+}}
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMAEncoder.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMAEncoder.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMAEncoder.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMAEncoder.cpp	2022-01-01 15:08:47.889171448 +0800
@@ -0,0 +1,1504 @@
+// LZMA/Encoder.cpp
+
+#include "StdAfx.h"
+
+#include "../../../Common/Defs.h"
+#include "../../Common/StreamUtils.h"
+
+#include "LZMAEncoder.h"
+
+// for minimal compressing code size define these:
+// #define COMPRESS_MF_BT
+// #define COMPRESS_MF_BT4
+
+#if !defined(COMPRESS_MF_BT) && !defined(COMPRESS_MF_PAT) && !defined(COMPRESS_MF_HC)
+#define COMPRESS_MF_BT
+#define COMPRESS_MF_PAT
+#define COMPRESS_MF_HC
+#endif
+
+#ifdef COMPRESS_MF_BT
+#if !defined(COMPRESS_MF_BT2) && !defined(COMPRESS_MF_BT3) && !defined(COMPRESS_MF_BT4) && !defined(COMPRESS_MF_BT4B)
+#define COMPRESS_MF_BT2
+#define COMPRESS_MF_BT3
+#define COMPRESS_MF_BT4
+#define COMPRESS_MF_BT4B
+#endif
+#ifdef COMPRESS_MF_BT2
+#include "../LZ/BinTree/BinTree2.h"
+#endif
+#ifdef COMPRESS_MF_BT3
+#include "../LZ/BinTree/BinTree3.h"
+#endif
+#ifdef COMPRESS_MF_BT4
+#include "../LZ/BinTree/BinTree4.h"
+#endif
+#ifdef COMPRESS_MF_BT4B
+#include "../LZ/BinTree/BinTree4b.h"
+#endif
+#endif
+
+#ifdef COMPRESS_MF_PAT
+#include "../LZ/Patricia/Pat2.h"
+#include "../LZ/Patricia/Pat2H.h"
+#include "../LZ/Patricia/Pat3H.h"
+#include "../LZ/Patricia/Pat4H.h"
+#include "../LZ/Patricia/Pat2R.h"
+#endif
+
+#ifdef COMPRESS_MF_HC
+#include "../LZ/HashChain/HC3.h"
+#include "../LZ/HashChain/HC4.h"
+#endif
+
+#ifdef COMPRESS_MF_MT
+#include "../LZ/MT/MT.h"
+#endif
+
+namespace NCompress {
+namespace NLZMA {
+
+const int kDefaultDictionaryLogSize = 20;
+const UInt32 kNumFastBytesDefault = 0x20;
+
+enum 
+{
+  kBT2,
+  kBT3,
+  kBT4,
+  kBT4B,
+  kPat2,
+  kPat2H,
+  kPat3H,
+  kPat4H,
+  kPat2R,
+  kHC3,
+  kHC4
+};
+
+static const wchar_t *kMatchFinderIDs[] = 
+{
+  L"BT2",
+  L"BT3",
+  L"BT4",
+  L"BT4B",
+  L"PAT2",
+  L"PAT2H",
+  L"PAT3H",
+  L"PAT4H",
+  L"PAT2R",
+  L"HC3",
+  L"HC4"
+};
+
+Byte g_FastPos[1024];
+
+class CFastPosInit
+{
+public:
+  CFastPosInit() { Init(); }
+  void Init()
+  {
+    const Byte kFastSlots = 20;
+    int c = 2;
+    g_FastPos[0] = 0;
+    g_FastPos[1] = 1;
+
+    for (Byte slotFast = 2; slotFast < kFastSlots; slotFast++)
+    {
+      UInt32 k = (1 << ((slotFast >> 1) - 1));
+      for (UInt32 j = 0; j < k; j++, c++)
+        g_FastPos[c] = slotFast;
+    }
+  }
+} g_FastPosInit;
+
+
+void CLiteralEncoder2::Encode(NRangeCoder::CEncoder *rangeEncoder, Byte symbol)
+{
+  UInt32 context = 1;
+  int i = 8;
+  do 
+  {
+    i--;
+    UInt32 bit = (symbol >> i) & 1;
+    _encoders[context].Encode(rangeEncoder, bit);
+    context = (context << 1) | bit;
+  }
+  while(i != 0);
+}
+
+void CLiteralEncoder2::EncodeMatched(NRangeCoder::CEncoder *rangeEncoder, 
+    Byte matchByte, Byte symbol)
+{
+  UInt32 context = 1;
+  int i = 8;
+  do 
+  {
+    i--;
+    UInt32 bit = (symbol >> i) & 1;
+    UInt32 matchBit = (matchByte >> i) & 1;
+    _encoders[0x100 + (matchBit << 8) + context].Encode(rangeEncoder, bit);
+    context = (context << 1) | bit;
+    if (matchBit != bit)
+    {
+      while(i != 0)
+      {
+        i--;
+        UInt32 bit = (symbol >> i) & 1;
+        _encoders[context].Encode(rangeEncoder, bit);
+        context = (context << 1) | bit;
+      }
+      break;
+    }
+  }
+  while(i != 0);
+}
+
+UInt32 CLiteralEncoder2::GetPrice(bool matchMode, Byte matchByte, Byte symbol) const
+{
+  UInt32 price = 0;
+  UInt32 context = 1;
+  int i = 8;
+  if (matchMode)
+  {
+    do 
+    {
+      i--;
+      UInt32 matchBit = (matchByte >> i) & 1;
+      UInt32 bit = (symbol >> i) & 1;
+      price += _encoders[0x100 + (matchBit << 8) + context].GetPrice(bit);
+      context = (context << 1) | bit;
+      if (matchBit != bit)
+        break;
+    }
+    while (i != 0);
+  }
+  while(i != 0)
+  {
+    i--;
+    UInt32 bit = (symbol >> i) & 1;
+    price += _encoders[context].GetPrice(bit);
+    context = (context << 1) | bit;
+  }
+  return price;
+};
+
+
+namespace NLength {
+
+void CEncoder::Init(UInt32 numPosStates)
+{
+  _choice.Init();
+  _choice2.Init();
+  for (UInt32 posState = 0; posState < numPosStates; posState++)
+  {
+    _lowCoder[posState].Init();
+    _midCoder[posState].Init();
+  }
+  _highCoder.Init();
+}
+
+void CEncoder::Encode(NRangeCoder::CEncoder *rangeEncoder, UInt32 symbol, UInt32 posState)
+{
+  if(symbol < kNumLowSymbols)
+  {
+    _choice.Encode(rangeEncoder, 0);
+    _lowCoder[posState].Encode(rangeEncoder, symbol);
+  }
+  else
+  {
+    _choice.Encode(rangeEncoder, 1);
+    if(symbol < kNumLowSymbols + kNumMidSymbols)
+    {
+      _choice2.Encode(rangeEncoder, 0);
+      _midCoder[posState].Encode(rangeEncoder, symbol - kNumLowSymbols);
+    }
+    else
+    {
+      _choice2.Encode(rangeEncoder, 1);
+      _highCoder.Encode(rangeEncoder, symbol - kNumLowSymbols - kNumMidSymbols);
+    }
+  }
+}
+
+UInt32 CEncoder::GetPrice(UInt32 symbol, UInt32 posState) const
+{
+  if(symbol < kNumLowSymbols)
+    return _choice.GetPrice0() + _lowCoder[posState].GetPrice(symbol);
+  UInt32 price = _choice.GetPrice1();
+  if(symbol < kNumLowSymbols + kNumMidSymbols)
+  {
+    price += _choice2.GetPrice0();
+    price += _midCoder[posState].GetPrice(symbol - kNumLowSymbols);
+  }
+  else
+  {
+    price += _choice2.GetPrice1();
+    price += _highCoder.GetPrice(symbol - kNumLowSymbols - kNumMidSymbols);
+  }
+  return price;
+}
+
+}
+CEncoder::CEncoder():
+  _numFastBytes(kNumFastBytesDefault),
+  _distTableSize(kDefaultDictionaryLogSize * 2),
+  _posStateBits(2),
+  _posStateMask(4 - 1),
+  _numLiteralPosStateBits(0),
+  _numLiteralContextBits(3),
+  _dictionarySize(1 << kDefaultDictionaryLogSize),
+  _dictionarySizePrev(UInt32(-1)),
+  _numFastBytesPrev(UInt32(-1)),
+  _matchFinderIndex(kBT4),
+   #ifdef COMPRESS_MF_MT
+  _multiThread(false),
+   #endif
+  _writeEndMark(false)
+{
+  _maxMode = false;
+  _fastMode = false;
+}
+
+HRESULT CEncoder::Create()
+{
+  if (!_rangeEncoder.Create(1 << 20))
+    return E_OUTOFMEMORY;
+  if (!_matchFinder)
+  {
+    switch(_matchFinderIndex)
+    {
+      #ifdef COMPRESS_MF_BT
+      #ifdef COMPRESS_MF_BT2
+      case kBT2:
+        _matchFinder = new NBT2::CMatchFinderBinTree;
+        break;
+      #endif
+      #ifdef COMPRESS_MF_BT3
+      case kBT3:
+        _matchFinder = new NBT3::CMatchFinderBinTree;
+        break;
+      #endif
+      #ifdef COMPRESS_MF_BT4
+      case kBT4:
+        _matchFinder = new NBT4::CMatchFinderBinTree;
+        break;
+      #endif
+      #ifdef COMPRESS_MF_BT4B
+      case kBT4B:
+        _matchFinder = new NBT4B::CMatchFinderBinTree;
+        break;
+      #endif
+      #endif
+      
+      #ifdef COMPRESS_MF_PAT
+      case kPat2:
+        _matchFinder = new NPat2::CPatricia;
+        break;
+      case kPat2H:
+        _matchFinder = new NPat2H::CPatricia;
+        break;
+      case kPat3H:
+        _matchFinder = new NPat3H::CPatricia;
+        break;
+      case kPat4H:
+        _matchFinder = new NPat4H::CPatricia;
+        break;
+      case kPat2R:
+        _matchFinder = new NPat2R::CPatricia;
+        break;
+      #endif
+
+      #ifdef COMPRESS_MF_HC
+      case kHC3:
+        _matchFinder = new NHC3::CMatchFinderHC;
+        break;
+      case kHC4:
+        _matchFinder = new NHC4::CMatchFinderHC;
+        break;
+      #endif
+    }
+    if (_matchFinder == 0)
+      return E_OUTOFMEMORY;
+
+    #ifdef COMPRESS_MF_MT
+    if (_multiThread && !(_fastMode && (_matchFinderIndex == kHC3 || _matchFinderIndex == kHC4)))
+    {
+      CMatchFinderMT *mfSpec = new CMatchFinderMT;
+      if (mfSpec == 0)
+        return E_OUTOFMEMORY;
+      CMyComPtr<IMatchFinder> mf = mfSpec;
+      RINOK(mfSpec->SetMatchFinder(_matchFinder));
+      _matchFinder.Release();
+      _matchFinder = mf;
+    }
+    #endif
+  }
+  
+  if (!_literalEncoder.Create(_numLiteralPosStateBits, _numLiteralContextBits))
+    return E_OUTOFMEMORY;
+
+  if (_dictionarySize == _dictionarySizePrev && _numFastBytesPrev == _numFastBytes)
+    return S_OK;
+  RINOK(_matchFinder->Create(_dictionarySize, kNumOpts, _numFastBytes, 
+      kMatchMaxLen * 2 + 1 - _numFastBytes));
+  _dictionarySizePrev = _dictionarySize;
+  _numFastBytesPrev = _numFastBytes;
+  return S_OK;
+}
+
+static bool AreStringsEqual(const wchar_t *base, const wchar_t *testString)
+{
+  while (true)
+  {
+    wchar_t c = *testString;
+    if (c >= 'a' && c <= 'z')
+      c -= 0x20;
+    if (*base != c)
+      return false;
+    if (c == 0)
+      return true;
+    base++;
+    testString++;
+  }
+}
+
+static int FindMatchFinder(const wchar_t *s)
+{
+  for (int m = 0; m < (int)(sizeof(kMatchFinderIDs) / sizeof(kMatchFinderIDs[0])); m++)
+    if (AreStringsEqual(kMatchFinderIDs[m], s))
+      return m;
+  return -1;
+}
+
+STDMETHODIMP CEncoder::SetCoderProperties(const PROPID *propIDs, 
+    const PROPVARIANT *properties, UInt32 numProperties)
+{
+  for (UInt32 i = 0; i < numProperties; i++)
+  {
+    const PROPVARIANT &prop = properties[i];
+    switch(propIDs[i])
+    {
+      case NCoderPropID::kNumFastBytes:
+      {
+        if (prop.vt != VT_UI4)
+          return E_INVALIDARG;
+        UInt32 numFastBytes = prop.ulVal;
+        if(numFastBytes < 5 || numFastBytes > kMatchMaxLen)
+          return E_INVALIDARG;
+        _numFastBytes = numFastBytes;
+        break;
+      }
+      case NCoderPropID::kAlgorithm:
+      {
+        if (prop.vt != VT_UI4)
+          return E_INVALIDARG;
+        UInt32 maximize = prop.ulVal;
+        _fastMode = (maximize == 0); 
+        _maxMode = (maximize >= 2);
+        break;
+      }
+      case NCoderPropID::kMatchFinder:
+      {
+        if (prop.vt != VT_BSTR)
+          return E_INVALIDARG;
+        int matchFinderIndexPrev = _matchFinderIndex;
+        int m = FindMatchFinder(prop.bstrVal);
+        if (m < 0)
+          return E_INVALIDARG;
+        _matchFinderIndex = m;
+        if (_matchFinder && matchFinderIndexPrev != _matchFinderIndex)
+        {
+          _dictionarySizePrev = UInt32(-1);
+          _matchFinder.Release();
+        }
+        break;
+      }
+      #ifdef COMPRESS_MF_MT
+      case NCoderPropID::kMultiThread:
+      {
+        if (prop.vt != VT_BOOL)
+          return E_INVALIDARG;
+        bool newMultiThread = (prop.boolVal == VARIANT_TRUE);
+        if (newMultiThread != _multiThread)
+        {
+          _dictionarySizePrev = UInt32(-1);
+          _matchFinder.Release();
+        }
+        _multiThread = newMultiThread;
+        break;
+      }
+      #endif
+      case NCoderPropID::kDictionarySize:
+      {
+        const int kDicLogSizeMaxCompress = 28;
+        if (prop.vt != VT_UI4)
+          return E_INVALIDARG;
+        UInt32 dictionarySize = prop.ulVal;
+        if (dictionarySize < UInt32(1 << kDicLogSizeMin) ||
+            dictionarySize > UInt32(1 << kDicLogSizeMaxCompress))
+          return E_INVALIDARG;
+        _dictionarySize = dictionarySize;
+        UInt32 dicLogSize;
+        for(dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)
+          if (dictionarySize <= (UInt32(1) << dicLogSize))
+            break;
+        _distTableSize = dicLogSize * 2;
+        break;
+      }
+      case NCoderPropID::kPosStateBits:
+      {
+        if (prop.vt != VT_UI4)
+          return E_INVALIDARG;
+        UInt32 value = prop.ulVal;
+        if (value > (UInt32)NLength::kNumPosStatesBitsEncodingMax)
+          return E_INVALIDARG;
+        _posStateBits = value;
+        _posStateMask = (1 << _posStateBits) - 1;
+        break;
+      }
+      case NCoderPropID::kLitPosBits:
+      {
+        if (prop.vt != VT_UI4)
+          return E_INVALIDARG;
+        UInt32 value = prop.ulVal;
+        if (value > (UInt32)kNumLitPosStatesBitsEncodingMax)
+          return E_INVALIDARG;
+        _numLiteralPosStateBits = value;
+        break;
+      }
+      case NCoderPropID::kLitContextBits:
+      {
+        if (prop.vt != VT_UI4)
+          return E_INVALIDARG;
+        UInt32 value = prop.ulVal;
+        if (value > (UInt32)kNumLitContextBitsMax)
+          return E_INVALIDARG;
+        _numLiteralContextBits = value;
+        break;
+      }
+      case NCoderPropID::kEndMarker:
+      {
+        if (prop.vt != VT_BOOL)
+          return E_INVALIDARG;
+        SetWriteEndMarkerMode(prop.boolVal == VARIANT_TRUE);
+        break;
+      }
+      default:
+        return E_INVALIDARG;
+    }
+  }
+  return S_OK;
+}
+
+STDMETHODIMP CEncoder::WriteCoderProperties(ISequentialOutStream *outStream)
+{ 
+  const UInt32 kPropSize = 5;
+  Byte properties[kPropSize];
+  properties[0] = (_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits;
+  for (int i = 0; i < 4; i++)
+    properties[1 + i] = Byte(_dictionarySize >> (8 * i));
+  return WriteStream(outStream, properties, kPropSize, NULL);
+}
+
+STDMETHODIMP CEncoder::SetOutStream(ISequentialOutStream *outStream)
+{
+  _rangeEncoder.SetStream(outStream);
+  return S_OK;
+}
+
+STDMETHODIMP CEncoder::ReleaseOutStream()
+{
+  _rangeEncoder.ReleaseStream();
+  return S_OK;
+}
+
+HRESULT CEncoder::Init()
+{
+  CBaseState::Init();
+
+  // RINOK(_matchFinder->Init(inStream));
+  _rangeEncoder.Init();
+
+  for(int i = 0; i < kNumStates; i++)
+  {
+    for (UInt32 j = 0; j <= _posStateMask; j++)
+    {
+      _isMatch[i][j].Init();
+      _isRep0Long[i][j].Init();
+    }
+    _isRep[i].Init();
+    _isRepG0[i].Init();
+    _isRepG1[i].Init();
+    _isRepG2[i].Init();
+  }
+
+  _literalEncoder.Init();
+
+  // _repMatchLenEncoder.Init();
+  
+  {
+    for(UInt32 i = 0; i < kNumLenToPosStates; i++)
+      _posSlotEncoder[i].Init();
+  }
+  {
+    for(UInt32 i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
+      _posEncoders[i].Init();
+  }
+
+  _lenEncoder.Init(1 << _posStateBits);
+  _repMatchLenEncoder.Init(1 << _posStateBits);
+
+  _posAlignEncoder.Init();
+
+  _longestMatchWasFound = false;
+  _optimumEndIndex = 0;
+  _optimumCurrentIndex = 0;
+  _additionalOffset = 0;
+
+  return S_OK;
+}
+
+HRESULT CEncoder::MovePos(UInt32 num)
+{
+  for (;num != 0; num--)
+  {
+    _matchFinder->DummyLongestMatch();
+    RINOK(_matchFinder->MovePos());
+    _additionalOffset++;
+  }
+  return S_OK;
+}
+
+UInt32 CEncoder::Backward(UInt32 &backRes, UInt32 cur)
+{
+  _optimumEndIndex = cur;
+  UInt32 posMem = _optimum[cur].PosPrev;
+  UInt32 backMem = _optimum[cur].BackPrev;
+  do
+  {
+    if (_optimum[cur].Prev1IsChar)
+    {
+      _optimum[posMem].MakeAsChar();
+      _optimum[posMem].PosPrev = posMem - 1;
+      if (_optimum[cur].Prev2)
+      {
+        _optimum[posMem - 1].Prev1IsChar = false;
+        _optimum[posMem - 1].PosPrev = _optimum[cur].PosPrev2;
+        _optimum[posMem - 1].BackPrev = _optimum[cur].BackPrev2;
+      }
+    }
+    UInt32 posPrev = posMem;
+    UInt32 backCur = backMem;
+
+    backMem = _optimum[posPrev].BackPrev;
+    posMem = _optimum[posPrev].PosPrev;
+
+    _optimum[posPrev].BackPrev = backCur;
+    _optimum[posPrev].PosPrev = cur;
+    cur = posPrev;
+  }
+  while(cur != 0);
+  backRes = _optimum[0].BackPrev;
+  _optimumCurrentIndex  = _optimum[0].PosPrev;
+  return _optimumCurrentIndex; 
+}
+
+/*
+inline UInt32 GetMatchLen(const Byte *data, UInt32 back, UInt32 limit)
+{  
+  back++;
+  for(UInt32 i = 0; i < limit && data[i] == data[i - back]; i++);
+  return i;
+}
+*/
+
+
+/*
+Out:
+  (lenRes == 1) && (backRes == 0xFFFFFFFF) means Literal
+*/
+
+HRESULT CEncoder::GetOptimum(UInt32 position, UInt32 &backRes, UInt32 &lenRes)
+{
+  if(_optimumEndIndex != _optimumCurrentIndex)
+  {
+    const COptimal &optimum = _optimum[_optimumCurrentIndex];
+    lenRes = optimum.PosPrev - _optimumCurrentIndex;
+    backRes = optimum.BackPrev;
+    _optimumCurrentIndex = optimum.PosPrev;
+    return S_OK;
+  }
+  _optimumCurrentIndex = 0;
+  _optimumEndIndex = 0; // test it;
+  
+  UInt32 lenMain;
+  if (!_longestMatchWasFound)
+  {
+    RINOK(ReadMatchDistances(lenMain));
+  }
+  else
+  {
+    lenMain = _longestMatchLength;
+    _longestMatchWasFound = false;
+  }
+
+
+  UInt32 reps[kNumRepDistances];
+  UInt32 repLens[kNumRepDistances];
+  UInt32 repMaxIndex = 0;
+  UInt32 i;
+  for(i = 0; i < kNumRepDistances; i++)
+  {
+    reps[i] = _repDistances[i];
+    repLens[i] = _matchFinder->GetMatchLen(0 - 1, reps[i], kMatchMaxLen);
+    if (i == 0 || repLens[i] > repLens[repMaxIndex])
+      repMaxIndex = i;
+  }
+  if(repLens[repMaxIndex] >= _numFastBytes)
+  {
+    backRes = repMaxIndex;
+    lenRes = repLens[repMaxIndex];
+    return MovePos(lenRes - 1);
+  }
+
+  if(lenMain >= _numFastBytes)
+  {
+    backRes = _matchDistances[_numFastBytes] + kNumRepDistances; 
+    lenRes = lenMain;
+    return MovePos(lenMain - 1);
+  }
+  Byte currentByte = _matchFinder->GetIndexByte(0 - 1);
+
+  _optimum[0].State = _state;
+
+  Byte matchByte;
+  
+  matchByte = _matchFinder->GetIndexByte(0 - _repDistances[0] - 1 - 1);
+
+  UInt32 posState = (position & _posStateMask);
+
+  _optimum[1].Price = _isMatch[_state.Index][posState].GetPrice0() + 
+      _literalEncoder.GetPrice(position, _previousByte, !_state.IsCharState(), matchByte, currentByte);
+  _optimum[1].MakeAsChar();
+
+  _optimum[1].PosPrev = 0;
+
+  for (i = 0; i < kNumRepDistances; i++)
+    _optimum[0].Backs[i] = reps[i];
+
+  UInt32 matchPrice = _isMatch[_state.Index][posState].GetPrice1();
+  UInt32 repMatchPrice = matchPrice + _isRep[_state.Index].GetPrice1();
+
+  if(matchByte == currentByte)
+  {
+    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(_state, posState);
+    if(shortRepPrice < _optimum[1].Price)
+    {
+      _optimum[1].Price = shortRepPrice;
+      _optimum[1].MakeAsShortRep();
+    }
+  }
+  if(lenMain < 2)
+  {
+    backRes = _optimum[1].BackPrev;
+    lenRes = 1;
+    return S_OK;
+  }
+
+  
+  UInt32 normalMatchPrice = matchPrice + 
+      _isRep[_state.Index].GetPrice0();
+
+  if (lenMain <= repLens[repMaxIndex])
+    lenMain = 0;
+
+  UInt32 len;
+  for(len = 2; len <= lenMain; len++)
+  {
+    _optimum[len].PosPrev = 0;
+    _optimum[len].BackPrev = _matchDistances[len] + kNumRepDistances;
+    _optimum[len].Price = normalMatchPrice + 
+        GetPosLenPrice(_matchDistances[len], len, posState);
+    _optimum[len].Prev1IsChar = false;
+  }
+
+  if (lenMain < repLens[repMaxIndex])
+    lenMain = repLens[repMaxIndex];
+
+  for (; len <= lenMain; len++)
+    _optimum[len].Price = kIfinityPrice;
+
+  for(i = 0; i < kNumRepDistances; i++)
+  {
+    UInt32 repLen = repLens[i];
+    for(UInt32 lenTest = 2; lenTest <= repLen; lenTest++)
+    {
+      UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(i, lenTest, _state, posState);
+      COptimal &optimum = _optimum[lenTest];
+      if (curAndLenPrice < optimum.Price) 
+      {
+        optimum.Price = curAndLenPrice;
+        optimum.PosPrev = 0;
+        optimum.BackPrev = i;
+        optimum.Prev1IsChar = false;
+      }
+    }
+  }
+
+  UInt32 cur = 0;
+  UInt32 lenEnd = lenMain;
+
+  while(true)
+  {
+    cur++;
+    if(cur == lenEnd)
+    {
+      lenRes = Backward(backRes, cur);
+      return S_OK;
+    }
+    position++;
+    COptimal &curOptimum = _optimum[cur];
+    UInt32 posPrev = curOptimum.PosPrev;
+    CState state;
+    if (curOptimum.Prev1IsChar)
+    {
+      posPrev--;
+      if (curOptimum.Prev2)
+      {
+        state = _optimum[curOptimum.PosPrev2].State;
+        if (curOptimum.BackPrev2 < kNumRepDistances)
+          state.UpdateRep();
+        else
+          state.UpdateMatch();
+      }
+      else
+        state = _optimum[posPrev].State;
+      state.UpdateChar();
+    }
+    else
+      state = _optimum[posPrev].State;
+    if (posPrev == cur - 1)
+    {
+      if (curOptimum.IsShortRep())
+        state.UpdateShortRep();
+      else
+        state.UpdateChar();
+      /*
+      if (curOptimum.Prev1IsChar)
+        for(int i = 0; i < kNumRepDistances; i++)
+          reps[i] = _optimum[posPrev].Backs[i];
+      */
+    }
+    else
+    {
+      UInt32 pos;
+      if (curOptimum.Prev1IsChar && curOptimum.Prev2)
+      {
+        posPrev = curOptimum.PosPrev2;
+        pos = curOptimum.BackPrev2;
+        state.UpdateRep();
+      }
+      else
+      {
+        pos = curOptimum.BackPrev;
+        if (pos < kNumRepDistances)
+          state.UpdateRep();
+        else
+          state.UpdateMatch();
+      }
+      const COptimal &prevOptimum = _optimum[posPrev];
+      if (pos < kNumRepDistances)
+      {
+        reps[0] = prevOptimum.Backs[pos];
+    		UInt32 i;
+        for(i = 1; i <= pos; i++)
+          reps[i] = prevOptimum.Backs[i - 1];
+        for(; i < kNumRepDistances; i++)
+          reps[i] = prevOptimum.Backs[i];
+      }
+      else
+      {
+        reps[0] = (pos - kNumRepDistances);
+        for(UInt32 i = 1; i < kNumRepDistances; i++)
+          reps[i] = prevOptimum.Backs[i - 1];
+      }
+    }
+    curOptimum.State = state;
+    for(UInt32 i = 0; i < kNumRepDistances; i++)
+      curOptimum.Backs[i] = reps[i];
+    UInt32 newLen;
+    RINOK(ReadMatchDistances(newLen));
+    if(newLen >= _numFastBytes)
+    {
+      _longestMatchLength = newLen;
+      _longestMatchWasFound = true;
+      lenRes = Backward(backRes, cur);
+      return S_OK;
+    }
+    UInt32 curPrice = curOptimum.Price; 
+    // Byte currentByte  = _matchFinder->GetIndexByte(0 - 1);
+    // Byte matchByte = _matchFinder->GetIndexByte(0 - reps[0] - 1 - 1);
+    const Byte *data = _matchFinder->GetPointerToCurrentPos() - 1;
+    Byte currentByte = *data;
+    Byte matchByte = data[(size_t)0 - reps[0] - 1];
+
+    UInt32 posState = (position & _posStateMask);
+
+    UInt32 curAnd1Price = curPrice +
+        _isMatch[state.Index][posState].GetPrice0() +
+        _literalEncoder.GetPrice(position, data[(size_t)0 - 1], !state.IsCharState(), matchByte, currentByte);
+
+    COptimal &nextOptimum = _optimum[cur + 1];
+
+    bool nextIsChar = false;
+    if (curAnd1Price < nextOptimum.Price) 
+    {
+      nextOptimum.Price = curAnd1Price;
+      nextOptimum.PosPrev = cur;
+      nextOptimum.MakeAsChar();
+      nextIsChar = true;
+    }
+
+    UInt32 matchPrice = curPrice + _isMatch[state.Index][posState].GetPrice1();
+    UInt32 repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();
+    
+    if(matchByte == currentByte &&
+        !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))
+    {
+      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state, posState);
+      if(shortRepPrice <= nextOptimum.Price)
+      {
+        nextOptimum.Price = shortRepPrice;
+        nextOptimum.PosPrev = cur;
+        nextOptimum.MakeAsShortRep();
+        // nextIsChar = false;
+      }
+    }
+    /*
+    if(newLen == 2 && _matchDistances[2] >= kDistLimit2) // test it maybe set 2000 ?
+      continue;
+    */
+
+    UInt32 numAvailableBytesFull = _matchFinder->GetNumAvailableBytes() + 1;
+    numAvailableBytesFull = MyMin(kNumOpts - 1 - cur, numAvailableBytesFull);
+    UInt32 numAvailableBytes = numAvailableBytesFull;
+
+    if (numAvailableBytes < 2)
+      continue;
+    if (numAvailableBytes > _numFastBytes)
+      numAvailableBytes = _numFastBytes;
+    if (numAvailableBytes >= 3 && !nextIsChar)
+    {
+      // try Literal + rep0
+      UInt32 backOffset = reps[0] + 1;
+      UInt32 temp;
+      for (temp = 1; temp < numAvailableBytes; temp++)
+        if (data[temp] != data[(size_t)temp - backOffset])
+          break;
+      UInt32 lenTest2 = temp - 1;
+      if (lenTest2 >= 2)
+      {
+        CState state2 = state;
+        state2.UpdateChar();
+        UInt32 posStateNext = (position + 1) & _posStateMask;
+        UInt32 nextRepMatchPrice = curAnd1Price + 
+            _isMatch[state2.Index][posStateNext].GetPrice1() +
+            _isRep[state2.Index].GetPrice1();
+        // for (; lenTest2 >= 2; lenTest2--)
+        {
+          while(lenEnd < cur + 1 + lenTest2)
+            _optimum[++lenEnd].Price = kIfinityPrice;
+          UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(
+              0, lenTest2, state2, posStateNext);
+          COptimal &optimum = _optimum[cur + 1 + lenTest2];
+          if (curAndLenPrice < optimum.Price) 
+          {
+            optimum.Price = curAndLenPrice;
+            optimum.PosPrev = cur + 1;
+            optimum.BackPrev = 0;
+            optimum.Prev1IsChar = true;
+            optimum.Prev2 = false;
+          }
+        }
+      }
+    }
+    for(UInt32 repIndex = 0; repIndex < kNumRepDistances; repIndex++)
+    {
+      // UInt32 repLen = _matchFinder->GetMatchLen(0 - 1, reps[repIndex], newLen); // test it;
+      UInt32 backOffset = reps[repIndex] + 1;
+      if (data[0] != data[(size_t)0 - backOffset] ||
+          data[1] != data[(size_t)1 - backOffset])
+        continue;
+      UInt32 lenTest;
+      for (lenTest = 2; lenTest < numAvailableBytes; lenTest++)
+        if (data[lenTest] != data[(size_t)lenTest - backOffset])
+          break;
+      UInt32 lenTestTemp = lenTest;
+      do
+      {
+        while(lenEnd < cur + lenTest)
+          _optimum[++lenEnd].Price = kIfinityPrice;
+        UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex, lenTest, state, posState);
+        COptimal &optimum = _optimum[cur + lenTest];
+        if (curAndLenPrice < optimum.Price) 
+        {
+          optimum.Price = curAndLenPrice;
+          optimum.PosPrev = cur;
+          optimum.BackPrev = repIndex;
+          optimum.Prev1IsChar = false;
+        }
+      }
+      while(--lenTest >= 2);
+      lenTest = lenTestTemp;
+
+        if (_maxMode)
+        {
+          UInt32 lenTest2 = lenTest + 1;
+          UInt32 limit = MyMin(numAvailableBytesFull, lenTest2 + _numFastBytes);
+          for (; lenTest2 < limit; lenTest2++)
+            if (data[lenTest2] != data[(size_t)lenTest2 - backOffset])
+              break;
+          lenTest2 -= lenTest + 1;
+          if (lenTest2 >= 2)
+          {
+            CState state2 = state;
+            state2.UpdateRep();
+            UInt32 posStateNext = (position + lenTest) & _posStateMask;
+            UInt32 curAndLenCharPrice = 
+                repMatchPrice + GetRepPrice(repIndex, lenTest, state, posState) + 
+                _isMatch[state2.Index][posStateNext].GetPrice0() +
+                _literalEncoder.GetPrice(position + lenTest, data[(size_t)lenTest - 1], 
+                true, data[(size_t)lenTest - backOffset], data[lenTest]);
+            state2.UpdateChar();
+            posStateNext = (position + lenTest + 1) & _posStateMask;
+            UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[state2.Index][posStateNext].GetPrice1();
+            UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();
+            
+            // for(; lenTest2 >= 2; lenTest2--)
+            {
+              UInt32 offset = lenTest + 1 + lenTest2;
+              while(lenEnd < cur + offset)
+                _optimum[++lenEnd].Price = kIfinityPrice;
+              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(
+                  0, lenTest2, state2, posStateNext);
+              COptimal &optimum = _optimum[cur + offset];
+              if (curAndLenPrice < optimum.Price) 
+              {
+                optimum.Price = curAndLenPrice;
+                optimum.PosPrev = cur + lenTest + 1;
+                optimum.BackPrev = 0;
+                optimum.Prev1IsChar = true;
+                optimum.Prev2 = true;
+                optimum.PosPrev2 = cur;
+                optimum.BackPrev2 = repIndex;
+              }
+            }
+          }
+        }
+      }
+    
+    //    for(UInt32 lenTest = 2; lenTest <= newLen; lenTest++)
+    if (newLen > numAvailableBytes)
+      newLen = numAvailableBytes;
+    if (newLen >= 2)
+    {
+      if (newLen == 2 && _matchDistances[2] >= 0x80)
+        continue;
+      UInt32 normalMatchPrice = matchPrice + 
+        _isRep[state.Index].GetPrice0();
+      while(lenEnd < cur + newLen)
+        _optimum[++lenEnd].Price = kIfinityPrice;
+
+      for(UInt32 lenTest = newLen; lenTest >= 2; lenTest--)
+      {
+        UInt32 curBack = _matchDistances[lenTest];
+        UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack, lenTest, posState);
+        COptimal &optimum = _optimum[cur + lenTest];
+        if (curAndLenPrice < optimum.Price) 
+        {
+          optimum.Price = curAndLenPrice;
+          optimum.PosPrev = cur;
+          optimum.BackPrev = curBack + kNumRepDistances;
+          optimum.Prev1IsChar = false;
+        }
+
+        if (_maxMode && (lenTest == newLen || curBack != _matchDistances[lenTest + 1]))
+        {
+          // Try Match + Literal + Rep0
+          UInt32 backOffset = curBack + 1;
+          UInt32 lenTest2 = lenTest + 1;
+          UInt32 limit = MyMin(numAvailableBytesFull, lenTest2 + _numFastBytes);
+          for (; lenTest2 < limit; lenTest2++)
+            if (data[lenTest2] != data[(size_t)lenTest2 - backOffset])
+              break;
+          lenTest2 -= lenTest + 1;
+          if (lenTest2 >= 2)
+          {
+            CState state2 = state;
+            state2.UpdateMatch();
+            UInt32 posStateNext = (position + lenTest) & _posStateMask;
+            UInt32 curAndLenCharPrice = curAndLenPrice + 
+                _isMatch[state2.Index][posStateNext].GetPrice0() +
+                _literalEncoder.GetPrice(position + lenTest, data[(size_t)lenTest - 1], 
+                true, data[(size_t)lenTest - backOffset], data[lenTest]);
+            state2.UpdateChar();
+            posStateNext = (position + lenTest + 1) & _posStateMask;
+            UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[state2.Index][posStateNext].GetPrice1();
+            UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();
+            
+            // for(; lenTest2 >= 2; lenTest2--)
+            {
+              UInt32 offset = lenTest + 1 + lenTest2;
+              while(lenEnd < cur + offset)
+                _optimum[++lenEnd].Price = kIfinityPrice;
+              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(
+                  0, lenTest2, state2, posStateNext);
+              COptimal &optimum = _optimum[cur + offset];
+              if (curAndLenPrice < optimum.Price) 
+              {
+                optimum.Price = curAndLenPrice;
+                optimum.PosPrev = cur + lenTest + 1;
+                optimum.BackPrev = 0;
+                optimum.Prev1IsChar = true;
+                optimum.Prev2 = true;
+                optimum.PosPrev2 = cur;
+                optimum.BackPrev2 = curBack + kNumRepDistances;
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+}
+
+static inline bool ChangePair(UInt32 smallDist, UInt32 bigDist)
+{
+  const int kDif = 7;
+  return (smallDist < (UInt32(1) << (32-kDif)) && bigDist >= (smallDist << kDif));
+}
+
+
+HRESULT CEncoder::ReadMatchDistances(UInt32 &lenRes)
+{
+  lenRes = _matchFinder->GetLongestMatch(_matchDistances);
+  if (lenRes == _numFastBytes)
+    lenRes += _matchFinder->GetMatchLen(lenRes, _matchDistances[lenRes], 
+        kMatchMaxLen - lenRes);
+  _additionalOffset++;
+  return _matchFinder->MovePos();
+}
+
+HRESULT CEncoder::GetOptimumFast(UInt32 position, UInt32 &backRes, UInt32 &lenRes)
+{
+  UInt32 lenMain;
+  if (!_longestMatchWasFound)
+  {
+    RINOK(ReadMatchDistances(lenMain));
+  }
+  else
+  {
+    lenMain = _longestMatchLength;
+    _longestMatchWasFound = false;
+  }
+  UInt32 repLens[kNumRepDistances];
+  UInt32 repMaxIndex = 0;
+  for(UInt32 i = 0; i < kNumRepDistances; i++)
+  {
+    repLens[i] = _matchFinder->GetMatchLen(0 - 1, _repDistances[i], kMatchMaxLen);
+    if (i == 0 || repLens[i] > repLens[repMaxIndex])
+      repMaxIndex = i;
+  }
+  if(repLens[repMaxIndex] >= _numFastBytes)
+  {
+    backRes = repMaxIndex;
+    lenRes = repLens[repMaxIndex];
+    return MovePos(lenRes - 1);
+  }
+  if(lenMain >= _numFastBytes)
+  {
+    backRes = _matchDistances[_numFastBytes] + kNumRepDistances; 
+    lenRes = lenMain;
+    return MovePos(lenMain - 1);
+  }
+  while (lenMain > 2)
+  {
+    if (!ChangePair(_matchDistances[lenMain - 1], _matchDistances[lenMain]))
+      break;
+    lenMain--;
+  }
+  if (lenMain == 2 && _matchDistances[2] >= 0x80)
+    lenMain = 1;
+
+  UInt32 backMain = _matchDistances[lenMain];
+  if (repLens[repMaxIndex] >= 2)
+  {
+    if (repLens[repMaxIndex] + 1 >= lenMain || 
+        (repLens[repMaxIndex] + 2 >= lenMain && (backMain > (1<<12))))
+    {
+      backRes = repMaxIndex;
+      lenRes = repLens[repMaxIndex];
+      return MovePos(lenRes - 1);
+    }
+  }
+  
+
+  if (lenMain >= 2)
+  {
+    RINOK(ReadMatchDistances(_longestMatchLength));
+    if (_longestMatchLength >= 2 &&
+      (
+        (_longestMatchLength >= lenMain && _matchDistances[lenMain] < backMain) || 
+        ((_longestMatchLength == lenMain + 1) && 
+          !ChangePair(backMain, _matchDistances[_longestMatchLength])) ||
+        (_longestMatchLength > lenMain + 1) ||
+        ((_longestMatchLength + 1 >= lenMain) && lenMain >= 3 &&
+          ChangePair(_matchDistances[lenMain - 1], backMain))
+      )
+      )
+    {
+      _longestMatchWasFound = true;
+      backRes = UInt32(-1);
+      lenRes = 1;
+      return S_OK;
+    }
+    for(UInt32 i = 0; i < kNumRepDistances; i++)
+    {
+      UInt32 repLen = _matchFinder->GetMatchLen(0 - 1, _repDistances[i], kMatchMaxLen);
+      if (repLen >= 2 && repLen + 1 >= lenMain)
+      {
+        _longestMatchWasFound = true;
+        backRes = UInt32(-1);
+        lenRes = 1;
+        return S_OK;
+      }
+    }
+    backRes = backMain + kNumRepDistances; 
+    lenRes = lenMain;
+    return MovePos(lenMain - 2);
+  }
+  backRes = UInt32(-1);
+  lenRes = 1;
+  return S_OK;
+}
+
+STDMETHODIMP CEncoder::InitMatchFinder(IMatchFinder *matchFinder)
+{
+  _matchFinder = matchFinder;
+  return S_OK;
+}
+
+HRESULT CEncoder::Flush(UInt32 nowPos)
+{
+  ReleaseMFStream();
+  WriteEndMarker(nowPos & _posStateMask);
+  _rangeEncoder.FlushData();
+  return _rangeEncoder.FlushStream();
+}
+
+void CEncoder::WriteEndMarker(UInt32 posState)
+{
+  // This function for writing End Mark for stream version of LZMA. 
+  // In current version this feature is not used.
+  if (!_writeEndMark)
+    return;
+
+  _isMatch[_state.Index][posState].Encode(&_rangeEncoder, 1);
+  _isRep[_state.Index].Encode(&_rangeEncoder, 0);
+  _state.UpdateMatch();
+  UInt32 len = kMatchMinLen; // kMatchMaxLen;
+  _lenEncoder.Encode(&_rangeEncoder, len - kMatchMinLen, posState);
+  UInt32 posSlot = (1 << kNumPosSlotBits)  - 1;
+  UInt32 lenToPosState = GetLenToPosState(len);
+  _posSlotEncoder[lenToPosState].Encode(&_rangeEncoder, posSlot);
+  UInt32 footerBits = 30;
+  UInt32 posReduced = (UInt32(1) << footerBits) - 1;
+  _rangeEncoder.EncodeDirectBits(posReduced >> kNumAlignBits, footerBits - kNumAlignBits);
+  _posAlignEncoder.ReverseEncode(&_rangeEncoder, posReduced & kAlignMask);
+}
+
+HRESULT CEncoder::CodeReal(ISequentialInStream *inStream,
+      ISequentialOutStream *outStream, 
+      const UInt64 *inSize, const UInt64 *outSize,
+      ICompressProgressInfo *progress)
+{
+  _needReleaseMFStream = false;
+  CCoderReleaser coderReleaser(this);
+  RINOK(SetStreams(inStream, outStream, inSize, outSize));
+  while(true)
+  {
+    UInt64 processedInSize;
+    UInt64 processedOutSize;
+    Int32 finished;
+    RINOK(CodeOneBlock(&processedInSize, &processedOutSize, &finished));
+    if (finished != 0)
+      return S_OK;
+    if (progress != 0)
+    {
+      RINOK(progress->SetRatioInfo(&processedInSize, &processedOutSize));
+    }
+  }
+}
+
+HRESULT CEncoder::SetStreams(ISequentialInStream *inStream,
+      ISequentialOutStream *outStream, 
+      const UInt64 *inSize, const UInt64 *outSize)
+{
+  _inStream = inStream;
+  _finished = false;
+  RINOK(Create());
+  RINOK(SetOutStream(outStream));
+  RINOK(Init());
+  
+  // CCoderReleaser releaser(this);
+
+  /*
+  if (_matchFinder->GetNumAvailableBytes() == 0)
+    return Flush();
+  */
+
+  if (!_fastMode)
+  {
+    FillPosSlotPrices();
+    FillDistancesPrices();
+    FillAlignPrices();
+  }
+
+  _lenEncoder.SetTableSize(_numFastBytes + 1 - kMatchMinLen);
+  _lenEncoder.UpdateTables(1 << _posStateBits);
+  _repMatchLenEncoder.SetTableSize(_numFastBytes + 1 - kMatchMinLen);
+  _repMatchLenEncoder.UpdateTables(1 << _posStateBits);
+
+  lastPosSlotFillingPos = 0;
+  nowPos64 = 0;
+  return S_OK;
+}
+
+HRESULT CEncoder::CodeOneBlock(UInt64 *inSize, UInt64 *outSize, Int32 *finished)
+{
+  if (_inStream != 0)
+  {
+    RINOK(_matchFinder->Init(_inStream));
+    _needReleaseMFStream = true;
+    _inStream = 0;
+  }
+
+
+  *finished = 1;
+  if (_finished)
+    return S_OK;
+  _finished = true;
+
+
+  UInt64 progressPosValuePrev = nowPos64;
+  if (nowPos64 == 0)
+  {
+    if (_matchFinder->GetNumAvailableBytes() == 0)
+      return Flush(UInt32(nowPos64));
+    UInt32 len; // it's not used
+    RINOK(ReadMatchDistances(len));
+    UInt32 posState = UInt32(nowPos64) & _posStateMask;
+    _isMatch[_state.Index][posState].Encode(&_rangeEncoder, 0);
+    _state.UpdateChar();
+    Byte curByte = _matchFinder->GetIndexByte(0 - _additionalOffset);
+    _literalEncoder.GetSubCoder(UInt32(nowPos64), _previousByte)->Encode(&_rangeEncoder, curByte);
+    _previousByte = curByte;
+    _additionalOffset--;
+    nowPos64++;
+  }
+  if (_matchFinder->GetNumAvailableBytes() == 0)
+    return Flush(UInt32(nowPos64));
+  while(true)
+  {
+    #ifdef _NO_EXCEPTIONS
+    if (_rangeEncoder.Stream.ErrorCode != S_OK)
+      return _rangeEncoder.Stream.ErrorCode;
+    #endif
+    UInt32 pos;
+    UInt32 posState = UInt32(nowPos64) & _posStateMask;
+
+    UInt32 len;
+    HRESULT result;
+    if (_fastMode)
+      result = GetOptimumFast(UInt32(nowPos64), pos, len);
+    else
+      result = GetOptimum(UInt32(nowPos64), pos, len);
+    RINOK(result);
+
+    if(len == 1 && pos == 0xFFFFFFFF)
+    {
+      _isMatch[_state.Index][posState].Encode(&_rangeEncoder, 0);
+      Byte curByte = _matchFinder->GetIndexByte(0 - _additionalOffset);
+      CLiteralEncoder2 *subCoder = _literalEncoder.GetSubCoder(UInt32(nowPos64), _previousByte);
+      if(!_state.IsCharState())
+      {
+        Byte matchByte = _matchFinder->GetIndexByte(0 - _repDistances[0] - 1 - _additionalOffset);
+        subCoder->EncodeMatched(&_rangeEncoder, matchByte, curByte);
+      }
+      else
+        subCoder->Encode(&_rangeEncoder, curByte);
+      _state.UpdateChar();
+      _previousByte = curByte;
+    }
+    else
+    {
+      _isMatch[_state.Index][posState].Encode(&_rangeEncoder, 1);
+      if(pos < kNumRepDistances)
+      {
+        _isRep[_state.Index].Encode(&_rangeEncoder, 1);
+        if(pos == 0)
+        {
+          _isRepG0[_state.Index].Encode(&_rangeEncoder, 0);
+          if(len == 1)
+            _isRep0Long[_state.Index][posState].Encode(&_rangeEncoder, 0);
+          else
+            _isRep0Long[_state.Index][posState].Encode(&_rangeEncoder, 1);
+        }
+        else
+        {
+          _isRepG0[_state.Index].Encode(&_rangeEncoder, 1);
+          if (pos == 1)
+            _isRepG1[_state.Index].Encode(&_rangeEncoder, 0);
+          else
+          {
+            _isRepG1[_state.Index].Encode(&_rangeEncoder, 1);
+            _isRepG2[_state.Index].Encode(&_rangeEncoder, pos - 2);
+          }
+        }
+        if (len == 1)
+          _state.UpdateShortRep();
+        else
+        {
+          _repMatchLenEncoder.Encode(&_rangeEncoder, len - kMatchMinLen, posState);
+          _state.UpdateRep();
+        }
+
+
+        UInt32 distance = _repDistances[pos];
+        if (pos != 0)
+        {
+          for(UInt32 i = pos; i >= 1; i--)
+            _repDistances[i] = _repDistances[i - 1];
+          _repDistances[0] = distance;
+        }
+      }
+      else
+      {
+        _isRep[_state.Index].Encode(&_rangeEncoder, 0);
+        _state.UpdateMatch();
+        _lenEncoder.Encode(&_rangeEncoder, len - kMatchMinLen, posState);
+        pos -= kNumRepDistances;
+        UInt32 posSlot = GetPosSlot(pos);
+        UInt32 lenToPosState = GetLenToPosState(len);
+        _posSlotEncoder[lenToPosState].Encode(&_rangeEncoder, posSlot);
+        
+        if (posSlot >= kStartPosModelIndex)
+        {
+          UInt32 footerBits = ((posSlot >> 1) - 1);
+          UInt32 base = ((2 | (posSlot & 1)) << footerBits);
+          UInt32 posReduced = pos - base;
+
+          if (posSlot < kEndPosModelIndex)
+            NRangeCoder::ReverseBitTreeEncode(_posEncoders + base - posSlot - 1, 
+                &_rangeEncoder, footerBits, posReduced);
+          else
+          {
+            _rangeEncoder.EncodeDirectBits(posReduced >> kNumAlignBits, footerBits - kNumAlignBits);
+            _posAlignEncoder.ReverseEncode(&_rangeEncoder, posReduced & kAlignMask);
+            if (!_fastMode)
+              if (--_alignPriceCount == 0)
+                FillAlignPrices();
+          }
+        }
+        UInt32 distance = pos;
+        for(UInt32 i = kNumRepDistances - 1; i >= 1; i--)
+          _repDistances[i] = _repDistances[i - 1];
+        _repDistances[0] = distance;
+      }
+      _previousByte = _matchFinder->GetIndexByte(len - 1 - _additionalOffset);
+    }
+    _additionalOffset -= len;
+    nowPos64 += len;
+    if (!_fastMode)
+      if (nowPos64 - lastPosSlotFillingPos >= (1 << 9))
+      {
+        FillPosSlotPrices();
+        FillDistancesPrices();
+        lastPosSlotFillingPos = nowPos64;
+      }
+    if (_additionalOffset == 0)
+    {
+      *inSize = nowPos64;
+      *outSize = _rangeEncoder.GetProcessedSize();
+      if (_matchFinder->GetNumAvailableBytes() == 0)
+        return Flush(UInt32(nowPos64));
+      if (nowPos64 - progressPosValuePrev >= (1 << 12))
+      {
+        _finished = false;
+        *finished = 0;
+        return S_OK;
+      }
+    }
+  }
+}
+
+STDMETHODIMP CEncoder::Code(ISequentialInStream *inStream,
+    ISequentialOutStream *outStream, const UInt64 *inSize, const UInt64 *outSize,
+    ICompressProgressInfo *progress)
+{
+  #ifndef _NO_EXCEPTIONS
+  try 
+  { 
+  #endif
+    return CodeReal(inStream, outStream, inSize, outSize, progress); 
+  #ifndef _NO_EXCEPTIONS
+  }
+  catch(const COutBufferException &e) { return e.ErrorCode; }
+  catch(...) { return E_FAIL; }
+  #endif
+}
+  
+void CEncoder::FillPosSlotPrices()
+{
+  for (UInt32 lenToPosState = 0; lenToPosState < kNumLenToPosStates; lenToPosState++)
+  {
+	  UInt32 posSlot;
+    for (posSlot = 0; posSlot < kEndPosModelIndex && posSlot < _distTableSize; posSlot++)
+      _posSlotPrices[lenToPosState][posSlot] = _posSlotEncoder[lenToPosState].GetPrice(posSlot);
+    for (; posSlot < _distTableSize; posSlot++)
+      _posSlotPrices[lenToPosState][posSlot] = _posSlotEncoder[lenToPosState].GetPrice(posSlot) + 
+      ((((posSlot >> 1) - 1) - kNumAlignBits) << NRangeCoder::kNumBitPriceShiftBits);
+  }
+}
+
+void CEncoder::FillDistancesPrices()
+{
+  for (UInt32 lenToPosState = 0; lenToPosState < kNumLenToPosStates; lenToPosState++)
+  {
+	  UInt32 i;
+    for (i = 0; i < kStartPosModelIndex; i++)
+      _distancesPrices[lenToPosState][i] = _posSlotPrices[lenToPosState][i];
+    for (; i < kNumFullDistances; i++)
+    { 
+      UInt32 posSlot = GetPosSlot(i);
+      UInt32 footerBits = ((posSlot >> 1) - 1);
+      UInt32 base = ((2 | (posSlot & 1)) << footerBits);
+
+      _distancesPrices[lenToPosState][i] = _posSlotPrices[lenToPosState][posSlot] +
+          NRangeCoder::ReverseBitTreeGetPrice(_posEncoders + 
+              base - posSlot - 1, footerBits, i - base);
+            
+    }
+  }
+}
+
+void CEncoder::FillAlignPrices()
+{
+  for (UInt32 i = 0; i < kAlignTableSize; i++)
+    _alignPrices[i] = _posAlignEncoder.ReverseGetPrice(i);
+  _alignPriceCount = kAlignTableSize;
+}
+
+}}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMAEncoder.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMAEncoder.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMAEncoder.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMAEncoder.h	2022-01-01 15:08:47.889171448 +0800
@@ -0,0 +1,416 @@
+// LZMA/Encoder.h
+
+#ifndef __LZMA_ENCODER_H
+#define __LZMA_ENCODER_H
+
+#include "../../../Common/MyCom.h"
+#include "../../../Common/Alloc.h"
+#include "../../ICoder.h"
+#include "../LZ/IMatchFinder.h"
+#include "../RangeCoder/RangeCoderBitTree.h"
+
+#include "LZMA.h"
+
+namespace NCompress {
+namespace NLZMA {
+
+typedef NRangeCoder::CBitEncoder<kNumMoveBits> CMyBitEncoder;
+
+class CBaseState
+{
+protected:
+  CState _state;
+  Byte _previousByte;
+  UInt32 _repDistances[kNumRepDistances];
+  void Init()
+  {
+    _state.Init();
+    _previousByte = 0;
+    for(UInt32 i = 0 ; i < kNumRepDistances; i++)
+      _repDistances[i] = 0;
+  }
+};
+
+struct COptimal
+{
+  CState State;
+
+  bool Prev1IsChar;
+  bool Prev2;
+
+  UInt32 PosPrev2;
+  UInt32 BackPrev2;     
+
+  UInt32 Price;    
+  UInt32 PosPrev;         // posNext;
+  UInt32 BackPrev;     
+  UInt32 Backs[kNumRepDistances];
+  void MakeAsChar() { BackPrev = UInt32(-1); Prev1IsChar = false; }
+  void MakeAsShortRep() { BackPrev = 0; ; Prev1IsChar = false; }
+  bool IsShortRep() { return (BackPrev == 0); }
+};
+
+
+extern Byte g_FastPos[1024];
+inline UInt32 GetPosSlot(UInt32 pos)
+{
+  if (pos < (1 << 10))
+    return g_FastPos[pos];
+  if (pos < (1 << 19))
+    return g_FastPos[pos >> 9] + 18;
+  return g_FastPos[pos >> 18] + 36;
+}
+
+inline UInt32 GetPosSlot2(UInt32 pos)
+{
+  if (pos < (1 << 16))
+    return g_FastPos[pos >> 6] + 12;
+  if (pos < (1 << 25))
+    return g_FastPos[pos >> 15] + 30;
+  return g_FastPos[pos >> 24] + 48;
+}
+
+const UInt32 kIfinityPrice = 0xFFFFFFF;
+
+const UInt32 kNumOpts = 1 << 12;
+
+
+class CLiteralEncoder2
+{
+  CMyBitEncoder _encoders[0x300];
+public:
+  void Init()
+  {
+    for (int i = 0; i < 0x300; i++)
+      _encoders[i].Init();
+  }
+  void Encode(NRangeCoder::CEncoder *rangeEncoder, Byte symbol);
+  void EncodeMatched(NRangeCoder::CEncoder *rangeEncoder, Byte matchByte, Byte symbol);
+  UInt32 GetPrice(bool matchMode, Byte matchByte, Byte symbol) const;
+};
+
+class CLiteralEncoder
+{
+  CLiteralEncoder2 *_coders;
+  int _numPrevBits;
+  int _numPosBits;
+  UInt32 _posMask;
+public:
+  CLiteralEncoder(): _coders(0) {}
+  ~CLiteralEncoder()  { Free(); }
+  void Free()
+  { 
+    MyFree(_coders);
+    _coders = 0;
+  }
+  bool Create(int numPosBits, int numPrevBits)
+  {
+    if (_coders == 0 || (numPosBits + numPrevBits) != 
+        (_numPrevBits + _numPosBits) )
+    {
+      Free();
+      UInt32 numStates = 1 << (numPosBits + numPrevBits);
+      _coders = (CLiteralEncoder2 *)MyAlloc(numStates * sizeof(CLiteralEncoder2));
+    }
+    _numPosBits = numPosBits;
+    _posMask = (1 << numPosBits) - 1;
+    _numPrevBits = numPrevBits;
+    return (_coders != 0);
+  }
+  void Init()
+  {
+    UInt32 numStates = 1 << (_numPrevBits + _numPosBits);
+    for (UInt32 i = 0; i < numStates; i++)
+      _coders[i].Init();
+  }
+  UInt32 GetState(UInt32 pos, Byte prevByte) const
+    { return ((pos & _posMask) << _numPrevBits) + (prevByte >> (8 - _numPrevBits)); }
+  CLiteralEncoder2 *GetSubCoder(UInt32 pos, Byte prevByte)
+    { return &_coders[GetState(pos, prevByte)]; }
+  /*
+  void Encode(NRangeCoder::CEncoder *rangeEncoder, UInt32 pos, Byte prevByte, 
+      Byte symbol)
+    { _coders[GetState(pos, prevByte)].Encode(rangeEncoder, symbol); }
+  void EncodeMatched(NRangeCoder::CEncoder *rangeEncoder, UInt32 pos, Byte prevByte, 
+      Byte matchByte, Byte symbol)
+    { _coders[GetState(pos, prevByte)].Encode(rangeEncoder,
+      matchByte, symbol); }
+  */
+  UInt32 GetPrice(UInt32 pos, Byte prevByte, bool matchMode, Byte matchByte, Byte symbol) const
+    { return _coders[GetState(pos, prevByte)].GetPrice(matchMode, matchByte, symbol); }
+};
+
+namespace NLength {
+
+class CEncoder
+{
+  CMyBitEncoder _choice;
+  CMyBitEncoder  _choice2;
+  NRangeCoder::CBitTreeEncoder<kNumMoveBits, kNumLowBits>  _lowCoder[kNumPosStatesEncodingMax];
+  NRangeCoder::CBitTreeEncoder<kNumMoveBits, kNumMidBits>  _midCoder[kNumPosStatesEncodingMax];
+  NRangeCoder::CBitTreeEncoder<kNumMoveBits, kNumHighBits>  _highCoder;
+public:
+  void Init(UInt32 numPosStates);
+  void Encode(NRangeCoder::CEncoder *rangeEncoder, UInt32 symbol, UInt32 posState);
+  UInt32 GetPrice(UInt32 symbol, UInt32 posState) const;
+};
+
+const UInt32 kNumSpecSymbols = kNumLowSymbols + kNumMidSymbols;
+
+class CPriceTableEncoder: public CEncoder
+{
+  UInt32 _prices[kNumSymbolsTotal][kNumPosStatesEncodingMax];
+  UInt32 _tableSize;
+  UInt32 _counters[kNumPosStatesEncodingMax];
+public:
+  void SetTableSize(UInt32 tableSize) { _tableSize = tableSize;  }
+  UInt32 GetPrice(UInt32 symbol, UInt32 posState) const
+    { return _prices[symbol][posState]; }
+  void UpdateTable(UInt32 posState)
+  {
+    for (UInt32 len = 0; len < _tableSize; len++)
+      _prices[len][posState] = CEncoder::GetPrice(len, posState);
+    _counters[posState] = _tableSize;
+  }
+  void UpdateTables(UInt32 numPosStates)
+  {
+    for (UInt32 posState = 0; posState < numPosStates; posState++)
+      UpdateTable(posState);
+  }
+  void Encode(NRangeCoder::CEncoder *rangeEncoder, UInt32 symbol, UInt32 posState)
+  {
+    CEncoder::Encode(rangeEncoder, symbol, posState);
+    if (--_counters[posState] == 0)
+      UpdateTable(posState);
+  }
+};
+
+}
+
+class CEncoder : 
+  public ICompressCoder,
+  public ICompressSetOutStream,
+  public ICompressSetCoderProperties,
+  public ICompressWriteCoderProperties,
+  public CBaseState,
+  public CMyUnknownImp
+{
+  COptimal _optimum[kNumOpts];
+  CMyComPtr<IMatchFinder> _matchFinder; // test it
+  NRangeCoder::CEncoder _rangeEncoder;
+
+  CMyBitEncoder _isMatch[kNumStates][NLength::kNumPosStatesEncodingMax];
+  CMyBitEncoder _isRep[kNumStates];
+  CMyBitEncoder _isRepG0[kNumStates];
+  CMyBitEncoder _isRepG1[kNumStates];
+  CMyBitEncoder _isRepG2[kNumStates];
+  CMyBitEncoder _isRep0Long[kNumStates][NLength::kNumPosStatesEncodingMax];
+
+  NRangeCoder::CBitTreeEncoder<kNumMoveBits, kNumPosSlotBits> _posSlotEncoder[kNumLenToPosStates];
+
+  CMyBitEncoder _posEncoders[kNumFullDistances - kEndPosModelIndex];
+  NRangeCoder::CBitTreeEncoder<kNumMoveBits, kNumAlignBits> _posAlignEncoder;
+  
+  NLength::CPriceTableEncoder _lenEncoder;
+  NLength::CPriceTableEncoder _repMatchLenEncoder;
+
+  CLiteralEncoder _literalEncoder;
+
+  UInt32 _matchDistances[kMatchMaxLen + 1];
+
+  bool _fastMode;
+  bool _maxMode;
+  UInt32 _numFastBytes;
+  UInt32 _longestMatchLength;    
+
+  UInt32 _additionalOffset;
+
+  UInt32 _optimumEndIndex;
+  UInt32 _optimumCurrentIndex;
+
+  bool _longestMatchWasFound;
+
+  UInt32 _posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];
+  
+  UInt32 _distancesPrices[kNumLenToPosStates][kNumFullDistances];
+
+  UInt32 _alignPrices[kAlignTableSize];
+  UInt32 _alignPriceCount;
+
+  UInt32 _distTableSize;
+
+  UInt32 _posStateBits;
+  UInt32 _posStateMask;
+  UInt32 _numLiteralPosStateBits;
+  UInt32 _numLiteralContextBits;
+
+  UInt32 _dictionarySize;
+
+  UInt32 _dictionarySizePrev;
+  UInt32 _numFastBytesPrev;
+
+  UInt64 lastPosSlotFillingPos;
+  UInt64 nowPos64;
+  bool _finished;
+  ISequentialInStream *_inStream;
+
+  int _matchFinderIndex;
+  #ifdef COMPRESS_MF_MT
+  bool _multiThread;
+  #endif
+
+  bool _writeEndMark;
+
+  bool _needReleaseMFStream;
+  
+  HRESULT ReadMatchDistances(UInt32 &len);
+
+  HRESULT MovePos(UInt32 num);
+  UInt32 GetRepLen1Price(CState state, UInt32 posState) const
+  {
+    return _isRepG0[state.Index].GetPrice0() +
+        _isRep0Long[state.Index][posState].GetPrice0();
+  }
+  UInt32 GetRepPrice(UInt32 repIndex, UInt32 len, CState state, UInt32 posState) const
+  {
+    UInt32 price = _repMatchLenEncoder.GetPrice(len - kMatchMinLen, posState);
+    if(repIndex == 0)
+    {
+      price += _isRepG0[state.Index].GetPrice0();
+      price += _isRep0Long[state.Index][posState].GetPrice1();
+    }
+    else
+    {
+      price += _isRepG0[state.Index].GetPrice1();
+      if (repIndex == 1)
+        price += _isRepG1[state.Index].GetPrice0();
+      else
+      {
+        price += _isRepG1[state.Index].GetPrice1();
+        price += _isRepG2[state.Index].GetPrice(repIndex - 2);
+      }
+    }
+    return price;
+  }
+  /*
+  UInt32 GetPosLen2Price(UInt32 pos, UInt32 posState) const
+  {
+    if (pos >= kNumFullDistances)
+      return kIfinityPrice;
+    return _distancesPrices[0][pos] + _lenEncoder.GetPrice(0, posState);
+  }
+  UInt32 GetPosLen3Price(UInt32 pos, UInt32 len, UInt32 posState) const
+  {
+    UInt32 price;
+    UInt32 lenToPosState = GetLenToPosState(len);
+    if (pos < kNumFullDistances)
+      price = _distancesPrices[lenToPosState][pos];
+    else
+      price = _posSlotPrices[lenToPosState][GetPosSlot2(pos)] + 
+          _alignPrices[pos & kAlignMask];
+    return price + _lenEncoder.GetPrice(len - kMatchMinLen, posState);
+  }
+  */
+  UInt32 GetPosLenPrice(UInt32 pos, UInt32 len, UInt32 posState) const
+  {
+    if (len == 2 && pos >= 0x80)
+      return kIfinityPrice;
+    UInt32 price;
+    UInt32 lenToPosState = GetLenToPosState(len);
+    if (pos < kNumFullDistances)
+      price = _distancesPrices[lenToPosState][pos];
+    else
+      price = _posSlotPrices[lenToPosState][GetPosSlot2(pos)] + 
+          _alignPrices[pos & kAlignMask];
+    return price + _lenEncoder.GetPrice(len - kMatchMinLen, posState);
+  }
+
+  UInt32 Backward(UInt32 &backRes, UInt32 cur);
+  HRESULT GetOptimum(UInt32 position, UInt32 &backRes, UInt32 &lenRes);
+  HRESULT GetOptimumFast(UInt32 position, UInt32 &backRes, UInt32 &lenRes);
+
+  void FillPosSlotPrices();
+  void FillDistancesPrices();
+  void FillAlignPrices();
+    
+  void ReleaseMFStream()
+  {
+    if (_matchFinder && _needReleaseMFStream)
+    {
+      _matchFinder->ReleaseStream();
+      _needReleaseMFStream = false;
+    }
+  }
+
+  void ReleaseStreams()
+  {
+    ReleaseMFStream();
+    ReleaseOutStream();
+  }
+
+  HRESULT Flush(UInt32 nowPos);
+  class CCoderReleaser
+  {
+    CEncoder *_coder;
+  public:
+    CCoderReleaser(CEncoder *coder): _coder(coder) {}
+    ~CCoderReleaser()
+    {
+      _coder->ReleaseStreams();
+    }
+  };
+  friend class CCoderReleaser;
+
+  void WriteEndMarker(UInt32 posState);
+
+public:
+  CEncoder();
+  void SetWriteEndMarkerMode(bool writeEndMarker)
+    { _writeEndMark= writeEndMarker; }
+
+  HRESULT Create();
+
+  MY_UNKNOWN_IMP3(
+      ICompressSetOutStream,
+      ICompressSetCoderProperties,
+      ICompressWriteCoderProperties
+      )
+    
+  HRESULT Init();
+  
+  // ICompressCoder interface
+  HRESULT SetStreams(ISequentialInStream *inStream,
+      ISequentialOutStream *outStream,
+      const UInt64 *inSize, const UInt64 *outSize);
+  HRESULT CodeOneBlock(UInt64 *inSize, UInt64 *outSize, Int32 *finished);
+
+  HRESULT CodeReal(ISequentialInStream *inStream,
+      ISequentialOutStream *outStream, 
+      const UInt64 *inSize, const UInt64 *outSize,
+      ICompressProgressInfo *progress);
+
+  // ICompressCoder interface
+  STDMETHOD(Code)(ISequentialInStream *inStream,
+      ISequentialOutStream *outStream, 
+      const UInt64 *inSize, const UInt64 *outSize,
+      ICompressProgressInfo *progress);
+
+  // IInitMatchFinder interface
+  STDMETHOD(InitMatchFinder)(IMatchFinder *matchFinder);
+
+  // ICompressSetCoderProperties2
+  STDMETHOD(SetCoderProperties)(const PROPID *propIDs, 
+      const PROPVARIANT *properties, UInt32 numProperties);
+  
+  // ICompressWriteCoderProperties
+  STDMETHOD(WriteCoderProperties)(ISequentialOutStream *outStream);
+
+  STDMETHOD(SetOutStream)(ISequentialOutStream *outStream);
+  STDMETHOD(ReleaseOutStream)();
+
+  virtual ~CEncoder() {}
+};
+
+}}
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMA.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMA.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMA.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA/LZMA.h	2022-01-01 15:08:47.889171448 +0800
@@ -0,0 +1,82 @@
+// LZMA.h
+
+#ifndef __LZMA_H
+#define __LZMA_H
+
+namespace NCompress {
+namespace NLZMA {
+
+const UInt32 kNumRepDistances = 4;
+
+const int kNumStates = 12;
+
+const Byte kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
+const Byte kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
+const Byte kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
+const Byte kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};
+
+class CState
+{
+public:
+  Byte Index;
+  void Init() { Index = 0; }
+  void UpdateChar() { Index = kLiteralNextStates[Index]; }
+  void UpdateMatch() { Index = kMatchNextStates[Index]; }
+  void UpdateRep() { Index = kRepNextStates[Index]; }
+  void UpdateShortRep() { Index = kShortRepNextStates[Index]; }
+  bool IsCharState() const { return Index < 7; }
+};
+
+const int kNumPosSlotBits = 6; 
+const int kDicLogSizeMin = 0; 
+const int kDicLogSizeMax = 32; 
+const int kDistTableSizeMax = kDicLogSizeMax * 2; 
+
+const UInt32 kNumLenToPosStates = 4;
+
+inline UInt32 GetLenToPosState(UInt32 len)
+{
+  len -= 2;
+  if (len < kNumLenToPosStates)
+    return len;
+  return kNumLenToPosStates - 1;
+}
+
+namespace NLength {
+
+const int kNumPosStatesBitsMax = 4;
+const UInt32 kNumPosStatesMax = (1 << kNumPosStatesBitsMax);
+
+const int kNumPosStatesBitsEncodingMax = 4;
+const UInt32 kNumPosStatesEncodingMax = (1 << kNumPosStatesBitsEncodingMax);
+
+const int kNumLowBits = 3;
+const int kNumMidBits = 3;
+const int kNumHighBits = 8;
+const UInt32 kNumLowSymbols = 1 << kNumLowBits;
+const UInt32 kNumMidSymbols = 1 << kNumMidBits;
+const UInt32 kNumSymbolsTotal = kNumLowSymbols + kNumMidSymbols + (1 << kNumHighBits);
+
+}
+
+const UInt32 kMatchMinLen = 2;
+const UInt32 kMatchMaxLen = kMatchMinLen + NLength::kNumSymbolsTotal - 1;
+
+const int kNumAlignBits = 4;
+const UInt32 kAlignTableSize = 1 << kNumAlignBits;
+const UInt32 kAlignMask = (kAlignTableSize - 1);
+
+const UInt32 kStartPosModelIndex = 4;
+const UInt32 kEndPosModelIndex = 14;
+const UInt32 kNumPosModels = kEndPosModelIndex - kStartPosModelIndex;
+
+const UInt32 kNumFullDistances = 1 << (kEndPosModelIndex / 2);
+
+const int kNumLitPosStatesBitsEncodingMax = 4;
+const int kNumLitContextBitsMax = 8;
+
+const int kNumMoveBits = 5;
+
+}}
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA/StdAfx.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA/StdAfx.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA/StdAfx.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA/StdAfx.h	2022-01-01 15:08:47.893171448 +0800
@@ -0,0 +1,8 @@
+// StdAfx.h
+
+#ifndef __STDAFX_H
+#define __STDAFX_H
+
+#include "../../../Common/MyWindows.h"
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsp	2022-01-01 15:08:47.893171448 +0800
@@ -0,0 +1,523 @@
+# Microsoft Developer Studio Project File - Name="AloneLZMA" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=AloneLZMA - Win32 DebugU
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "AloneLZMA.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "AloneLZMA.mak" CFG="AloneLZMA - Win32 DebugU"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "AloneLZMA - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "AloneLZMA - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE "AloneLZMA - Win32 ReleaseU" (based on "Win32 (x86) Console Application")
+!MESSAGE "AloneLZMA - Win32 DebugU" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "AloneLZMA - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /I "..\..\..\\" /D "NDEBUG" /D "_MBCS" /D "WIN32" /D "_CONSOLE" /Yu"StdAfx.h" /FD /c
+# ADD BASE RSC /l 0x419 /d "NDEBUG"
+# ADD RSC /l 0x419 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:"c:\UTIL\lzma.exe" /opt:NOWIN98
+# SUBTRACT LINK32 /pdb:none
+
+!ELSEIF  "$(CFG)" == "AloneLZMA - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "..\..\..\\" /D "_DEBUG" /D "_MBCS" /D "WIN32" /D "_CONSOLE" /Yu"StdAfx.h" /FD /GZ /c
+# ADD BASE RSC /l 0x419 /d "_DEBUG"
+# ADD RSC /l 0x419 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:"c:\UTIL\lzma.exe" /pdbtype:sept
+
+!ELSEIF  "$(CFG)" == "AloneLZMA - Win32 ReleaseU"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "ReleaseU"
+# PROP BASE Intermediate_Dir "ReleaseU"
+# PROP BASE Ignore_Export_Lib 0
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "ReleaseU"
+# PROP Intermediate_Dir "ReleaseU"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MD /W3 /GX /O2 /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "EXCLUDE_COM" /D "NO_REGISTRY" /D "FORMAT_7Z" /D "FORMAT_BZIP2" /D "FORMAT_ZIP" /D "FORMAT_TAR" /D "FORMAT_GZIP" /D "COMPRESS_LZMA" /D "COMPRESS_BCJ_X86" /D "COMPRESS_BCJ2" /D "COMPRESS_COPY" /D "COMPRESS_MF_PAT" /D "COMPRESS_MF_BT" /D "COMPRESS_PPMD" /D "COMPRESS_DEFLATE" /D "COMPRESS_IMPLODE" /D "COMPRESS_BZIP2" /D "CRYPTO_ZIP" /Yu"StdAfx.h" /FD /c
+# ADD CPP /nologo /MD /W3 /GX /O2 /I "..\..\..\\" /D "NDEBUG" /D "UNICODE" /D "_UNICODE" /D "WIN32" /D "_CONSOLE" /Yu"StdAfx.h" /FD /c
+# ADD BASE RSC /l 0x419 /d "NDEBUG"
+# ADD RSC /l 0x419 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:"c:\UTIL\7za2.exe" /opt:NOWIN98
+# SUBTRACT BASE LINK32 /pdb:none
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:"c:\UTIL\lzma.exe" /opt:NOWIN98
+# SUBTRACT LINK32 /pdb:none
+
+!ELSEIF  "$(CFG)" == "AloneLZMA - Win32 DebugU"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "DebugU"
+# PROP BASE Intermediate_Dir "DebugU"
+# PROP BASE Ignore_Export_Lib 0
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "DebugU"
+# PROP Intermediate_Dir "DebugU"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "_DEBUG" /D "WIN32" /D "_CONSOLE" /D "EXCLUDE_COM" /D "NO_REGISTRY" /D "FORMAT_7Z" /D "FORMAT_BZIP2" /D "FORMAT_ZIP" /D "FORMAT_TAR" /D "FORMAT_GZIP" /D "COMPRESS_LZMA" /D "COMPRESS_BCJ_X86" /D "COMPRESS_BCJ2" /D "COMPRESS_COPY" /D "COMPRESS_MF_PAT" /D "COMPRESS_MF_BT" /D "COMPRESS_PPMD" /D "COMPRESS_DEFLATE" /D "COMPRESS_IMPLODE" /D "COMPRESS_BZIP2" /D "CRYPTO_ZIP" /D "_MBCS" /Yu"StdAfx.h" /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "..\..\..\\" /D "_DEBUG" /D "_UNICODE" /D "UNICODE" /D "WIN32" /D "_CONSOLE" /Yu"StdAfx.h" /FD /GZ /c
+# ADD BASE RSC /l 0x419 /d "_DEBUG"
+# ADD RSC /l 0x419 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:"c:\UTIL\7za2.exe" /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:"c:\UTIL\lzma.exe" /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "AloneLZMA - Win32 Release"
+# Name "AloneLZMA - Win32 Debug"
+# Name "AloneLZMA - Win32 ReleaseU"
+# Name "AloneLZMA - Win32 DebugU"
+# Begin Group "Spec"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\StdAfx.cpp
+# ADD CPP /Yc"StdAfx.h"
+# End Source File
+# Begin Source File
+
+SOURCE=.\StdAfx.h
+# End Source File
+# End Group
+# Begin Group "Compress"
+
+# PROP Default_Filter ""
+# Begin Group "LZMA"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\LZMA\LZMA.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZMA\LZMADecoder.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZMA\LZMADecoder.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZMA\LZMAEncoder.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZMA\LZMAEncoder.h
+# End Source File
+# End Group
+# Begin Group "RangeCoder"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\RangeCoder\RangeCoder.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\RangeCoder\RangeCoderBit.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\RangeCoder\RangeCoderBit.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\RangeCoder\RangeCoderBitTree.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\RangeCoder\RangeCoderOpt.h
+# End Source File
+# End Group
+# Begin Group "LZ"
+
+# PROP Default_Filter ""
+# Begin Group "Pat"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\LZ\Patricia\Pat.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\Patricia\Pat2.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\Patricia\Pat2H.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\Patricia\Pat2R.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\Patricia\Pat3H.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\Patricia\Pat4H.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\Patricia\PatMain.h
+# End Source File
+# End Group
+# Begin Group "BT"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\LZ\BinTree\BinTree.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\BinTree\BinTree2.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\BinTree\BinTree3.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\BinTree\BinTree3Z.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\BinTree\BinTree3ZMain.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\BinTree\BinTree4.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\BinTree\BinTree4b.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\BinTree\BinTreeMain.h
+# End Source File
+# End Group
+# Begin Group "HC"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\LZ\HashChain\HC.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\HashChain\HC2.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\HashChain\HC3.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\HashChain\HC4.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\HashChain\HC4b.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\HashChain\HCMain.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=..\LZ\IMatchFinder.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\LZInWindow.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\LZInWindow.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\LZOutWindow.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZ\LZOutWindow.h
+# End Source File
+# End Group
+# Begin Group "Branch"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\Branch\BranchX86.c
+# SUBTRACT CPP /YX /Yc /Yu
+# End Source File
+# Begin Source File
+
+SOURCE=..\Branch\BranchX86.h
+# End Source File
+# End Group
+# Begin Group "LZMA_C"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\LZMA_C\LzmaDecode.c
+# SUBTRACT CPP /YX /Yc /Yu
+# End Source File
+# Begin Source File
+
+SOURCE=..\LZMA_C\LzmaDecode.h
+# End Source File
+# End Group
+# End Group
+# Begin Group "Windows"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\..\Windows\FileIO.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Windows\FileIO.h
+# End Source File
+# End Group
+# Begin Group "Common"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\..\Common\Alloc.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\Alloc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\CommandLineParser.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\CommandLineParser.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\CRC.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\CRC.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\Defs.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Windows\Defs.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\MyCom.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\MyWindows.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\NewHandler.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\NewHandler.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\String.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\String.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\StringConvert.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\StringConvert.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\StringToInt.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\StringToInt.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\Types.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\Vector.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\Common\Vector.h
+# End Source File
+# End Group
+# Begin Group "7zip Common"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\Common\FileStreams.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Common\FileStreams.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Common\InBuffer.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Common\InBuffer.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Common\OutBuffer.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Common\OutBuffer.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Common\StreamUtils.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Common\StreamUtils.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=..\..\ICoder.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaAlone.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaBench.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaBench.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaRam.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaRam.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaRamDecode.c
+# SUBTRACT CPP /YX /Yc /Yu
+# End Source File
+# Begin Source File
+
+SOURCE=.\LzmaRamDecode.h
+# End Source File
+# End Target
+# End Project
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsw squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsw
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsw	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/AloneLZMA.dsw	2022-01-01 15:08:47.893171448 +0800
@@ -0,0 +1,29 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "AloneLZMA"=.\AloneLZMA.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaAlone.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaAlone.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaAlone.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaAlone.cpp	2022-01-01 15:08:47.893171448 +0800
@@ -0,0 +1,509 @@
+// LzmaAlone.cpp
+
+#include "StdAfx.h"
+
+#include "../../../Common/MyWindows.h"
+#include "../../../Common/MyInitGuid.h"
+
+#include <stdio.h>
+
+#if defined(_WIN32) || defined(OS2) || defined(MSDOS)
+#include <fcntl.h>
+#include <io.h>
+#define MY_SET_BINARY_MODE(file) setmode(fileno(file),O_BINARY)
+#else
+#define MY_SET_BINARY_MODE(file)
+#endif
+
+#include "../../../Common/CommandLineParser.h"
+#include "../../../Common/StringConvert.h"
+#include "../../../Common/StringToInt.h"
+
+#include "../../Common/FileStreams.h"
+#include "../../Common/StreamUtils.h"
+
+#include "../LZMA/LZMADecoder.h"
+#include "../LZMA/LZMAEncoder.h"
+
+#include "LzmaBench.h"
+#include "LzmaRam.h"
+
+extern "C"
+{
+#include "LzmaRamDecode.h"
+}
+
+using namespace NCommandLineParser;
+
+#ifdef _WIN32
+bool g_IsNT = false;
+static inline bool IsItWindowsNT()
+{
+  OSVERSIONINFO versionInfo;
+  versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);
+  if (!::GetVersionEx(&versionInfo)) 
+    return false;
+  return (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
+}
+#endif
+
+static const char *kCantAllocate = "Can not allocate memory";
+static const char *kReadError = "Read error";
+static const char *kWriteError = "Write error";
+
+namespace NKey {
+enum Enum
+{
+  kHelp1 = 0,
+  kHelp2,
+  kMode,
+  kDictionary,
+  kFastBytes,
+  kLitContext,
+  kLitPos,
+  kPosBits,
+  kMatchFinder,
+  kEOS,
+  kStdIn,
+  kStdOut,
+  kFilter86
+};
+}
+
+static const CSwitchForm kSwitchForms[] = 
+{
+  { L"?",  NSwitchType::kSimple, false },
+  { L"H",  NSwitchType::kSimple, false },
+  { L"A", NSwitchType::kUnLimitedPostString, false, 1 },
+  { L"D", NSwitchType::kUnLimitedPostString, false, 1 },
+  { L"FB", NSwitchType::kUnLimitedPostString, false, 1 },
+  { L"LC", NSwitchType::kUnLimitedPostString, false, 1 },
+  { L"LP", NSwitchType::kUnLimitedPostString, false, 1 },
+  { L"PB", NSwitchType::kUnLimitedPostString, false, 1 },
+  { L"MF", NSwitchType::kUnLimitedPostString, false, 1 },
+  { L"EOS", NSwitchType::kSimple, false },
+  { L"SI",  NSwitchType::kSimple, false },
+  { L"SO",  NSwitchType::kSimple, false },
+  { L"F86",  NSwitchType::kSimple, false }
+};
+
+static const int kNumSwitches = sizeof(kSwitchForms) / sizeof(kSwitchForms[0]);
+
+static void PrintHelp()
+{
+  fprintf(stderr, "\nUsage:  LZMA <e|d> inputFile outputFile [<switches>...]\n"
+             "  e: encode file\n"
+             "  d: decode file\n"
+             "  b: Benchmark\n"
+    "<Switches>\n"
+    "  -a{N}:  set compression mode - [0, 2], default: 2 (max)\n"
+    "  -d{N}:  set dictionary - [0,28], default: 23 (8MB)\n"
+    "  -fb{N}: set number of fast bytes - [5, 273], default: 128\n"
+    "  -lc{N}: set number of literal context bits - [0, 8], default: 3\n"
+    "  -lp{N}: set number of literal pos bits - [0, 4], default: 0\n"
+    "  -pb{N}: set number of pos bits - [0, 4], default: 2\n"
+    "  -mf{MF_ID}: set Match Finder: [bt2, bt3, bt4, bt4b, pat2r, pat2,\n"
+    "              pat2h, pat3h, pat4h, hc3, hc4], default: bt4\n"
+    "  -eos:   write End Of Stream marker\n"
+    "  -si:    read data from stdin\n"
+    "  -so:    write data to stdout\n"
+    );
+}
+
+static void PrintHelpAndExit(const char *s)
+{
+  fprintf(stderr, "\nError: %s\n\n", s);
+  PrintHelp();
+  throw -1;
+}
+
+static void IncorrectCommand()
+{
+  PrintHelpAndExit("Incorrect command");
+}
+
+static void WriteArgumentsToStringList(int numArguments, const char *arguments[], 
+    UStringVector &strings)
+{
+  for(int i = 1; i < numArguments; i++)
+    strings.Add(MultiByteToUnicodeString(arguments[i]));
+}
+
+static bool GetNumber(const wchar_t *s, UInt32 &value)
+{
+  value = 0;
+  if (MyStringLen(s) == 0)
+    return false;
+  const wchar_t *end;
+  UInt64 res = ConvertStringToUInt64(s, &end);
+  if (*end != L'\0')
+    return false;
+  if (res > 0xFFFFFFFF)
+    return false;
+  value = UInt32(res);
+  return true;
+}
+
+int main2(int n, const char *args[])
+{
+  #ifdef _WIN32
+  g_IsNT = IsItWindowsNT();
+  #endif
+
+  fprintf(stderr, "\nLZMA 4.32 Copyright (c) 1999-2005 Igor Pavlov  2005-12-09\n");
+
+  if (n == 1)
+  {
+    PrintHelp();
+    return 0;
+  }
+
+  if (sizeof(Byte) != 1 || sizeof(UInt32) < 4 || sizeof(UInt64) < 4)
+  {
+    fprintf(stderr, "Unsupported base types. Edit Common/Types.h and recompile");
+    return 1;
+  }   
+
+  UStringVector commandStrings;
+  WriteArgumentsToStringList(n, args, commandStrings);
+  CParser parser(kNumSwitches);
+  try
+  {
+    parser.ParseStrings(kSwitchForms, commandStrings);
+  }
+  catch(...) 
+  {
+    IncorrectCommand();
+  }
+
+  if(parser[NKey::kHelp1].ThereIs || parser[NKey::kHelp2].ThereIs)
+  {
+    PrintHelp();
+    return 0;
+  }
+  const UStringVector &nonSwitchStrings = parser.NonSwitchStrings;
+
+  int paramIndex = 0;
+  if (paramIndex >= nonSwitchStrings.Size())
+    IncorrectCommand();
+  const UString &command = nonSwitchStrings[paramIndex++]; 
+
+  bool dictionaryIsDefined = false;
+  UInt32 dictionary = 1 << 21;
+  if(parser[NKey::kDictionary].ThereIs)
+  {
+    UInt32 dicLog;
+    if (!GetNumber(parser[NKey::kDictionary].PostStrings[0], dicLog))
+      IncorrectCommand();
+    dictionary = 1 << dicLog;
+    dictionaryIsDefined = true;
+  }
+  UString mf = L"BT4";
+  if (parser[NKey::kMatchFinder].ThereIs)
+    mf = parser[NKey::kMatchFinder].PostStrings[0];
+
+  if (command.CompareNoCase(L"b") == 0)
+  {
+    const UInt32 kNumDefaultItereations = 10;
+    UInt32 numIterations = kNumDefaultItereations;
+    {
+      if (paramIndex < nonSwitchStrings.Size())
+        if (!GetNumber(nonSwitchStrings[paramIndex++], numIterations))
+          numIterations = kNumDefaultItereations;
+    }
+    return LzmaBenchmark(stderr, numIterations, dictionary, 
+        mf.CompareNoCase(L"BT4") == 0);
+  }
+
+  bool encodeMode = false;
+  if (command.CompareNoCase(L"e") == 0)
+    encodeMode = true;
+  else if (command.CompareNoCase(L"d") == 0)
+    encodeMode = false;
+  else
+    IncorrectCommand();
+
+  bool stdInMode = parser[NKey::kStdIn].ThereIs;
+  bool stdOutMode = parser[NKey::kStdOut].ThereIs;
+
+  CMyComPtr<ISequentialInStream> inStream;
+  CInFileStream *inStreamSpec = 0;
+  if (stdInMode)
+  {
+    inStream = new CStdInFileStream;
+    MY_SET_BINARY_MODE(stdin);
+  }
+  else
+  {
+    if (paramIndex >= nonSwitchStrings.Size())
+      IncorrectCommand();
+    const UString &inputName = nonSwitchStrings[paramIndex++]; 
+    inStreamSpec = new CInFileStream;
+    inStream = inStreamSpec;
+    if (!inStreamSpec->Open(GetSystemString(inputName)))
+    {
+      fprintf(stderr, "\nError: can not open input file %s\n", 
+          (const char *)GetOemString(inputName));
+      return 1;
+    }
+  }
+
+  CMyComPtr<ISequentialOutStream> outStream;
+  if (stdOutMode)
+  {
+    outStream = new CStdOutFileStream;
+    MY_SET_BINARY_MODE(stdout);
+  }
+  else
+  {
+    if (paramIndex >= nonSwitchStrings.Size())
+      IncorrectCommand();
+    const UString &outputName = nonSwitchStrings[paramIndex++]; 
+    COutFileStream *outStreamSpec = new COutFileStream;
+    outStream = outStreamSpec;
+    if (!outStreamSpec->Create(GetSystemString(outputName), true))
+    {
+      fprintf(stderr, "\nError: can not open output file %s\n", 
+        (const char *)GetOemString(outputName));
+      return 1;
+    }
+  }
+
+  if (parser[NKey::kFilter86].ThereIs)
+  {
+    // -f86 switch is for x86 filtered mode: BCJ + LZMA.
+    if (parser[NKey::kEOS].ThereIs || stdInMode)
+      throw "Can not use stdin in this mode";
+    UInt64 fileSize;
+    inStreamSpec->File.GetLength(fileSize);
+    if (fileSize > 0xF0000000)
+      throw "File is too big";
+    UInt32 inSize = (UInt32)fileSize;
+    Byte *inBuffer = 0;
+    if (inSize != 0)
+    {
+      inBuffer = (Byte *)MyAlloc((size_t)inSize); 
+      if (inBuffer == 0)
+        throw kCantAllocate;
+    }
+    
+    UInt32 processedSize;
+    if (ReadStream(inStream, inBuffer, (UInt32)inSize, &processedSize) != S_OK)
+      throw "Can not read";
+    if ((UInt32)inSize != processedSize)
+      throw "Read size error";
+
+    Byte *outBuffer = 0;
+    size_t outSizeProcessed;
+    if (encodeMode)
+    {
+      // we allocate 105% of original size for output buffer
+      size_t outSize = (size_t)fileSize / 20 * 21 + (1 << 16);
+      if (outSize != 0)
+      {
+        outBuffer = (Byte *)MyAlloc((size_t)outSize); 
+        if (outBuffer == 0)
+          throw kCantAllocate;
+      }
+      if (!dictionaryIsDefined)
+        dictionary = 1 << 23;
+      int res = LzmaRamEncode(inBuffer, inSize, outBuffer, outSize, &outSizeProcessed, 
+          dictionary, SZ_FILTER_AUTO);
+      if (res != 0)
+      {
+        fprintf(stderr, "\nEncoder error = %d\n", (int)res);
+        return 1;
+      }
+    }
+    else
+    {
+      size_t outSize;
+      if (LzmaRamGetUncompressedSize(inBuffer, inSize, &outSize) != 0)
+        throw "data error";
+      if (outSize != 0)
+      {
+        outBuffer = (Byte *)MyAlloc(outSize); 
+        if (outBuffer == 0)
+          throw kCantAllocate;
+      }
+      int res = LzmaRamDecompress(inBuffer, inSize, outBuffer, outSize, &outSizeProcessed, malloc, free);
+      if (res != 0)
+        throw "LzmaDecoder error";
+    }
+    if (WriteStream(outStream, outBuffer, (UInt32)outSizeProcessed, &processedSize) != S_OK)
+      throw kWriteError;
+    MyFree(outBuffer);
+    MyFree(inBuffer);
+    return 0;
+  }
+
+
+  UInt64 fileSize;
+  if (encodeMode)
+  {
+    NCompress::NLZMA::CEncoder *encoderSpec = 
+      new NCompress::NLZMA::CEncoder;
+    CMyComPtr<ICompressCoder> encoder = encoderSpec;
+
+    if (!dictionaryIsDefined)
+      dictionary = 1 << 23;
+
+    UInt32 posStateBits = 2;
+    UInt32 litContextBits = 3; // for normal files
+    // UInt32 litContextBits = 0; // for 32-bit data
+    UInt32 litPosBits = 0;
+    // UInt32 litPosBits = 2; // for 32-bit data
+    UInt32 algorithm = 2;
+    UInt32 numFastBytes = 128;
+
+    bool eos = parser[NKey::kEOS].ThereIs || stdInMode;
+ 
+    if(parser[NKey::kMode].ThereIs)
+      if (!GetNumber(parser[NKey::kMode].PostStrings[0], algorithm))
+        IncorrectCommand();
+
+    if(parser[NKey::kFastBytes].ThereIs)
+      if (!GetNumber(parser[NKey::kFastBytes].PostStrings[0], numFastBytes))
+        IncorrectCommand();
+    if(parser[NKey::kLitContext].ThereIs)
+      if (!GetNumber(parser[NKey::kLitContext].PostStrings[0], litContextBits))
+        IncorrectCommand();
+    if(parser[NKey::kLitPos].ThereIs)
+      if (!GetNumber(parser[NKey::kLitPos].PostStrings[0], litPosBits))
+        IncorrectCommand();
+    if(parser[NKey::kPosBits].ThereIs)
+      if (!GetNumber(parser[NKey::kPosBits].PostStrings[0], posStateBits))
+        IncorrectCommand();
+
+    PROPID propIDs[] = 
+    {
+      NCoderPropID::kDictionarySize,
+      NCoderPropID::kPosStateBits,
+      NCoderPropID::kLitContextBits,
+      NCoderPropID::kLitPosBits,
+      NCoderPropID::kAlgorithm,
+      NCoderPropID::kNumFastBytes,
+      NCoderPropID::kMatchFinder,
+      NCoderPropID::kEndMarker
+    };
+    const int kNumProps = sizeof(propIDs) / sizeof(propIDs[0]);
+    /*
+    NWindows::NCOM::CPropVariant properties[kNumProps];
+    properties[0] = UInt32(dictionary);
+    properties[1] = UInt32(posStateBits);
+    properties[2] = UInt32(litContextBits);
+   
+    properties[3] = UInt32(litPosBits);
+    properties[4] = UInt32(algorithm);
+    properties[5] = UInt32(numFastBytes);
+    properties[6] = mf;
+    properties[7] = eos;
+    */
+    PROPVARIANT properties[kNumProps];
+    for (int p = 0; p < 6; p++)
+      properties[p].vt = VT_UI4;
+    properties[0].ulVal = UInt32(dictionary);
+    properties[1].ulVal = UInt32(posStateBits);
+    properties[2].ulVal = UInt32(litContextBits);
+    properties[3].ulVal = UInt32(litPosBits);
+    properties[4].ulVal = UInt32(algorithm);
+    properties[5].ulVal = UInt32(numFastBytes);
+    
+    properties[6].vt = VT_BSTR;
+    properties[6].bstrVal = (BSTR)(const wchar_t *)mf;
+
+    properties[7].vt = VT_BOOL;
+    properties[7].boolVal = eos ? VARIANT_TRUE : VARIANT_FALSE;
+
+    if (encoderSpec->SetCoderProperties(propIDs, properties, kNumProps) != S_OK)
+      IncorrectCommand();
+    encoderSpec->WriteCoderProperties(outStream);
+
+    if (eos || stdInMode)
+      fileSize = (UInt64)(Int64)-1;
+    else
+      inStreamSpec->File.GetLength(fileSize);
+
+    for (int i = 0; i < 8; i++)
+    {
+      Byte b = Byte(fileSize >> (8 * i));
+      if (outStream->Write(&b, 1, 0) != S_OK)
+      {
+        fprintf(stderr, kWriteError);
+        return 1;
+      }
+    }
+    HRESULT result = encoder->Code(inStream, outStream, 0, 0, 0);
+    if (result == E_OUTOFMEMORY)
+    {
+      fprintf(stderr, "\nError: Can not allocate memory\n");
+      return 1;
+    }   
+    else if (result != S_OK)
+    {
+      fprintf(stderr, "\nEncoder error = %X\n", (unsigned int)result);
+      return 1;
+    }   
+  }
+  else
+  {
+    NCompress::NLZMA::CDecoder *decoderSpec = 
+        new NCompress::NLZMA::CDecoder;
+    CMyComPtr<ICompressCoder> decoder = decoderSpec;
+    const UInt32 kPropertiesSize = 5;
+    Byte properties[kPropertiesSize];
+    UInt32 processedSize;
+    if (ReadStream(inStream, properties, kPropertiesSize, &processedSize) != S_OK)
+    {
+      fprintf(stderr, kReadError);
+      return 1;
+    }
+    if (processedSize != kPropertiesSize)
+    {
+      fprintf(stderr, kReadError);
+      return 1;
+    }
+    if (decoderSpec->SetDecoderProperties2(properties, kPropertiesSize) != S_OK)
+    {
+      fprintf(stderr, "SetDecoderProperties error");
+      return 1;
+    }
+    fileSize = 0;
+    for (int i = 0; i < 8; i++)
+    {
+      Byte b;
+      if (inStream->Read(&b, 1, &processedSize) != S_OK)
+      {
+        fprintf(stderr, kReadError);
+        return 1;
+      }
+      if (processedSize != 1)
+      {
+        fprintf(stderr, kReadError);
+        return 1;
+      }
+      fileSize |= ((UInt64)b) << (8 * i);
+    }
+    if (decoder->Code(inStream, outStream, 0, &fileSize, 0) != S_OK)
+    {
+      fprintf(stderr, "Decoder error");
+      return 1;
+    }   
+  }
+  return 0;
+}
+
+int main(int n, const char *args[])
+{
+  try { return main2(n, args); }
+  catch(const char *s) 
+  { 
+    fprintf(stderr, "\nError: %s\n", s);
+    return 1; 
+  }
+  catch(...) 
+  { 
+    fprintf(stderr, "\nError\n");
+    return 1; 
+  }
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaBench.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaBench.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaBench.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaBench.cpp	2022-01-01 15:08:47.893171448 +0800
@@ -0,0 +1,508 @@
+// LzmaBench.cpp
+
+#include "StdAfx.h"
+
+#include "LzmaBench.h"
+
+#ifndef _WIN32
+#include <time.h>
+#endif
+
+#include "../../../Common/CRC.h"
+#include "../LZMA/LZMADecoder.h"
+#include "../LZMA/LZMAEncoder.h"
+
+static const UInt32 kAdditionalSize = 
+#ifdef _WIN32_WCE
+(1 << 20);
+#else
+(6 << 20);
+#endif
+
+static const UInt32 kCompressedAdditionalSize = (1 << 10);
+static const UInt32 kMaxLzmaPropSize = 10;
+
+class CRandomGenerator
+{
+  UInt32 A1;
+  UInt32 A2;
+public:
+  CRandomGenerator() { Init(); }
+  void Init() { A1 = 362436069; A2 = 521288629;}
+  UInt32 GetRnd() 
+  {
+    return 
+      ((A1 = 36969 * (A1 & 0xffff) + (A1 >> 16)) << 16) ^
+      ((A2 = 18000 * (A2 & 0xffff) + (A2 >> 16)) );
+  }
+};
+
+class CBitRandomGenerator
+{
+  CRandomGenerator RG;
+  UInt32 Value;
+  int NumBits;
+public:
+  void Init()
+  {
+    Value = 0;
+    NumBits = 0;
+  }
+  UInt32 GetRnd(int numBits) 
+  {
+    if (NumBits > numBits)
+    {
+      UInt32 result = Value & ((1 << numBits) - 1);
+      Value >>= numBits;
+      NumBits -= numBits;
+      return result;
+    }
+    numBits -= NumBits;
+    UInt32 result = (Value << numBits);
+    Value = RG.GetRnd();
+    result |= Value & ((1 << numBits) - 1);
+    Value >>= numBits;
+    NumBits = 32 - numBits;
+    return result;
+  }
+};
+
+class CBenchRandomGenerator
+{
+  CBitRandomGenerator RG;
+  UInt32 Pos;
+public:
+  UInt32 BufferSize;
+  Byte *Buffer;
+  CBenchRandomGenerator(): Buffer(0) {} 
+  ~CBenchRandomGenerator() { delete []Buffer; }
+  void Init() { RG.Init(); }
+  void Set(UInt32 bufferSize) 
+  {
+    delete []Buffer;
+    Buffer = 0;
+    Buffer = new Byte[bufferSize];
+    Pos = 0;
+    BufferSize = bufferSize;
+  }
+  UInt32 GetRndBit() { return RG.GetRnd(1); }
+  /*
+  UInt32 GetLogRand(int maxLen)
+  {
+    UInt32 len = GetRnd() % (maxLen + 1);
+    return GetRnd() & ((1 << len) - 1);
+  }
+  */
+  UInt32 GetLogRandBits(int numBits)
+  {
+    UInt32 len = RG.GetRnd(numBits);
+    return RG.GetRnd(len);
+  }
+  UInt32 GetOffset()
+  {
+    if (GetRndBit() == 0)
+      return GetLogRandBits(4);
+    return (GetLogRandBits(4) << 10) | RG.GetRnd(10);
+  }
+  UInt32 GetLen()
+  {
+    if (GetRndBit() == 0)
+      return RG.GetRnd(2);
+    if (GetRndBit() == 0)
+      return 4 + RG.GetRnd(3);
+    return 12 + RG.GetRnd(4);
+  }
+  void Generate()
+  {
+    while(Pos < BufferSize)
+    {
+      if (GetRndBit() == 0 || Pos < 1)
+        Buffer[Pos++] = Byte(RG.GetRnd(8));
+      else
+      {
+        UInt32 offset = GetOffset();
+        while (offset >= Pos)
+          offset >>= 1;
+        offset += 1;
+        UInt32 len = 2 + GetLen();
+        for (UInt32 i = 0; i < len && Pos < BufferSize; i++, Pos++)
+          Buffer[Pos] = Buffer[Pos - offset];
+      }
+    }
+  }
+};
+
+class CBenchmarkInStream: 
+  public ISequentialInStream,
+  public CMyUnknownImp
+{
+  const Byte *Data;
+  UInt32 Pos;
+  UInt32 Size;
+public:
+  MY_UNKNOWN_IMP
+  void Init(const Byte *data, UInt32 size)
+  {
+    Data = data;
+    Size = size;
+    Pos = 0;
+  }
+  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
+};
+
+STDMETHODIMP CBenchmarkInStream::Read(void *data, UInt32 size, UInt32 *processedSize)
+{
+  UInt32 remain = Size - Pos;
+  if (size > remain)
+    size = remain;
+  for (UInt32 i = 0; i < size; i++)
+    ((Byte *)data)[i] = Data[Pos + i];
+  Pos += size;
+  if(processedSize != NULL)
+    *processedSize = size;
+  return S_OK;
+}
+  
+class CBenchmarkOutStream: 
+  public ISequentialOutStream,
+  public CMyUnknownImp
+{
+  UInt32 BufferSize;
+  FILE *_f;
+public:
+  UInt32 Pos;
+  Byte *Buffer;
+  CBenchmarkOutStream(): _f(0), Buffer(0) {} 
+  virtual ~CBenchmarkOutStream() { delete []Buffer; }
+  void Init(FILE *f, UInt32 bufferSize) 
+  {
+    delete []Buffer;
+    Buffer = 0;
+    Buffer = new Byte[bufferSize];
+    Pos = 0;
+    BufferSize = bufferSize;
+    _f = f;
+  }
+  MY_UNKNOWN_IMP
+  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
+};
+
+STDMETHODIMP CBenchmarkOutStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
+{
+  UInt32 i;
+  for (i = 0; i < size && Pos < BufferSize; i++)
+    Buffer[Pos++] = ((const Byte *)data)[i];
+  if(processedSize != NULL)
+    *processedSize = i;
+  if (i != size)
+  {
+    fprintf(_f, "\nERROR: Buffer is full\n");
+    return E_FAIL;
+  }
+  return S_OK;
+}
+  
+class CCrcOutStream: 
+  public ISequentialOutStream,
+  public CMyUnknownImp
+{
+public:
+  CCRC CRC;
+  MY_UNKNOWN_IMP
+  void Init() { CRC.Init(); }
+  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
+};
+
+STDMETHODIMP CCrcOutStream::Write(const void *data, UInt32 size, UInt32 *processedSize)
+{
+  CRC.Update(data, size);
+  if(processedSize != NULL)
+    *processedSize = size;
+  return S_OK;
+}
+  
+static UInt64 GetTimeCount()
+{
+  #ifdef _WIN32
+  LARGE_INTEGER value;
+  if (::QueryPerformanceCounter(&value))
+    return value.QuadPart;
+  return GetTickCount();
+  #else
+  return clock();
+  #endif 
+}
+
+static UInt64 GetFreq()
+{
+  #ifdef _WIN32
+  LARGE_INTEGER value;
+  if (::QueryPerformanceFrequency(&value))
+    return value.QuadPart;
+  return 1000;
+  #else
+  return CLOCKS_PER_SEC;
+  #endif 
+}
+
+struct CProgressInfo:
+  public ICompressProgressInfo,
+  public CMyUnknownImp
+{
+  UInt64 ApprovedStart;
+  UInt64 InSize;
+  UInt64 Time;
+  void Init()
+  {
+    InSize = 0;
+    Time = 0;
+  }
+  MY_UNKNOWN_IMP
+  STDMETHOD(SetRatioInfo)(const UInt64 *inSize, const UInt64 *outSize);
+};
+
+STDMETHODIMP CProgressInfo::SetRatioInfo(const UInt64 *inSize, const UInt64 *outSize)
+{
+  if (*inSize >= ApprovedStart && InSize == 0)
+  {
+    Time = ::GetTimeCount();
+    InSize = *inSize;
+  }
+  return S_OK;
+}
+
+static const int kSubBits = 8;
+
+static UInt32 GetLogSize(UInt32 size)
+{
+  for (int i = kSubBits; i < 32; i++)
+    for (UInt32 j = 0; j < (1 << kSubBits); j++)
+      if (size <= (((UInt32)1) << i) + (j << (i - kSubBits)))
+        return (i << kSubBits) + j;
+  return (32 << kSubBits);
+}
+
+static UInt64 MyMultDiv64(UInt64 value, UInt64 elapsedTime)
+{
+  UInt64 freq = GetFreq();
+  UInt64 elTime = elapsedTime;
+  while(freq > 1000000)
+  {
+    freq >>= 1;
+    elTime >>= 1;
+  }
+  if (elTime == 0)
+    elTime = 1;
+  return value * freq / elTime;
+}
+
+static UInt64 GetCompressRating(UInt32 dictionarySize, bool isBT4,
+    UInt64 elapsedTime, UInt64 size)
+{
+  UInt64 numCommandsForOne;
+  if (isBT4)
+  {
+    UInt64 t = GetLogSize(dictionarySize) - (19 << kSubBits);
+    numCommandsForOne = 2000 + ((t * t * 68) >> (2 * kSubBits));
+  }
+  else
+  {
+    UInt64 t = GetLogSize(dictionarySize) - (15 << kSubBits);
+    numCommandsForOne = 1500 + ((t * t * 41) >> (2 * kSubBits));
+  }
+  UInt64 numCommands = (UInt64)(size) * numCommandsForOne;
+  return MyMultDiv64(numCommands, elapsedTime);
+}
+
+static UInt64 GetDecompressRating(UInt64 elapsedTime, 
+    UInt64 outSize, UInt64 inSize)
+{
+  UInt64 numCommands = inSize * 250 + outSize * 21;
+  return MyMultDiv64(numCommands, elapsedTime);
+}
+
+/*
+static UInt64 GetTotalRating(
+    UInt32 dictionarySize, 
+    bool isBT4,
+    UInt64 elapsedTimeEn, UInt64 sizeEn,
+    UInt64 elapsedTimeDe, 
+    UInt64 inSizeDe, UInt64 outSizeDe)
+{
+  return (GetCompressRating(dictionarySize, isBT4, elapsedTimeEn, sizeEn) + 
+    GetDecompressRating(elapsedTimeDe, inSizeDe, outSizeDe)) / 2;
+}
+*/
+
+static void PrintRating(FILE *f, UInt64 rating)
+{
+  fprintf(f, "%5d MIPS", (unsigned int)(rating / 1000000));
+}
+
+static void PrintResults(
+    FILE *f, 
+    UInt32 dictionarySize,
+    bool isBT4,
+    UInt64 elapsedTime, 
+    UInt64 size, 
+    bool decompressMode, UInt64 secondSize)
+{
+  UInt64 speed = MyMultDiv64(size, elapsedTime);
+  fprintf(f, "%6d KB/s  ", (unsigned int)(speed / 1024));
+  UInt64 rating;
+  if (decompressMode)
+    rating = GetDecompressRating(elapsedTime, size, secondSize);
+  else
+    rating = GetCompressRating(dictionarySize, isBT4, elapsedTime, size);
+  PrintRating(f, rating);
+}
+
+static void ThrowError(FILE *f, HRESULT result, const char *s)
+{
+  fprintf(f, "\nError: ");
+  if (result == E_ABORT)
+    fprintf(f, "User break");
+  if (result == E_OUTOFMEMORY)
+    fprintf(f, "Can not allocate memory");
+  else
+    fprintf(f, s);
+  fprintf(f, "\n");
+}
+
+const wchar_t *bt2 = L"BT2";
+const wchar_t *bt4 = L"BT4";
+
+int LzmaBenchmark(FILE *f, UInt32 numIterations, UInt32 dictionarySize, bool isBT4)
+{
+  if (numIterations == 0)
+    return 0;
+  if (dictionarySize < (1 << 19) && isBT4 || dictionarySize < (1 << 15))
+  {
+    fprintf(f, "\nError: dictionary size for benchmark must be >= 19 (512 KB)\n");
+    return 1;
+  }
+  fprintf(f, "\n       Compressing                Decompressing\n\n");
+  NCompress::NLZMA::CEncoder *encoderSpec = new NCompress::NLZMA::CEncoder;
+  CMyComPtr<ICompressCoder> encoder = encoderSpec;
+
+  NCompress::NLZMA::CDecoder *decoderSpec = new NCompress::NLZMA::CDecoder;
+  CMyComPtr<ICompressCoder> decoder = decoderSpec;
+
+  CBenchmarkOutStream *propStreamSpec = new CBenchmarkOutStream;
+  CMyComPtr<ISequentialOutStream> propStream = propStreamSpec;
+  propStreamSpec->Init(f, kMaxLzmaPropSize);
+  
+  PROPID propIDs[] = 
+  { 
+    NCoderPropID::kDictionarySize,  
+    NCoderPropID::kMatchFinder  
+  };
+  const int kNumProps = sizeof(propIDs) / sizeof(propIDs[0]);
+  PROPVARIANT properties[kNumProps];
+  properties[0].vt = VT_UI4;
+  properties[0].ulVal = UInt32(dictionarySize);
+
+  properties[1].vt = VT_BSTR;
+  properties[1].bstrVal = isBT4 ? (BSTR)bt4: (BSTR)bt2;
+
+  const UInt32 kBufferSize = dictionarySize + kAdditionalSize;
+  const UInt32 kCompressedBufferSize = (kBufferSize / 2) + kCompressedAdditionalSize;
+
+  if (encoderSpec->SetCoderProperties(propIDs, properties, kNumProps) != S_OK)
+  {
+    fprintf(f, "\nError: Incorrect command\n");
+    return 1;
+  }
+  encoderSpec->WriteCoderProperties(propStream);
+
+  CBenchRandomGenerator rg;
+  rg.Init();
+  rg.Set(kBufferSize);
+  rg.Generate();
+  CCRC crc;
+  crc.Update(rg.Buffer, rg.BufferSize);
+
+  CProgressInfo *progressInfoSpec = new CProgressInfo;
+  CMyComPtr<ICompressProgressInfo> progressInfo = progressInfoSpec;
+
+  progressInfoSpec->ApprovedStart = dictionarySize;
+
+  UInt64 totalBenchSize = 0;
+  UInt64 totalEncodeTime = 0;
+  UInt64 totalDecodeTime = 0;
+  UInt64 totalCompressedSize = 0;
+
+  for (UInt32 i = 0; i < numIterations; i++)
+  {
+    progressInfoSpec->Init();
+    CBenchmarkInStream *inStreamSpec = new CBenchmarkInStream;
+    inStreamSpec->Init(rg.Buffer, rg.BufferSize);
+    CMyComPtr<ISequentialInStream> inStream = inStreamSpec;
+    CBenchmarkOutStream *outStreamSpec = new CBenchmarkOutStream;
+    outStreamSpec->Init(f, kCompressedBufferSize);
+    CMyComPtr<ISequentialOutStream> outStream = outStreamSpec;
+    HRESULT result = encoder->Code(inStream, outStream, 0, 0, progressInfo);
+    UInt64 encodeTime = ::GetTimeCount() - progressInfoSpec->Time;
+    UInt32 compressedSize = outStreamSpec->Pos;
+    if(result != S_OK)
+    {
+      ThrowError(f, result, "Encoder Error");
+      return 1;
+    }
+    if (progressInfoSpec->InSize == 0)
+    {
+      fprintf(f, "\nError: Internal ERROR 1282\n");
+      return 1;
+    }
+  
+    ///////////////////////
+    // Decompressing
+  
+    CCrcOutStream *crcOutStreamSpec = new CCrcOutStream;
+    CMyComPtr<ISequentialOutStream> crcOutStream = crcOutStreamSpec;
+    
+    UInt64 decodeTime;
+    for (int j = 0; j < 2; j++)
+    {
+      inStreamSpec->Init(outStreamSpec->Buffer, compressedSize);
+      crcOutStreamSpec->Init();
+      
+      if (decoderSpec->SetDecoderProperties2(propStreamSpec->Buffer, propStreamSpec->Pos) != S_OK)
+      {
+        fprintf(f, "\nError: Set Decoder Properties Error\n");
+        return 1;
+      }
+      UInt64 outSize = kBufferSize;
+      UInt64 startTime = ::GetTimeCount();
+      result = decoder->Code(inStream, crcOutStream, 0, &outSize, 0);
+      decodeTime = ::GetTimeCount() - startTime;
+      if(result != S_OK)
+      {
+        ThrowError(f, result, "Decode Error");
+        return 1;
+      }
+      if (crcOutStreamSpec->CRC.GetDigest() != crc.GetDigest())
+      {
+        fprintf(f, "\nError: CRC Error\n");
+        return 1;
+      }
+    }
+    UInt64 benchSize = kBufferSize - progressInfoSpec->InSize;
+    PrintResults(f, dictionarySize, isBT4, encodeTime, benchSize, false, 0);
+    fprintf(f, "     ");
+    PrintResults(f, dictionarySize, isBT4, decodeTime, kBufferSize, true, compressedSize);
+    fprintf(f, "\n");
+
+    totalBenchSize += benchSize;
+    totalEncodeTime += encodeTime;
+    totalDecodeTime += decodeTime;
+    totalCompressedSize += compressedSize;
+  }
+  fprintf(f, "---------------------------------------------------\n");
+  PrintResults(f, dictionarySize, isBT4, totalEncodeTime, totalBenchSize, false, 0);
+  fprintf(f, "     ");
+  PrintResults(f, dictionarySize, isBT4, totalDecodeTime, 
+      kBufferSize * numIterations, true, totalCompressedSize);
+  fprintf(f, "    Average\n");
+  return 0;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaBench.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaBench.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaBench.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaBench.h	2022-01-01 15:08:47.893171448 +0800
@@ -0,0 +1,11 @@
+// LzmaBench.h
+
+#ifndef __LzmaBench_h
+#define __LzmaBench_h
+
+#include <stdio.h>
+#include "../../../Common/Types.h"
+
+int LzmaBenchmark(FILE *f, UInt32 numIterations, UInt32 dictionarySize, bool isBT4);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRam.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRam.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRam.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRam.cpp	2022-01-01 15:08:47.893171448 +0800
@@ -0,0 +1,228 @@
+// LzmaRam.cpp
+
+#include "StdAfx.h"
+#include "../../../Common/Types.h"
+#include "../LZMA/LZMADecoder.h"
+#include "../LZMA/LZMAEncoder.h"
+#include "LzmaRam.h"
+
+extern "C"
+{
+#include "../Branch/BranchX86.h"
+}
+
+class CInStreamRam: 
+  public ISequentialInStream,
+  public CMyUnknownImp
+{
+  const Byte *Data;
+  size_t Size;
+  size_t Pos;
+public:
+  MY_UNKNOWN_IMP
+  void Init(const Byte *data, size_t size)
+  {
+    Data = data;
+    Size = size;
+    Pos = 0;
+  }
+  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize);
+};
+
+STDMETHODIMP CInStreamRam::Read(void *data, UInt32 size, UInt32 *processedSize)
+{
+  UInt32 remain = Size - Pos;
+  if (size > remain)
+    size = remain;
+  for (UInt32 i = 0; i < size; i++)
+    ((Byte *)data)[i] = Data[Pos + i];
+  Pos += size;
+  if(processedSize != NULL)
+    *processedSize = size;
+  return S_OK;
+}
+  
+class COutStreamRam: 
+  public ISequentialOutStream,
+  public CMyUnknownImp
+{
+  size_t Size;
+public:
+  Byte *Data;
+  size_t Pos;
+  bool Overflow;
+  void Init(Byte *data, size_t size)
+  {
+    Data = data;
+    Size = size;
+    Pos = 0;
+    Overflow = false;
+  }
+  void SetPos(size_t pos)
+  {
+    Overflow = false;
+    Pos = pos;
+  }
+  MY_UNKNOWN_IMP
+  HRESULT WriteByte(Byte b)
+  {
+    if (Pos >= Size)
+    {
+      Overflow = true;
+      return E_FAIL;
+    }
+    Data[Pos++] = b;
+    return S_OK;
+  }
+  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize);
+};
+
+STDMETHODIMP COutStreamRam::Write(const void *data, UInt32 size, UInt32 *processedSize)
+{
+  UInt32 i;
+  for (i = 0; i < size && Pos < Size; i++)
+    Data[Pos++] = ((const Byte *)data)[i];
+  if(processedSize != NULL)
+    *processedSize = i;
+  if (i != size)
+  {
+    Overflow = true;
+    return E_FAIL;
+  }
+  return S_OK;
+}
+  
+#define SZE_FAIL (1)
+#define SZE_OUTOFMEMORY (2)
+#define SZE_OUT_OVERFLOW (3)
+
+int LzmaRamEncode(
+    const Byte *inBuffer, size_t inSize, 
+    Byte *outBuffer, size_t outSize, size_t *outSizeProcessed, 
+    UInt32 dictionarySize, ESzFilterMode filterMode)
+{
+  #ifndef _NO_EXCEPTIONS
+  try { 
+  #endif
+
+  *outSizeProcessed = 0;
+  const size_t kIdSize = 1;
+  const size_t kLzmaPropsSize = 5;
+  const size_t kMinDestSize = kIdSize + kLzmaPropsSize + 8;
+  if (outSize < kMinDestSize)
+    return SZE_OUT_OVERFLOW;
+  NCompress::NLZMA::CEncoder *encoderSpec = new NCompress::NLZMA::CEncoder;
+  CMyComPtr<ICompressCoder> encoder = encoderSpec;
+
+  PROPID propIDs[] = 
+  { 
+    NCoderPropID::kAlgorithm,
+    NCoderPropID::kDictionarySize,  
+    NCoderPropID::kNumFastBytes,
+  };
+  const int kNumProps = sizeof(propIDs) / sizeof(propIDs[0]);
+  PROPVARIANT properties[kNumProps];
+  properties[0].vt = VT_UI4;
+  properties[1].vt = VT_UI4;
+  properties[2].vt = VT_UI4;
+  properties[0].ulVal = (UInt32)2;
+  properties[1].ulVal = (UInt32)dictionarySize;
+  properties[2].ulVal = (UInt32)64;
+
+  if (encoderSpec->SetCoderProperties(propIDs, properties, kNumProps) != S_OK)
+    return 1;
+  
+  COutStreamRam *outStreamSpec = new COutStreamRam;
+  if (outStreamSpec == 0)
+    return SZE_OUTOFMEMORY;
+  CMyComPtr<ISequentialOutStream> outStream = outStreamSpec;
+  CInStreamRam *inStreamSpec = new CInStreamRam;
+  if (inStreamSpec == 0)
+    return SZE_OUTOFMEMORY;
+  CMyComPtr<ISequentialInStream> inStream = inStreamSpec;
+
+  outStreamSpec->Init(outBuffer, outSize);
+  if (outStreamSpec->WriteByte(0) != S_OK)
+    return SZE_OUT_OVERFLOW;
+
+  if (encoderSpec->WriteCoderProperties(outStream) != S_OK)
+    return SZE_OUT_OVERFLOW;
+  if (outStreamSpec->Pos != kIdSize + kLzmaPropsSize)
+    return 1;
+  
+  int i;
+  for (i = 0; i < 8; i++)
+  {
+    UInt64 t = (UInt64)(inSize);
+    if (outStreamSpec->WriteByte((Byte)((t) >> (8 * i))) != S_OK)
+      return SZE_OUT_OVERFLOW;
+  }
+
+  Byte *filteredStream = 0;
+
+  bool useFilter = (filterMode != SZ_FILTER_NO);
+  if (useFilter)
+  {
+    if (inSize != 0)
+    {
+      filteredStream = (Byte *)MyAlloc(inSize);
+      if (filteredStream == 0)
+        return SZE_OUTOFMEMORY;
+      memmove(filteredStream, inBuffer, inSize);
+    }
+    UInt32 _prevMask;
+    UInt32 _prevPos;
+    x86_Convert_Init(_prevMask, _prevPos);
+    x86_Convert(filteredStream, (UInt32)inSize, 0, &_prevMask, &_prevPos, 1);
+  }
+  
+  UInt32 minSize = 0;
+  int numPasses = (filterMode == SZ_FILTER_AUTO) ? 3 : 1;
+  bool bestIsFiltered = false;
+  int mainResult = 0;
+  size_t startPos = outStreamSpec->Pos;
+  for (i = 0; i < numPasses; i++)
+  {
+    if (numPasses > 1 && i == numPasses - 1 && !bestIsFiltered)
+      break;
+    outStreamSpec->SetPos(startPos);
+    bool curModeIsFiltered = false;
+    if (useFilter && i == 0)
+      curModeIsFiltered = true;
+    if (numPasses > 1 && i == numPasses - 1)
+      curModeIsFiltered = true;
+
+    inStreamSpec->Init(curModeIsFiltered ? filteredStream : inBuffer, inSize);
+    
+    HRESULT lzmaResult = encoder->Code(inStream, outStream, 0, 0, 0);
+    
+    mainResult = 0;
+    if (lzmaResult == E_OUTOFMEMORY)
+    {
+      mainResult = SZE_OUTOFMEMORY;
+      break;
+    } 
+    if (i == 0 || outStreamSpec->Pos <= minSize)
+    {
+      minSize = outStreamSpec->Pos;
+      bestIsFiltered = curModeIsFiltered;
+    }
+    if (outStreamSpec->Overflow)
+      mainResult = SZE_OUT_OVERFLOW;
+    else if (lzmaResult != S_OK)
+    {
+      mainResult = SZE_FAIL;
+      break;
+    } 
+  }
+  *outSizeProcessed = outStreamSpec->Pos;
+  if (bestIsFiltered)
+    outBuffer[0] = 1;
+  if (useFilter)
+    MyFree(filteredStream);
+  return mainResult;
+  
+  #ifndef _NO_EXCEPTIONS
+  } catch(...) { return SZE_OUTOFMEMORY; }
+  #endif
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.c	2022-01-01 15:08:47.893171448 +0800
@@ -0,0 +1,79 @@
+/* LzmaRamDecode.c */
+
+#include "LzmaRamDecode.h"
+#ifdef _SZ_ONE_DIRECTORY
+#include "LzmaDecode.h"
+#include "BranchX86.h"
+#else
+#include "../LZMA_C/LzmaDecode.h"
+#include "../Branch/BranchX86.h"
+#endif
+
+#define LZMA_PROPS_SIZE 14
+#define LZMA_SIZE_OFFSET 6
+
+int LzmaRamGetUncompressedSize(
+    const unsigned char *inBuffer, 
+    size_t inSize, 
+    size_t *outSize)
+{
+  unsigned int i;
+  if (inSize < LZMA_PROPS_SIZE)
+    return 1;
+  *outSize = 0;
+  for(i = 0; i < sizeof(size_t); i++)
+    *outSize += ((size_t)inBuffer[LZMA_SIZE_OFFSET + i]) << (8 * i);
+  for(; i < 8; i++)
+    if (inBuffer[LZMA_SIZE_OFFSET + i] != 0)
+      return 1;
+  return 0;
+}
+
+#define SZE_DATA_ERROR (1)
+#define SZE_OUTOFMEMORY (2)
+
+int LzmaRamDecompress(
+    const unsigned char *inBuffer, 
+    size_t inSize,
+    unsigned char *outBuffer,
+    size_t outSize,
+    size_t *outSizeProcessed,
+    void * (*allocFunc)(size_t size), 
+    void (*freeFunc)(void *))
+{
+  CLzmaDecoderState state;  /* it's about 24 bytes structure, if int is 32-bit */
+  int result;
+  SizeT outSizeProcessedLoc;
+  SizeT inProcessed;
+  int useFilter;
+  
+  if (inSize < LZMA_PROPS_SIZE)
+    return 1;
+  useFilter = inBuffer[0];
+
+  *outSizeProcessed = 0;
+  if (useFilter > 1)
+    return 1;
+
+  if (LzmaDecodeProperties(&state.Properties, inBuffer + 1, LZMA_PROPERTIES_SIZE) != LZMA_RESULT_OK)
+    return 1;
+  state.Probs = (CProb *)allocFunc(LzmaGetNumProbs(&state.Properties) * sizeof(CProb));
+  if (state.Probs == 0)
+    return SZE_OUTOFMEMORY;
+  
+  result = LzmaDecode(&state,
+    inBuffer + LZMA_PROPS_SIZE, (SizeT)inSize - LZMA_PROPS_SIZE, &inProcessed,
+    outBuffer, (SizeT)outSize, &outSizeProcessedLoc);
+  freeFunc(state.Probs);
+  if (result != LZMA_RESULT_OK)
+    return 1;
+  *outSizeProcessed = (size_t)outSizeProcessedLoc;
+  if (useFilter == 1)
+  {
+    UInt32 _prevMask;
+    UInt32 _prevPos;
+    x86_Convert_Init(_prevMask, _prevPos);
+    x86_Convert(outBuffer, (UInt32)outSizeProcessedLoc, 0, &_prevMask, &_prevPos, 0);
+  }
+  return 0;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRamDecode.h	2022-01-01 15:08:47.893171448 +0800
@@ -0,0 +1,55 @@
+/* LzmaRamDecode.h */
+
+#ifndef __LzmaRamDecode_h
+#define __LzmaRamDecode_h
+
+#include <stdlib.h>
+
+/*
+LzmaRamGetUncompressedSize:
+  In: 
+    inBuffer - input data
+    inSize   - input data size
+  Out: 
+    outSize  - uncompressed size
+  Return code:
+    0 - OK
+    1 - Error in headers
+*/
+
+int LzmaRamGetUncompressedSize(
+    const unsigned char *inBuffer, 
+    size_t inSize,
+    size_t *outSize);
+
+
+/*
+LzmaRamDecompress:
+  In: 
+    inBuffer  - input data
+    inSize    - input data size
+    outBuffer - output data
+    outSize   - output size
+    allocFunc - alloc function (can be malloc)
+    freeFunc  - free function (can be free)
+  Out: 
+    outSizeProcessed - processed size
+  Return code:
+    0 - OK
+    1 - Error in headers / data stream
+    2 - Memory allocating error
+
+Memory requirements depend from properties of LZMA stream.
+With default lzma settings it's about 16 KB.
+*/
+
+int LzmaRamDecompress(
+    const unsigned char *inBuffer, 
+    size_t inSize,
+    unsigned char *outBuffer,
+    size_t outSize,
+    size_t *outSizeProcessed,
+    void * (*allocFunc)(size_t size), 
+    void (*freeFunc)(void *));
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRam.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRam.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRam.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/LzmaRam.h	2022-01-01 15:08:47.893171448 +0800
@@ -0,0 +1,46 @@
+// LzmaRam.h
+
+#ifndef __LzmaRam_h
+#define __LzmaRam_h
+
+#include <stdlib.h>
+#include "../../../Common/Types.h"
+
+/*
+LzmaRamEncode: BCJ + LZMA RAM->RAM compressing.
+It uses .lzma format, but it writes one additional byte to .lzma file:
+  0: - no filter
+  1: - x86(BCJ) filter.
+
+To provide best compression ratio dictionarySize mustbe >= inSize
+
+LzmaRamEncode allocates Data with MyAlloc/BigAlloc functions.
+RAM Requirements:
+  RamSize = dictionarySize * 9.5 + 6MB + FilterBlockSize 
+    FilterBlockSize = 0, if useFilter == false
+    FilterBlockSize = inSize, if useFilter == true
+
+  Return code:
+    0 - OK
+    1 - Unspecified Error
+    2 - Memory allocating error
+    3 - Output buffer OVERFLOW
+
+If you use SZ_FILTER_AUTO mode, then encoder will use 2 or 3 passes:
+  2 passes when FILTER_NO provides better compression.
+  3 passes when FILTER_YES provides better compression.
+*/
+
+enum ESzFilterMode 
+{
+  SZ_FILTER_NO,
+  SZ_FILTER_YES,
+  SZ_FILTER_AUTO
+};
+
+int LzmaRamEncode(
+    const Byte *inBuffer, size_t inSize, 
+    Byte *outBuffer, size_t outSize, size_t *outSizeProcessed, 
+    UInt32 dictionarySize, ESzFilterMode filterMode);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/makefile squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/makefile
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/makefile	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/makefile	2022-01-01 15:08:47.893171448 +0800
@@ -0,0 +1,100 @@
+PROG = lzma.exe
+CFLAGS = $(CFLAGS) -I ../../../
+LIBS = $(LIBS) oleaut32.lib user32.lib
+
+!IFNDEF O
+!IFDEF CPU
+O=$(CPU)
+!ELSE
+O=O
+!ENDIF
+!ENDIF
+
+CFLAGS = $(CFLAGS) -nologo -EHsc -c -Fo$O/ -GS- 
+CFLAGS_O1 = $(CFLAGS) -O1
+CFLAGS_O2 = $(CFLAGS) -O2
+
+LFLAGS = $(LFLAGS) -nologo -OPT:NOWIN98
+
+PROGPATH = $O\$(PROG)
+
+COMPL_O1   = $(CPP) $(CFLAGS_O1) $**
+COMPL_O2   = $(CPP) $(CFLAGS_O2) $**
+COMPL      = $(CPP) $(CFLAGS_O1) $**
+
+
+LZMA_OBJS = \
+  $O\LzmaAlone.obj \
+  $O\LzmaBench.obj \
+  $O\LzmaRam.obj \
+
+LZMA_OPT_OBJS = \
+  $O\LZMADecoder.obj \
+  $O\LZMAEncoder.obj \
+
+COMMON_OBJS = \
+  $O\Alloc.obj \
+  $O\CRC.obj \
+  $O\CommandLineParser.obj \
+  $O\String.obj \
+  $O\StringConvert.obj \
+  $O\StringToInt.obj \
+  $O\Vector.obj
+
+7ZIP_COMMON_OBJS = \
+  $O\InBuffer.obj \
+  $O\OutBuffer.obj \
+  $O\StreamUtils.obj \
+
+LZ_OBJS = \
+  $O\LZInWindow.obj \
+  $O\LZOutWindow.obj \
+
+
+OBJS = \
+  $(LZMA_OBJS) \
+  $(LZMA_OPT_OBJS) \
+  $(COMMON_OBJS) \
+  $(7ZIP_COMMON_OBJS) \
+  $(LZ_OBJS) \
+  $O\LzmaRamDecode.obj \
+  $O\LzmaDecode.obj \
+  $O\FileStreams.obj \
+  $O\FileIO.obj \
+  $O\RangeCoderBit.obj \
+  $O\BranchX86.obj \
+
+all: $(PROGPATH) 
+
+clean:
+	-del /Q $(PROGPATH) $O\*.exe $O\*.dll $O\*.obj $O\*.lib $O\*.exp $O\*.res $O\*.pch 
+
+$O:
+	if not exist "$O" mkdir "$O"
+
+$(PROGPATH): $O $(OBJS)
+	link $(LFLAGS) -out:$(PROGPATH) $(OBJS) $(LIBS)
+
+
+$(LZMA_OBJS): $(*B).cpp
+	$(COMPL)
+$(LZMA_OPT_OBJS): ../LZMA/$(*B).cpp
+	$(COMPL_O2)
+$(COMMON_OBJS): ../../../Common/$(*B).cpp
+	$(COMPL)
+$(7ZIP_COMMON_OBJS): ../../Common/$(*B).cpp
+	$(COMPL)
+$(LZ_OBJS): ../LZ/$(*B).cpp
+	$(COMPL)
+$O\RangeCoderBit.obj: ../RangeCoder/$(*B).cpp
+	$(COMPL)
+$O\LzmaRamDecode.obj: LzmaRamDecode.c
+	$(COMPL_O1)
+$O\LzmaDecode.obj: ../LZMA_C/LzmaDecode.c
+	$(COMPL_O2)
+$O\BranchX86.obj: ../Branch/BranchX86.c
+	$(COMPL_O2)
+$O\FileStreams.obj: ../../Common/FileStreams.cpp
+	$(COMPL)
+$O\FileIO.obj: ../../../Windows/FileIO.cpp
+	$(COMPL)
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/makefile.gcc squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/makefile.gcc
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/makefile.gcc	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/makefile.gcc	2022-01-01 15:08:47.893171448 +0800
@@ -0,0 +1,113 @@
+PROG = lzma
+CXX = g++ -O2 -Wall
+CXX_C = gcc -O2 -Wall
+LIB = -lm
+RM = rm -f
+CFLAGS = -c -I ../../../
+
+OBJS = \
+  LzmaAlone.o \
+  LzmaBench.o \
+  LzmaRam.o \
+  LzmaRamDecode.o \
+  LzmaDecode.o \
+  BranchX86.o \
+  LZMADecoder.o \
+  LZMAEncoder.o \
+  LZInWindow.o \
+  LZOutWindow.o \
+  RangeCoderBit.o \
+  InBuffer.o \
+  OutBuffer.o \
+  FileStreams.o \
+  StreamUtils.o \
+  Alloc.o \
+  C_FileIO.o \
+  CommandLineParser.o \
+  CRC.o \
+  String.o \
+  StringConvert.o \
+  StringToInt.o \
+  Vector.o \
+
+
+all: $(PROG)
+
+$(PROG): $(OBJS)
+	$(CXX) -o $(PROG) $(LDFLAGS) $(OBJS) $(LIB)
+
+LzmaAlone.o: LzmaAlone.cpp
+	$(CXX) $(CFLAGS) LzmaAlone.cpp
+
+LzmaBench.o: LzmaBench.cpp
+	$(CXX) $(CFLAGS) LzmaBench.cpp
+
+LzmaRam.o: LzmaRam.cpp
+	$(CXX) $(CFLAGS) LzmaRam.cpp
+
+LzmaRamDecode.o: LzmaRamDecode.c
+	$(CXX_C) $(CFLAGS) LzmaRamDecode.c
+
+LzmaDecode.o: ../LZMA_C/LzmaDecode.c
+	$(CXX_C) $(CFLAGS) ../LZMA_C/LzmaDecode.c
+
+BranchX86.o: ../Branch/BranchX86.c
+	$(CXX_C) $(CFLAGS) ../Branch/BranchX86.c
+
+LZMADecoder.o: ../LZMA/LZMADecoder.cpp
+	$(CXX) $(CFLAGS) ../LZMA/LZMADecoder.cpp
+
+LZMAEncoder.o: ../LZMA/LZMAEncoder.cpp
+	$(CXX) $(CFLAGS) ../LZMA/LZMAEncoder.cpp
+
+LZInWindow.o: ../LZ/LZInWindow.cpp
+	$(CXX) $(CFLAGS) ../LZ/LZInWindow.cpp
+
+LZOutWindow.o: ../LZ/LZOutWindow.cpp
+	$(CXX) $(CFLAGS) ../LZ/LZOutWindow.cpp
+
+RangeCoderBit.o: ../RangeCoder/RangeCoderBit.cpp
+	$(CXX) $(CFLAGS) ../RangeCoder/RangeCoderBit.cpp
+
+InBuffer.o: ../../Common/InBuffer.cpp
+	$(CXX) $(CFLAGS) ../../Common/InBuffer.cpp
+
+OutBuffer.o: ../../Common/OutBuffer.cpp
+	$(CXX) $(CFLAGS) ../../Common/OutBuffer.cpp
+
+FileStreams.o: ../../Common/FileStreams.cpp
+	$(CXX) $(CFLAGS) ../../Common/FileStreams.cpp
+
+StreamUtils.o: ../../Common/StreamUtils.cpp
+	$(CXX) $(CFLAGS) ../../Common/StreamUtils.cpp
+
+Alloc.o: ../../../Common/Alloc.cpp
+	$(CXX) $(CFLAGS) ../../../Common/Alloc.cpp
+
+C_FileIO.o: ../../../Common/C_FileIO.cpp
+	$(CXX) $(CFLAGS) ../../../Common/C_FileIO.cpp
+
+CommandLineParser.o: ../../../Common/CommandLineParser.cpp
+	$(CXX) $(CFLAGS) ../../../Common/CommandLineParser.cpp
+
+CRC.o: ../../../Common/CRC.cpp
+	$(CXX) $(CFLAGS) ../../../Common/CRC.cpp
+
+MyWindows.o: ../../../Common/MyWindows.cpp
+	$(CXX) $(CFLAGS) ../../../Common/MyWindows.cpp
+
+String.o: ../../../Common/String.cpp
+	$(CXX) $(CFLAGS) ../../../Common/String.cpp
+
+StringConvert.o: ../../../Common/StringConvert.cpp
+	$(CXX) $(CFLAGS) ../../../Common/StringConvert.cpp
+
+StringToInt.o: ../../../Common/StringToInt.cpp
+	$(CXX) $(CFLAGS) ../../../Common/StringToInt.cpp
+
+Vector.o: ../../../Common/Vector.cpp
+	$(CXX) $(CFLAGS) ../../../Common/Vector.cpp
+
+clean:
+	-$(RM) $(PROG) $(OBJS)
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/StdAfx.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/StdAfx.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/StdAfx.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/StdAfx.cpp	2022-01-01 15:08:47.893171448 +0800
@@ -0,0 +1,3 @@
+// StdAfx.cpp
+
+#include "StdAfx.h"
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/StdAfx.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/StdAfx.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/StdAfx.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Alone/StdAfx.h	2022-01-01 15:08:47.893171448 +0800
@@ -0,0 +1,8 @@
+// StdAfx.h
+
+#ifndef __STDAFX_H
+#define __STDAFX_H
+
+#include "../../../Common/MyWindows.h"
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaDecode.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaDecode.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaDecode.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaDecode.c	2022-01-01 15:08:47.893171448 +0800
@@ -0,0 +1,588 @@
+/*
+  LzmaDecode.c
+  LZMA Decoder (optimized for Speed version)
+  
+  LZMA SDK 4.22 Copyright (c) 1999-2005 Igor Pavlov (2005-06-10)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this Code, expressly permits you to 
+  statically or dynamically link your Code (or bind by name) to the 
+  interfaces of this file without subjecting your linked Code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#include "LzmaDecode.h"
+
+#ifndef Byte
+#define Byte unsigned char
+#endif
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*Buffer++)
+
+#define RC_INIT2 Code = 0; Range = 0xFFFFFFFF; \
+  { int i; for(i = 0; i < 5; i++) { RC_TEST; Code = (Code << 8) | RC_READ_BYTE; }}
+
+#ifdef _LZMA_IN_CB
+
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) return result; \
+  BufferLim = Buffer + size; if (size == 0) return LZMA_RESULT_DATA_ERROR; }}
+
+#define RC_INIT Buffer = BufferLim = 0; RC_INIT2
+
+#else
+
+#define RC_TEST { if (Buffer == BufferLim) return LZMA_RESULT_DATA_ERROR; }
+
+#define RC_INIT(buffer, bufferSize) Buffer = buffer; BufferLim = buffer + bufferSize; RC_INIT2
+ 
+#endif
+
+#define RC_NORMALIZE if (Range < kTopValue) { RC_TEST; Range <<= 8; Code = (Code << 8) | RC_READ_BYTE; }
+
+#define IfBit0(p) RC_NORMALIZE; bound = (Range >> kNumBitModelTotalBits) * *(p); if (Code < bound)
+#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) >> kNumMoveBits;
+#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) >> kNumMoveBits;
+
+#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
+  { UpdateBit0(p); mi <<= 1; A0; } else \
+  { UpdateBit1(p); mi = (mi + mi) + 1; A1; } 
+  
+#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)               
+
+#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
+  { int i = numLevels; res = 1; \
+  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
+  res -= (1 << numLevels); }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+{
+  unsigned char prop0;
+  if (size < LZMA_PROPERTIES_SIZE)
+    return LZMA_RESULT_DATA_ERROR;
+  prop0 = propsData[0];
+  if (prop0 >= (9 * 5 * 5))
+    return LZMA_RESULT_DATA_ERROR;
+  {
+    for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5));
+    for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9);
+    propsRes->lc = prop0;
+    /*
+    unsigned char remainder = (unsigned char)(prop0 / 9);
+    propsRes->lc = prop0 % 9;
+    propsRes->pb = remainder / 5;
+    propsRes->lp = remainder % 5;
+    */
+  }
+
+  #ifdef _LZMA_OUT_READ
+  {
+    int i;
+    propsRes->DictionarySize = 0;
+    for (i = 0; i < 4; i++)
+      propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
+    if (propsRes->DictionarySize == 0)
+      propsRes->DictionarySize = 1;
+  }
+  #endif
+  return LZMA_RESULT_OK;
+}
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *InCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
+{
+  CProb *p = vs->Probs;
+  SizeT nowPos = 0;
+  Byte previousByte = 0;
+  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
+  int lc = vs->Properties.lc;
+
+  #ifdef _LZMA_OUT_READ
+  
+  UInt32 Range = vs->Range;
+  UInt32 Code = vs->Code;
+  #ifdef _LZMA_IN_CB
+  const Byte *Buffer = vs->Buffer;
+  const Byte *BufferLim = vs->BufferLim;
+  #else
+  const Byte *Buffer = inStream;
+  const Byte *BufferLim = inStream + inSize;
+  #endif
+  int state = vs->State;
+  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
+  int len = vs->RemainLen;
+  UInt32 globalPos = vs->GlobalPos;
+  UInt32 distanceLimit = vs->DistanceLimit;
+
+  Byte *dictionary = vs->Dictionary;
+  UInt32 dictionarySize = vs->Properties.DictionarySize;
+  UInt32 dictionaryPos = vs->DictionaryPos;
+
+  Byte tempDictionary[4];
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs->TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+      UInt32 i;
+      for (i = 0; i < numProbs; i++)
+        p[i] = kBitModelTotal >> 1; 
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      #ifdef _LZMA_IN_CB
+      RC_INIT;
+      #else
+      RC_INIT(inStream, inSize);
+      #endif
+    }
+    len = 0;
+  }
+  while(len != 0 && nowPos < outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos >= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  #else /* if !_LZMA_OUT_READ */
+
+  int state = 0;
+  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  int len = 0;
+  const Byte *Buffer;
+  const Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+
+  {
+    UInt32 i;
+    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+    for (i = 0; i < numProbs; i++)
+      p[i] = kBitModelTotal >> 1;
+  }
+  
+  #ifdef _LZMA_IN_CB
+  RC_INIT;
+  #else
+  RC_INIT(inStream, inSize);
+  #endif
+
+  #endif /* _LZMA_OUT_READ */
+
+  while(nowPos < outSize)
+  {
+    CProb *prob;
+    UInt32 bound;
+    int posState = (int)(
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & posStateMask);
+
+    prob = p + IsMatch + (state << kNumPosBitsMax) + posState;
+    IfBit0(prob)
+    {
+      int symbol = 1;
+      UpdateBit0(prob)
+      prob = p + Literal + (LZMA_LIT_SIZE * 
+        (((
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & literalPosMask) << lc) + (previousByte >> (8 - lc))));
+
+      if (state >= kNumLitStates)
+      {
+        int matchByte;
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        #else
+        matchByte = outStream[nowPos - rep0];
+        #endif
+        do
+        {
+          int bit;
+          CProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & 0x100);
+          probLit = prob + 0x100 + bit + symbol;
+          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
+        }
+        while (symbol < 0x100);
+      }
+      while (symbol < 0x100)
+      {
+        CProb *probLit = prob + symbol;
+        RC_GET_BIT(probLit, symbol)
+      }
+      previousByte = (Byte)symbol;
+
+      outStream[nowPos++] = previousByte;
+      #ifdef _LZMA_OUT_READ
+      if (distanceLimit < dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      #endif
+      if (state < 4) state = 0;
+      else if (state < 10) state -= 3;
+      else state -= 6;
+    }
+    else             
+    {
+      UpdateBit1(prob);
+      prob = p + IsRep + state;
+      IfBit0(prob)
+      {
+        UpdateBit0(prob);
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state < kNumLitStates ? 0 : 3;
+        prob = p + LenCoder;
+      }
+      else
+      {
+        UpdateBit1(prob);
+        prob = p + IsRepG0 + state;
+        IfBit0(prob)
+        {
+          UpdateBit0(prob);
+          prob = p + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IfBit0(prob)
+          {
+            #ifdef _LZMA_OUT_READ
+            UInt32 pos;
+            #endif
+            UpdateBit0(prob);
+            
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit == 0)
+            #else
+            if (nowPos == 0)
+            #endif
+              return LZMA_RESULT_DATA_ERROR;
+            
+            state = state < kNumLitStates ? 9 : 11;
+            #ifdef _LZMA_OUT_READ
+            pos = dictionaryPos - rep0;
+            if (pos >= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            #else
+            previousByte = outStream[nowPos - rep0];
+            #endif
+            outStream[nowPos++] = previousByte;
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit < dictionarySize)
+              distanceLimit++;
+            #endif
+
+            continue;
+          }
+          else
+          {
+            UpdateBit1(prob);
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          UpdateBit1(prob);
+          prob = p + IsRepG1 + state;
+          IfBit0(prob)
+          {
+            UpdateBit0(prob);
+            distance = rep1;
+          }
+          else 
+          {
+            UpdateBit1(prob);
+            prob = p + IsRepG2 + state;
+            IfBit0(prob)
+            {
+              UpdateBit0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UpdateBit1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state < kNumLitStates ? 8 : 11;
+        prob = p + RepLenCoder;
+      }
+      {
+        int numBits, offset;
+        CProb *probLen = prob + LenChoice;
+        IfBit0(probLen)
+        {
+          UpdateBit0(probLen);
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          numBits = kLenNumLowBits;
+        }
+        else
+        {
+          UpdateBit1(probLen);
+          probLen = prob + LenChoice2;
+          IfBit0(probLen)
+          {
+            UpdateBit0(probLen);
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            numBits = kLenNumMidBits;
+          }
+          else
+          {
+            UpdateBit1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            numBits = kLenNumHighBits;
+          }
+        }
+        RangeDecoderBitTreeDecode(probLen, numBits, len);
+        len += offset;
+      }
+
+      if (state < 4)
+      {
+        int posSlot;
+        state += kNumLitStates;
+        prob = p + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << 
+            kNumPosSlotBits);
+        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+          rep0 = (2 | ((UInt32)posSlot & 1));
+          if (posSlot < kEndPosModelIndex)
+          {
+            rep0 <<= numDirectBits;
+            prob = p + SpecPos + rep0 - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              RC_NORMALIZE
+              Range >>= 1;
+              rep0 <<= 1;
+              if (Code >= Range)
+              {
+                Code -= Range;
+                rep0 |= 1;
+              }
+            }
+            while (--numDirectBits != 0);
+            prob = p + Align;
+            rep0 <<= kNumAlignBits;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            int i = 1;
+            int mi = 1;
+            do
+            {
+              CProb *prob3 = prob + mi;
+              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
+              i <<= 1;
+            }
+            while(--numDirectBits != 0);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      #ifdef _LZMA_OUT_READ
+      if (rep0 > distanceLimit) 
+      #else
+      if (rep0 > nowPos)
+      #endif
+        return LZMA_RESULT_DATA_ERROR;
+
+      #ifdef _LZMA_OUT_READ
+      if (dictionarySize - distanceLimit > (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+      #endif
+
+      do
+      {
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        #else
+        previousByte = outStream[nowPos - rep0];
+        #endif
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 && nowPos < outSize);
+    }
+  }
+  RC_NORMALIZE;
+
+  #ifdef _LZMA_OUT_READ
+  vs->Range = Range;
+  vs->Code = Code;
+  vs->DictionaryPos = dictionaryPos;
+  vs->GlobalPos = globalPos + (UInt32)nowPos;
+  vs->DistanceLimit = distanceLimit;
+  vs->Reps[0] = rep0;
+  vs->Reps[1] = rep1;
+  vs->Reps[2] = rep2;
+  vs->Reps[3] = rep3;
+  vs->State = state;
+  vs->RemainLen = len;
+  vs->TempDictionary[0] = tempDictionary[0];
+  #endif
+
+  #ifdef _LZMA_IN_CB
+  vs->Buffer = Buffer;
+  vs->BufferLim = BufferLim;
+  #else
+  *inSizeProcessed = (SizeT)(Buffer - inStream);
+  #endif
+  *outSizeProcessed = nowPos;
+  return LZMA_RESULT_OK;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaDecode.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaDecode.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaDecode.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaDecode.h	2022-01-01 15:08:47.893171448 +0800
@@ -0,0 +1,131 @@
+/* 
+  LzmaDecode.h
+  LZMA Decoder interface
+
+  LZMA SDK 4.21 Copyright (c) 1999-2005 Igor Pavlov (2005-06-08)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifndef __LZMADECODE_H
+#define __LZMADECODE_H
+
+/* #define _LZMA_IN_CB */
+/* Use callback for input data */
+
+/* #define _LZMA_OUT_READ */
+/* Use read function for output data */
+
+/* #define _LZMA_PROB32 */
+/* It can increase speed on some 32-bit CPUs, 
+   but memory usage will be doubled in that case */
+
+/* #define _LZMA_LOC_OPT */
+/* Enable local speed optimizations inside code */
+
+/* #define _LZMA_SYSTEM_SIZE_T */
+/* Use system's size_t. You can use it to enable 64-bit sizes supporting*/
+
+#ifndef UInt32
+#ifdef _LZMA_UINT32_IS_ULONG
+#define UInt32 unsigned long
+#else
+#define UInt32 unsigned int
+#endif
+#endif
+
+#ifndef SizeT
+#ifdef _LZMA_SYSTEM_SIZE_T
+#include <stddef.h>
+#define SizeT size_t
+#else
+#define SizeT UInt32
+#endif
+#endif
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb unsigned short
+#endif
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+#ifdef _LZMA_IN_CB
+typedef struct _ILzmaInCallback
+{
+  int (*Read)(void *object, const unsigned char **buffer, SizeT *bufferSize);
+} ILzmaInCallback;
+#endif
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LZMA_PROPERTIES_SIZE 5
+
+typedef struct _CLzmaProperties
+{
+  int lc;
+  int lp;
+  int pb;
+  #ifdef _LZMA_OUT_READ
+  UInt32 DictionarySize;
+  #endif
+}CLzmaProperties;
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);
+
+#define LzmaGetNumProbs(Properties) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((Properties)->lc + (Properties)->lp)))
+
+#define kLzmaNeedInitId (-2)
+
+typedef struct _CLzmaDecoderState
+{
+  CLzmaProperties Properties;
+  CProb *Probs;
+
+  #ifdef _LZMA_IN_CB
+  const unsigned char *Buffer;
+  const unsigned char *BufferLim;
+  #endif
+
+  #ifdef _LZMA_OUT_READ
+  unsigned char *Dictionary;
+  UInt32 Range;
+  UInt32 Code;
+  UInt32 DictionaryPos;
+  UInt32 GlobalPos;
+  UInt32 DistanceLimit;
+  UInt32 Reps[4];
+  int State;
+  int RemainLen;
+  unsigned char TempDictionary[4];
+  #endif
+} CLzmaDecoderState;
+
+#ifdef _LZMA_OUT_READ
+#define LzmaDecoderInit(vs) { (vs)->RemainLen = kLzmaNeedInitId; }
+#endif
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *inCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaDecodeSize.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaDecodeSize.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaDecodeSize.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaDecodeSize.c	2022-01-01 15:08:47.893171448 +0800
@@ -0,0 +1,716 @@
+/*
+  LzmaDecodeSize.c
+  LZMA Decoder (optimized for Size version)
+  
+  LZMA SDK 4.27 Copyright (c) 1999-2005 Igor Pavlov (2005-08-07)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#include "LzmaDecode.h"
+
+#ifndef Byte
+#define Byte unsigned char
+#endif
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+typedef struct _CRangeDecoder
+{
+  const Byte *Buffer;
+  const Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+  #ifdef _LZMA_IN_CB
+  ILzmaInCallback *InCallback;
+  int Result;
+  #endif
+  int ExtraBytes;
+} CRangeDecoder;
+
+Byte RangeDecoderReadByte(CRangeDecoder *rd)
+{
+  if (rd->Buffer == rd->BufferLim)
+  {
+    #ifdef _LZMA_IN_CB
+    SizeT size;
+    rd->Result = rd->InCallback->Read(rd->InCallback, &rd->Buffer, &size);
+    rd->BufferLim = rd->Buffer + size;
+    if (size == 0)
+    #endif
+    {
+      rd->ExtraBytes = 1;
+      return 0xFF;
+    }
+  }
+  return (*rd->Buffer++);
+}
+
+/* #define ReadByte (*rd->Buffer++) */
+#define ReadByte (RangeDecoderReadByte(rd))
+
+void RangeDecoderInit(CRangeDecoder *rd
+  #ifndef _LZMA_IN_CB
+    , const Byte *stream, SizeT bufferSize
+  #endif
+    )
+{
+  int i;
+  #ifdef _LZMA_IN_CB
+  rd->Buffer = rd->BufferLim = 0;
+  #else
+  rd->Buffer = stream;
+  rd->BufferLim = stream + bufferSize;
+  #endif
+  rd->ExtraBytes = 0;
+  rd->Code = 0;
+  rd->Range = (0xFFFFFFFF);
+  for(i = 0; i < 5; i++)
+    rd->Code = (rd->Code << 8) | ReadByte;
+}
+
+#define RC_INIT_VAR UInt32 range = rd->Range; UInt32 code = rd->Code;        
+#define RC_FLUSH_VAR rd->Range = range; rd->Code = code;
+#define RC_NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | ReadByte; }
+
+UInt32 RangeDecoderDecodeDirectBits(CRangeDecoder *rd, int numTotalBits)
+{
+  RC_INIT_VAR
+  UInt32 result = 0;
+  int i;
+  for (i = numTotalBits; i != 0; i--)
+  {
+    /* UInt32 t; */
+    range >>= 1;
+
+    result <<= 1;
+    if (code >= range)
+    {
+      code -= range;
+      result |= 1;
+    }
+    /*
+    t = (code - range) >> 31;
+    t &= 1;
+    code -= range & (t - 1);
+    result = (result + result) | (1 - t);
+    */
+    RC_NORMALIZE
+  }
+  RC_FLUSH_VAR
+  return result;
+}
+
+int RangeDecoderBitDecode(CProb *prob, CRangeDecoder *rd)
+{
+  UInt32 bound = (rd->Range >> kNumBitModelTotalBits) * *prob;
+  if (rd->Code < bound)
+  {
+    rd->Range = bound;
+    *prob += (kBitModelTotal - *prob) >> kNumMoveBits;
+    if (rd->Range < kTopValue)
+    {
+      rd->Code = (rd->Code << 8) | ReadByte;
+      rd->Range <<= 8;
+    }
+    return 0;
+  }
+  else
+  {
+    rd->Range -= bound;
+    rd->Code -= bound;
+    *prob -= (*prob) >> kNumMoveBits;
+    if (rd->Range < kTopValue)
+    {
+      rd->Code = (rd->Code << 8) | ReadByte;
+      rd->Range <<= 8;
+    }
+    return 1;
+  }
+}
+
+#define RC_GET_BIT2(prob, mi, A0, A1) \
+  UInt32 bound = (range >> kNumBitModelTotalBits) * *prob; \
+  if (code < bound) \
+    { A0; range = bound; *prob += (kBitModelTotal - *prob) >> kNumMoveBits; mi <<= 1; } \
+  else \
+    { A1; range -= bound; code -= bound; *prob -= (*prob) >> kNumMoveBits; mi = (mi + mi) + 1; } \
+  RC_NORMALIZE
+
+#define RC_GET_BIT(prob, mi) RC_GET_BIT2(prob, mi, ; , ;)               
+
+int RangeDecoderBitTreeDecode(CProb *probs, int numLevels, CRangeDecoder *rd)
+{
+  int mi = 1;
+  int i;
+  #ifdef _LZMA_LOC_OPT
+  RC_INIT_VAR
+  #endif
+  for(i = numLevels; i != 0; i--)
+  {
+    #ifdef _LZMA_LOC_OPT
+    CProb *prob = probs + mi;
+    RC_GET_BIT(prob, mi)
+    #else
+    mi = (mi + mi) + RangeDecoderBitDecode(probs + mi, rd);
+    #endif
+  }
+  #ifdef _LZMA_LOC_OPT
+  RC_FLUSH_VAR
+  #endif
+  return mi - (1 << numLevels);
+}
+
+int RangeDecoderReverseBitTreeDecode(CProb *probs, int numLevels, CRangeDecoder *rd)
+{
+  int mi = 1;
+  int i;
+  int symbol = 0;
+  #ifdef _LZMA_LOC_OPT
+  RC_INIT_VAR
+  #endif
+  for(i = 0; i < numLevels; i++)
+  {
+    #ifdef _LZMA_LOC_OPT
+    CProb *prob = probs + mi;
+    RC_GET_BIT2(prob, mi, ; , symbol |= (1 << i))
+    #else
+    int bit = RangeDecoderBitDecode(probs + mi, rd);
+    mi = mi + mi + bit;
+    symbol |= (bit << i);
+    #endif
+  }
+  #ifdef _LZMA_LOC_OPT
+  RC_FLUSH_VAR
+  #endif
+  return symbol;
+}
+
+Byte LzmaLiteralDecode(CProb *probs, CRangeDecoder *rd)
+{ 
+  int symbol = 1;
+  #ifdef _LZMA_LOC_OPT
+  RC_INIT_VAR
+  #endif
+  do
+  {
+    #ifdef _LZMA_LOC_OPT
+    CProb *prob = probs + symbol;
+    RC_GET_BIT(prob, symbol)
+    #else
+    symbol = (symbol + symbol) | RangeDecoderBitDecode(probs + symbol, rd);
+    #endif
+  }
+  while (symbol < 0x100);
+  #ifdef _LZMA_LOC_OPT
+  RC_FLUSH_VAR
+  #endif
+  return symbol;
+}
+
+Byte LzmaLiteralDecodeMatch(CProb *probs, CRangeDecoder *rd, Byte matchByte)
+{ 
+  int symbol = 1;
+  #ifdef _LZMA_LOC_OPT
+  RC_INIT_VAR
+  #endif
+  do
+  {
+    int bit;
+    int matchBit = (matchByte >> 7) & 1;
+    matchByte <<= 1;
+    #ifdef _LZMA_LOC_OPT
+    {
+      CProb *prob = probs + 0x100 + (matchBit << 8) + symbol;
+      RC_GET_BIT2(prob, symbol, bit = 0, bit = 1)
+    }
+    #else
+    bit = RangeDecoderBitDecode(probs + 0x100 + (matchBit << 8) + symbol, rd);
+    symbol = (symbol << 1) | bit;
+    #endif
+    if (matchBit != bit)
+    {
+      while (symbol < 0x100)
+      {
+        #ifdef _LZMA_LOC_OPT
+        CProb *prob = probs + symbol;
+        RC_GET_BIT(prob, symbol)
+        #else
+        symbol = (symbol + symbol) | RangeDecoderBitDecode(probs + symbol, rd);
+        #endif
+      }
+      break;
+    }
+  }
+  while (symbol < 0x100);
+  #ifdef _LZMA_LOC_OPT
+  RC_FLUSH_VAR
+  #endif
+  return symbol;
+}
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+int LzmaLenDecode(CProb *p, CRangeDecoder *rd, int posState)
+{
+  if(RangeDecoderBitDecode(p + LenChoice, rd) == 0)
+    return RangeDecoderBitTreeDecode(p + LenLow +
+        (posState << kLenNumLowBits), kLenNumLowBits, rd);
+  if(RangeDecoderBitDecode(p + LenChoice2, rd) == 0)
+    return kLenNumLowSymbols + RangeDecoderBitTreeDecode(p + LenMid +
+        (posState << kLenNumMidBits), kLenNumMidBits, rd);
+  return kLenNumLowSymbols + kLenNumMidSymbols + 
+      RangeDecoderBitTreeDecode(p + LenHigh, kLenNumHighBits, rd);
+}
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+{
+  unsigned char prop0;
+  if (size < LZMA_PROPERTIES_SIZE)
+    return LZMA_RESULT_DATA_ERROR;
+  prop0 = propsData[0];
+  if (prop0 >= (9 * 5 * 5))
+    return LZMA_RESULT_DATA_ERROR;
+  {
+    for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5));
+    for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9);
+    propsRes->lc = prop0;
+    /*
+    unsigned char remainder = (unsigned char)(prop0 / 9);
+    propsRes->lc = prop0 % 9;
+    propsRes->pb = remainder / 5;
+    propsRes->lp = remainder % 5;
+    */
+  }
+
+  #ifdef _LZMA_OUT_READ
+  {
+    int i;
+    propsRes->DictionarySize = 0;
+    for (i = 0; i < 4; i++)
+      propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
+    if (propsRes->DictionarySize == 0)
+      propsRes->DictionarySize = 1;
+  }
+  #endif
+  return LZMA_RESULT_OK;
+}
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *InCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
+{
+  CProb *p = vs->Probs;
+  SizeT nowPos = 0;
+  Byte previousByte = 0;
+  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
+  int lc = vs->Properties.lc;
+  CRangeDecoder rd;
+
+  #ifdef _LZMA_OUT_READ
+  
+  int state = vs->State;
+  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
+  int len = vs->RemainLen;
+  UInt32 globalPos = vs->GlobalPos;
+  UInt32 distanceLimit = vs->DistanceLimit;
+
+  Byte *dictionary = vs->Dictionary;
+  UInt32 dictionarySize = vs->Properties.DictionarySize;
+  UInt32 dictionaryPos = vs->DictionaryPos;
+
+  Byte tempDictionary[4];
+
+  rd.Range = vs->Range;
+  rd.Code = vs->Code;
+  #ifdef _LZMA_IN_CB
+  rd.InCallback = InCallback;
+  rd.Buffer = vs->Buffer;
+  rd.BufferLim = vs->BufferLim;
+  #else
+  rd.Buffer = inStream;
+  rd.BufferLim = inStream + inSize;
+  #endif
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs->TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+      UInt32 i;
+      for (i = 0; i < numProbs; i++)
+        p[i] = kBitModelTotal >> 1; 
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      RangeDecoderInit(&rd
+          #ifndef _LZMA_IN_CB
+          , inStream, inSize
+          #endif
+          );
+      #ifdef _LZMA_IN_CB
+      if (rd.Result != LZMA_RESULT_OK)
+        return rd.Result;
+      #endif
+      if (rd.ExtraBytes != 0)
+        return LZMA_RESULT_DATA_ERROR;
+    }
+    len = 0;
+  }
+  while(len != 0 && nowPos < outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos >= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  #ifdef _LZMA_IN_CB
+  rd.Result = LZMA_RESULT_OK;
+  #endif
+  rd.ExtraBytes = 0;
+
+  #else /* if !_LZMA_OUT_READ */
+
+  int state = 0;
+  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  int len = 0;
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+
+  {
+    UInt32 i;
+    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+    for (i = 0; i < numProbs; i++)
+      p[i] = kBitModelTotal >> 1;
+  }
+  
+  #ifdef _LZMA_IN_CB
+  rd.InCallback = InCallback;
+  #endif
+  RangeDecoderInit(&rd
+      #ifndef _LZMA_IN_CB
+      , inStream, inSize
+      #endif
+      );
+
+  #ifdef _LZMA_IN_CB
+  if (rd.Result != LZMA_RESULT_OK)
+    return rd.Result;
+  #endif
+  if (rd.ExtraBytes != 0)
+    return LZMA_RESULT_DATA_ERROR;
+
+  #endif /* _LZMA_OUT_READ */
+
+
+  while(nowPos < outSize)
+  {
+    int posState = (int)(
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & posStateMask);
+    #ifdef _LZMA_IN_CB
+    if (rd.Result != LZMA_RESULT_OK)
+      return rd.Result;
+    #endif
+    if (rd.ExtraBytes != 0)
+      return LZMA_RESULT_DATA_ERROR;
+    if (RangeDecoderBitDecode(p + IsMatch + (state << kNumPosBitsMax) + posState, &rd) == 0)
+    {
+      CProb *probs = p + Literal + (LZMA_LIT_SIZE * 
+        (((
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & literalPosMask) << lc) + (previousByte >> (8 - lc))));
+
+      if (state >= kNumLitStates)
+      {
+        Byte matchByte;
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        #else
+        matchByte = outStream[nowPos - rep0];
+        #endif
+        previousByte = LzmaLiteralDecodeMatch(probs, &rd, matchByte);
+      }
+      else
+        previousByte = LzmaLiteralDecode(probs, &rd);
+      outStream[nowPos++] = previousByte;
+      #ifdef _LZMA_OUT_READ
+      if (distanceLimit < dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      #endif
+      if (state < 4) state = 0;
+      else if (state < 10) state -= 3;
+      else state -= 6;
+    }
+    else             
+    {
+      if (RangeDecoderBitDecode(p + IsRep + state, &rd) == 1)
+      {
+        if (RangeDecoderBitDecode(p + IsRepG0 + state, &rd) == 0)
+        {
+          if (RangeDecoderBitDecode(p + IsRep0Long + (state << kNumPosBitsMax) + posState, &rd) == 0)
+          {
+            #ifdef _LZMA_OUT_READ
+            UInt32 pos;
+            #endif
+      
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit == 0)
+            #else
+            if (nowPos == 0)
+            #endif
+              return LZMA_RESULT_DATA_ERROR;
+
+            state = state < 7 ? 9 : 11;
+            #ifdef _LZMA_OUT_READ
+            pos = dictionaryPos - rep0;
+            if (pos >= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            #else
+            previousByte = outStream[nowPos - rep0];
+            #endif
+            outStream[nowPos++] = previousByte;
+
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit < dictionarySize)
+              distanceLimit++;
+            #endif
+            continue;
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          if(RangeDecoderBitDecode(p + IsRepG1 + state, &rd) == 0)
+            distance = rep1;
+          else 
+          {
+            if(RangeDecoderBitDecode(p + IsRepG2 + state, &rd) == 0)
+              distance = rep2;
+            else
+            {
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        len = LzmaLenDecode(p + RepLenCoder, &rd, posState);
+        state = state < 7 ? 8 : 11;
+      }
+      else
+      {
+        int posSlot;
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state < 7 ? 7 : 10;
+        len = LzmaLenDecode(p + LenCoder, &rd, posState);
+        posSlot = RangeDecoderBitTreeDecode(p + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << 
+            kNumPosSlotBits), kNumPosSlotBits, &rd);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+          rep0 = ((2 | ((UInt32)posSlot & 1)) << numDirectBits);
+          if (posSlot < kEndPosModelIndex)
+          {
+            rep0 += RangeDecoderReverseBitTreeDecode(
+                p + SpecPos + rep0 - posSlot - 1, numDirectBits, &rd);
+          }
+          else
+          {
+            rep0 += RangeDecoderDecodeDirectBits(&rd, 
+                numDirectBits - kNumAlignBits) << kNumAlignBits;
+            rep0 += RangeDecoderReverseBitTreeDecode(p + Align, kNumAlignBits, &rd);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      #ifdef _LZMA_OUT_READ
+      if (rep0 > distanceLimit) 
+      #else
+      if (rep0 > nowPos)
+      #endif
+        return LZMA_RESULT_DATA_ERROR;
+
+      #ifdef _LZMA_OUT_READ
+      if (dictionarySize - distanceLimit > (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+      #endif
+
+      do
+      {
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        #else
+        previousByte = outStream[nowPos - rep0];
+        #endif
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 && nowPos < outSize);
+    }
+  }
+
+
+  #ifdef _LZMA_OUT_READ
+  vs->Range = rd.Range;
+  vs->Code = rd.Code;
+  vs->DictionaryPos = dictionaryPos;
+  vs->GlobalPos = globalPos + (UInt32)nowPos;
+  vs->DistanceLimit = distanceLimit;
+  vs->Reps[0] = rep0;
+  vs->Reps[1] = rep1;
+  vs->Reps[2] = rep2;
+  vs->Reps[3] = rep3;
+  vs->State = state;
+  vs->RemainLen = len;
+  vs->TempDictionary[0] = tempDictionary[0];
+  #endif
+
+  #ifdef _LZMA_IN_CB
+  vs->Buffer = rd.Buffer;
+  vs->BufferLim = rd.BufferLim;
+  #else
+  *inSizeProcessed = (SizeT)(rd.Buffer - inStream);
+  #endif
+  *outSizeProcessed = nowPos;
+  return LZMA_RESULT_OK;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaStateDecode.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaStateDecode.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaStateDecode.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaStateDecode.c	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,521 @@
+/*
+  LzmaStateDecode.c
+  LZMA Decoder (State version)
+  
+  LZMA SDK 4.21 Copyright (c) 1999-2005 Igor Pavlov (2005-06-08)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this Code, expressly permits you to 
+  statically or dynamically link your Code (or bind by name) to the 
+  interfaces of this file without subjecting your linked Code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#include "LzmaStateDecode.h"
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*Buffer++)
+
+#define RC_INIT Code = 0; Range = 0xFFFFFFFF; \
+  { int i; for(i = 0; i < 5; i++) { Code = (Code << 8) | RC_READ_BYTE; }}
+
+#define RC_NORMALIZE if (Range < kTopValue) { Range <<= 8; Code = (Code << 8) | RC_READ_BYTE; }
+
+#define IfBit0(p) RC_NORMALIZE; bound = (Range >> kNumBitModelTotalBits) * *(p); if (Code < bound)
+#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) >> kNumMoveBits;
+#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) >> kNumMoveBits;
+
+#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
+  { UpdateBit0(p); mi <<= 1; A0; } else \
+  { UpdateBit1(p); mi = (mi + mi) + 1; A1; } 
+  
+#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)               
+
+#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
+  { int i = numLevels; res = 1; \
+  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
+  res -= (1 << numLevels); }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+/* kRequiredInBufferSize = number of required input bytes for worst case: 
+   longest match with longest distance.
+   kLzmaInBufferSize must be larger than kRequiredInBufferSize 
+   23 bits = 2 (match select) + 10 (len) + 6 (distance) + 4(align) + 1 (RC_NORMALIZE)
+*/
+
+#define kRequiredInBufferSize ((23 * (kNumBitModelTotalBits - kNumMoveBits + 1) + 26 + 9) / 8)
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+{
+  unsigned char prop0;
+  if (size < LZMA_PROPERTIES_SIZE)
+    return LZMA_RESULT_DATA_ERROR;
+  prop0 = propsData[0];
+  if (prop0 >= (9 * 5 * 5))
+    return LZMA_RESULT_DATA_ERROR;
+  {
+    for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5));
+    for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9);
+    propsRes->lc = prop0;
+    /*
+    unsigned char remainder = (unsigned char)(prop0 / 9);
+    propsRes->lc = prop0 % 9;
+    propsRes->pb = remainder / 5;
+    propsRes->lp = remainder % 5;
+    */
+  }
+
+  {
+    int i;
+    propsRes->DictionarySize = 0;
+    for (i = 0; i < 4; i++)
+      propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
+    if (propsRes->DictionarySize == 0)
+      propsRes->DictionarySize = 1;
+    return LZMA_RESULT_OK;
+  }
+}
+
+int LzmaDecode(
+    CLzmaDecoderState *vs,
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed,
+    int finishDecoding)
+{
+  UInt32 Range = vs->Range;
+  UInt32 Code = vs->Code;
+
+  unsigned char *Buffer = vs->Buffer;
+  int BufferSize = vs->BufferSize; /* don't change it to unsigned int */
+  CProb *p = vs->Probs;
+
+  int state = vs->State;
+  unsigned char previousByte;
+  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
+  SizeT nowPos = 0;
+  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
+  int lc = vs->Properties.lc;
+  int len = vs->RemainLen;
+  UInt32 globalPos = vs->GlobalPos;
+  UInt32 distanceLimit = vs->DistanceLimit;
+
+  unsigned char *dictionary = vs->Dictionary;
+  UInt32 dictionarySize = vs->Properties.DictionarySize;
+  UInt32 dictionaryPos = vs->DictionaryPos;
+
+  unsigned char tempDictionary[4];
+
+  (*inSizeProcessed) = 0;
+  (*outSizeProcessed) = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs->TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    while (inSize > 0 && BufferSize < kLzmaInBufferSize)
+    {
+      Buffer[BufferSize++] = *inStream++;
+      (*inSizeProcessed)++;
+      inSize--;
+    }
+    if (BufferSize < 5)
+    {
+      vs->BufferSize = BufferSize;
+      return finishDecoding ? LZMA_RESULT_DATA_ERROR : LZMA_RESULT_OK;
+    }
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+      UInt32 i;
+      for (i = 0; i < numProbs; i++)
+        p[i] = kBitModelTotal >> 1; 
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      RC_INIT;
+    }
+    len = 0;
+  }
+  while(len != 0 && nowPos < outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos >= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  while(1)
+  {
+    int bufferPos = (int)(Buffer - vs->Buffer);
+    if (BufferSize - bufferPos < kRequiredInBufferSize)
+    {
+      int i;
+      BufferSize -= bufferPos;
+      if (BufferSize < 0)
+        return LZMA_RESULT_DATA_ERROR;
+      for (i = 0; i < BufferSize; i++)
+        vs->Buffer[i] = Buffer[i];
+      Buffer = vs->Buffer;
+      while (inSize > 0 && BufferSize < kLzmaInBufferSize)
+      {
+        Buffer[BufferSize++] = *inStream++;
+        (*inSizeProcessed)++;
+        inSize--;
+      }
+      if (BufferSize < kRequiredInBufferSize && !finishDecoding)
+        break;
+    }
+    if (nowPos >= outSize)
+      break;
+    {
+    CProb *prob;
+    UInt32 bound;
+    int posState = (int)((nowPos + globalPos) & posStateMask);
+
+    prob = p + IsMatch + (state << kNumPosBitsMax) + posState;
+    IfBit0(prob)
+    {
+      int symbol = 1;
+      UpdateBit0(prob)
+      prob = p + Literal + (LZMA_LIT_SIZE * 
+        ((((nowPos + globalPos)& literalPosMask) << lc) + (previousByte >> (8 - lc))));
+
+      if (state >= kNumLitStates)
+      {
+        int matchByte;
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        do
+        {
+          int bit;
+          CProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & 0x100);
+          probLit = prob + 0x100 + bit + symbol;
+          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
+        }
+        while (symbol < 0x100);
+      }
+      while (symbol < 0x100)
+      {
+        CProb *probLit = prob + symbol;
+        RC_GET_BIT(probLit, symbol)
+      }
+      previousByte = (unsigned char)symbol;
+
+      outStream[nowPos++] = previousByte;
+      if (distanceLimit < dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      if (state < 4) state = 0;
+      else if (state < 10) state -= 3;
+      else state -= 6;
+    }
+    else             
+    {
+      UpdateBit1(prob);
+      prob = p + IsRep + state;
+      IfBit0(prob)
+      {
+        UpdateBit0(prob);
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state < kNumLitStates ? 0 : 3;
+        prob = p + LenCoder;
+      }
+      else
+      {
+        UpdateBit1(prob);
+        prob = p + IsRepG0 + state;
+        IfBit0(prob)
+        {
+          UpdateBit0(prob);
+          prob = p + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IfBit0(prob)
+          {
+            UInt32 pos;
+            UpdateBit0(prob);
+            if (distanceLimit == 0)
+              return LZMA_RESULT_DATA_ERROR;
+            if (distanceLimit < dictionarySize)
+              distanceLimit++;
+            state = state < kNumLitStates ? 9 : 11;
+            pos = dictionaryPos - rep0;
+            if (pos >= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            outStream[nowPos++] = previousByte;
+            continue;
+          }
+          else
+          {
+            UpdateBit1(prob);
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          UpdateBit1(prob);
+          prob = p + IsRepG1 + state;
+          IfBit0(prob)
+          {
+            UpdateBit0(prob);
+            distance = rep1;
+          }
+          else 
+          {
+            UpdateBit1(prob);
+            prob = p + IsRepG2 + state;
+            IfBit0(prob)
+            {
+              UpdateBit0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UpdateBit1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state < kNumLitStates ? 8 : 11;
+        prob = p + RepLenCoder;
+      }
+      {
+        int numBits, offset;
+        CProb *probLen = prob + LenChoice;
+        IfBit0(probLen)
+        {
+          UpdateBit0(probLen);
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          numBits = kLenNumLowBits;
+        }
+        else
+        {
+          UpdateBit1(probLen);
+          probLen = prob + LenChoice2;
+          IfBit0(probLen)
+          {
+            UpdateBit0(probLen);
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            numBits = kLenNumMidBits;
+          }
+          else
+          {
+            UpdateBit1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            numBits = kLenNumHighBits;
+          }
+        }
+        RangeDecoderBitTreeDecode(probLen, numBits, len);
+        len += offset;
+      }
+
+      if (state < 4)
+      {
+        int posSlot;
+        state += kNumLitStates;
+        prob = p + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << 
+            kNumPosSlotBits);
+        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+          rep0 = (2 | ((UInt32)posSlot & 1));
+          if (posSlot < kEndPosModelIndex)
+          {
+            rep0 <<= numDirectBits;
+            prob = p + SpecPos + rep0 - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              RC_NORMALIZE
+              Range >>= 1;
+              rep0 <<= 1;
+              if (Code >= Range)
+              {
+                Code -= Range;
+                rep0 |= 1;
+              }
+            }
+            while (--numDirectBits != 0);
+            prob = p + Align;
+            rep0 <<= kNumAlignBits;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            int i = 1;
+            int mi = 1;
+            do
+            {
+              CProb *prob3 = prob + mi;
+              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
+              i <<= 1;
+            }
+            while(--numDirectBits != 0);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      if (rep0 > distanceLimit) 
+        return LZMA_RESULT_DATA_ERROR;
+      if (dictionarySize - distanceLimit > (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+
+      do
+      {
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 && nowPos < outSize);
+    }
+    }
+  }
+  RC_NORMALIZE;
+
+  BufferSize -= (int)(Buffer - vs->Buffer);
+  if (BufferSize < 0)
+    return LZMA_RESULT_DATA_ERROR;
+  {
+    int i;
+    for (i = 0; i < BufferSize; i++)
+      vs->Buffer[i] = Buffer[i];
+  }
+  vs->BufferSize = BufferSize;
+  vs->Range = Range;
+  vs->Code = Code;
+  vs->DictionaryPos = dictionaryPos;
+  vs->GlobalPos = (UInt32)(globalPos + nowPos);
+  vs->DistanceLimit = distanceLimit;
+  vs->Reps[0] = rep0;
+  vs->Reps[1] = rep1;
+  vs->Reps[2] = rep2;
+  vs->Reps[3] = rep3;
+  vs->State = state;
+  vs->RemainLen = len;
+  vs->TempDictionary[0] = tempDictionary[0];
+
+  (*outSizeProcessed) = nowPos;
+  return LZMA_RESULT_OK;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaStateDecode.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaStateDecode.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaStateDecode.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaStateDecode.h	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,115 @@
+/* 
+  LzmaStateDecode.h
+  LZMA Decoder interface (State version)
+
+  LZMA SDK 4.21 Copyright (c) 1999-2005 Igor Pavlov (2005-06-08)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifndef __LZMASTATEDECODE_H
+#define __LZMASTATEDECODE_H
+
+/* #define _LZMA_PROB32 */
+/* It can increase speed on some 32-bit CPUs, 
+   but memory usage will be doubled in that case */
+
+/* #define _LZMA_SYSTEM_SIZE_T */
+/* Use system's size_t. You can use it to enable 64-bit sizes supporting*/
+
+
+#ifndef UInt32
+#ifdef _LZMA_UINT32_IS_ULONG
+#define UInt32 unsigned long
+#else
+#define UInt32 unsigned int
+#endif
+#endif
+
+#ifndef SizeT
+#ifdef _LZMA_SYSTEM_SIZE_T
+#include <stddef.h>
+#define SizeT size_t
+#else
+#define SizeT UInt32
+#endif
+#endif
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb unsigned short
+#endif
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LZMA_PROPERTIES_SIZE 5
+
+typedef struct _CLzmaProperties
+{
+  int lc;
+  int lp;
+  int pb;
+  UInt32 DictionarySize;
+}CLzmaProperties;
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);
+
+#define LzmaGetNumProbs(lzmaProps) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((lzmaProps)->lc + (lzmaProps)->lp)))
+
+#define kLzmaInBufferSize 64   /* don't change it. it must be larger than kRequiredInBufferSize */
+
+#define kLzmaNeedInitId (-2)
+
+typedef struct _CLzmaDecoderState
+{
+  CLzmaProperties Properties;
+  CProb *Probs;
+  unsigned char *Dictionary;
+
+  unsigned char Buffer[kLzmaInBufferSize];
+  int BufferSize;
+
+  UInt32 Range;
+  UInt32 Code;
+  UInt32 DictionaryPos;
+  UInt32 GlobalPos;
+  UInt32 DistanceLimit;
+  UInt32 Reps[4];
+  int State;
+  int RemainLen;  /* -2: decoder needs internal initialization
+                     -1: stream was finished, 
+                      0: ok
+                    > 0: need to write RemainLen bytes as match Reps[0],
+                  */
+  unsigned char TempDictionary[4];  /* it's required when DictionarySize = 0 */
+} CLzmaDecoderState;
+
+#define LzmaDecoderInit(vs) { (vs)->RemainLen = kLzmaNeedInitId; (vs)->BufferSize = 0; }
+
+/* LzmaDecode: decoding from input stream to output stream.
+  If finishDecoding != 0, then there are no more bytes in input stream
+  after inStream[inSize - 1]. */
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    const unsigned char *inStream, SizeT inSize,  SizeT *inSizeProcessed,
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed,
+    int finishDecoding);
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaStateTest.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaStateTest.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaStateTest.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaStateTest.c	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,195 @@
+/* 
+LzmaStateTest.c
+Test application for LZMA Decoder (State version)
+
+This file written and distributed to public domain by Igor Pavlov.
+This file is part of LZMA SDK 4.26 (2005-08-02)
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "LzmaStateDecode.h"
+
+const char *kCantReadMessage = "Can not read input file";
+const char *kCantWriteMessage = "Can not write output file";
+const char *kCantAllocateMessage = "Can not allocate memory";
+
+#define kInBufferSize (1 << 15)
+#define kOutBufferSize (1 << 15)
+
+unsigned char g_InBuffer[kInBufferSize];
+unsigned char g_OutBuffer[kOutBufferSize];
+
+size_t MyReadFile(FILE *file, void *data, size_t size)
+  { return fread(data, 1, size, file); }
+
+int MyReadFileAndCheck(FILE *file, void *data, size_t size)
+  { return (MyReadFile(file, data, size) == size); }
+
+int PrintError(char *buffer, const char *message)
+{
+  sprintf(buffer + strlen(buffer), "\nError: ");
+  sprintf(buffer + strlen(buffer), message);
+  return 1;
+}
+
+int main3(FILE *inFile, FILE *outFile, char *rs)
+{
+  /* We use two 32-bit integers to construct 64-bit integer for file size.
+     You can remove outSizeHigh, if you don't need >= 4GB supporting,
+     or you can use UInt64 outSize, if your compiler supports 64-bit integers*/
+  UInt32 outSize = 0;
+  UInt32 outSizeHigh = 0; 
+  
+  int waitEOS = 1; 
+  /* waitEOS = 1, if there is no uncompressed size in headers, 
+   so decoder will wait EOS (End of Stream Marker) in compressed stream */
+
+  int i;
+  int res = 0;
+  CLzmaDecoderState state;  /* it's about 140 bytes structure, if int is 32-bit */
+  unsigned char properties[LZMA_PROPERTIES_SIZE];
+  SizeT inAvail = 0;
+  unsigned char *inBuffer = 0;
+
+  if (sizeof(UInt32) < 4)
+    return PrintError(rs, "LZMA decoder needs correct UInt32");
+
+  /* Read LZMA properties for compressed stream */
+
+  if (!MyReadFileAndCheck(inFile, properties, sizeof(properties)))
+    return PrintError(rs, kCantReadMessage);
+
+  /* Read uncompressed size */
+  
+  for (i = 0; i < 8; i++)
+  {
+    unsigned char b;
+    if (!MyReadFileAndCheck(inFile, &b, 1))
+      return PrintError(rs, kCantReadMessage);
+    if (b != 0xFF)
+      waitEOS = 0;
+    if (i < 4)
+      outSize += (UInt32)(b) << (i * 8);
+    else
+      outSizeHigh += (UInt32)(b) << ((i - 4) * 8);
+  }
+
+  /* Decode LZMA properties and allocate memory */
+  
+  if (LzmaDecodeProperties(&state.Properties, properties, LZMA_PROPERTIES_SIZE) != LZMA_RESULT_OK)
+    return PrintError(rs, "Incorrect stream properties");
+  state.Probs = (CProb *)malloc(LzmaGetNumProbs(&state.Properties) * sizeof(CProb));
+  if (state.Probs == 0)
+    return PrintError(rs, kCantAllocateMessage);
+  
+  if (state.Properties.DictionarySize == 0)
+    state.Dictionary = 0;
+  else
+  {
+    state.Dictionary = (unsigned char *)malloc(state.Properties.DictionarySize);
+    if (state.Dictionary == 0)
+    {
+      free(state.Probs);
+      return PrintError(rs, kCantAllocateMessage);
+    }
+  }
+  
+  /* Decompress */
+  
+  LzmaDecoderInit(&state);
+  
+  do
+  {
+    SizeT inProcessed, outProcessed;
+    int finishDecoding;
+    UInt32 outAvail = kOutBufferSize;
+    if (!waitEOS && outSizeHigh == 0 && outAvail > outSize)
+      outAvail = outSize;
+    if (inAvail == 0)
+    {
+      inAvail = (SizeT)MyReadFile(inFile, g_InBuffer, kInBufferSize);
+      inBuffer = g_InBuffer;
+    }
+    finishDecoding = (inAvail == 0);
+    res = LzmaDecode(&state,
+        inBuffer, inAvail, &inProcessed,
+        g_OutBuffer, outAvail, &outProcessed,
+        finishDecoding);
+    if (res != 0)
+    {
+      sprintf(rs + strlen(rs), "\nDecoding error = %d\n", res);
+      res = 1;
+      break;
+    }
+    inAvail -= inProcessed;
+    inBuffer += inProcessed;
+    
+    if (outFile != 0)  
+      if (fwrite(g_OutBuffer, 1, outProcessed, outFile) != outProcessed)
+      {
+        PrintError(rs, kCantWriteMessage);
+        res = 1;
+        break;
+      }
+      
+    if (outSize < outProcessed)
+      outSizeHigh--;
+    outSize -= (UInt32)outProcessed;
+    outSize &= 0xFFFFFFFF;
+
+    if (outProcessed == 0 && finishDecoding)
+    {
+      if (!waitEOS && (outSize != 0 || outSizeHigh != 0))
+        res = 1;
+      break;
+    }
+  }
+  while ((outSize != 0 && outSizeHigh == 0) || outSizeHigh != 0  || waitEOS);
+
+  free(state.Dictionary);
+  free(state.Probs);
+  return res;
+}
+
+int main2(int numArgs, const char *args[], char *rs)
+{
+  FILE *inFile = 0;
+  FILE *outFile = 0;
+  int res;
+
+  sprintf(rs + strlen(rs), "\nLZMA Decoder 4.26 Copyright (c) 1999-2005 Igor Pavlov  2005-08-02\n");
+  if (numArgs < 2 || numArgs > 3)
+  {
+    sprintf(rs + strlen(rs), "\nUsage:  lzmadec file.lzma [outFile]\n");
+    return 1;
+  }
+
+  inFile = fopen(args[1], "rb");
+  if (inFile == 0)
+    return PrintError(rs, "Can not open input file");
+
+  if (numArgs > 2)
+  {
+    outFile = fopen(args[2], "wb+");
+    if (outFile == 0)
+      return PrintError(rs, "Can not open output file");
+  }
+
+  res = main3(inFile, outFile, rs);
+
+  if (outFile != 0)
+    fclose(outFile);
+  fclose(inFile);
+  return res;
+}
+
+int main(int numArgs, const char *args[])
+{
+  char rs[800] = { 0 };
+  int res = main2(numArgs, args, rs);
+  printf(rs);
+  return res;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaTest.c squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaTest.c
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaTest.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/LzmaTest.c	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,342 @@
+/* 
+LzmaTest.c
+Test application for LZMA Decoder
+
+This file written and distributed to public domain by Igor Pavlov.
+This file is part of LZMA SDK 4.26 (2005-08-05)
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "LzmaDecode.h"
+
+const char *kCantReadMessage = "Can not read input file";
+const char *kCantWriteMessage = "Can not write output file";
+const char *kCantAllocateMessage = "Can not allocate memory";
+
+size_t MyReadFile(FILE *file, void *data, size_t size)
+{ 
+  if (size == 0)
+    return 0;
+  return fread(data, 1, size, file); 
+}
+
+int MyReadFileAndCheck(FILE *file, void *data, size_t size)
+  { return (MyReadFile(file, data, size) == size);} 
+
+size_t MyWriteFile(FILE *file, const void *data, size_t size)
+{ 
+  if (size == 0)
+    return 0;
+  return fwrite(data, 1, size, file); 
+}
+
+int MyWriteFileAndCheck(FILE *file, const void *data, size_t size)
+  { return (MyWriteFile(file, data, size) == size); }
+
+#ifdef _LZMA_IN_CB
+#define kInBufferSize (1 << 15)
+typedef struct _CBuffer
+{
+  ILzmaInCallback InCallback;
+  FILE *File;
+  unsigned char Buffer[kInBufferSize];
+} CBuffer;
+
+int LzmaReadCompressed(void *object, const unsigned char **buffer, SizeT *size)
+{
+  CBuffer *b = (CBuffer *)object;
+  *buffer = b->Buffer;
+  *size = (SizeT)MyReadFile(b->File, b->Buffer, kInBufferSize);
+  return LZMA_RESULT_OK;
+}
+CBuffer g_InBuffer;
+
+#endif
+
+#ifdef _LZMA_OUT_READ
+#define kOutBufferSize (1 << 15)
+unsigned char g_OutBuffer[kOutBufferSize];
+#endif
+
+int PrintError(char *buffer, const char *message)
+{
+  sprintf(buffer + strlen(buffer), "\nError: ");
+  sprintf(buffer + strlen(buffer), message);
+  return 1;
+}
+
+int main3(FILE *inFile, FILE *outFile, char *rs)
+{
+  /* We use two 32-bit integers to construct 64-bit integer for file size.
+     You can remove outSizeHigh, if you don't need >= 4GB supporting,
+     or you can use UInt64 outSize, if your compiler supports 64-bit integers*/
+  UInt32 outSize = 0;
+  UInt32 outSizeHigh = 0;
+  #ifndef _LZMA_OUT_READ
+  SizeT outSizeFull;
+  unsigned char *outStream;
+  #endif
+  
+  int waitEOS = 1; 
+  /* waitEOS = 1, if there is no uncompressed size in headers, 
+   so decoder will wait EOS (End of Stream Marker) in compressed stream */
+
+  #ifndef _LZMA_IN_CB
+  SizeT compressedSize;
+  unsigned char *inStream;
+  #endif
+
+  CLzmaDecoderState state;  /* it's about 24-80 bytes structure, if int is 32-bit */
+  unsigned char properties[LZMA_PROPERTIES_SIZE];
+
+  int res;
+
+  #ifdef _LZMA_IN_CB
+  g_InBuffer.File = inFile;
+  #endif
+
+  if (sizeof(UInt32) < 4)
+    return PrintError(rs, "LZMA decoder needs correct UInt32");
+
+  #ifndef _LZMA_IN_CB
+  {
+    long length;
+    fseek(inFile, 0, SEEK_END);
+    length = ftell(inFile);
+    fseek(inFile, 0, SEEK_SET);
+    if ((long)(SizeT)length != length)
+      return PrintError(rs, "Too big compressed stream");
+    compressedSize = (SizeT)(length - (LZMA_PROPERTIES_SIZE + 8));
+  }
+  #endif
+
+  /* Read LZMA properties for compressed stream */
+
+  if (!MyReadFileAndCheck(inFile, properties, sizeof(properties)))
+    return PrintError(rs, kCantReadMessage);
+
+  /* Read uncompressed size */
+
+  {
+    int i;
+    for (i = 0; i < 8; i++)
+    {
+      unsigned char b;
+      if (!MyReadFileAndCheck(inFile, &b, 1))
+        return PrintError(rs, kCantReadMessage);
+      if (b != 0xFF)
+        waitEOS = 0;
+      if (i < 4)
+        outSize += (UInt32)(b) << (i * 8);
+      else
+        outSizeHigh += (UInt32)(b) << ((i - 4) * 8);
+    }
+    
+    #ifndef _LZMA_OUT_READ
+    if (waitEOS)
+      return PrintError(rs, "Stream with EOS marker is not supported");
+    outSizeFull = (SizeT)outSize;
+    if (sizeof(SizeT) >= 8)
+      outSizeFull |= (((SizeT)outSizeHigh << 16) << 16);
+    else if (outSizeHigh != 0 || (UInt32)(SizeT)outSize != outSize)
+      return PrintError(rs, "Too big uncompressed stream");
+    #endif
+  }
+
+  /* Decode LZMA properties and allocate memory */
+  
+  if (LzmaDecodeProperties(&state.Properties, properties, LZMA_PROPERTIES_SIZE) != LZMA_RESULT_OK)
+    return PrintError(rs, "Incorrect stream properties");
+  state.Probs = (CProb *)malloc(LzmaGetNumProbs(&state.Properties) * sizeof(CProb));
+
+  #ifdef _LZMA_OUT_READ
+  if (state.Properties.DictionarySize == 0)
+    state.Dictionary = 0;
+  else
+    state.Dictionary = (unsigned char *)malloc(state.Properties.DictionarySize);
+  #else
+  if (outSizeFull == 0)
+    outStream = 0;
+  else
+    outStream = (unsigned char *)malloc(outSizeFull);
+  #endif
+
+  #ifndef _LZMA_IN_CB
+  if (compressedSize == 0)
+    inStream = 0;
+  else
+    inStream = (unsigned char *)malloc(compressedSize);
+  #endif
+
+  if (state.Probs == 0 
+    #ifdef _LZMA_OUT_READ
+    || (state.Dictionary == 0 && state.Properties.DictionarySize != 0)
+    #else
+    || (outStream == 0 && outSizeFull != 0)
+    #endif
+    #ifndef _LZMA_IN_CB
+    || (inStream == 0 && compressedSize != 0)
+    #endif
+    )
+  {
+    free(state.Probs);
+    #ifdef _LZMA_OUT_READ
+    free(state.Dictionary);
+    #else
+    free(outStream);
+    #endif
+    #ifndef _LZMA_IN_CB
+    free(inStream);
+    #endif
+    return PrintError(rs, kCantAllocateMessage);
+  }
+
+  /* Decompress */
+
+  #ifdef _LZMA_IN_CB
+  g_InBuffer.InCallback.Read = LzmaReadCompressed;
+  #else
+  if (!MyReadFileAndCheck(inFile, inStream, compressedSize))
+    return PrintError(rs, kCantReadMessage);
+  #endif
+
+  #ifdef _LZMA_OUT_READ
+  {
+    #ifndef _LZMA_IN_CB
+    SizeT inAvail = compressedSize;
+    const unsigned char *inBuffer = inStream;
+    #endif
+    LzmaDecoderInit(&state);
+    do
+    {
+      #ifndef _LZMA_IN_CB
+      SizeT inProcessed;
+      #endif
+      SizeT outProcessed;
+      SizeT outAvail = kOutBufferSize;
+      if (!waitEOS && outSizeHigh == 0 && outAvail > outSize)
+        outAvail = (SizeT)outSize;
+      res = LzmaDecode(&state,
+        #ifdef _LZMA_IN_CB
+        &g_InBuffer.InCallback,
+        #else
+        inBuffer, inAvail, &inProcessed,
+        #endif
+        g_OutBuffer, outAvail, &outProcessed);
+      if (res != 0)
+      {
+        sprintf(rs + strlen(rs), "\nDecoding error = %d\n", res);
+        res = 1;
+        break;
+      }
+      #ifndef _LZMA_IN_CB
+      inAvail -= inProcessed;
+      inBuffer += inProcessed;
+      #endif
+      
+      if (outFile != 0)  
+        if (!MyWriteFileAndCheck(outFile, g_OutBuffer, (size_t)outProcessed))
+        {
+          PrintError(rs, kCantWriteMessage);
+          res = 1;
+          break;
+        }
+        
+      if (outSize < outProcessed)
+        outSizeHigh--;
+      outSize -= (UInt32)outProcessed;
+      outSize &= 0xFFFFFFFF;
+        
+      if (outProcessed == 0)
+      {
+        if (!waitEOS && (outSize != 0 || outSizeHigh != 0))
+          res = 1;
+        break;
+      }
+    }
+    while ((outSize != 0 && outSizeHigh == 0) || outSizeHigh != 0  || waitEOS);
+  }
+
+  #else
+  {
+    #ifndef _LZMA_IN_CB
+    SizeT inProcessed;
+    #endif
+    SizeT outProcessed;
+    res = LzmaDecode(&state,
+      #ifdef _LZMA_IN_CB
+      &g_InBuffer.InCallback,
+      #else
+      inStream, compressedSize, &inProcessed,
+      #endif
+      outStream, outSizeFull, &outProcessed);
+    if (res != 0)
+    {
+      sprintf(rs + strlen(rs), "\nDecoding error = %d\n", res);
+      res = 1;
+    }
+    else if (outFile != 0)
+    {
+      if (!MyWriteFileAndCheck(outFile, outStream, (size_t)outProcessed))
+      {
+        PrintError(rs, kCantWriteMessage);
+        res = 1;
+      }
+    }
+  }
+  #endif
+
+  free(state.Probs);
+  #ifdef _LZMA_OUT_READ
+  free(state.Dictionary);
+  #else
+  free(outStream);
+  #endif
+  #ifndef _LZMA_IN_CB
+  free(inStream);
+  #endif
+  return res;
+}
+
+int main2(int numArgs, const char *args[], char *rs)
+{
+  FILE *inFile = 0;
+  FILE *outFile = 0;
+  int res;
+
+  sprintf(rs + strlen(rs), "\nLZMA Decoder 4.26 Copyright (c) 1999-2005 Igor Pavlov  2005-08-05\n");
+  if (numArgs < 2 || numArgs > 3)
+  {
+    sprintf(rs + strlen(rs), "\nUsage:  lzmadec file.lzma [outFile]\n");
+    return 1;
+  }
+
+  inFile = fopen(args[1], "rb");
+  if (inFile == 0)
+    return PrintError(rs, "Can not open input file");
+
+  if (numArgs > 2)
+  {
+    outFile = fopen(args[2], "wb+");
+    if (outFile == 0)
+      return PrintError(rs, "Can not open output file");
+  }
+
+  res = main3(inFile, outFile, rs);
+
+  if (outFile != 0)
+    fclose(outFile);
+  fclose(inFile);
+  return res;
+}
+
+int main(int numArgs, const char *args[])
+{
+  char rs[800] = { 0 };
+  int res = main2(numArgs, args, rs);
+  printf(rs);
+  return res;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/makefile squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/makefile
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/makefile	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/makefile	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,43 @@
+PROG = lzmaDec.exe
+
+!IFNDEF O
+!IFDEF CPU
+O=$(CPU)
+!ELSE
+O=O
+!ENDIF
+!ENDIF
+
+CFLAGS = $(CFLAGS) -nologo -c -Fo$O/ -GS- 
+CFLAGS_O1 = $(CFLAGS) -O1
+CFLAGS_O2 = $(CFLAGS) -O2
+
+LFLAGS = $(LFLAGS) -nologo -OPT:NOWIN98
+
+PROGPATH = $O\$(PROG)
+
+COMPL_O1   = $(CPP) $(CFLAGS_O1) $**
+COMPL_O2   = $(CPP) $(CFLAGS_O2) $**
+COMPL      = $(CPP) $(CFLAGS_O1) $**
+
+
+OBJS = \
+  $O\LzmaTest.obj \
+  $O\LzmaDecode.obj \
+
+all: $(PROGPATH) 
+
+clean:
+	-del /Q $(PROGPATH) $O\*.exe $O\*.dll $O\*.obj $O\*.lib $O\*.exp $O\*.res $O\*.pch 
+
+$O:
+	if not exist "$O" mkdir "$O"
+
+$(PROGPATH): $O $(OBJS)
+	link $(LFLAGS) -out:$(PROGPATH) $(OBJS) $(LIBS)
+
+
+$O\LzmaTest.obj: $(*B).c
+	$(COMPL)
+$O\LzmaDecode.obj: ../../Compress/LZMA_C/$(*B).c
+	$(COMPL_O2)
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/makefile.gcc squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/makefile.gcc
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/makefile.gcc	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_C/makefile.gcc	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,23 @@
+PROG = lzmadec
+CXX = gcc 
+LIB = 
+RM = rm -f
+CFLAGS = -c -O2 -Wall -pedantic -D _LZMA_PROB32 
+
+OBJS = LzmaTest.o LzmaDecode.o 
+
+all: $(PROG)
+
+$(PROG): $(OBJS)
+	$(CXX) -o $(PROG) $(LDFLAGS) $(OBJS) $(LIB)
+
+LzmaTest.o: LzmaTest.c
+	$(CXX) $(CFLAGS) LzmaTest.c
+
+LzmaDecode.o: LzmaDecode.c
+	$(CXX) $(CFLAGS) LzmaDecode.c
+
+
+clean:
+	-$(RM) $(PROG) $(OBJS)
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Lib/lzmadaptive.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Lib/lzmadaptive.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Lib/lzmadaptive.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Lib/lzmadaptive.h	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,21 @@
+#ifndef __LZMA_LIB_H__
+#define __LZMA_LIB_H__
+
+#include <zlib.h>
+
+// CJH: For Gentoo zlib compatibility
+#ifdef _Z_OF
+#undef OF
+#define OF _Z_OF
+#endif
+
+/* CJH: Depreciated.
+int lzmalib_uncompress OF((Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen));
+int lzma7z_uncompress OF((Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen));
+int lzmalinksys_uncompress OF((Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen));
+*/
+
+int lzmawrt_uncompress OF((Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen));
+int lzmaspec_uncompress OF((Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen, int lc, int lp, int pb, int dictionary_size, int offset));
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Lib/makefile squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Lib/makefile
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Lib/makefile	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Lib/makefile	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,92 @@
+PROG = liblzmalib.a
+CXX = g++ -O3 -Wall
+AR = ar
+RM = rm -f
+CFLAGS = -c  -I ../../../
+
+OBJS = \
+  ZLib.o \
+  LZMADecoder.o \
+  LZMAEncoder.o \
+  LZInWindow.o \
+  LZOutWindow.o \
+  RangeCoderBit.o \
+  InBuffer.o \
+  OutBuffer.o \
+  FileStreams.o \
+  Alloc.o \
+  C_FileIO.o \
+  CommandLineParser.o \
+  CRC.o \
+  StreamUtils.o \
+  String.o \
+  StringConvert.o \
+  StringToInt.o \
+  Vector.o \
+
+
+all: $(PROG)
+
+$(PROG): $(OBJS)
+	$(AR) r $(PROG) $(OBJS)
+
+ZLib.o: ZLib.cpp
+	$(CXX) $(CFLAGS) ZLib.cpp
+
+LZMADecoder.o: ../LZMA/LZMADecoder.cpp
+	$(CXX) $(CFLAGS) ../LZMA/LZMADecoder.cpp
+
+LZMAEncoder.o: ../LZMA/LZMAEncoder.cpp
+	$(CXX) $(CFLAGS) ../LZMA/LZMAEncoder.cpp
+
+LZInWindow.o: ../LZ/LZInWindow.cpp
+	$(CXX) $(CFLAGS) ../LZ/LZInWindow.cpp
+
+LZOutWindow.o: ../LZ/LZOutWindow.cpp
+	$(CXX) $(CFLAGS) ../LZ/LZOutWindow.cpp
+
+RangeCoderBit.o: ../RangeCoder/RangeCoderBit.cpp
+	$(CXX) $(CFLAGS) ../RangeCoder/RangeCoderBit.cpp
+
+InBuffer.o: ../../Common/InBuffer.cpp
+	$(CXX) $(CFLAGS) ../../Common/InBuffer.cpp
+
+OutBuffer.o: ../../Common/OutBuffer.cpp
+	$(CXX) $(CFLAGS) ../../Common/OutBuffer.cpp
+
+StreamUtils.o: ../../Common/StreamUtils.cpp
+	$(CXX) $(CFLAGS) ../../Common/StreamUtils.cpp
+
+FileStreams.o: ../../Common/FileStreams.cpp
+	$(CXX) $(CFLAGS) ../../Common/FileStreams.cpp
+
+Alloc.o: ../../../Common/Alloc.cpp
+	$(CXX) $(CFLAGS) ../../../Common/Alloc.cpp
+
+C_FileIO.o: ../../../Common/C_FileIO.cpp
+	$(CXX) $(CFLAGS) ../../../Common/C_FileIO.cpp
+
+CommandLineParser.o: ../../../Common/CommandLineParser.cpp
+	$(CXX) $(CFLAGS) ../../../Common/CommandLineParser.cpp
+
+CRC.o: ../../../Common/CRC.cpp
+	$(CXX) $(CFLAGS) ../../../Common/CRC.cpp
+
+MyWindows.o: ../../../Common/MyWindows.cpp
+	$(CXX) $(CFLAGS) ../../../Common/MyWindows.cpp
+
+String.o: ../../../Common/String.cpp
+	$(CXX) $(CFLAGS) ../../../Common/String.cpp
+
+StringConvert.o: ../../../Common/StringConvert.cpp
+	$(CXX) $(CFLAGS) ../../../Common/StringConvert.cpp
+
+StringToInt.o: ../../../Common/StringToInt.cpp
+	$(CXX) $(CFLAGS) ../../../Common/StringToInt.cpp
+
+Vector.o: ../../../Common/Vector.cpp
+	$(CXX) $(CFLAGS) ../../../Common/Vector.cpp
+
+clean:
+	-$(RM) $(PROG) $(OBJS)
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Lib/ZLib.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Lib/ZLib.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Lib/ZLib.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/LZMA_Lib/ZLib.cpp	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,451 @@
+/*
+ * lzma zlib simplified wrapper
+ *
+ * Copyright (c) 2005-2006 Oleg I. Vdovikin <oleg@cs.msu.su>
+ *
+ * This library is free software; you can redistribute 
+ * it and/or modify it under the terms of the GNU Lesser 
+ * General Public License as published by the Free Software 
+ * Foundation; either version 2.1 of the License, or 
+ * (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be 
+ * useful, but WITHOUT ANY WARRANTY; without even the implied 
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
+ * PURPOSE. See the GNU Lesser General Public License 
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General 
+ * Public License along with this library; if not, write to 
+ * the Free Software Foundation, Inc., 59 Temple Place, 
+ * Suite 330, Boston, MA 02111-1307 USA 
+ */
+
+/*
+ * default values for encoder/decoder used by wrapper
+ */
+
+#include <stdio.h>
+#include <zlib.h>
+
+// CJH: For Gentoo zlib compatibility.
+#ifdef _Z_OF
+#undef OF
+#define OF _Z_OF
+#endif
+
+#define ZLIB_LC 3
+#define ZLIB_LP 0
+#define ZLIB_PB 2
+
+// CJH: Taken from E2100 squashfs implementation
+#define ZLIB_LC_E2100 0
+#define ZLIB_LP_E2100 0
+#define ZLIB_PB_E2100 2
+
+#ifdef WIN32
+#include <initguid.h>
+#else
+#define INITGUID
+#endif
+
+#include "../../../Common/MyWindows.h"
+#include "../LZMA/LZMADecoder.h"
+#include "../LZMA/LZMAEncoder.h"
+
+#define STG_E_SEEKERROR                  ((HRESULT)0x80030019L)
+#define STG_E_MEDIUMFULL                 ((HRESULT)0x80030070L)
+
+class CInMemoryStream: 
+  public IInStream,
+  public IStreamGetSize,
+  public CMyUnknownImp
+{
+public:
+  CInMemoryStream(const Bytef *data, UInt64 size) : 
+	  m_data(data), m_size(size), m_offset(0) {}
+
+  virtual ~CInMemoryStream() {}
+
+  MY_UNKNOWN_IMP2(IInStream, IStreamGetSize)
+
+  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize)
+  {
+	  if (size > m_size - m_offset) 
+		  size = m_size - m_offset;
+
+	  if (size) {
+		  memcpy(data, m_data + m_offset, size);
+	  }
+
+	  m_offset += size;
+
+	  if (processedSize) 
+		  *processedSize = size;
+
+	  return S_OK;
+  }
+
+  STDMETHOD(ReadPart)(void *data, UInt32 size, UInt32 *processedSize)
+  {
+	return Read(data, size, processedSize);
+  }
+
+  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)
+  {
+	  UInt64 _offset;
+
+	  if (seekOrigin == STREAM_SEEK_SET) _offset = offset;
+	  else if (seekOrigin == STREAM_SEEK_CUR) _offset = m_offset + offset; 
+	  else if (seekOrigin == STREAM_SEEK_END) _offset = m_size;
+	  else return STG_E_INVALIDFUNCTION;
+
+	  if (_offset < 0 || _offset > m_size)
+		  return STG_E_SEEKERROR;
+
+	  m_offset = _offset;
+
+	  if (newPosition)
+		  *newPosition = m_offset;
+
+	  return S_OK;
+  }
+
+  STDMETHOD(GetSize)(UInt64 *size)
+  {
+	  *size = m_size;
+	  return S_OK;
+  }
+protected:
+	const Bytef *m_data;
+	UInt64 m_size;
+	UInt64 m_offset;
+};
+
+class COutMemoryStream: 
+  public IOutStream,
+  public CMyUnknownImp
+{
+public:
+  COutMemoryStream(Bytef *data, UInt64 maxsize) : 
+	  m_data(data), m_size(0), m_maxsize(maxsize), m_offset(0) {}
+  virtual ~COutMemoryStream() {}
+  
+  MY_UNKNOWN_IMP1(IOutStream)
+
+  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize)
+  {
+	  if (size > m_maxsize - m_offset) 
+		  size = m_maxsize - m_offset;
+
+	  if (size) {
+		  memcpy(m_data + m_offset, data, size);
+	  }
+
+	  m_offset += size;
+
+	  if (m_offset > m_size)
+		m_size = m_offset;
+
+	  if (processedSize) 
+		  *processedSize = size;
+
+	  return S_OK;
+  }
+  
+  STDMETHOD(WritePart)(const void *data, UInt32 size, UInt32 *processedSize)
+  {
+	  return Write(data, size, processedSize);
+  }
+
+  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition)
+  {
+	  UInt64 _offset;
+
+	  if (seekOrigin == STREAM_SEEK_SET) _offset = offset;
+	  else if (seekOrigin == STREAM_SEEK_CUR) _offset = m_offset + offset; 
+	  else if (seekOrigin == STREAM_SEEK_END) _offset = m_size;
+	  else return STG_E_INVALIDFUNCTION;
+
+	  if (_offset < 0 || _offset > m_maxsize)
+		  return STG_E_SEEKERROR;
+
+	  m_offset = _offset;
+
+	  if (newPosition)
+		  *newPosition = m_offset;
+
+	  return S_OK;
+  }
+  
+  STDMETHOD(SetSize)(Int64 newSize)
+  {
+	  if ((UInt64)newSize > m_maxsize) 
+		  return STG_E_MEDIUMFULL;
+
+	  return S_OK;
+  }
+protected:
+	Bytef *m_data;
+	UInt64 m_size;
+	UInt64 m_maxsize;
+	UInt64 m_offset;
+};
+
+ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
+                                  const Bytef *source, uLong sourceLen,
+                                  int level))
+{
+	CInMemoryStream *inStreamSpec = new CInMemoryStream(source, sourceLen);
+	CMyComPtr<ISequentialInStream> inStream = inStreamSpec;
+	
+	COutMemoryStream *outStreamSpec = new COutMemoryStream(dest, *destLen);
+	CMyComPtr<ISequentialOutStream> outStream = outStreamSpec;
+	
+	NCompress::NLZMA::CEncoder *encoderSpec = 
+		new NCompress::NLZMA::CEncoder;
+	CMyComPtr<ICompressCoder> encoder = encoderSpec;
+	
+	PROPID propIDs[] = 
+	{
+		NCoderPropID::kDictionarySize,
+		NCoderPropID::kPosStateBits,
+		NCoderPropID::kLitContextBits,
+		NCoderPropID::kLitPosBits,
+		NCoderPropID::kAlgorithm,
+		NCoderPropID::kNumFastBytes,
+		NCoderPropID::kMatchFinder,
+		NCoderPropID::kEndMarker
+	};
+	const int kNumProps = sizeof(propIDs) / sizeof(propIDs[0]);
+	
+	PROPVARIANT properties[kNumProps];
+	for (int p = 0; p < 6; p++)
+		properties[p].vt = VT_UI4;
+	properties[0].ulVal = UInt32(1 << (level + 14));
+	properties[1].ulVal = UInt32(ZLIB_PB);
+	properties[2].ulVal = UInt32(ZLIB_LC); // for normal files
+	properties[3].ulVal = UInt32(ZLIB_LP); // for normal files
+	properties[4].ulVal = UInt32(2);
+	properties[5].ulVal = UInt32(128);
+	
+	properties[6].vt = VT_BSTR;
+	properties[6].bstrVal = (BSTR)(const wchar_t *)L"BT4";
+	
+	properties[7].vt = VT_BOOL;
+	properties[7].boolVal = VARIANT_TRUE;
+	
+	if (encoderSpec->SetCoderProperties(propIDs, properties, kNumProps) != S_OK)
+		return Z_MEM_ERROR; // should not happen
+	
+	HRESULT result = encoder->Code(inStream, outStream, 0, 0, 0);
+	if (result == E_OUTOFMEMORY)
+	{
+		return Z_MEM_ERROR;
+	}   
+	else if (result != S_OK)
+	{
+		return Z_BUF_ERROR;	// should not happen
+	}   
+	
+	UInt64 fileSize;
+	outStreamSpec->Seek(0, STREAM_SEEK_END, &fileSize);
+	*destLen = fileSize;
+	
+	return Z_OK;
+}
+
+/*
+ * CJH: These are depreciated, and left here merely for future reference.
+ *
+// CJH: s/uncompress/lzmalib_uncompress/
+extern "C" int lzmalib_uncompress OF((Bytef *dest,   uLongf *destLen,
+                                   const Bytef *source, uLong sourceLen))
+{
+	// CJH: 7zip ID implemented by some LZMA implementations
+	if(strncmp((char *) source, "7zip", 4) == 0)
+	{
+		source += 4;
+		sourceLen -= 4;
+	}
+
+	CInMemoryStream *inStreamSpec = new CInMemoryStream(source, sourceLen);
+	CMyComPtr<ISequentialInStream> inStream = inStreamSpec;
+	
+	COutMemoryStream *outStreamSpec = new COutMemoryStream(dest, *destLen);
+	CMyComPtr<ISequentialOutStream> outStream = outStreamSpec;
+	
+	NCompress::NLZMA::CDecoder *decoderSpec = 
+		new NCompress::NLZMA::CDecoder;
+	CMyComPtr<ICompressCoder> decoder = decoderSpec;
+	
+	if (decoderSpec->SetDecoderPropertiesRaw(ZLIB_LC, 
+		ZLIB_LP, ZLIB_PB, (1 << 23)) != S_OK) return Z_DATA_ERROR;
+	
+	UInt64 fileSize = *destLen;
+	
+	if (decoder->Code(inStream, outStream, 0, &fileSize, 0) != S_OK)
+	{
+        return Z_DATA_ERROR;
+	}
+	
+	outStreamSpec->Seek(0, STREAM_SEEK_END, &fileSize);
+	*destLen = fileSize;
+	
+	return Z_OK;
+}
+
+// CJH: A decompressor used by some Linksys SquashFS images
+extern "C" int lzmalinksys_uncompress OF((Bytef *dest,   uLongf *destLen,
+                                   const Bytef *source, uLong sourceLen))
+{
+	CInMemoryStream *inStreamSpec = new CInMemoryStream(source, sourceLen);
+	CMyComPtr<ISequentialInStream> inStream = inStreamSpec;
+	
+	COutMemoryStream *outStreamSpec = new COutMemoryStream(dest, *destLen);
+	CMyComPtr<ISequentialOutStream> outStream = outStreamSpec;
+	
+	NCompress::NLZMA::CDecoder *decoderSpec = 
+		new NCompress::NLZMA::CDecoder;
+	CMyComPtr<ICompressCoder> decoder = decoderSpec;
+	
+	if (decoderSpec->SetDecoderPropertiesRaw(ZLIB_LC_E2100, 
+		ZLIB_LP_E2100, ZLIB_PB_E2100, (1 << 23)) != S_OK) return Z_DATA_ERROR;
+	
+	UInt64 fileSize = *destLen;
+	
+	if (decoder->Code(inStream, outStream, 0, &fileSize, 0) != S_OK)
+	{
+        return Z_DATA_ERROR;
+	}
+	
+	outStreamSpec->Seek(0, STREAM_SEEK_END, &fileSize);
+	*destLen = fileSize;
+	
+	return Z_OK;
+}
+
+// CJH: A decompressor for "squashfs7z" images
+extern "C" int lzma7z_uncompress OF((Bytef *dest,   uLongf *destLen,
+                                   const Bytef *source, uLong sourceLen))
+{
+    // CJH: This variation encodes the properties values + size into the first nine bytes
+	CInMemoryStream *inStreamSpec = new CInMemoryStream(source+9, sourceLen-9);
+	CMyComPtr<ISequentialInStream> inStream = inStreamSpec;
+	
+	COutMemoryStream *outStreamSpec = new COutMemoryStream(dest, *destLen);
+	CMyComPtr<ISequentialOutStream> outStream = outStreamSpec;
+	
+	NCompress::NLZMA::CDecoder *decoderSpec = 
+		new NCompress::NLZMA::CDecoder;
+	CMyComPtr<ICompressCoder> decoder = decoderSpec;
+
+    // CJH: This variation uses SetDecoderProperties2
+	//if (decoderSpec->SetDecoderPropertiesRaw(source[1], 
+	//	source[2], source[0], (1 << 23)) != S_OK) return Z_DATA_ERROR;
+    if (decoderSpec->SetDecoderProperties2(source+4, 5) != S_OK)
+                return Z_DATA_ERROR;
+
+	UInt64 fileSize = *destLen;
+	
+	if (decoder->Code(inStream, outStream, 0, &fileSize, 0) != S_OK)
+	{
+		return Z_DATA_ERROR;
+	}
+	
+	outStreamSpec->Seek(0, STREAM_SEEK_END, &fileSize);
+	*destLen = fileSize;
+	
+	return Z_OK;
+}
+
+*/
+
+// CJH: A decompressor for LZMA DD-WRT SquashFS images
+extern "C" int lzmawrt_uncompress OF((Bytef *dest,   uLongf *destLen,
+                                   const Bytef *source, uLong sourceLen))
+{
+    // CJH: DD-WRT encodes the properties values into the first four bytes
+	CInMemoryStream *inStreamSpec = new CInMemoryStream(source+4, sourceLen-4);
+	CMyComPtr<ISequentialInStream> inStream = inStreamSpec;
+	
+	COutMemoryStream *outStreamSpec = new COutMemoryStream(dest, *destLen);
+	CMyComPtr<ISequentialOutStream> outStream = outStreamSpec;
+	
+	NCompress::NLZMA::CDecoder *decoderSpec = 
+		new NCompress::NLZMA::CDecoder;
+	CMyComPtr<ICompressCoder> decoder = decoderSpec;
+
+    /*
+     * CJH: DD-WRT encodes the LZMA properties into the beginning of each compressed block.
+     *      Sanity check these values to prevent errors in the LZMA library.
+     */
+     //printf("WRT properties: %d %d %d\n", (unsigned int) source[1],
+     //                                     (unsigned int) source[2],
+     //                                     (unsigned int) source[0]);
+    if((unsigned int) source[1] > 4 ||
+       (unsigned int) source[2] > 4 ||
+       (unsigned int) source[0] > 4 ||
+       ((unsigned int) source[1] + (unsigned int) source[2]) > 4)
+    {
+        return Z_DATA_ERROR;
+    }
+
+	if (decoderSpec->SetDecoderPropertiesRaw(source[1], 
+		source[2], source[0], (1 << 23)) != S_OK) return Z_DATA_ERROR;
+	
+	UInt64 fileSize = *destLen;
+	
+	if (decoder->Code(inStream, outStream, 0, &fileSize, 0) != S_OK)
+	{
+		return Z_DATA_ERROR;
+	}
+	
+	outStreamSpec->Seek(0, STREAM_SEEK_END, &fileSize);
+	*destLen = fileSize;
+	
+	return Z_OK;
+}
+
+// CJH: A decompressor used for brute forcing commonly modified LZMA fields
+extern "C" int lzmaspec_uncompress OF((Bytef *dest, 
+                                       uLongf *destLen, 
+                                       const Bytef *source, 
+                                       uLong sourceLen, 
+                                       int lc, 
+                                       int lp, 
+                                       int pb, 
+                                       int dictionary_size,
+                                       int offset))
+{
+	CInMemoryStream *inStreamSpec = new CInMemoryStream(source+offset, sourceLen-offset);
+	CMyComPtr<ISequentialInStream> inStream = inStreamSpec;
+	
+	COutMemoryStream *outStreamSpec = new COutMemoryStream(dest, *destLen);
+	CMyComPtr<ISequentialOutStream> outStream = outStreamSpec;
+	
+	NCompress::NLZMA::CDecoder *decoderSpec = new NCompress::NLZMA::CDecoder;
+	CMyComPtr<ICompressCoder> decoder = decoderSpec;
+
+    // CJH: Use the default dictionary size if none was specified
+    if (dictionary_size <= 0)
+    {
+            dictionary_size = (1 << 23);
+    }
+
+	if (decoderSpec->SetDecoderPropertiesRaw(lc, 
+		lp, pb, dictionary_size) != S_OK) return Z_DATA_ERROR;
+	
+	UInt64 fileSize = *destLen;
+
+	if (decoder->Code(inStream, outStream, 0, &fileSize, 0) != S_OK)
+	{
+        return Z_DATA_ERROR;
+	}
+	
+	outStreamSpec->Seek(0, STREAM_SEEK_END, &fileSize);
+	*destLen = fileSize;
+	
+	return Z_OK;
+}
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderBit.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderBit.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderBit.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderBit.cpp	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,80 @@
+// Compress/RangeCoder/RangeCoderBit.cpp
+
+#include "StdAfx.h"
+
+#include "RangeCoderBit.h"
+
+namespace NCompress {
+namespace NRangeCoder {
+
+UInt32 CPriceTables::ProbPrices[kBitModelTotal >> kNumMoveReducingBits];
+static CPriceTables g_PriceTables;
+
+CPriceTables::CPriceTables() { Init(); }
+
+void CPriceTables::Init()
+{
+  const int kNumBits = (kNumBitModelTotalBits - kNumMoveReducingBits);
+  for(int i = kNumBits - 1; i >= 0; i--)
+  {
+    UInt32 start = 1 << (kNumBits - i - 1);
+    UInt32 end = 1 << (kNumBits - i);
+    for (UInt32 j = start; j < end; j++)
+      ProbPrices[j] = (i << kNumBitPriceShiftBits) + 
+          (((end - j) << kNumBitPriceShiftBits) >> (kNumBits - i - 1));
+  }
+
+  /*
+  // simplest: bad solution
+  for(UInt32 i = 1; i < (kBitModelTotal >> kNumMoveReducingBits) - 1; i++)
+    ProbPrices[i] = kBitPrice;
+  */
+  
+  /*
+  const double kDummyMultMid = (1.0 / kBitPrice) / 2;
+  const double kDummyMultMid = 0;
+  // float solution
+  double ln2 = log(double(2));
+  double lnAll = log(double(kBitModelTotal >> kNumMoveReducingBits));
+  for(UInt32 i = 1; i < (kBitModelTotal >> kNumMoveReducingBits) - 1; i++)
+    ProbPrices[i] = UInt32((fabs(lnAll - log(double(i))) / ln2 + kDummyMultMid) * kBitPrice);
+  */
+  
+  /*
+  // experimental, slow, solution:
+  for(UInt32 i = 1; i < (kBitModelTotal >> kNumMoveReducingBits) - 1; i++)
+  {
+    const int kCyclesBits = 5;
+    const UInt32 kCycles = (1 << kCyclesBits);
+
+    UInt32 range = UInt32(-1);
+    UInt32 bitCount = 0;
+    for (UInt32 j = 0; j < kCycles; j++)
+    {
+      range >>= (kNumBitModelTotalBits - kNumMoveReducingBits);
+      range *= i;
+      while(range < (1 << 31))
+      {
+        range <<= 1;
+        bitCount++;
+      }
+    }
+    bitCount <<= kNumBitPriceShiftBits;
+    range -= (1 << 31);
+    for (int k = kNumBitPriceShiftBits - 1; k >= 0; k--)
+    {
+      range <<= 1;
+      if (range > (1 << 31))
+      {
+        bitCount += (1 << k);
+        range -= (1 << 31);
+      }
+    }
+    ProbPrices[i] = (bitCount 
+      // + (1 << (kCyclesBits - 1))
+      ) >> kCyclesBits;
+  }
+  */
+}
+
+}}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderBit.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderBit.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderBit.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderBit.h	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,120 @@
+// Compress/RangeCoder/RangeCoderBit.h
+
+#ifndef __COMPRESS_RANGECODER_BIT_H
+#define __COMPRESS_RANGECODER_BIT_H
+
+#include "RangeCoder.h"
+
+namespace NCompress {
+namespace NRangeCoder {
+
+const int kNumBitModelTotalBits  = 11;
+const UInt32 kBitModelTotal = (1 << kNumBitModelTotalBits);
+
+const int kNumMoveReducingBits = 2;
+
+const int kNumBitPriceShiftBits = 6;
+const UInt32 kBitPrice = 1 << kNumBitPriceShiftBits;
+
+class CPriceTables
+{
+public:
+  static UInt32 ProbPrices[kBitModelTotal >> kNumMoveReducingBits];
+  static void Init();
+  CPriceTables();
+};
+
+template <int numMoveBits>
+class CBitModel
+{
+public:
+  UInt32 Prob;
+  void UpdateModel(UInt32 symbol)
+  {
+    /*
+    Prob -= (Prob + ((symbol - 1) & ((1 << numMoveBits) - 1))) >> numMoveBits;
+    Prob += (1 - symbol) << (kNumBitModelTotalBits - numMoveBits);
+    */
+    if (symbol == 0)
+      Prob += (kBitModelTotal - Prob) >> numMoveBits;
+    else
+      Prob -= (Prob) >> numMoveBits;
+  }
+public:
+  void Init() { Prob = kBitModelTotal / 2; }
+};
+
+template <int numMoveBits>
+class CBitEncoder: public CBitModel<numMoveBits>
+{
+public:
+  void Encode(CEncoder *encoder, UInt32 symbol)
+  {
+    /*
+    encoder->EncodeBit(this->Prob, kNumBitModelTotalBits, symbol);
+    this->UpdateModel(symbol);
+    */
+    UInt32 newBound = (encoder->Range >> kNumBitModelTotalBits) * this->Prob;
+    if (symbol == 0)
+    {
+      encoder->Range = newBound;
+      this->Prob += (kBitModelTotal - this->Prob) >> numMoveBits;
+    }
+    else
+    {
+      encoder->Low += newBound;
+      encoder->Range -= newBound;
+      this->Prob -= (this->Prob) >> numMoveBits;
+    }
+    if (encoder->Range < kTopValue)
+    {
+      encoder->Range <<= 8;
+      encoder->ShiftLow();
+    }
+  }
+  UInt32 GetPrice(UInt32 symbol) const
+  {
+    return CPriceTables::ProbPrices[
+      (((this->Prob - symbol) ^ ((-(int)symbol))) & (kBitModelTotal - 1)) >> kNumMoveReducingBits];
+  }
+  UInt32 GetPrice0() const { return CPriceTables::ProbPrices[this->Prob >> kNumMoveReducingBits]; }
+  UInt32 GetPrice1() const { return CPriceTables::ProbPrices[(kBitModelTotal - this->Prob) >> kNumMoveReducingBits]; }
+};
+
+
+template <int numMoveBits>
+class CBitDecoder: public CBitModel<numMoveBits>
+{
+public:
+  UInt32 Decode(CDecoder *decoder)
+  {
+    UInt32 newBound = (decoder->Range >> kNumBitModelTotalBits) * this->Prob;
+    if (decoder->Code < newBound)
+    {
+      decoder->Range = newBound;
+      this->Prob += (kBitModelTotal - this->Prob) >> numMoveBits;
+      if (decoder->Range < kTopValue)
+      {
+        decoder->Code = (decoder->Code << 8) | decoder->Stream.ReadByte();
+        decoder->Range <<= 8;
+      }
+      return 0;
+    }
+    else
+    {
+      decoder->Range -= newBound;
+      decoder->Code -= newBound;
+      this->Prob -= (this->Prob) >> numMoveBits;
+      if (decoder->Range < kTopValue)
+      {
+        decoder->Code = (decoder->Code << 8) | decoder->Stream.ReadByte();
+        decoder->Range <<= 8;
+      }
+      return 1;
+    }
+  }
+};
+
+}}
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderBitTree.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderBitTree.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderBitTree.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderBitTree.h	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,161 @@
+// Compress/RangeCoder/RangeCoderBitTree.h
+
+#ifndef __COMPRESS_RANGECODER_BIT_TREE_H
+#define __COMPRESS_RANGECODER_BIT_TREE_H
+
+#include "RangeCoderBit.h"
+#include "RangeCoderOpt.h"
+
+namespace NCompress {
+namespace NRangeCoder {
+
+template <int numMoveBits, int NumBitLevels>
+class CBitTreeEncoder
+{
+  CBitEncoder<numMoveBits> Models[1 << NumBitLevels];
+public:
+  void Init()
+  {
+    for(UInt32 i = 1; i < (1 << NumBitLevels); i++)
+      Models[i].Init();
+  }
+  void Encode(CEncoder *rangeEncoder, UInt32 symbol)
+  {
+    UInt32 modelIndex = 1;
+    for (int bitIndex = NumBitLevels; bitIndex != 0 ;)
+    {
+      bitIndex--;
+      UInt32 bit = (symbol >> bitIndex) & 1;
+      Models[modelIndex].Encode(rangeEncoder, bit);
+      modelIndex = (modelIndex << 1) | bit;
+    }
+  };
+  void ReverseEncode(CEncoder *rangeEncoder, UInt32 symbol)
+  {
+    UInt32 modelIndex = 1;
+    for (int i = 0; i < NumBitLevels; i++)
+    {
+      UInt32 bit = symbol & 1;
+      Models[modelIndex].Encode(rangeEncoder, bit);
+      modelIndex = (modelIndex << 1) | bit;
+      symbol >>= 1;
+    }
+  }
+  UInt32 GetPrice(UInt32 symbol) const
+  {
+    symbol |= (1 << NumBitLevels);
+    UInt32 price = 0;
+    while (symbol != 1)
+    {
+      price += Models[symbol >> 1].GetPrice(symbol & 1);
+      symbol >>= 1;
+    }
+    return price;
+  }
+  UInt32 ReverseGetPrice(UInt32 symbol) const
+  {
+    UInt32 price = 0;
+    UInt32 modelIndex = 1;
+    for (int i = NumBitLevels; i != 0; i--)
+    {
+      UInt32 bit = symbol & 1;
+      symbol >>= 1;
+      price += Models[modelIndex].GetPrice(bit);
+      modelIndex = (modelIndex << 1) | bit;
+    }
+    return price;
+  }
+};
+
+template <int numMoveBits, int NumBitLevels>
+class CBitTreeDecoder
+{
+  CBitDecoder<numMoveBits> Models[1 << NumBitLevels];
+public:
+  void Init()
+  {
+    for(UInt32 i = 1; i < (1 << NumBitLevels); i++)
+      Models[i].Init();
+  }
+  UInt32 Decode(CDecoder *rangeDecoder)
+  {
+    UInt32 modelIndex = 1;
+    RC_INIT_VAR
+    for(int bitIndex = NumBitLevels; bitIndex != 0; bitIndex--)
+    {
+      // modelIndex = (modelIndex << 1) + Models[modelIndex].Decode(rangeDecoder);
+      RC_GETBIT(numMoveBits, Models[modelIndex].Prob, modelIndex)
+    }
+    RC_FLUSH_VAR
+    return modelIndex - (1 << NumBitLevels);
+  };
+  UInt32 ReverseDecode(CDecoder *rangeDecoder)
+  {
+    UInt32 modelIndex = 1;
+    UInt32 symbol = 0;
+    RC_INIT_VAR
+    for(int bitIndex = 0; bitIndex < NumBitLevels; bitIndex++)
+    {
+      // UInt32 bit = Models[modelIndex].Decode(rangeDecoder);
+      // modelIndex <<= 1;
+      // modelIndex += bit;
+      // symbol |= (bit << bitIndex);
+      RC_GETBIT2(numMoveBits, Models[modelIndex].Prob, modelIndex, ; , symbol |= (1 << bitIndex))
+    }
+    RC_FLUSH_VAR
+    return symbol;
+  }
+};
+
+template <int numMoveBits>
+void ReverseBitTreeEncode(CBitEncoder<numMoveBits> *Models, 
+    CEncoder *rangeEncoder, int NumBitLevels, UInt32 symbol)
+{
+  UInt32 modelIndex = 1;
+  for (int i = 0; i < NumBitLevels; i++)
+  {
+    UInt32 bit = symbol & 1;
+    Models[modelIndex].Encode(rangeEncoder, bit);
+    modelIndex = (modelIndex << 1) | bit;
+    symbol >>= 1;
+  }
+}
+
+template <int numMoveBits>
+UInt32 ReverseBitTreeGetPrice(CBitEncoder<numMoveBits> *Models, 
+    UInt32 NumBitLevels, UInt32 symbol)
+{
+  UInt32 price = 0;
+  UInt32 modelIndex = 1;
+  for (int i = NumBitLevels; i != 0; i--)
+  {
+    UInt32 bit = symbol & 1;
+    symbol >>= 1;
+    price += Models[modelIndex].GetPrice(bit);
+    modelIndex = (modelIndex << 1) | bit;
+  }
+  return price;
+}
+
+template <int numMoveBits>
+UInt32 ReverseBitTreeDecode(CBitDecoder<numMoveBits> *Models, 
+    CDecoder *rangeDecoder, int NumBitLevels)
+{
+  UInt32 modelIndex = 1;
+  UInt32 symbol = 0;
+  RC_INIT_VAR
+  for(int bitIndex = 0; bitIndex < NumBitLevels; bitIndex++)
+  {
+    // UInt32 bit = Models[modelIndex].Decode(rangeDecoder);
+    // modelIndex <<= 1;
+    // modelIndex += bit;
+    // symbol |= (bit << bitIndex);
+    RC_GETBIT2(numMoveBits, Models[modelIndex].Prob, modelIndex, ; , symbol |= (1 << bitIndex))
+  }
+  RC_FLUSH_VAR
+  return symbol;
+}
+
+}}
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoder.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoder.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoder.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoder.h	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,205 @@
+// Compress/RangeCoder/RangeCoder.h
+
+#ifndef __COMPRESS_RANGECODER_H
+#define __COMPRESS_RANGECODER_H
+
+#include "../../Common/InBuffer.h"
+#include "../../Common/OutBuffer.h"
+
+namespace NCompress {
+namespace NRangeCoder {
+
+const int kNumTopBits = 24;
+const UInt32 kTopValue = (1 << kNumTopBits);
+
+class CEncoder
+{
+  UInt32 _cacheSize;
+  Byte _cache;
+public:
+  UInt64 Low;
+  UInt32 Range;
+  COutBuffer Stream;
+  bool Create(UInt32 bufferSize) { return Stream.Create(bufferSize); }
+
+  void SetStream(ISequentialOutStream *stream) { Stream.SetStream(stream); }
+  void Init()
+  {
+    Stream.Init();
+    Low = 0;
+    Range = 0xFFFFFFFF;
+    _cacheSize = 1;
+    _cache = 0;
+  }
+
+  void FlushData()
+  {
+    // Low += 1; 
+    for(int i = 0; i < 5; i++)
+      ShiftLow();
+  }
+
+  HRESULT FlushStream() { return Stream.Flush();  }
+
+  void ReleaseStream() { Stream.ReleaseStream(); }
+
+  void Encode(UInt32 start, UInt32 size, UInt32 total)
+  {
+    Low += start * (Range /= total);
+    Range *= size;
+    while (Range < kTopValue)
+    {
+      Range <<= 8;
+      ShiftLow();
+    }
+  }
+
+  void ShiftLow()
+  {
+    if ((UInt32)Low < (UInt32)0xFF000000 || (int)(Low >> 32) != 0) 
+    {
+      Byte temp = _cache;
+      do
+      {
+        Stream.WriteByte((Byte)(temp + (Byte)(Low >> 32)));
+        temp = 0xFF;
+      }
+      while(--_cacheSize != 0);
+      _cache = (Byte)((UInt32)Low >> 24);                      
+    } 
+    _cacheSize++;                               
+    Low = (UInt32)Low << 8;                           
+  }
+  
+  void EncodeDirectBits(UInt32 value, int numTotalBits)
+  {
+    for (int i = numTotalBits - 1; i >= 0; i--)
+    {
+      Range >>= 1;
+      if (((value >> i) & 1) == 1)
+        Low += Range;
+      if (Range < kTopValue)
+      {
+        Range <<= 8;
+        ShiftLow();
+      }
+    }
+  }
+
+  void EncodeBit(UInt32 size0, UInt32 numTotalBits, UInt32 symbol)
+  {
+    UInt32 newBound = (Range >> numTotalBits) * size0;
+    if (symbol == 0)
+      Range = newBound;
+    else
+    {
+      Low += newBound;
+      Range -= newBound;
+    }
+    while (Range < kTopValue)
+    {
+      Range <<= 8;
+      ShiftLow();
+    }
+  }
+
+  UInt64 GetProcessedSize() {  return Stream.GetProcessedSize() + _cacheSize + 4; }
+};
+
+class CDecoder
+{
+public:
+  CInBuffer Stream;
+  UInt32 Range;
+  UInt32 Code;
+  bool Create(UInt32 bufferSize) { return Stream.Create(bufferSize); }
+
+  void Normalize()
+  {
+    while (Range < kTopValue)
+    {
+      Code = (Code << 8) | Stream.ReadByte();
+      Range <<= 8;
+    }
+  }
+  
+  void SetStream(ISequentialInStream *stream) { Stream.SetStream(stream); }
+  void Init()
+  {
+    Stream.Init();
+    Code = 0;
+    Range = 0xFFFFFFFF;
+    for(int i = 0; i < 5; i++)
+      Code = (Code << 8) | Stream.ReadByte();
+  }
+
+  void ReleaseStream() { Stream.ReleaseStream(); }
+
+  UInt32 GetThreshold(UInt32 total)
+  {
+    return (Code) / ( Range /= total);
+  }
+
+  void Decode(UInt32 start, UInt32 size)
+  {
+    Code -= start * Range;
+    Range *= size;
+    Normalize();
+  }
+
+  UInt32 DecodeDirectBits(int numTotalBits)
+  {
+    UInt32 range = Range;
+    UInt32 code = Code;        
+    UInt32 result = 0;
+    for (int i = numTotalBits; i != 0; i--)
+    {
+      range >>= 1;
+      /*
+      result <<= 1;
+      if (code >= range)
+      {
+        code -= range;
+        result |= 1;
+      }
+      */
+      UInt32 t = (code - range) >> 31;
+      code -= range & (t - 1);
+      result = (result << 1) | (1 - t);
+
+      if (range < kTopValue)
+      {
+        code = (code << 8) | Stream.ReadByte();
+        range <<= 8; 
+      }
+    }
+    Range = range;
+    Code = code;
+    return result;
+  }
+
+  UInt32 DecodeBit(UInt32 size0, UInt32 numTotalBits)
+  {
+    UInt32 newBound = (Range >> numTotalBits) * size0;
+    UInt32 symbol;
+    if (Code < newBound)
+    {
+      symbol = 0;
+      Range = newBound;
+    }
+    else
+    {
+      symbol = 1;
+      Code -= newBound;
+      Range -= newBound;
+    }
+    Normalize();
+    return symbol;
+  }
+
+  UInt64 GetProcessedSize() {return Stream.GetProcessedSize(); }
+};
+
+}}
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderOpt.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderOpt.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderOpt.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/RangeCoderOpt.h	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,31 @@
+// Compress/RangeCoder/RangeCoderOpt.h
+
+#ifndef __COMPRESS_RANGECODER_OPT_H
+#define __COMPRESS_RANGECODER_OPT_H
+
+#define RC_INIT_VAR \
+  UInt32 range = rangeDecoder->Range; \
+  UInt32 code = rangeDecoder->Code;        
+
+#define RC_FLUSH_VAR \
+  rangeDecoder->Range = range; \
+  rangeDecoder->Code = code;
+
+#define RC_NORMALIZE \
+  if (range < NCompress::NRangeCoder::kTopValue) \
+    { code = (code << 8) | rangeDecoder->Stream.ReadByte(); range <<= 8; }
+
+#define RC_GETBIT2(numMoveBits, prob, mi, A0, A1) \
+  { UInt32 bound = (range >> NCompress::NRangeCoder::kNumBitModelTotalBits) * prob; \
+  if (code < bound) \
+  { A0; range = bound; \
+    prob += (NCompress::NRangeCoder::kBitModelTotal - prob) >> numMoveBits; \
+    mi <<= 1; } \
+  else \
+  { A1; range -= bound; code -= bound; prob -= (prob) >> numMoveBits; \
+    mi = (mi + mi) + 1; }} \
+  RC_NORMALIZE
+
+#define RC_GETBIT(numMoveBits, prob, mi) RC_GETBIT2(numMoveBits, prob, mi, ; , ;)
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/StdAfx.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/StdAfx.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/StdAfx.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/Compress/RangeCoder/StdAfx.h	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,6 @@
+// StdAfx.h
+
+#ifndef __STDAFX_H
+#define __STDAFX_H
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/ICoder.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/ICoder.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/ICoder.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/ICoder.h	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,156 @@
+// ICoder.h
+
+#ifndef __ICODER_H
+#define __ICODER_H
+
+#include "IStream.h"
+
+// "23170F69-40C1-278A-0000-000400xx0000"
+#define CODER_INTERFACE(i, x) \
+DEFINE_GUID(IID_ ## i, \
+0x23170F69, 0x40C1, 0x278A, 0x00, 0x00, 0x00, 0x04, 0x00, x, 0x00, 0x00); \
+struct i: public IUnknown
+
+CODER_INTERFACE(ICompressProgressInfo, 0x04)
+{
+  STDMETHOD(SetRatioInfo)(const UInt64 *inSize, const UInt64 *outSize) PURE;
+};
+
+CODER_INTERFACE(ICompressCoder, 0x05)
+{
+  STDMETHOD(Code)(ISequentialInStream *inStream,
+      ISequentialOutStream *outStream, 
+      const UInt64 *inSize, 
+      const UInt64 *outSize,
+      ICompressProgressInfo *progress) PURE;
+};
+
+CODER_INTERFACE(ICompressCoder2, 0x18)
+{
+  STDMETHOD(Code)(ISequentialInStream **inStreams,
+      const UInt64 **inSizes, 
+      UInt32 numInStreams,
+      ISequentialOutStream **outStreams, 
+      const UInt64 **outSizes,
+      UInt32 numOutStreams,
+      ICompressProgressInfo *progress) PURE;
+};
+
+namespace NCoderPropID
+{
+  enum EEnum
+  {
+    kDictionarySize = 0x400,
+    kUsedMemorySize,
+    kOrder,
+    kPosStateBits = 0x440,
+    kLitContextBits,
+    kLitPosBits,
+    kNumFastBytes = 0x450,
+    kMatchFinder,
+    kNumPasses = 0x460, 
+    kAlgorithm = 0x470,
+    kMultiThread = 0x480,
+    kEndMarker = 0x490
+  };
+}
+
+CODER_INTERFACE(ICompressSetCoderProperties, 0x20)
+{
+  STDMETHOD(SetCoderProperties)(const PROPID *propIDs, 
+      const PROPVARIANT *properties, UInt32 numProperties) PURE;
+};
+
+/*
+CODER_INTERFACE(ICompressSetCoderProperties, 0x21)
+{
+  STDMETHOD(SetDecoderProperties)(ISequentialInStream *inStream) PURE;
+};
+*/
+
+CODER_INTERFACE(ICompressSetDecoderProperties2, 0x22)
+{
+  STDMETHOD(SetDecoderProperties2)(const Byte *data, UInt32 size) PURE;
+};
+
+CODER_INTERFACE(ICompressWriteCoderProperties, 0x23)
+{
+  STDMETHOD(WriteCoderProperties)(ISequentialOutStream *outStreams) PURE;
+};
+
+CODER_INTERFACE(ICompressGetInStreamProcessedSize, 0x24)
+{
+  STDMETHOD(GetInStreamProcessedSize)(UInt64 *value) PURE;
+};
+
+CODER_INTERFACE(ICompressGetSubStreamSize, 0x30)
+{
+  STDMETHOD(GetSubStreamSize)(UInt64 subStream, UInt64 *value) PURE;
+};
+
+CODER_INTERFACE(ICompressSetInStream, 0x31)
+{
+  STDMETHOD(SetInStream)(ISequentialInStream *inStream) PURE;
+  STDMETHOD(ReleaseInStream)() PURE;
+};
+
+CODER_INTERFACE(ICompressSetOutStream, 0x32)
+{
+  STDMETHOD(SetOutStream)(ISequentialOutStream *outStream) PURE;
+  STDMETHOD(ReleaseOutStream)() PURE;
+};
+
+CODER_INTERFACE(ICompressSetInStreamSize, 0x33)
+{
+  STDMETHOD(SetInStreamSize)(const UInt64 *inSize) PURE;
+};
+
+CODER_INTERFACE(ICompressSetOutStreamSize, 0x34)
+{
+  STDMETHOD(SetOutStreamSize)(const UInt64 *outSize) PURE;
+};
+
+CODER_INTERFACE(ICompressFilter, 0x40)
+{
+  STDMETHOD(Init)() PURE;
+  STDMETHOD_(UInt32, Filter)(Byte *data, UInt32 size) PURE;
+  // Filter return outSize (UInt32)
+  // if (outSize <= size): Filter have converted outSize bytes
+  // if (outSize > size): Filter have not converted anything.
+  //      and it needs at least outSize bytes to convert one block 
+  //      (it's for crypto block algorithms).
+};
+
+CODER_INTERFACE(ICryptoProperties, 0x80)
+{
+  STDMETHOD(SetKey)(const Byte *data, UInt32 size) PURE;
+  STDMETHOD(SetInitVector)(const Byte *data, UInt32 size) PURE;
+};
+
+CODER_INTERFACE(ICryptoSetPassword, 0x90)
+{
+  STDMETHOD(CryptoSetPassword)(const Byte *data, UInt32 size) PURE;
+};
+
+CODER_INTERFACE(ICryptoSetCRC, 0xA0)
+{
+  STDMETHOD(CryptoSetCRC)(UInt32 crc) PURE;
+};
+
+//////////////////////
+// It's for DLL file
+namespace NMethodPropID
+{
+  enum EEnum
+  {
+    kID,
+    kName,
+    kDecoder,
+    kEncoder,
+    kInStreams,
+    kOutStreams,
+    kDescription
+  };
+}
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/7zip/IStream.h squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/IStream.h
--- squashfs-tools/LZMA/lzmadaptive/C/7zip/IStream.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/7zip/IStream.h	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,62 @@
+// IStream.h
+
+#ifndef __ISTREAM_H
+#define __ISTREAM_H
+
+#include "../Common/MyUnknown.h"
+#include "../Common/Types.h"
+
+// "23170F69-40C1-278A-0000-000300xx0000"
+
+#define STREAM_INTERFACE_SUB(i, b, x) \
+DEFINE_GUID(IID_ ## i, \
+0x23170F69, 0x40C1, 0x278A, 0x00, 0x00, 0x00, 0x03, 0x00, x, 0x00, 0x00); \
+struct i: public b
+
+#define STREAM_INTERFACE(i, x) STREAM_INTERFACE_SUB(i, IUnknown, x)
+
+STREAM_INTERFACE(ISequentialInStream, 0x01)
+{
+  STDMETHOD(Read)(void *data, UInt32 size, UInt32 *processedSize) PURE;
+  /*
+  Out: if size != 0, return_value = S_OK and (*processedSize == 0),
+    then there are no more bytes in stream.
+  if (size > 0) && there are bytes in stream, 
+  this function must read at least 1 byte.
+  This function is allowed to read less than number of remaining bytes in stream.
+  You must call Read function in loop, if you need exact amount of data
+  */
+};
+
+STREAM_INTERFACE(ISequentialOutStream, 0x02)
+{
+  STDMETHOD(Write)(const void *data, UInt32 size, UInt32 *processedSize) PURE;
+  /*
+  if (size > 0) this function must write at least 1 byte.
+  This function is allowed to write less than "size".
+  You must call Write function in loop, if you need to write exact amount of data
+  */
+};
+
+STREAM_INTERFACE_SUB(IInStream, ISequentialInStream, 0x03)
+{
+  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition) PURE;
+};
+
+STREAM_INTERFACE_SUB(IOutStream, ISequentialOutStream, 0x04)
+{
+  STDMETHOD(Seek)(Int64 offset, UInt32 seekOrigin, UInt64 *newPosition) PURE;
+  STDMETHOD(SetSize)(Int64 newSize) PURE;
+};
+
+STREAM_INTERFACE(IStreamGetSize, 0x06)
+{
+  STDMETHOD(GetSize)(UInt64 *size) PURE;
+};
+
+STREAM_INTERFACE(IOutStreamFlush, 0x07)
+{
+  STDMETHOD(Flush)() PURE;
+};
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/Alloc.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/Common/Alloc.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/Common/Alloc.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/Alloc.cpp	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,118 @@
+// Common/Alloc.cpp
+
+#include "StdAfx.h"
+
+#ifdef _WIN32
+#include "MyWindows.h"
+#else
+#include <stdlib.h>
+#endif
+
+#include "Alloc.h"
+
+/* #define _SZ_ALLOC_DEBUG */
+/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
+#ifdef _SZ_ALLOC_DEBUG
+#include <stdio.h>
+int g_allocCount = 0;
+int g_allocCountMid = 0;
+int g_allocCountBig = 0;
+#endif
+
+void *MyAlloc(size_t size) throw()
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, "\nAlloc %10d bytes; count = %10d", size, g_allocCount++);
+  #endif
+  return ::malloc(size);
+}
+
+void MyFree(void *address) throw()
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+    fprintf(stderr, "\nFree; count = %10d", --g_allocCount);
+  #endif
+  
+  ::free(address);
+}
+
+#ifdef _WIN32
+
+void *MidAlloc(size_t size) throw()
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, "\nAlloc_Mid %10d bytes;  count = %10d", size, g_allocCountMid++);
+  #endif
+  return ::VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
+}
+
+void MidFree(void *address) throw()
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+    fprintf(stderr, "\nFree_Mid; count = %10d", --g_allocCountMid);
+  #endif
+  if (address == 0)
+    return;
+  ::VirtualFree(address, 0, MEM_RELEASE);
+}
+
+static SIZE_T g_LargePageSize = 
+    #ifdef _WIN64
+    (1 << 21);
+    #else
+    (1 << 22);
+    #endif
+
+typedef SIZE_T (WINAPI *GetLargePageMinimumP)();
+
+bool SetLargePageSize()
+{
+  GetLargePageMinimumP largePageMinimum = (GetLargePageMinimumP)
+        ::GetProcAddress(::GetModuleHandle(TEXT("kernel32.dll")), "GetLargePageMinimum");
+  if (largePageMinimum == 0)
+    return false;
+  SIZE_T size = largePageMinimum();
+  if (size == 0 || (size & (size - 1)) != 0)
+    return false;
+  g_LargePageSize = size;
+  return true;
+}
+
+
+void *BigAlloc(size_t size) throw()
+{
+  if (size == 0)
+    return 0;
+  #ifdef _SZ_ALLOC_DEBUG
+  fprintf(stderr, "\nAlloc_Big %10d bytes;  count = %10d", size, g_allocCountBig++);
+  #endif
+  
+  if (size >= (1 << 18))
+  {
+    void *res = ::VirtualAlloc(0, (size + g_LargePageSize - 1) & (~(g_LargePageSize - 1)), 
+        MEM_COMMIT | MEM_LARGE_PAGES, PAGE_READWRITE);
+    if (res != 0)
+      return res;
+  }
+  return ::VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
+}
+
+void BigFree(void *address) throw()
+{
+  #ifdef _SZ_ALLOC_DEBUG
+  if (address != 0)
+    fprintf(stderr, "\nFree_Big; count = %10d", --g_allocCountBig);
+  #endif
+  
+  if (address == 0)
+    return;
+  ::VirtualFree(address, 0, MEM_RELEASE);
+}
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/Alloc.h squashfs-tools-patched/LZMA/lzmadaptive/C/Common/Alloc.h
--- squashfs-tools/LZMA/lzmadaptive/C/Common/Alloc.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/Alloc.h	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,29 @@
+// Common/Alloc.h
+
+#ifndef __COMMON_ALLOC_H
+#define __COMMON_ALLOC_H
+
+#include <stddef.h>
+
+void *MyAlloc(size_t size) throw();
+void MyFree(void *address) throw();
+
+#ifdef _WIN32
+
+bool SetLargePageSize();
+
+void *MidAlloc(size_t size) throw();
+void MidFree(void *address) throw();
+void *BigAlloc(size_t size) throw();
+void BigFree(void *address) throw();
+
+#else
+
+#define MidAlloc(size) MyAlloc(size)
+#define MidFree(address) MyFree(address)
+#define BigAlloc(size) MyAlloc(size)
+#define BigFree(address) MyFree(address)
+
+#endif
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/C_FileIO.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/Common/C_FileIO.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/Common/C_FileIO.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/C_FileIO.cpp	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,78 @@
+// Common/C_FileIO.h
+
+#include "C_FileIO.h"
+
+#include <fcntl.h>
+#include <unistd.h>
+
+namespace NC {
+namespace NFile {
+namespace NIO {
+
+bool CFileBase::OpenBinary(const char *name, int flags)
+{
+  #ifdef O_BINARY
+  flags |= O_BINARY;
+  #endif
+  Close();
+  _handle = ::open(name, flags, 0666);
+  return _handle != -1;
+}
+
+bool CFileBase::Close()
+{
+  if(_handle == -1)
+    return true;
+  if (close(_handle) != 0)
+    return false;
+  _handle = -1;
+  return true;
+}
+
+bool CFileBase::GetLength(UInt64 &length) const
+{
+  off_t curPos = Seek(0, SEEK_CUR);
+  off_t lengthTemp = Seek(0, SEEK_END);
+  Seek(curPos, SEEK_SET);
+  length = (UInt64)lengthTemp;
+  return true;
+}
+
+off_t CFileBase::Seek(off_t distanceToMove, int moveMethod) const
+{
+  return ::lseek(_handle, distanceToMove, moveMethod);
+}
+
+/////////////////////////
+// CInFile
+
+bool CInFile::Open(const char *name)
+{
+  return CFileBase::OpenBinary(name, O_RDONLY);
+}
+
+ssize_t CInFile::Read(void *data, size_t size)
+{
+  return read(_handle, data, size);
+}
+
+/////////////////////////
+// COutFile
+
+bool COutFile::Create(const char *name, bool createAlways)
+{
+  if (createAlways)
+  {
+    Close();
+    _handle = ::creat(name, 0666);
+    return _handle != -1;
+  }
+  return OpenBinary(name, O_CREAT | O_EXCL | O_WRONLY);
+}
+
+ssize_t COutFile::Write(const void *data, size_t size)
+{
+  return write(_handle, data, size);
+}
+
+}}}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/C_FileIO.h squashfs-tools-patched/LZMA/lzmadaptive/C/Common/C_FileIO.h
--- squashfs-tools/LZMA/lzmadaptive/C/Common/C_FileIO.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/C_FileIO.h	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,45 @@
+// Common/C_FileIO.h
+
+#ifndef __COMMON_C_FILEIO_H
+#define __COMMON_C_FILEIO_H
+
+#include <stdio.h>
+#include <sys/types.h>
+
+#include "Types.h"
+#include "MyWindows.h"
+
+namespace NC {
+namespace NFile {
+namespace NIO {
+
+class CFileBase
+{
+protected:
+  int _handle;
+  bool OpenBinary(const char *name, int flags);
+public:
+  CFileBase(): _handle(-1) {};
+  ~CFileBase() { Close(); }
+  bool Close();
+  bool GetLength(UInt64 &length) const;
+  off_t Seek(off_t distanceToMove, int moveMethod) const;
+};
+
+class CInFile: public CFileBase
+{
+public:
+  bool Open(const char *name);
+  ssize_t Read(void *data, size_t size);
+};
+
+class COutFile: public CFileBase
+{
+public:
+  bool Create(const char *name, bool createAlways);
+  ssize_t Write(const void *data, size_t size);
+};
+
+}}}
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/CommandLineParser.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/Common/CommandLineParser.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/Common/CommandLineParser.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/CommandLineParser.cpp	2022-01-01 15:08:47.897171448 +0800
@@ -0,0 +1,263 @@
+// CommandLineParser.cpp
+
+#include "StdAfx.h"
+
+#include "CommandLineParser.h"
+
+namespace NCommandLineParser {
+
+void SplitCommandLine(const UString &src, UString &dest1, UString &dest2)
+{
+  dest1.Empty();
+  dest2.Empty();
+  bool quoteMode = false;
+  int i;
+  for (i = 0; i < src.Length(); i++)
+  {
+    wchar_t c = src[i];
+    if (c == L'\"')
+      quoteMode = !quoteMode;
+    else if (c == L' ' && !quoteMode)
+    {
+      i++;
+      break;
+    }
+    else 
+      dest1 += c;
+  }
+  dest2 = src.Mid(i);
+}
+
+void SplitCommandLine(const UString &s, UStringVector &parts)
+{
+  UString sTemp = s;
+  sTemp.Trim();
+  parts.Clear();
+  while (true)
+  {
+    UString s1, s2;
+    SplitCommandLine(sTemp, s1, s2);
+    // s1.Trim();
+    // s2.Trim();
+    if (!s1.IsEmpty())
+      parts.Add(s1);
+    if (s2.IsEmpty())
+      return;
+    sTemp = s2;
+  }
+}
+
+
+static const wchar_t kSwitchID1 = '-';
+// static const wchar_t kSwitchID2 = '/';
+
+static const wchar_t kSwitchMinus = '-';
+static const wchar_t *kStopSwitchParsing = L"--";
+
+static bool IsItSwitchChar(wchar_t c)
+{ 
+  return (c == kSwitchID1 /*|| c == kSwitchID2 */); 
+}
+
+CParser::CParser(int numSwitches):
+  _numSwitches(numSwitches)
+{
+  _switches = new CSwitchResult[_numSwitches];
+}
+
+CParser::~CParser()
+{
+  delete []_switches;
+}
+
+void CParser::ParseStrings(const CSwitchForm *switchForms, 
+  const UStringVector &commandStrings)
+{
+  int numCommandStrings = commandStrings.Size();
+  bool stopSwitch = false;
+  for (int i = 0; i < numCommandStrings; i++)
+  {
+    const UString &s = commandStrings[i];
+    if (stopSwitch)
+      NonSwitchStrings.Add(s);
+    else
+      if (s == kStopSwitchParsing)
+        stopSwitch = true;
+      else
+        if (!ParseString(s, switchForms))
+          NonSwitchStrings.Add(s);
+  }
+}
+
+// if string contains switch then function updates switch structures
+// out: (string is a switch)
+bool CParser::ParseString(const UString &s, const CSwitchForm *switchForms)
+{
+  int len = s.Length();
+  if (len == 0) 
+    return false;
+  int pos = 0;
+  if (!IsItSwitchChar(s[pos]))
+    return false;
+  while(pos < len)
+  {
+    if (IsItSwitchChar(s[pos]))
+      pos++;
+    const int kNoLen = -1;
+    int matchedSwitchIndex = 0; // GCC Warning
+    int maxLen = kNoLen;
+    for(int switchIndex = 0; switchIndex < _numSwitches; switchIndex++)
+    {
+      int switchLen = MyStringLen(switchForms[switchIndex].IDString);
+      if (switchLen <= maxLen || pos + switchLen > len) 
+        continue;
+
+      UString temp = s + pos;
+      temp = temp.Left(switchLen);
+      if(temp.CompareNoCase(switchForms[switchIndex].IDString) == 0)
+      // if(_strnicmp(switchForms[switchIndex].IDString, LPCSTR(s) + pos, switchLen) == 0)
+      {
+        matchedSwitchIndex = switchIndex;
+        maxLen = switchLen;
+      }
+    }
+    if (maxLen == kNoLen)
+      throw "maxLen == kNoLen";
+    CSwitchResult &matchedSwitch = _switches[matchedSwitchIndex];
+    const CSwitchForm &switchForm = switchForms[matchedSwitchIndex];
+    if ((!switchForm.Multi) && matchedSwitch.ThereIs)
+      throw "switch must be single";
+    matchedSwitch.ThereIs = true;
+    pos += maxLen;
+    int tailSize = len - pos;
+    NSwitchType::EEnum type = switchForm.Type;
+    switch(type)
+    {
+      case NSwitchType::kPostMinus:
+        {
+          if (tailSize == 0)
+            matchedSwitch.WithMinus = false;
+          else
+          {
+            matchedSwitch.WithMinus = (s[pos] == kSwitchMinus);
+            if (matchedSwitch.WithMinus)
+              pos++;
+          }
+          break;
+        }
+      case NSwitchType::kPostChar:
+        {
+          if (tailSize < switchForm.MinLen)
+            throw "switch is not full";
+          UString set = switchForm.PostCharSet;
+          const int kEmptyCharValue = -1;
+          if (tailSize == 0)
+            matchedSwitch.PostCharIndex = kEmptyCharValue;
+          else
+          {
+            int index = set.Find(s[pos]);
+            if (index < 0)
+              matchedSwitch.PostCharIndex =  kEmptyCharValue;
+            else
+            {
+              matchedSwitch.PostCharIndex = index;
+              pos++;
+            }
+          }
+          break;
+        }
+      case NSwitchType::kLimitedPostString: 
+      case NSwitchType::kUnLimitedPostString: 
+        {
+          int minLen = switchForm.MinLen;
+          if (tailSize < minLen)
+            throw "switch is not full";
+          if (type == NSwitchType::kUnLimitedPostString)
+          {
+            matchedSwitch.PostStrings.Add(s.Mid(pos));
+            return true;
+          }
+          int maxLen = switchForm.MaxLen;
+          UString stringSwitch = s.Mid(pos, minLen);
+          pos += minLen;
+          for(int i = minLen; i < maxLen && pos < len; i++, pos++)
+          {
+            wchar_t c = s[pos];
+            if (IsItSwitchChar(c))
+              break;
+            stringSwitch += c;
+          }
+          matchedSwitch.PostStrings.Add(stringSwitch);
+          break;
+        }
+      case NSwitchType::kSimple:
+          break;
+    }
+  }
+  return true;
+}
+
+const CSwitchResult& CParser::operator[](size_t index) const
+{
+  return _switches[index];
+}
+
+/////////////////////////////////
+// Command parsing procedures
+
+int ParseCommand(int numCommandForms, const CCommandForm *commandForms, 
+    const UString &commandString, UString &postString)
+{
+  for(int i = 0; i < numCommandForms; i++)
+  {
+    const UString id = commandForms[i].IDString;
+    if (commandForms[i].PostStringMode)
+    {
+      if(commandString.Find(id) == 0)
+      {
+        postString = commandString.Mid(id.Length());
+        return i;
+      }
+    }
+    else
+      if (commandString == id)
+      {
+        postString.Empty();
+        return i;
+      }
+  }
+  return -1;
+}
+   
+bool ParseSubCharsCommand(int numForms, const CCommandSubCharsSet *forms, 
+    const UString &commandString, CIntVector &indices)
+{
+  indices.Clear();
+  int numUsedChars = 0;
+  for(int i = 0; i < numForms; i++)
+  {
+    const CCommandSubCharsSet &set = forms[i];
+    int currentIndex = -1;
+    int len = MyStringLen(set.Chars);
+    for(int j = 0; j < len; j++)
+    {
+      wchar_t c = set.Chars[j];
+      int newIndex = commandString.Find(c);
+      if (newIndex >= 0)
+      {
+        if (currentIndex >= 0)
+          return false;
+        if (commandString.Find(c, newIndex + 1) >= 0)
+          return false;
+        currentIndex = j;
+        numUsedChars++;
+      }
+    }
+    if(currentIndex == -1 && !set.EmptyAllowed)
+      return false;
+    indices.Add(currentIndex);
+  }
+  return (numUsedChars == commandString.Length());
+}
+
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/CommandLineParser.h squashfs-tools-patched/LZMA/lzmadaptive/C/Common/CommandLineParser.h
--- squashfs-tools/LZMA/lzmadaptive/C/Common/CommandLineParser.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/CommandLineParser.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,82 @@
+// Common/CommandLineParser.h
+
+#ifndef __COMMON_COMMANDLINEPARSER_H
+#define __COMMON_COMMANDLINEPARSER_H
+
+#include "Common/String.h"
+
+namespace NCommandLineParser {
+
+void SplitCommandLine(const UString &src, UString &dest1, UString &dest2);
+void SplitCommandLine(const UString &s, UStringVector &parts);
+
+namespace NSwitchType {
+  enum EEnum
+  { 
+    kSimple,
+    kPostMinus,
+    kLimitedPostString,
+    kUnLimitedPostString,
+    kPostChar
+  };
+}
+
+struct CSwitchForm
+{
+  const wchar_t *IDString;
+  NSwitchType::EEnum Type;
+  bool Multi;
+  int MinLen;
+  int MaxLen;
+  const wchar_t *PostCharSet;
+};
+
+struct CSwitchResult
+{
+  bool ThereIs;
+  bool WithMinus;
+  UStringVector PostStrings;
+  int PostCharIndex;
+  CSwitchResult(): ThereIs(false) {};
+};
+  
+class CParser
+{
+  int _numSwitches;
+  CSwitchResult *_switches;
+  bool ParseString(const UString &s, const CSwitchForm *switchForms); 
+public:
+  UStringVector NonSwitchStrings;
+  CParser(int numSwitches);
+  ~CParser();
+  void ParseStrings(const CSwitchForm *switchForms, 
+    const UStringVector &commandStrings);
+  const CSwitchResult& operator[](size_t index) const;
+};
+
+/////////////////////////////////
+// Command parsing procedures
+
+struct CCommandForm
+{
+  wchar_t *IDString;
+  bool PostStringMode;
+};
+
+// Returns: Index of form and postString; -1, if there is no match
+int ParseCommand(int numCommandForms, const CCommandForm *commandForms, 
+    const UString &commandString, UString &postString);
+
+struct CCommandSubCharsSet
+{
+  wchar_t *Chars;
+  bool EmptyAllowed;
+};
+
+// Returns: indices of finded chars; -1 if there is no match
+bool ParseSubCharsCommand(int numForms, const CCommandSubCharsSet *forms, 
+    const UString &commandString, CIntVector &indices);
+
+}
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/ComTry.h squashfs-tools-patched/LZMA/lzmadaptive/C/Common/ComTry.h
--- squashfs-tools/LZMA/lzmadaptive/C/Common/ComTry.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/ComTry.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,17 @@
+// ComTry.h
+
+#ifndef __COM_TRY_H
+#define __COM_TRY_H
+
+#include "MyWindows.h"
+// #include "Exception.h"
+// #include "NewHandler.h"
+
+#define COM_TRY_BEGIN try {
+#define COM_TRY_END } catch(...) { return E_OUTOFMEMORY; }
+  
+  // catch(const CNewException &) { return E_OUTOFMEMORY; }\
+  // catch(const CSystemException &e) { return e.ErrorCode; }\
+  // catch(...) { return E_FAIL; }
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/CRC.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/Common/CRC.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/Common/CRC.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/CRC.cpp	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,61 @@
+// Common/CRC.cpp
+
+#include "StdAfx.h"
+
+#include "CRC.h"
+
+static const UInt32 kCRCPoly = 0xEDB88320;
+
+UInt32 CCRC::Table[256];
+
+void CCRC::InitTable()
+{
+  for (UInt32 i = 0; i < 256; i++)
+  {
+    UInt32 r = i;
+    for (int j = 0; j < 8; j++)
+      if (r & 1) 
+        r = (r >> 1) ^ kCRCPoly;
+      else     
+        r >>= 1;
+    CCRC::Table[i] = r;
+  }
+}
+
+class CCRCTableInit
+{
+public:
+  CCRCTableInit() { CCRC::InitTable(); }
+} g_CRCTableInit;
+
+void CCRC::UpdateByte(Byte b)
+{
+  _value = Table[((Byte)(_value)) ^ b] ^ (_value >> 8);
+}
+
+void CCRC::UpdateUInt16(UInt16 v)
+{
+  UpdateByte(Byte(v));
+  UpdateByte(Byte(v >> 8));
+}
+
+void CCRC::UpdateUInt32(UInt32 v)
+{
+  for (int i = 0; i < 4; i++)
+    UpdateByte((Byte)(v >> (8 * i)));
+}
+
+void CCRC::UpdateUInt64(UInt64 v)
+{
+  for (int i = 0; i < 8; i++)
+    UpdateByte((Byte)(v >> (8 * i)));
+}
+
+void CCRC::Update(const void *data, size_t size)
+{
+  UInt32 v = _value;
+  const Byte *p = (const Byte *)data;
+  for (; size > 0 ; size--, p++)
+    v = Table[((Byte)(v)) ^ *p] ^ (v >> 8);
+  _value = v;
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/CRC.h squashfs-tools-patched/LZMA/lzmadaptive/C/Common/CRC.h
--- squashfs-tools/LZMA/lzmadaptive/C/Common/CRC.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/CRC.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,36 @@
+// Common/CRC.h
+
+#ifndef __COMMON_CRC_H
+#define __COMMON_CRC_H
+
+#include <stddef.h>
+#include "Types.h"
+
+class CCRC
+{
+  UInt32 _value;
+public:
+	static UInt32 Table[256];
+	static void InitTable();
+
+  CCRC():  _value(0xFFFFFFFF){};
+  void Init() { _value = 0xFFFFFFFF; }
+  void UpdateByte(Byte v);
+  void UpdateUInt16(UInt16 v);
+  void UpdateUInt32(UInt32 v);
+  void UpdateUInt64(UInt64 v);
+  void Update(const void *data, size_t size);
+  UInt32 GetDigest() const { return _value ^ 0xFFFFFFFF; } 
+  static UInt32 CalculateDigest(const void *data, size_t size)
+  {
+    CCRC crc;
+    crc.Update(data, size);
+    return crc.GetDigest();
+  }
+  static bool VerifyDigest(UInt32 digest, const void *data, size_t size)
+  {
+    return (CalculateDigest(data, size) == digest);
+  }
+};
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/Defs.h squashfs-tools-patched/LZMA/lzmadaptive/C/Common/Defs.h
--- squashfs-tools/LZMA/lzmadaptive/C/Common/Defs.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/Defs.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,20 @@
+// Common/Defs.h
+
+#ifndef __COMMON_DEFS_H
+#define __COMMON_DEFS_H
+
+template <class T> inline T MyMin(T a, T b)
+  {  return a < b ? a : b; }
+template <class T> inline T MyMax(T a, T b)
+  {  return a > b ? a : b; }
+
+template <class T> inline int MyCompare(T a, T b)
+  {  return a < b ? -1 : (a == b ? 0 : 1); }
+
+inline int BoolToInt(bool value)
+  { return (value ? 1: 0); }
+
+inline bool IntToBool(int value)
+  { return (value != 0); }
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/MyCom.h squashfs-tools-patched/LZMA/lzmadaptive/C/Common/MyCom.h
--- squashfs-tools/LZMA/lzmadaptive/C/Common/MyCom.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/MyCom.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,203 @@
+// MyCom.h
+
+#ifndef __MYCOM_H
+#define __MYCOM_H
+
+#include "MyWindows.h"
+
+#define RINOK(x) { HRESULT __result_ = (x); if(__result_ != S_OK) return __result_; }
+
+template <class T>
+class CMyComPtr
+{
+  T* _p;
+public:
+  // typedef T _PtrClass;
+  CMyComPtr() { _p = NULL;}
+  CMyComPtr(T* p) {if ((_p = p) != NULL) p->AddRef(); }
+  CMyComPtr(const CMyComPtr<T>& lp)
+  {
+    if ((_p = lp._p) != NULL)
+      _p->AddRef();
+  }
+  ~CMyComPtr() { if (_p) _p->Release(); }
+  void Release() { if (_p) { _p->Release(); _p = NULL; } }
+  operator T*() const {  return (T*)_p;  }
+  // T& operator*() const {  return *_p; }
+  T** operator&() { return &_p; }
+  T* operator->() const { return _p; }
+  T* operator=(T* p) 
+  { 
+    if (p != 0)
+      p->AddRef();
+    if (_p) 
+      _p->Release();
+    _p = p;
+    return p;
+  }
+  T* operator=(const CMyComPtr<T>& lp) { return (*this = lp._p); }
+  bool operator!() const { return (_p == NULL); }
+  // bool operator==(T* pT) const {  return _p == pT; }
+  // Compare two objects for equivalence
+  void Attach(T* p2)
+  {
+    Release();
+    _p = p2;
+  }
+  T* Detach()
+  {
+    T* pt = _p;
+    _p = NULL;
+    return pt;
+  }
+  #ifdef _WIN32
+  HRESULT CoCreateInstance(REFCLSID rclsid, REFIID iid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
+  {
+    return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, iid, (void**)&_p);
+  }
+  #endif
+  /*
+  HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
+  {
+    CLSID clsid;
+    HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
+    ATLASSERT(_p == NULL);
+    if (SUCCEEDED(hr))
+      hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&_p);
+    return hr;
+  }
+  */
+  template <class Q>
+  HRESULT QueryInterface(REFGUID iid, Q** pp) const
+  {
+    return _p->QueryInterface(iid, (void**)pp);
+  }
+};
+
+//////////////////////////////////////////////////////////
+
+class CMyComBSTR
+{
+public:
+  BSTR m_str;
+  CMyComBSTR() { m_str = NULL; }
+  CMyComBSTR(LPCOLESTR pSrc) {  m_str = ::SysAllocString(pSrc);  }
+  // CMyComBSTR(int nSize) { m_str = ::SysAllocStringLen(NULL, nSize); }
+  // CMyComBSTR(int nSize, LPCOLESTR sz) { m_str = ::SysAllocStringLen(sz, nSize);  }
+  CMyComBSTR(const CMyComBSTR& src) { m_str = src.MyCopy(); }
+  /*
+  CMyComBSTR(REFGUID src)
+  {
+    LPOLESTR szGuid;
+    StringFromCLSID(src, &szGuid);
+    m_str = ::SysAllocString(szGuid);
+    CoTaskMemFree(szGuid);
+  }
+  */
+  ~CMyComBSTR() { ::SysFreeString(m_str); }
+  CMyComBSTR& operator=(const CMyComBSTR& src)
+  {
+    if (m_str != src.m_str)
+    {
+      if (m_str)
+        ::SysFreeString(m_str);
+      m_str = src.MyCopy();
+    }
+    return *this;
+  }
+  CMyComBSTR& operator=(LPCOLESTR pSrc)
+  {
+    ::SysFreeString(m_str);
+    m_str = ::SysAllocString(pSrc);
+    return *this;
+  }
+  unsigned int Length() const { return ::SysStringLen(m_str); }
+  operator BSTR() const { return m_str; }
+  BSTR* operator&() { return &m_str; }
+  BSTR MyCopy() const 
+  { 
+    int byteLen = ::SysStringByteLen(m_str);
+    BSTR res = ::SysAllocStringByteLen(NULL, byteLen);
+    memmove(res, m_str, byteLen);
+    return res;
+  }
+  void Attach(BSTR src) {  m_str = src; }
+  BSTR Detach()
+  {
+    BSTR s = m_str;
+    m_str = NULL;
+    return s;
+  }
+  void Empty()
+  {
+    ::SysFreeString(m_str);
+    m_str = NULL;
+  }
+  bool operator!() const {  return (m_str == NULL); }
+};
+
+
+//////////////////////////////////////////////////////////
+
+class CMyUnknownImp
+{
+public:
+  ULONG __m_RefCount;
+  CMyUnknownImp(): __m_RefCount(0) {}
+};
+
+#define MY_QUERYINTERFACE_BEGIN STDMETHOD(QueryInterface) \
+    (REFGUID iid, void **outObject) { 
+
+#define MY_QUERYINTERFACE_ENTRY(i) if (iid == IID_ ## i) \
+    { *outObject = (void *)(i *)this; AddRef(); return S_OK; }
+
+#define MY_QUERYINTERFACE_END return E_NOINTERFACE; }
+
+#define MY_ADDREF_RELEASE \
+STDMETHOD_(ULONG, AddRef)() { return ++__m_RefCount; } \
+STDMETHOD_(ULONG, Release)() { if (--__m_RefCount != 0)  \
+  return __m_RefCount; delete this; return 0; }
+
+#define MY_UNKNOWN_IMP_SPEC(i) \
+  MY_QUERYINTERFACE_BEGIN \
+  i \
+  MY_QUERYINTERFACE_END \
+  MY_ADDREF_RELEASE
+
+
+#define MY_UNKNOWN_IMP STDMETHOD(QueryInterface)(REFGUID, void **) { \
+  MY_QUERYINTERFACE_END \
+  MY_ADDREF_RELEASE
+
+#define MY_UNKNOWN_IMP1(i) MY_UNKNOWN_IMP_SPEC( \
+  MY_QUERYINTERFACE_ENTRY(i) \
+  )
+
+#define MY_UNKNOWN_IMP2(i1, i2) MY_UNKNOWN_IMP_SPEC( \
+  MY_QUERYINTERFACE_ENTRY(i1) \
+  MY_QUERYINTERFACE_ENTRY(i2) \
+  )
+
+#define MY_UNKNOWN_IMP3(i1, i2, i3) MY_UNKNOWN_IMP_SPEC( \
+  MY_QUERYINTERFACE_ENTRY(i1) \
+  MY_QUERYINTERFACE_ENTRY(i2) \
+  MY_QUERYINTERFACE_ENTRY(i3) \
+  )
+
+#define MY_UNKNOWN_IMP4(i1, i2, i3, i4) MY_UNKNOWN_IMP_SPEC( \
+  MY_QUERYINTERFACE_ENTRY(i1) \
+  MY_QUERYINTERFACE_ENTRY(i2) \
+  MY_QUERYINTERFACE_ENTRY(i3) \
+  MY_QUERYINTERFACE_ENTRY(i4) \
+  )
+
+#define MY_UNKNOWN_IMP5(i1, i2, i3, i4, i5) MY_UNKNOWN_IMP_SPEC( \
+  MY_QUERYINTERFACE_ENTRY(i1) \
+  MY_QUERYINTERFACE_ENTRY(i2) \
+  MY_QUERYINTERFACE_ENTRY(i3) \
+  MY_QUERYINTERFACE_ENTRY(i4) \
+  MY_QUERYINTERFACE_ENTRY(i5) \
+  )
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/MyGuidDef.h squashfs-tools-patched/LZMA/lzmadaptive/C/Common/MyGuidDef.h
--- squashfs-tools/LZMA/lzmadaptive/C/Common/MyGuidDef.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/MyGuidDef.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,54 @@
+// Common/MyGuidDef.h
+
+#ifndef GUID_DEFINED
+#define GUID_DEFINED
+
+#include "Types.h"
+
+typedef struct {
+  UInt32 Data1;
+  UInt16 Data2;
+  UInt16 Data3;
+  unsigned char Data4[8];
+} GUID;
+
+#ifdef __cplusplus
+#define REFGUID const GUID &
+#else
+#define REFGUID const GUID *
+#endif
+
+#define REFCLSID REFGUID
+#define REFIID REFGUID
+
+#ifdef __cplusplus
+inline bool operator==(REFGUID g1, REFGUID g2)
+{ 
+  for (int i = 0; i < (int)sizeof(g1); i++)
+    if (((unsigned char *)&g1)[i] != ((unsigned char *)&g2)[i])
+      return false;
+  return true;
+}
+inline bool operator!=(REFGUID g1, REFGUID g2) { return !(g1 == g2); }
+#endif
+
+#ifdef __cplusplus
+  #define MY_EXTERN_C extern "C"
+#else
+  #define MY_EXTERN_C extern
+#endif
+
+#endif // GUID_DEFINED
+
+
+#ifdef DEFINE_GUID
+#undef DEFINE_GUID
+#endif
+
+#ifdef INITGUID
+  #define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
+    MY_EXTERN_C const GUID name = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
+#else
+  #define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
+    MY_EXTERN_C const GUID name
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/MyInitGuid.h squashfs-tools-patched/LZMA/lzmadaptive/C/Common/MyInitGuid.h
--- squashfs-tools/LZMA/lzmadaptive/C/Common/MyInitGuid.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/MyInitGuid.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,13 @@
+// Common/MyInitGuid.h
+
+#ifndef __COMMON_MYINITGUID_H
+#define __COMMON_MYINITGUID_H
+
+#ifdef _WIN32
+#include <initguid.h>
+#else
+#define INITGUID
+#include "MyGuidDef.h"
+#endif
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/MyUnknown.h squashfs-tools-patched/LZMA/lzmadaptive/C/Common/MyUnknown.h
--- squashfs-tools/LZMA/lzmadaptive/C/Common/MyUnknown.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/MyUnknown.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,24 @@
+// MyUnknown.h
+
+#ifndef __MYUNKNOWN_H
+#define __MYUNKNOWN_H
+
+#ifdef _WIN32
+
+#ifdef _WIN32_WCE
+#if (_WIN32_WCE > 300)
+#include <basetyps.h>
+#else
+#define MIDL_INTERFACE(x) struct 
+#endif
+#else
+#include <basetyps.h>
+#endif
+
+#include <unknwn.h>
+
+#else 
+#include "MyWindows.h"
+#endif
+  
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/MyWindows.h squashfs-tools-patched/LZMA/lzmadaptive/C/Common/MyWindows.h
--- squashfs-tools/LZMA/lzmadaptive/C/Common/MyWindows.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/MyWindows.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,183 @@
+// MyWindows.h
+
+#ifndef __MYWINDOWS_H
+#define __MYWINDOWS_H
+
+#ifdef _WIN32
+
+#include <windows.h>
+
+#else
+
+#include <stddef.h> // for wchar_t
+#include <string.h>
+
+#include "MyGuidDef.h"
+
+typedef char CHAR;
+typedef unsigned char UCHAR;
+typedef unsigned char BYTE;
+
+typedef short SHORT;
+typedef unsigned short USHORT;
+typedef unsigned short WORD;
+typedef short VARIANT_BOOL;
+
+typedef int INT;
+typedef Int32 INT32;
+typedef unsigned int UINT;
+typedef UInt32 UINT32;
+typedef INT32 LONG;   // LONG, ULONG and DWORD must be 32-bit
+typedef UINT32 ULONG;
+typedef UINT32 DWORD;
+
+typedef Int64 LONGLONG;
+typedef UInt64 ULONGLONG;
+
+typedef struct LARGE_INTEGER { LONGLONG QuadPart; }LARGE_INTEGER;
+typedef struct _ULARGE_INTEGER { ULONGLONG QuadPart;} ULARGE_INTEGER;
+
+typedef const CHAR *LPCSTR;
+typedef CHAR TCHAR;
+typedef const TCHAR *LPCTSTR;
+typedef wchar_t WCHAR;
+typedef WCHAR OLECHAR;
+typedef const WCHAR *LPCWSTR;
+typedef OLECHAR *BSTR;
+typedef const OLECHAR *LPCOLESTR;
+typedef OLECHAR *LPOLESTR;
+
+typedef struct _FILETIME
+{
+  DWORD dwLowDateTime;
+  DWORD dwHighDateTime;
+}FILETIME;
+
+#define HRESULT LONG
+#define FAILED(Status) ((HRESULT)(Status)<0)
+typedef ULONG PROPID;
+typedef LONG SCODE;
+
+#define S_OK    ((HRESULT)0x00000000L)
+#define S_FALSE ((HRESULT)0x00000001L)
+#define E_NOINTERFACE ((HRESULT)0x80004002L)
+#define E_ABORT ((HRESULT)0x80004004L)
+#define E_FAIL ((HRESULT)0x80004005L)
+#define STG_E_INVALIDFUNCTION ((HRESULT)0x80030001L)
+#define E_OUTOFMEMORY ((HRESULT)0x8007000EL)
+#define E_INVALIDARG ((HRESULT)0x80070057L)
+
+#ifdef _MSC_VER
+#define STDMETHODCALLTYPE __stdcall 
+#else
+#define STDMETHODCALLTYPE 
+#endif
+
+#define STDMETHOD_(t, f) virtual t STDMETHODCALLTYPE f
+#define STDMETHOD(f) STDMETHOD_(HRESULT, f)
+#define STDMETHODIMP_(type) type STDMETHODCALLTYPE
+#define STDMETHODIMP STDMETHODIMP_(HRESULT)
+
+#define PURE = 0
+
+#define MIDL_INTERFACE(x) struct 
+
+struct IUnknown
+{
+  STDMETHOD(QueryInterface) (REFIID iid, void **outObject) PURE;
+  STDMETHOD_(ULONG, AddRef)() PURE;
+  STDMETHOD_(ULONG, Release)() PURE;
+};
+
+typedef IUnknown *LPUNKNOWN;
+
+#define VARIANT_TRUE ((VARIANT_BOOL)-1)
+#define VARIANT_FALSE ((VARIANT_BOOL)0)
+
+enum VARENUM
+{	
+  VT_EMPTY	= 0,
+	VT_NULL	= 1,
+	VT_I2	= 2,
+	VT_I4	= 3,
+	VT_R4	= 4,
+	VT_R8	= 5,
+	VT_CY	= 6,
+	VT_DATE	= 7,
+	VT_BSTR	= 8,
+	VT_DISPATCH	= 9,
+	VT_ERROR	= 10,
+	VT_BOOL	= 11,
+	VT_VARIANT	= 12,
+	VT_UNKNOWN	= 13,
+	VT_DECIMAL	= 14,
+	VT_I1	= 16,
+	VT_UI1	= 17,
+	VT_UI2	= 18,
+	VT_UI4	= 19,
+	VT_I8	= 20,
+	VT_UI8	= 21,
+	VT_INT	= 22,
+	VT_UINT	= 23,
+	VT_VOID	= 24,
+	VT_HRESULT	= 25,
+	VT_FILETIME	= 64
+};
+
+typedef unsigned short VARTYPE;
+typedef WORD PROPVAR_PAD1;
+typedef WORD PROPVAR_PAD2;
+typedef WORD PROPVAR_PAD3;
+
+typedef struct tagPROPVARIANT
+{
+  VARTYPE vt;
+  PROPVAR_PAD1 wReserved1;
+  PROPVAR_PAD2 wReserved2;
+  PROPVAR_PAD3 wReserved3;
+  union 
+  {
+    CHAR cVal;
+    UCHAR bVal;
+    SHORT iVal;
+    USHORT uiVal;
+    LONG lVal;
+    ULONG ulVal;
+    INT intVal;
+    UINT uintVal;
+    LARGE_INTEGER hVal;
+    ULARGE_INTEGER uhVal;
+    VARIANT_BOOL boolVal;
+    SCODE scode;
+    FILETIME filetime;
+    BSTR bstrVal;
+  };
+} PROPVARIANT;
+
+typedef PROPVARIANT tagVARIANT;
+typedef tagVARIANT VARIANT;
+typedef VARIANT VARIANTARG;
+
+MY_EXTERN_C BSTR SysAllocStringByteLen(LPCSTR psz, UINT len);
+MY_EXTERN_C BSTR SysAllocString(const OLECHAR *sz);
+MY_EXTERN_C void SysFreeString(BSTR bstr);
+MY_EXTERN_C UINT SysStringByteLen(BSTR bstr);
+MY_EXTERN_C UINT SysStringLen(BSTR bstr);
+
+MY_EXTERN_C DWORD GetLastError();
+MY_EXTERN_C HRESULT VariantClear(VARIANTARG *prop);
+MY_EXTERN_C HRESULT VariantCopy(VARIANTARG *dest, VARIANTARG *src);
+MY_EXTERN_C LONG CompareFileTime(const FILETIME* ft1, const FILETIME* ft2);
+
+#define CP_ACP    0
+#define CP_OEMCP  1
+
+typedef enum tagSTREAM_SEEK
+{	
+  STREAM_SEEK_SET	= 0,
+  STREAM_SEEK_CUR	= 1,
+  STREAM_SEEK_END	= 2
+} STREAM_SEEK;
+
+#endif
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/NewHandler.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/Common/NewHandler.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/Common/NewHandler.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/NewHandler.cpp	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,114 @@
+// NewHandler.cpp
+ 
+#include "StdAfx.h"
+
+#include <stdlib.h>
+
+#include "NewHandler.h"
+
+// #define DEBUG_MEMORY_LEAK
+
+#ifndef DEBUG_MEMORY_LEAK
+
+void * 
+#ifdef _MSC_VER
+__cdecl 
+#endif
+operator new(size_t size)
+{
+  // void *p = ::HeapAlloc(::GetProcessHeap(), 0, size);
+  void *p = ::malloc(size);
+  if (p == 0)
+    throw CNewException();
+  return p;
+}
+
+void 
+#ifdef _MSC_VER
+__cdecl 
+#endif
+operator delete(void *p) throw()
+{
+  /*
+  if (p == 0)
+    return;
+  ::HeapFree(::GetProcessHeap(), 0, p);
+  */
+  ::free(p);
+}
+
+#else
+
+#pragma init_seg(lib)
+const int kDebugSize = 1000000;
+static void *a[kDebugSize];
+static int index = 0;
+
+static int numAllocs = 0;
+void * __cdecl operator new(size_t size)
+{
+  numAllocs++;
+  void *p = HeapAlloc(GetProcessHeap(), 0, size);
+  if (index == 40)
+  {
+    int t = 1;
+  }
+  if (index < kDebugSize)
+  {
+    a[index] = p;
+    index++;
+  }
+  if (p == 0)
+    throw CNewException();
+  printf("Alloc %6d, size = %8d\n", numAllocs, size);
+  return p;
+}
+
+class CC
+{
+public:
+  CC()
+  {
+    for (int i = 0; i < kDebugSize; i++)
+      a[i] = 0;
+  }
+  ~CC()
+  {
+    for (int i = 0; i < kDebugSize; i++)
+      if (a[i] != 0)
+        return;
+  }
+} g_CC;
+
+
+void __cdecl operator delete(void *p)
+{
+  if (p == 0)
+    return;
+  /*
+  for (int i = 0; i < index; i++)
+    if (a[i] == p)
+      a[i] = 0;
+  */
+  HeapFree(GetProcessHeap(), 0, p);
+  numAllocs--;
+  printf("Free %d\n", numAllocs);
+}
+
+#endif
+
+/*
+int MemErrorVC(size_t)
+{
+  throw CNewException();
+  // return 1;
+}
+CNewHandlerSetter::CNewHandlerSetter()
+{
+  // MemErrorOldVCFunction = _set_new_handler(MemErrorVC);
+}
+CNewHandlerSetter::~CNewHandlerSetter()
+{
+  // _set_new_handler(MemErrorOldVCFunction);
+}
+*/
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/NewHandler.h squashfs-tools-patched/LZMA/lzmadaptive/C/Common/NewHandler.h
--- squashfs-tools/LZMA/lzmadaptive/C/Common/NewHandler.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/NewHandler.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,14 @@
+// Common/NewHandler.h
+
+#ifndef __COMMON_NEWHANDLER_H
+#define __COMMON_NEWHANDLER_H
+
+class CNewException {};
+
+void 
+#ifdef _MSC_VER
+__cdecl 
+#endif
+operator delete(void *p) throw();
+
+#endif 
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/StdAfx.h squashfs-tools-patched/LZMA/lzmadaptive/C/Common/StdAfx.h
--- squashfs-tools/LZMA/lzmadaptive/C/Common/StdAfx.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/StdAfx.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,9 @@
+// StdAfx.h
+
+#ifndef __STDAFX_H
+#define __STDAFX_H
+
+// #include "MyWindows.h"
+#include "NewHandler.h"
+
+#endif 
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/StringConvert.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/Common/StringConvert.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/Common/StringConvert.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/StringConvert.cpp	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,93 @@
+// Common/StringConvert.cpp
+
+#include "StdAfx.h"
+
+#include "StringConvert.h"
+
+#ifndef _WIN32
+#include <stdlib.h>
+#endif
+
+#ifdef _WIN32
+UString MultiByteToUnicodeString(const AString &srcString, UINT codePage)
+{
+  UString resultString;
+  if(!srcString.IsEmpty())
+  {
+    int numChars = MultiByteToWideChar(codePage, 0, srcString, 
+      srcString.Length(), resultString.GetBuffer(srcString.Length()), 
+      srcString.Length() + 1);
+    #ifndef _WIN32_WCE
+    if(numChars == 0)
+      throw 282228;
+    #endif
+    resultString.ReleaseBuffer(numChars);
+  }
+  return resultString;
+}
+
+AString UnicodeStringToMultiByte(const UString &srcString, UINT codePage)
+{
+  AString resultString;
+  if(!srcString.IsEmpty())
+  {
+    int numRequiredBytes = srcString.Length() * 2;
+    int numChars = WideCharToMultiByte(codePage, 0, srcString, 
+      srcString.Length(), resultString.GetBuffer(numRequiredBytes), 
+      numRequiredBytes + 1, NULL, NULL);
+    #ifndef _WIN32_WCE
+    if(numChars == 0)
+      throw 282229;
+    #endif
+    resultString.ReleaseBuffer(numChars);
+  }
+  return resultString;
+}
+
+#ifndef _WIN32_WCE
+AString SystemStringToOemString(const CSysString &srcString)
+{
+  AString result;
+  CharToOem(srcString, result.GetBuffer(srcString.Length() * 2));
+  result.ReleaseBuffer();
+  return result;
+}
+#endif
+
+#else
+
+UString MultiByteToUnicodeString(const AString &srcString, UINT codePage)
+{
+  UString resultString;
+  for (int i = 0; i < srcString.Length(); i++)
+    resultString += wchar_t(srcString[i]);
+  /*
+  if(!srcString.IsEmpty())
+  {
+    int numChars = mbstowcs(resultString.GetBuffer(srcString.Length()), srcString, srcString.Length() + 1);
+    if (numChars < 0) throw "Your environment does not support UNICODE";
+    resultString.ReleaseBuffer(numChars);
+  }
+  */
+  return resultString;
+}
+
+AString UnicodeStringToMultiByte(const UString &srcString, UINT codePage)
+{
+  AString resultString;
+  for (int i = 0; i < srcString.Length(); i++)
+    resultString += char(srcString[i]);
+  /*
+  if(!srcString.IsEmpty())
+  {
+    int numRequiredBytes = srcString.Length() * 6 + 1;
+    int numChars = wcstombs(resultString.GetBuffer(numRequiredBytes), srcString, numRequiredBytes);
+    if (numChars < 0) throw "Your environment does not support UNICODE";
+    resultString.ReleaseBuffer(numChars);
+  }
+  */
+  return resultString;
+}
+
+#endif
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/StringConvert.h squashfs-tools-patched/LZMA/lzmadaptive/C/Common/StringConvert.h
--- squashfs-tools/LZMA/lzmadaptive/C/Common/StringConvert.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/StringConvert.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,71 @@
+// Common/StringConvert.h
+
+#ifndef __COMMON_STRINGCONVERT_H
+#define __COMMON_STRINGCONVERT_H
+
+#include "MyWindows.h"
+#include "Common/String.h"
+#include "Types.h"
+
+UString MultiByteToUnicodeString(const AString &srcString, UINT codePage = CP_ACP);
+AString UnicodeStringToMultiByte(const UString &srcString, UINT codePage = CP_ACP);
+
+inline const wchar_t* GetUnicodeString(const wchar_t* unicodeString)
+  { return unicodeString; }
+inline const UString& GetUnicodeString(const UString &unicodeString)
+  { return unicodeString; }
+inline UString GetUnicodeString(const AString &ansiString)
+  { return MultiByteToUnicodeString(ansiString); }
+inline UString GetUnicodeString(const AString &multiByteString, UINT codePage)
+  { return MultiByteToUnicodeString(multiByteString, codePage); }
+inline const wchar_t* GetUnicodeString(const wchar_t* unicodeString, UINT)
+  { return unicodeString; }
+inline const UString& GetUnicodeString(const UString &unicodeString, UINT)
+  { return unicodeString; }
+
+inline const char* GetAnsiString(const char* ansiString)
+  { return ansiString; }
+inline const AString& GetAnsiString(const AString &ansiString)
+  { return ansiString; }
+inline AString GetAnsiString(const UString &unicodeString)
+  { return UnicodeStringToMultiByte(unicodeString); }
+
+inline const char* GetOemString(const char* oemString)
+  { return oemString; }
+inline const AString& GetOemString(const AString &oemString)
+  { return oemString; }
+inline AString GetOemString(const UString &unicodeString)
+  { return UnicodeStringToMultiByte(unicodeString, CP_OEMCP); }
+
+
+#ifdef _UNICODE
+  inline const wchar_t* GetSystemString(const wchar_t* unicodeString)
+    { return unicodeString;}
+  inline const UString& GetSystemString(const UString &unicodeString)
+    { return unicodeString;}
+  inline const wchar_t* GetSystemString(const wchar_t* unicodeString, UINT codePage)
+    { return unicodeString;}
+  inline const UString& GetSystemString(const UString &unicodeString, UINT codePage)
+    { return unicodeString;}
+  inline UString GetSystemString(const AString &multiByteString, UINT codePage)
+    { return MultiByteToUnicodeString(multiByteString, codePage);}
+  inline UString GetSystemString(const AString &multiByteString)
+    { return MultiByteToUnicodeString(multiByteString);}
+#else
+  inline const char* GetSystemString(const char *ansiString)
+    { return ansiString; }
+  inline const AString& GetSystemString(const AString &multiByteString, UINT)
+    { return multiByteString; }
+  inline const char * GetSystemString(const char *multiByteString, UINT)
+    { return multiByteString; }
+  inline AString GetSystemString(const UString &unicodeString)
+    { return UnicodeStringToMultiByte(unicodeString); }
+  inline AString GetSystemString(const UString &unicodeString, UINT codePage)
+    { return UnicodeStringToMultiByte(unicodeString, codePage); }
+#endif
+
+#ifndef _WIN32_WCE
+AString SystemStringToOemString(const CSysString &srcString);
+#endif
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/String.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/Common/String.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/Common/String.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/String.cpp	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,198 @@
+// Common/String.cpp
+
+#include "StdAfx.h"
+
+#ifdef _WIN32
+#include "StringConvert.h"
+#else
+#include <ctype.h>
+#endif
+
+#include "Common/String.h"
+
+
+#ifdef _WIN32
+
+#ifndef _UNICODE
+
+wchar_t MyCharUpper(wchar_t c)
+{
+  if (c == 0)
+    return 0;
+  wchar_t *res = CharUpperW((LPWSTR)(unsigned int)c);
+  if (res != 0 || ::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
+    return (wchar_t)(unsigned int)res;
+  const int kBufferSize = 4;
+  char s[kBufferSize + 1];
+  int numChars = ::WideCharToMultiByte(CP_ACP, 0, &c, 1, s, kBufferSize, 0, 0);
+  if (numChars == 0 || numChars > kBufferSize)
+    return c;
+  s[numChars] = 0;
+  ::CharUpperA(s);
+  ::MultiByteToWideChar(CP_ACP, 0, s, numChars, &c, 1);
+  return c;
+}
+
+wchar_t MyCharLower(wchar_t c)
+{
+  if (c == 0)
+    return 0;
+  wchar_t *res = CharLowerW((LPWSTR)(unsigned int)c);
+  if (res != 0 || ::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
+    return (wchar_t)(unsigned int)res;
+  const int kBufferSize = 4;
+  char s[kBufferSize + 1];
+  int numChars = ::WideCharToMultiByte(CP_ACP, 0, &c, 1, s, kBufferSize, 0, 0);
+  if (numChars == 0 || numChars > kBufferSize)
+    return c;
+  s[numChars] = 0;
+  ::CharLowerA(s);
+  ::MultiByteToWideChar(CP_ACP, 0, s, numChars, &c, 1);
+  return c;
+}
+
+wchar_t * MyStringUpper(wchar_t *s)
+{
+  if (s == 0)
+    return 0;
+  wchar_t *res = CharUpperW(s);
+  if (res != 0 || ::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
+    return res;
+  AString a = UnicodeStringToMultiByte(s);
+  a.MakeUpper();
+  return MyStringCopy(s, (const wchar_t *)MultiByteToUnicodeString(a));
+}
+
+wchar_t * MyStringLower(wchar_t *s)
+{ 
+  if (s == 0)
+    return 0;
+  wchar_t *res = CharLowerW(s);
+  if (res != 0 || ::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
+    return res;
+  AString a = UnicodeStringToMultiByte(s);
+  a.MakeLower();
+  return MyStringCopy(s, (const wchar_t *)MultiByteToUnicodeString(a));
+}
+
+#endif
+
+/*
+inline int ConvertCompareResult(int r) { return r - 2; }
+
+int MyStringCollate(const wchar_t *s1, const wchar_t *s2)
+{ 
+  int res = CompareStringW(
+        LOCALE_USER_DEFAULT, SORT_STRINGSORT, s1, -1, s2, -1); 
+  #ifdef _UNICODE
+  return ConvertCompareResult(res);
+  #else
+  if (res != 0 || ::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
+    return ConvertCompareResult(res);
+  return MyStringCollate(UnicodeStringToMultiByte(s1), 
+        UnicodeStringToMultiByte(s2));
+  #endif
+}
+
+#ifndef _WIN32_WCE
+int MyStringCollate(const char *s1, const char *s2)
+{ 
+  return ConvertCompareResult(CompareStringA(
+    LOCALE_USER_DEFAULT, SORT_STRINGSORT, s1, -1, s2, -1)); 
+}
+
+int MyStringCollateNoCase(const char *s1, const char *s2)
+{ 
+  return ConvertCompareResult(CompareStringA(
+    LOCALE_USER_DEFAULT, NORM_IGNORECASE | SORT_STRINGSORT, s1, -1, s2, -1)); 
+}
+#endif
+
+int MyStringCollateNoCase(const wchar_t *s1, const wchar_t *s2)
+{ 
+  int res = CompareStringW(
+        LOCALE_USER_DEFAULT, NORM_IGNORECASE | SORT_STRINGSORT, s1, -1, s2, -1); 
+  #ifdef _UNICODE
+  return ConvertCompareResult(res);
+  #else
+  if (res != 0 || ::GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
+    return ConvertCompareResult(res);
+  return MyStringCollateNoCase(UnicodeStringToMultiByte(s1), 
+      UnicodeStringToMultiByte(s2));
+  #endif
+}
+*/
+
+#else
+
+wchar_t MyCharUpper(wchar_t c)
+{
+  return toupper(c);
+}
+
+/*
+int MyStringCollateNoCase(const wchar_t *s1, const wchar_t *s2)
+{ 
+  while (true)
+  {
+    wchar_t c1 = *s1++;
+    wchar_t c2 = *s2++;
+    wchar_t u1 = MyCharUpper(c1);
+    wchar_t u2 = MyCharUpper(c2);
+
+    if (u1 < u2) return -1;
+    if (u1 > u2) return 1;
+    if (u1 == 0) return 0;
+  }
+}
+*/
+
+#endif
+
+int MyStringCompare(const char *s1, const char *s2)
+{ 
+  while (true)
+  {
+    unsigned char c1 = (unsigned char)*s1++;
+    unsigned char c2 = (unsigned char)*s2++;
+    if (c1 < c2) return -1;
+    if (c1 > c2) return 1;
+    if (c1 == 0) return 0;
+  }
+}
+
+int MyStringCompare(const wchar_t *s1, const wchar_t *s2)
+{ 
+  while (true)
+  {
+    wchar_t c1 = *s1++;
+    wchar_t c2 = *s2++;
+    if (c1 < c2) return -1;
+    if (c1 > c2) return 1;
+    if (c1 == 0) return 0;
+  }
+}
+
+int MyStringCompareNoCase(const wchar_t *s1, const wchar_t *s2)
+{ 
+  while (true)
+  {
+    wchar_t c1 = *s1++;
+    wchar_t c2 = *s2++;
+    if (c1 != c2)
+    {
+      wchar_t u1 = MyCharUpper(c1);
+      wchar_t u2 = MyCharUpper(c2);
+      if (u1 < u2) return -1;
+      if (u1 > u2) return 1;
+    }
+    if (c1 == 0) return 0;
+  }
+}
+
+#ifdef _WIN32
+int MyStringCompareNoCase(const char *s1, const char *s2)
+{ 
+  return MyStringCompareNoCase(MultiByteToUnicodeString(s1), MultiByteToUnicodeString(s2));
+}
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/String.h squashfs-tools-patched/LZMA/lzmadaptive/C/Common/String.h
--- squashfs-tools/LZMA/lzmadaptive/C/Common/String.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/String.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,631 @@
+// Common/String.h
+
+#ifndef __COMMON_STRING_H
+#define __COMMON_STRING_H
+
+#include <string.h>
+// #include <wchar.h>
+
+#include "Vector.h"
+
+#ifdef _WIN32
+#include "MyWindows.h"
+#endif
+
+static const char *kTrimDefaultCharSet  = " \n\t";
+
+template <class T>
+inline int MyStringLen(const T *s)
+{ 
+  int i;
+  for (i = 0; s[i] != '\0'; i++);
+  return i;
+}
+
+template <class T>
+inline T * MyStringCopy(T *dest, const T *src)
+{ 
+  T *destStart = dest;
+  while((*dest++ = *src++) != 0);
+  return destStart;
+}
+
+inline wchar_t* MyStringGetNextCharPointer(wchar_t *p)
+  { return (p + 1); }
+inline const wchar_t* MyStringGetNextCharPointer(const wchar_t *p)
+  { return (p + 1); }
+inline wchar_t* MyStringGetPrevCharPointer(const wchar_t *, wchar_t *p)
+  { return (p - 1); }
+inline const wchar_t* MyStringGetPrevCharPointer(const wchar_t *, const wchar_t *p)
+  { return (p - 1); }
+
+#ifdef _WIN32
+
+inline char* MyStringGetNextCharPointer(char *p)
+  { return CharNextA(p); }
+inline const char* MyStringGetNextCharPointer(const char *p)
+  { return CharNextA(p); }
+
+inline char* MyStringGetPrevCharPointer(char *base, char *p)
+  { return CharPrevA(base, p); }
+inline const char* MyStringGetPrevCharPointer(const char *base, const char *p)
+  { return CharPrevA(base, p); }
+
+inline char MyCharUpper(char c)
+  { return (char)(unsigned int)CharUpperA((LPSTR)(unsigned int)(unsigned char)c); }
+#ifdef _UNICODE
+inline wchar_t MyCharUpper(wchar_t c)
+  { return (wchar_t)CharUpperW((LPWSTR)c); }
+#else
+wchar_t MyCharUpper(wchar_t c);
+#endif
+
+inline char MyCharLower(char c)
+  { return (char)(unsigned int)CharLowerA((LPSTR)(unsigned int)(unsigned char)c); }
+#ifdef _UNICODE
+inline wchar_t MyCharLower(wchar_t c)
+  { return (wchar_t)CharLowerW((LPWSTR)c); }
+#else
+wchar_t MyCharLower(wchar_t c);
+#endif
+
+inline char * MyStringUpper(char *s) { return CharUpperA(s); }
+#ifdef _UNICODE
+inline wchar_t * MyStringUpper(wchar_t *s) { return CharUpperW(s); }
+#else
+wchar_t * MyStringUpper(wchar_t *s);
+#endif
+
+inline char * MyStringLower(char *s) { return CharLowerA(s); }
+#ifdef _UNICODE
+inline wchar_t * MyStringLower(wchar_t *s) { return CharLowerW(s); }
+#else
+wchar_t * MyStringLower(wchar_t *s);
+#endif
+
+#else // Standard-C
+wchar_t MyCharUpper(wchar_t c);
+#endif
+
+//////////////////////////////////////
+// Compare
+
+/*
+#ifndef _WIN32_WCE
+int MyStringCollate(const char *s1, const char *s2);
+int MyStringCollateNoCase(const char *s1, const char *s2);
+#endif
+int MyStringCollate(const wchar_t *s1, const wchar_t *s2);
+int MyStringCollateNoCase(const wchar_t *s1, const wchar_t *s2);
+*/
+
+int MyStringCompare(const char *s1, const char  *s2);
+int MyStringCompare(const wchar_t *s1, const wchar_t *s2);
+
+#ifdef _WIN32
+int MyStringCompareNoCase(const char *s1, const char  *s2);
+#endif
+
+int MyStringCompareNoCase(const wchar_t *s1, const wchar_t *s2);
+
+template <class T>
+class CStringBase
+{
+  void TrimLeftWithCharSet(const CStringBase &charSet)
+  {
+    const T *p = _chars;
+    while (charSet.Find(*p) >= 0 && (*p != 0))
+      p = GetNextCharPointer(p);
+    Delete(0, (int)(p - _chars));
+  }
+  void TrimRightWithCharSet(const CStringBase &charSet)
+  {
+    const T *p = _chars;
+    const T *pLast = NULL;
+    while (*p != 0)
+    {
+      if (charSet.Find(*p) >= 0)
+      {
+        if (pLast == NULL)
+          pLast = p;
+      }
+      else
+        pLast = NULL;
+      p = GetNextCharPointer(p);
+    }
+    if(pLast != NULL)
+    {
+      int i = (int)(pLast - _chars);
+      Delete(i, _length - i);
+    }
+
+  }
+  void MoveItems(int destIndex, int srcIndex)
+  {
+    memmove(_chars + destIndex, _chars + srcIndex, 
+        sizeof(T) * (_length - srcIndex + 1));
+  }
+  
+  void InsertSpace(int &index, int size)
+  {
+    CorrectIndex(index);
+    GrowLength(size);
+    MoveItems(index + size, index);
+  }
+
+  static T *GetNextCharPointer(T *p)
+    { return MyStringGetNextCharPointer(p); }
+  static const T *GetNextCharPointer(const T *p)
+    { return MyStringGetNextCharPointer(p); }
+  static T *GetPrevCharPointer(T *base, T *p)
+    { return MyStringGetPrevCharPointer(base, p); }
+  static const T *GetPrevCharPointer(const T *base, const T *p)
+    { return MyStringGetPrevCharPointer(base, p); }
+protected:
+  T *_chars;
+  int _length;
+	int _capacity;
+  
+  void SetCapacity(int newCapacity)
+  {
+    int realCapacity = newCapacity + 1;
+    if(realCapacity == _capacity)
+      return;
+    /*
+    const int kMaxStringSize = 0x20000000;
+    #ifndef _WIN32_WCE
+    if(newCapacity > kMaxStringSize || newCapacity < _length)
+      throw 1052337;
+    #endif
+    */
+    T *newBuffer = new T[realCapacity];
+    if(_capacity > 0)
+    {
+      for (int i = 0; i < (_length + 1); i++)
+        newBuffer[i] = _chars[i];
+      delete []_chars;
+      _chars = newBuffer;
+    }
+    else
+    {
+      _chars = newBuffer;
+      _chars[0] = 0;
+    }
+    _capacity = realCapacity;
+  }
+
+  void GrowLength(int n)
+  {
+    int freeSize = _capacity - _length - 1;
+    if (n <= freeSize) 
+      return;
+    int delta;
+    if (_capacity > 64)
+      delta = _capacity / 2;
+    else if (_capacity > 8)
+      delta = 16;
+    else
+      delta = 4;
+    if (freeSize + delta < n)
+      delta = n - freeSize;
+    SetCapacity(_capacity + delta);
+  }
+
+  void CorrectIndex(int &index) const
+  {
+    if (index > _length)
+      index = _length;
+  }
+
+public:
+  CStringBase(): _chars(0), _length(0), _capacity(0)
+    { SetCapacity(16 - 1); }
+  CStringBase(T c):  _chars(0), _length(0), _capacity(0)
+  {
+    SetCapacity(1);
+    _chars[0] = c;
+    _chars[1] = 0;
+    _length = 1;
+  }
+  CStringBase(const T *chars): _chars(0), _length(0), _capacity(0)
+  {
+    int length = MyStringLen(chars);
+    SetCapacity(length);
+    MyStringCopy(_chars, chars); // can be optimized by memove()
+    _length = length;
+  }
+  CStringBase(const CStringBase &s):  _chars(0), _length(0), _capacity(0)
+  {
+    SetCapacity(s._length);
+    MyStringCopy(_chars, s._chars);
+    _length = s._length;
+  }
+  ~CStringBase() {  delete []_chars; }
+
+  operator const T*() const { return _chars;} 
+
+  // The minimum size of the character buffer in characters. 
+  // This value does not include space for a null terminator.
+  T* GetBuffer(int minBufLength)
+  {
+    if(minBufLength >= _capacity)
+      SetCapacity(minBufLength + 1);
+    return _chars;
+  }
+  void ReleaseBuffer() { ReleaseBuffer(MyStringLen(_chars)); }
+  void ReleaseBuffer(int newLength)
+  {
+    /*
+    #ifndef _WIN32_WCE
+    if(newLength >= _capacity)
+      throw 282217;
+    #endif
+    */
+    _chars[newLength] = 0;
+    _length = newLength;
+  }
+
+  CStringBase& operator=(T c)
+  {
+    Empty();
+    SetCapacity(1);
+    _chars[0] = c;
+    _chars[1] = 0;
+    _length = 1;
+    return *this;
+  }
+  CStringBase& operator=(const T *chars)
+  {
+    Empty();
+    int length = MyStringLen(chars);
+    SetCapacity(length);
+    MyStringCopy(_chars, chars);
+    _length = length; 
+    return *this;
+  }  
+  CStringBase& operator=(const CStringBase& s)
+  {
+    if(&s == this)
+      return *this;
+    Empty();
+    SetCapacity(s._length);
+    MyStringCopy(_chars, s._chars);
+    _length = s._length;
+    return *this;
+  }
+  
+  CStringBase& operator+=(T c)
+  {
+    GrowLength(1);
+    _chars[_length] = c;
+    _chars[++_length] = 0;
+    return *this;
+  }
+  CStringBase& operator+=(const T *s)
+  {
+    int len = MyStringLen(s);
+    GrowLength(len);
+    MyStringCopy(_chars + _length, s);
+    _length += len;
+    return *this;
+  }
+  CStringBase& operator+=(const CStringBase &s)
+  {
+    GrowLength(s._length);
+    MyStringCopy(_chars + _length, s._chars);
+    _length += s._length;
+    return *this;
+  }
+  void Empty()
+  {
+    _length = 0;
+    _chars[0] = 0;
+  }
+  int Length() const { return _length; }
+  bool IsEmpty() const { return (_length == 0); }
+
+  CStringBase Mid(int startIndex) const
+    { return Mid(startIndex, _length - startIndex); }
+  CStringBase Mid(int startIndex, int count ) const
+  {
+    if (startIndex + count > _length)
+      count = _length - startIndex;
+    
+    if (startIndex == 0 && startIndex + count == _length)
+      return *this;
+    
+    CStringBase<T> result;
+    result.SetCapacity(count);
+    // MyStringNCopy(result._chars, _chars + startIndex, count);
+    for (int i = 0; i < count; i++)
+      result._chars[i] = _chars[startIndex + i];
+    result._chars[count] = 0;
+    result._length = count;
+    return result;
+  }
+  CStringBase Left(int count) const
+    { return Mid(0, count); }
+  CStringBase Right(int count) const
+  {
+    if (count > _length)
+      count = _length;
+    return Mid(_length - count, count);
+  }
+
+  void MakeUpper()
+    { MyStringUpper(_chars); }
+  void MakeLower()
+    { MyStringLower(_chars); }
+
+  int Compare(const CStringBase& s) const
+    { return MyStringCompare(_chars, s._chars); }
+
+  int CompareNoCase(const CStringBase& s) const
+    { return MyStringCompareNoCase(_chars, s._chars); }
+  /*
+  int Collate(const CStringBase& s) const
+    { return MyStringCollate(_chars, s._chars); }
+  int CollateNoCase(const CStringBase& s) const
+    { return MyStringCollateNoCase(_chars, s._chars); }
+  */
+
+  int Find(T c) const { return Find(c, 0); }
+  int Find(T c, int startIndex) const
+  {
+    T *p = _chars + startIndex;
+    while (true)
+    {
+      if (*p == c)
+        return (int)(p - _chars);
+      if (*p == 0)
+        return -1;
+      p = GetNextCharPointer(p);
+    }
+  }
+  int Find(const CStringBase &s) const { return Find(s, 0); }
+  int Find(const CStringBase &s, int startIndex) const
+  {
+    if (s.IsEmpty())
+      return startIndex;
+    for (; startIndex < _length; startIndex++)
+    {
+      int j;
+      for (j = 0; j < s._length && startIndex + j < _length; j++)
+        if (_chars[startIndex+j] != s._chars[j])
+          break;
+      if (j == s._length)
+        return startIndex;
+    }
+    return -1;
+  }
+  int ReverseFind(T c) const
+  {
+    if (_length == 0)
+      return -1;
+    T *p = _chars + _length - 1;
+    while (true)
+    {
+      if (*p == c)
+        return (int)(p - _chars);
+      if (p == _chars)
+        return -1;
+      p = GetPrevCharPointer(_chars, p);
+    }
+  }
+  int FindOneOf(const CStringBase &s) const
+  {
+    for(int i = 0; i < _length; i++)
+      if (s.Find(_chars[i]) >= 0)
+        return i;
+      return -1;
+  }
+
+  void TrimLeft(T c)
+  {
+    const T *p = _chars;
+    while (c == *p)
+      p = GetNextCharPointer(p);
+    Delete(0, p - _chars);
+  }
+  private:
+  CStringBase GetTrimDefaultCharSet()
+  {
+    CStringBase<T> charSet;
+    for(int i = 0; i < (int)(sizeof(kTrimDefaultCharSet) /
+      sizeof(kTrimDefaultCharSet[0])); i++)
+      charSet += (T)kTrimDefaultCharSet[i];
+    return charSet;
+  }
+  public:
+
+  void TrimLeft()
+  {
+    TrimLeftWithCharSet(GetTrimDefaultCharSet());
+  }
+  void TrimRight()
+  {
+    TrimRightWithCharSet(GetTrimDefaultCharSet());
+  }
+  void TrimRight(T c)
+  {
+    const T *p = _chars;
+    const T *pLast = NULL;
+    while (*p != 0)
+    {
+      if (*p == c)
+      {
+        if (pLast == NULL)
+          pLast = p;
+      }
+      else
+        pLast = NULL;
+      p = GetNextCharPointer(p);
+    }
+    if(pLast != NULL)
+    {
+      int i = pLast - _chars;
+      Delete(i, _length - i);
+    }
+  }
+  void Trim()
+  {
+    TrimRight();
+    TrimLeft();
+  }
+
+  int Insert(int index, T c)
+  {
+    InsertSpace(index, 1);
+    _chars[index] = c;
+    _length++;
+    return _length;
+  }
+  int Insert(int index, const CStringBase &s)
+  {
+    CorrectIndex(index);
+    if (s.IsEmpty())
+      return _length;
+    int numInsertChars = s.Length();
+    InsertSpace(index, numInsertChars);
+    for(int i = 0; i < numInsertChars; i++)
+      _chars[index + i] = s[i];
+    _length += numInsertChars;
+    return _length;
+  }
+
+  // !!!!!!!!!!!!!!! test it if newChar = '\0'
+  int Replace(T oldChar, T newChar)
+  {
+    if (oldChar == newChar)
+      return 0;
+    int number  = 0;
+    int pos  = 0;
+    while (pos < Length())
+    {
+      pos = Find(oldChar, pos);
+      if (pos < 0) 
+        break;
+      _chars[pos] = newChar;
+      pos++;
+      number++;
+    }
+    return number;
+  }
+  int Replace(const CStringBase &oldString, const CStringBase &newString)
+  {
+    if (oldString.IsEmpty())
+      return 0;
+    if (oldString == newString)
+      return 0;
+    int oldStringLength = oldString.Length();
+    int newStringLength = newString.Length();
+    int number  = 0;
+    int pos  = 0;
+    while (pos < _length)
+    {
+      pos = Find(oldString, pos);
+      if (pos < 0) 
+        break;
+      Delete(pos, oldStringLength);
+      Insert(pos, newString);
+      pos += newStringLength;
+      number++;
+    }
+    return number;
+  }
+  int Delete(int index, int count = 1 )
+  {
+    if (index + count > _length)
+      count = _length - index;
+    if (count > 0)
+    {
+      MoveItems(index, index + count);
+      _length -= count;
+    }
+    return _length;
+  }
+};
+
+template <class T>
+CStringBase<T> operator+(const CStringBase<T>& s1, const CStringBase<T>& s2)
+{
+  CStringBase<T> result(s1);
+  result += s2;
+  return result; 
+}
+
+template <class T>
+CStringBase<T> operator+(const CStringBase<T>& s, T c)
+{
+  CStringBase<T> result(s);
+  result += c;
+  return result; 
+}
+
+template <class T>
+CStringBase<T> operator+(T c, const CStringBase<T>& s)
+{
+  CStringBase<T> result(c);
+  result += s;
+  return result; 
+}
+
+template <class T>
+CStringBase<T> operator+(const CStringBase<T>& s, const T * chars)
+{
+  CStringBase<T> result(s);
+  result += chars;
+  return result; 
+}
+
+template <class T>
+CStringBase<T> operator+(const T * chars, const CStringBase<T>& s)
+{
+  CStringBase<T> result(chars);
+  result += s;
+  return result; 
+}
+
+template <class T>
+bool operator==(const CStringBase<T>& s1, const CStringBase<T>& s2)
+  { return (s1.Compare(s2) == 0); }
+
+template <class T>
+bool operator<(const CStringBase<T>& s1, const CStringBase<T>& s2)
+  { return (s1.Compare(s2) < 0); }
+
+template <class T>
+bool operator==(const T *s1, const CStringBase<T>& s2)
+  { return (s2.Compare(s1) == 0); }
+
+template <class T>
+bool operator==(const CStringBase<T>& s1, const T *s2)
+  { return (s1.Compare(s2) == 0); }
+
+template <class T>
+bool operator!=(const CStringBase<T>& s1, const CStringBase<T>& s2)
+  { return (s1.Compare(s2) != 0); }
+
+template <class T>
+bool operator!=(const T *s1, const CStringBase<T>& s2)
+  { return (s2.Compare(s1) != 0); }
+
+template <class T>
+bool operator!=(const CStringBase<T>& s1, const T *s2)
+  { return (s1.Compare(s2) != 0); }
+
+typedef CStringBase<char> AString;
+typedef CStringBase<wchar_t> UString;
+
+typedef CObjectVector<AString> AStringVector;
+typedef CObjectVector<UString> UStringVector;
+
+#ifdef _UNICODE
+  typedef UString CSysString;
+#else
+  typedef AString CSysString;
+#endif
+
+typedef CObjectVector<CSysString> CSysStringVector;
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/StringToInt.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/Common/StringToInt.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/Common/StringToInt.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/StringToInt.cpp	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,68 @@
+// Common/StringToInt.cpp
+
+#include "StdAfx.h"
+
+#include "StringToInt.h"
+
+UInt64 ConvertStringToUInt64(const char *s, const char **end)
+{
+  UInt64 result = 0;
+  while(true)
+  {
+    char c = *s;
+    if (c < '0' || c > '9')
+    {
+      if (end != NULL)
+        *end = s;
+      return result;
+    }
+    result *= 10;
+    result += (c - '0');
+    s++;
+  }
+}
+
+UInt64 ConvertOctStringToUInt64(const char *s, const char **end)
+{
+  UInt64 result = 0;
+  while(true)
+  {
+    char c = *s;
+    if (c < '0' || c > '7')
+    {
+      if (end != NULL)
+        *end = s;
+      return result;
+    }
+    result <<= 3;
+    result += (c - '0');
+    s++;
+  }
+}
+
+
+UInt64 ConvertStringToUInt64(const wchar_t *s, const wchar_t **end)
+{
+  UInt64 result = 0;
+  while(true)
+  {
+    wchar_t c = *s;
+    if (c < '0' || c > '9')
+    {
+      if (end != NULL)
+        *end = s;
+      return result;
+    }
+    result *= 10;
+    result += (c - '0');
+    s++;
+  }
+}
+
+
+Int64 ConvertStringToInt64(const char *s, const char **end)
+{
+  if (*s == '-')
+    return -(Int64)ConvertStringToUInt64(s + 1, end);
+  return ConvertStringToUInt64(s, end);
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/StringToInt.h squashfs-tools-patched/LZMA/lzmadaptive/C/Common/StringToInt.h
--- squashfs-tools/LZMA/lzmadaptive/C/Common/StringToInt.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/StringToInt.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,17 @@
+// Common/StringToInt.h
+
+#ifndef __COMMON_STRINGTOINT_H
+#define __COMMON_STRINGTOINT_H
+
+#include <string.h>
+#include "Types.h"
+
+UInt64 ConvertStringToUInt64(const char *s, const char **end);
+UInt64 ConvertOctStringToUInt64(const char *s, const char **end);
+UInt64 ConvertStringToUInt64(const wchar_t *s, const wchar_t **end);
+
+Int64 ConvertStringToInt64(const char *s, const char **end);
+
+#endif
+
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/Types.h squashfs-tools-patched/LZMA/lzmadaptive/C/Common/Types.h
--- squashfs-tools/LZMA/lzmadaptive/C/Common/Types.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/Types.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,19 @@
+// Common/Types.h
+
+#ifndef __COMMON_TYPES_H
+#define __COMMON_TYPES_H
+
+typedef unsigned char Byte;
+typedef short Int16;
+typedef unsigned short UInt16;
+typedef int Int32;
+typedef unsigned int UInt32;
+#ifdef _MSC_VER
+typedef __int64 Int64;
+typedef unsigned __int64 UInt64;
+#else
+typedef long long int Int64;
+typedef unsigned long long int UInt64;
+#endif
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/Vector.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/Common/Vector.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/Common/Vector.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/Vector.cpp	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,74 @@
+// Common/Vector.cpp
+
+#include "StdAfx.h"
+
+#include <string.h>
+
+#include "Vector.h"
+
+CBaseRecordVector::~CBaseRecordVector()
+  { delete []((unsigned char *)_items); }
+void CBaseRecordVector::Clear() 
+  { DeleteFrom(0); }
+void CBaseRecordVector::DeleteBack() 
+  { Delete(_size - 1); }
+void CBaseRecordVector::DeleteFrom(int index)
+  { Delete(index, _size - index); }
+
+void CBaseRecordVector::ReserveOnePosition()
+{
+  if(_size != _capacity)
+    return;
+  int delta;
+  if (_capacity > 64)
+    delta = _capacity / 2;
+  else if (_capacity > 8)
+    delta = 8;
+  else
+    delta = 4;
+  Reserve(_capacity + delta);
+}
+
+void CBaseRecordVector::Reserve(int newCapacity)
+{
+  if(newCapacity <= _capacity)
+    return;
+  /*
+  #ifndef _DEBUG
+  static const unsigned int kMaxVectorSize = 0xF0000000;
+  if(newCapacity < _size || 
+      ((unsigned int )newCapacity * (unsigned int )_itemSize) > kMaxVectorSize) 
+    throw 1052354;
+  #endif
+  */
+  unsigned char *p = new unsigned char[newCapacity * _itemSize];
+  int numRecordsToMove = _capacity;
+  memmove(p, _items, _itemSize * numRecordsToMove);
+  delete [](unsigned char *)_items;
+  _items = p;
+  _capacity = newCapacity;
+}
+
+void CBaseRecordVector::MoveItems(int destIndex, int srcIndex)
+{
+  memmove(((unsigned char *)_items) + destIndex * _itemSize, 
+    ((unsigned char  *)_items) + srcIndex * _itemSize, 
+    _itemSize * (_size - srcIndex));
+}
+
+void CBaseRecordVector::InsertOneItem(int index)
+{
+  ReserveOnePosition();
+  MoveItems(index + 1, index);
+  _size++;
+}
+
+void CBaseRecordVector::Delete(int index, int num)
+{
+  TestIndexAndCorrectNum(index, num);
+  if (num > 0)
+  {
+    MoveItems(index, index + num);
+    _size -= num;
+  }
+}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Common/Vector.h squashfs-tools-patched/LZMA/lzmadaptive/C/Common/Vector.h
--- squashfs-tools/LZMA/lzmadaptive/C/Common/Vector.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Common/Vector.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,211 @@
+// Common/Vector.h
+
+#ifndef __COMMON_VECTOR_H
+#define __COMMON_VECTOR_H
+
+#include "Defs.h"
+
+class CBaseRecordVector
+{
+  void MoveItems(int destIndex, int srcIndex);
+protected:
+	int _capacity;
+  int _size;
+	void *_items;
+  size_t _itemSize;
+
+	void ReserveOnePosition();
+  void InsertOneItem(int index);
+  void TestIndexAndCorrectNum(int index, int &num) const
+    { if (index + num > _size) num = _size - index; } 
+public:
+  CBaseRecordVector(size_t itemSize):
+      _capacity(0), _size(0), _items(0), _itemSize(itemSize) {}
+	virtual ~CBaseRecordVector();
+  int Size() const { return _size; }
+	bool IsEmpty() const { return (_size == 0); }
+	void Reserve(int newCapacity);
+	virtual void Delete(int index, int num = 1);
+	void Clear();
+  void DeleteFrom(int index);
+  void DeleteBack();
+};
+
+template <class T>
+class CRecordVector: public CBaseRecordVector
+{
+public:
+  CRecordVector():CBaseRecordVector(sizeof(T)){};
+  CRecordVector(const CRecordVector &v):
+    CBaseRecordVector(sizeof(T)) { *this = v;}
+	CRecordVector& operator=(const CRecordVector &v)
+  {
+    Clear();
+    return (*this += v);
+  }
+  CRecordVector& operator+=(const CRecordVector &v)
+  {
+    int size = v.Size();
+    Reserve(Size() + size);
+    for(int i = 0; i < size; i++)
+      Add(v[i]);
+    return *this;
+  }
+	int Add(T item)
+  {
+    ReserveOnePosition();
+    ((T *)_items)[_size] = item;
+    return _size++;
+  }
+	void Insert(int index, T item)
+  {
+    InsertOneItem(index);
+    ((T *)_items)[index] = item;
+  }
+  // T* GetPointer() const { return (T*)_items; }
+  // operator const T *() const { return _items; };
+  const T& operator[](int index) const { return ((T *)_items)[index]; }
+	T& operator[](int index) { return ((T *)_items)[index]; }
+	const T& Front() const { return operator[](0); }
+  T& Front()   { return operator[](0); }
+	const T& Back() const { return operator[](_size - 1); }
+  T& Back()   { return operator[](_size - 1); }
+
+  void Swap(int i, int j)
+  {
+    T temp = operator[](i);
+    operator[](i) = operator[](j);
+    operator[](j) = temp;
+  }
+
+  void Sort(int left, int right)
+  { 
+    if (right - left < 2)
+      return;
+    Swap(left, (left + right) / 2);
+    int last = left;
+    for (int i = left; i < right; i++)
+      if (operator[](i) < operator[](left))
+        Swap(++last, i);
+    Swap(left, last);
+    Sort(left, last);
+    Sort(last + 1, right);
+  }
+  void Sort() { Sort(0, Size());  }
+  void Sort(int left, int right, int (*compare)(const T*, const T*, void *), void *param)
+  { 
+    if (right - left < 2)
+      return;
+    Swap(left, (left + right) / 2);
+    int last = left;
+    for (int i = left; i < right; i++)
+      if (compare(&operator[](i), &operator[](left), param) < 0)
+        Swap(++last, i);
+    Swap(left, last);
+    Sort(left, last, compare, param);
+    Sort(last + 1, right, compare, param);
+  }
+
+  void Sort(int (*compare)(const T*, const T*, void *), void *param) 
+  {  
+    Sort(0, Size(), compare, param);  
+  }
+};
+
+typedef CRecordVector<int> CIntVector;
+typedef CRecordVector<unsigned int> CUIntVector;
+typedef CRecordVector<bool> CBoolVector;
+typedef CRecordVector<unsigned char> CByteVector;
+typedef CRecordVector<void *> CPointerVector;
+
+template <class T>
+class CObjectVector: public CPointerVector
+{
+public:
+  CObjectVector(){};
+  ~CObjectVector() { Clear(); }
+  CObjectVector(const CObjectVector &objectVector)
+    { *this = objectVector; }
+	CObjectVector& operator=(const CObjectVector &objectVector)
+  {
+    Clear();
+    return (*this += objectVector);
+  }
+	CObjectVector& operator+=(const CObjectVector &objectVector)
+  {
+    int size = objectVector.Size();
+    Reserve(Size() + size);
+    for(int i = 0; i < size; i++)
+      Add(objectVector[i]);
+    return *this;
+  }
+	const T& operator[](int index) const { return *((T *)CPointerVector::operator[](index)); }
+	T& operator[](int index) { return *((T *)CPointerVector::operator[](index)); }
+	T& Front() { return operator[](0); }
+	const T& Front() const { return operator[](0); }
+	T& Back() { return operator[](_size - 1); }
+	const T& Back() const { return operator[](_size - 1); }
+	int Add(const T& item)
+    { return CPointerVector::Add(new T(item)); }
+	void Insert(int index, const T& item)
+    { CPointerVector::Insert(index, new T(item)); }
+	virtual void Delete(int index, int num = 1)
+  {
+    TestIndexAndCorrectNum(index, num);
+    for(int i = 0; i < num; i++)
+      delete (T *)(((void **)_items)[index + i]);
+    CPointerVector::Delete(index, num);
+  }
+  int Find(const T& item) const
+  {
+    for(int i = 0; i < Size(); i++)
+      if (item == (*this)[i])
+        return i;
+      return -1;
+  }
+  int FindInSorted(const T& item) const
+  {
+    int left = 0, right = Size(); 
+    while (left != right)
+    {
+      int mid = (left + right) / 2;
+      const T& midValue = (*this)[mid];
+      if (item == midValue)
+        return mid;
+      if (item < midValue)
+        right = mid;
+      else
+        left = mid + 1;
+    }
+    return -1;
+  }
+  int AddToSorted(const T& item)
+  {
+    int left = 0, right = Size(); 
+    while (left != right)
+    {
+      int mid = (left + right) / 2;
+      const T& midValue = (*this)[mid];
+      if (item == midValue)
+      {
+        right = mid + 1;
+        break;
+      }
+      if (item < midValue)
+        right = mid;
+      else
+        left = mid + 1;
+    }
+    Insert(right, item);
+    return right;
+  }
+
+  void Sort(int (*compare)(void *const *, void *const *, void *), void *param) 
+    { CPointerVector::Sort(compare, param); }
+
+  static int CompareObjectItems(void *const *a1, void *const *a2, void *param)
+    { return MyCompare(*(*((const T **)a1)), *(*((const T **)a2))); }
+  void Sort() { CPointerVector::Sort(CompareObjectItems, 0); }
+};
+
+#endif 
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Windows/Defs.h squashfs-tools-patched/LZMA/lzmadaptive/C/Windows/Defs.h
--- squashfs-tools/LZMA/lzmadaptive/C/Windows/Defs.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Windows/Defs.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,18 @@
+// Windows/Defs.h
+
+#ifndef __WINDOWS_DEFS_H
+#define __WINDOWS_DEFS_H
+
+inline bool BOOLToBool(BOOL value)
+  { return (value != FALSE); }
+
+inline BOOL BoolToBOOL(bool value)
+  { return (value ? TRUE: FALSE); }
+
+inline VARIANT_BOOL BoolToVARIANT_BOOL(bool value)
+  { return (value ? VARIANT_TRUE: VARIANT_FALSE); }
+
+inline bool VARIANT_BOOLToBool(VARIANT_BOOL value)
+  { return (value != VARIANT_FALSE); }
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Windows/FileIO.cpp squashfs-tools-patched/LZMA/lzmadaptive/C/Windows/FileIO.cpp
--- squashfs-tools/LZMA/lzmadaptive/C/Windows/FileIO.cpp	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Windows/FileIO.cpp	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,245 @@
+// Windows/FileIO.cpp
+
+#include "StdAfx.h"
+
+#include "FileIO.h"
+#include "Defs.h"
+#ifndef _UNICODE
+#include "../Common/StringConvert.h"
+#endif
+
+#ifndef _UNICODE
+extern bool g_IsNT;
+#endif
+
+namespace NWindows {
+namespace NFile {
+namespace NIO {
+
+CFileBase::~CFileBase() { Close(); }
+
+bool CFileBase::Create(LPCTSTR fileName, DWORD desiredAccess,
+    DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes)
+{
+  Close();
+  _handle = ::CreateFile(fileName, desiredAccess, shareMode, 
+      (LPSECURITY_ATTRIBUTES)NULL, creationDisposition, 
+      flagsAndAttributes, (HANDLE) NULL);
+  return (_fileIsOpen = (_handle != INVALID_HANDLE_VALUE));
+}
+
+#ifndef _UNICODE
+bool CFileBase::Create(LPCWSTR fileName, DWORD desiredAccess,
+    DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes)
+{
+  if (g_IsNT)
+  {
+    Close();
+    _handle = ::CreateFileW(fileName, desiredAccess, shareMode, 
+      (LPSECURITY_ATTRIBUTES)NULL, creationDisposition, 
+      flagsAndAttributes, (HANDLE) NULL);
+    return (_fileIsOpen = (_handle != INVALID_HANDLE_VALUE));
+  }
+  return Create(UnicodeStringToMultiByte(fileName, ::AreFileApisANSI() ? CP_ACP : CP_OEMCP), 
+    desiredAccess, shareMode, creationDisposition, flagsAndAttributes);
+}
+#endif
+
+bool CFileBase::Close()
+{
+  if(!_fileIsOpen)
+    return true;
+  bool result = BOOLToBool(::CloseHandle(_handle));
+  _fileIsOpen = !result;
+  return result;
+}
+
+bool CFileBase::GetPosition(UInt64 &position) const
+{
+  return Seek(0, FILE_CURRENT, position);
+}
+
+bool CFileBase::GetLength(UInt64 &length) const
+{
+  DWORD sizeHigh;
+  DWORD sizeLow = ::GetFileSize(_handle, &sizeHigh);
+  if(sizeLow == 0xFFFFFFFF)
+    if(::GetLastError() != NO_ERROR)
+      return false;
+  length = (((UInt64)sizeHigh) << 32) + sizeLow;
+  return true;
+}
+
+bool CFileBase::Seek(Int64 distanceToMove, DWORD moveMethod, UInt64 &newPosition) const
+{
+  LARGE_INTEGER value;
+  value.QuadPart = distanceToMove;
+  value.LowPart = ::SetFilePointer(_handle, value.LowPart, &value.HighPart, moveMethod);
+  if (value.LowPart == 0xFFFFFFFF)
+    if(::GetLastError() != NO_ERROR) 
+      return false;
+  newPosition = value.QuadPart;
+  return true;
+}
+
+bool CFileBase::Seek(UInt64 position, UInt64 &newPosition)
+{
+  return Seek(position, FILE_BEGIN, newPosition);
+}
+
+bool CFileBase::SeekToBegin()
+{
+  UInt64 newPosition;
+  return Seek(0, newPosition);
+}
+
+bool CFileBase::SeekToEnd(UInt64 &newPosition)
+{
+  return Seek(0, FILE_END, newPosition);
+}
+
+bool CFileBase::GetFileInformation(CByHandleFileInfo &fileInfo) const
+{
+  BY_HANDLE_FILE_INFORMATION winFileInfo;
+  if(!::GetFileInformationByHandle(_handle, &winFileInfo))
+    return false;
+  fileInfo.Attributes = winFileInfo.dwFileAttributes;
+  fileInfo.CreationTime = winFileInfo.ftCreationTime;
+  fileInfo.LastAccessTime = winFileInfo.ftLastAccessTime;
+  fileInfo.LastWriteTime = winFileInfo.ftLastWriteTime;
+  fileInfo.VolumeSerialNumber = winFileInfo.dwFileAttributes; 
+  fileInfo.Size = (((UInt64)winFileInfo.nFileSizeHigh) << 32) +  winFileInfo.nFileSizeLow;
+  fileInfo.NumberOfLinks = winFileInfo.nNumberOfLinks;
+  fileInfo.FileIndex = (((UInt64)winFileInfo.nFileIndexHigh) << 32) + winFileInfo.nFileIndexLow;
+  return true;
+}
+
+/////////////////////////
+// CInFile
+
+bool CInFile::Open(LPCTSTR fileName, DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes)
+  { return Create(fileName, GENERIC_READ, shareMode, creationDisposition, flagsAndAttributes); }
+
+bool CInFile::Open(LPCTSTR fileName)
+  { return Open(fileName, FILE_SHARE_READ, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL); }
+
+#ifndef _UNICODE
+bool CInFile::Open(LPCWSTR fileName, DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes)
+  { return Create(fileName, GENERIC_READ, shareMode, creationDisposition, flagsAndAttributes); }
+
+bool CInFile::Open(LPCWSTR fileName)
+  { return Open(fileName, FILE_SHARE_READ, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL); }
+#endif
+
+// ReadFile and WriteFile functions in Windows have BUG:
+// If you Read or Write 64MB or more (probably min_failure_size = 64MB - 32KB + 1) 
+// from/to Network file, it returns ERROR_NO_SYSTEM_RESOURCES 
+// (Insufficient system resources exist to complete the requested service).
+
+static UInt32 kChunkSizeMax = (1 << 24);
+
+bool CInFile::ReadPart(void *data, UInt32 size, UInt32 &processedSize)
+{
+  if (size > kChunkSizeMax)
+    size = kChunkSizeMax;
+  DWORD processedLoc = 0;
+  bool res = BOOLToBool(::ReadFile(_handle, data, size, &processedLoc, NULL));
+  processedSize = (UInt32)processedLoc;
+  return res;
+}
+
+bool CInFile::Read(void *data, UInt32 size, UInt32 &processedSize)
+{
+  processedSize = 0;
+  do
+  {
+    UInt32 processedLoc = 0;
+    bool res = ReadPart(data, size, processedLoc);
+    processedSize += processedLoc;
+    if (!res)
+      return false;
+    if (processedLoc == 0)
+      return true;
+    data = (void *)((unsigned char *)data + processedLoc);
+    size -= processedLoc;
+  }
+  while (size > 0);
+  return true;
+}
+
+/////////////////////////
+// COutFile
+
+bool COutFile::Open(LPCTSTR fileName, DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes)
+  { return CFileBase::Create(fileName, GENERIC_WRITE, shareMode, creationDisposition, flagsAndAttributes); }
+
+static inline DWORD GetCreationDisposition(bool createAlways)
+  { return createAlways? CREATE_ALWAYS: CREATE_NEW; }
+
+bool COutFile::Open(LPCTSTR fileName, DWORD creationDisposition)
+  { return Open(fileName, FILE_SHARE_READ, creationDisposition, FILE_ATTRIBUTE_NORMAL); }
+
+bool COutFile::Create(LPCTSTR fileName, bool createAlways)
+  { return Open(fileName, GetCreationDisposition(createAlways)); }
+
+#ifndef _UNICODE
+
+bool COutFile::Open(LPCWSTR fileName, DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes)
+  { return CFileBase::Create(fileName, GENERIC_WRITE, shareMode,      creationDisposition, flagsAndAttributes); }
+
+bool COutFile::Open(LPCWSTR fileName, DWORD creationDisposition)
+  { return Open(fileName, FILE_SHARE_READ,  creationDisposition, FILE_ATTRIBUTE_NORMAL); }
+
+bool COutFile::Create(LPCWSTR fileName, bool createAlways)
+  { return Open(fileName, GetCreationDisposition(createAlways)); }
+
+#endif
+
+bool COutFile::SetTime(const FILETIME *creationTime, const FILETIME *lastAccessTime, const FILETIME *lastWriteTime)
+  { return BOOLToBool(::SetFileTime(_handle, creationTime, lastAccessTime, lastWriteTime)); }
+
+bool COutFile::SetLastWriteTime(const FILETIME *lastWriteTime)
+  {  return SetTime(NULL, NULL, lastWriteTime); }
+
+bool COutFile::WritePart(const void *data, UInt32 size, UInt32 &processedSize)
+{
+  if (size > kChunkSizeMax)
+    size = kChunkSizeMax;
+  DWORD processedLoc = 0;
+  bool res = BOOLToBool(::WriteFile(_handle, data, size, &processedLoc, NULL));
+  processedSize = (UInt32)processedLoc;
+  return res;
+}
+
+bool COutFile::Write(const void *data, UInt32 size, UInt32 &processedSize)
+{
+  processedSize = 0;
+  do
+  {
+    UInt32 processedLoc = 0;
+    bool res = WritePart(data, size, processedLoc);
+    processedSize += processedLoc;
+    if (!res)
+      return false;
+    if (processedLoc == 0)
+      return true;
+    data = (const void *)((const unsigned char *)data + processedLoc);
+    size -= processedLoc;
+  }
+  while (size > 0);
+  return true;
+}
+
+bool COutFile::SetEndOfFile() { return BOOLToBool(::SetEndOfFile(_handle)); }
+
+bool COutFile::SetLength(UInt64 length)
+{
+  UInt64 newPosition;
+  if(!Seek(length, newPosition))
+    return false;
+  if(newPosition != length)
+    return false;
+  return SetEndOfFile();
+}
+
+}}}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Windows/FileIO.h squashfs-tools-patched/LZMA/lzmadaptive/C/Windows/FileIO.h
--- squashfs-tools/LZMA/lzmadaptive/C/Windows/FileIO.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Windows/FileIO.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,98 @@
+// Windows/FileIO.h
+
+#ifndef __WINDOWS_FILEIO_H
+#define __WINDOWS_FILEIO_H
+
+#include "../Common/Types.h"
+
+namespace NWindows {
+namespace NFile {
+namespace NIO {
+
+struct CByHandleFileInfo
+{ 
+  DWORD    Attributes; 
+  FILETIME CreationTime; 
+  FILETIME LastAccessTime; 
+  FILETIME LastWriteTime; 
+  DWORD    VolumeSerialNumber; 
+  UInt64   Size;
+  DWORD    NumberOfLinks; 
+  UInt64   FileIndex; 
+};
+
+class CFileBase
+{
+protected:
+  bool _fileIsOpen;
+  HANDLE _handle;
+  bool Create(LPCTSTR fileName, DWORD desiredAccess,
+      DWORD shareMode, DWORD creationDisposition,  DWORD flagsAndAttributes);
+  #ifndef _UNICODE
+  bool Create(LPCWSTR fileName, DWORD desiredAccess,
+      DWORD shareMode, DWORD creationDisposition,  DWORD flagsAndAttributes);
+  #endif
+
+public:
+  CFileBase(): _fileIsOpen(false){};
+  virtual ~CFileBase();
+
+  virtual bool Close();
+
+  bool GetPosition(UInt64 &position) const;
+  bool GetLength(UInt64 &length) const;
+
+  bool Seek(Int64 distanceToMove, DWORD moveMethod, UInt64 &newPosition) const;
+  bool Seek(UInt64 position, UInt64 &newPosition); 
+  bool SeekToBegin(); 
+  bool SeekToEnd(UInt64 &newPosition); 
+  
+  bool GetFileInformation(CByHandleFileInfo &fileInfo) const;
+};
+
+class CInFile: public CFileBase
+{
+public:
+  bool Open(LPCTSTR fileName, DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes);
+  bool Open(LPCTSTR fileName);
+  #ifndef _UNICODE
+  bool Open(LPCWSTR fileName, DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes);
+  bool Open(LPCWSTR fileName);
+  #endif
+  bool ReadPart(void *data, UInt32 size, UInt32 &processedSize);
+  bool Read(void *data, UInt32 size, UInt32 &processedSize);
+};
+
+class COutFile: public CFileBase
+{
+  // DWORD m_CreationDisposition;
+public:
+  // COutFile(): m_CreationDisposition(CREATE_NEW){};
+  bool Open(LPCTSTR fileName, DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes);
+  bool Open(LPCTSTR fileName, DWORD creationDisposition);
+  bool Create(LPCTSTR fileName, bool createAlways);
+
+  #ifndef _UNICODE
+  bool Open(LPCWSTR fileName, DWORD shareMode, DWORD creationDisposition, DWORD flagsAndAttributes);
+  bool Open(LPCWSTR fileName, DWORD creationDisposition);
+  bool Create(LPCWSTR fileName, bool createAlways);
+  #endif
+
+  /*
+  void SetOpenCreationDisposition(DWORD creationDisposition)
+    { m_CreationDisposition = creationDisposition; }
+  void SetOpenCreationDispositionCreateAlways()
+    { m_CreationDisposition = CREATE_ALWAYS; }
+  */
+
+  bool SetTime(const FILETIME *creationTime, const FILETIME *lastAccessTime, const FILETIME *lastWriteTime);
+  bool SetLastWriteTime(const FILETIME *lastWriteTime);
+  bool WritePart(const void *data, UInt32 size, UInt32 &processedSize);
+  bool Write(const void *data, UInt32 size, UInt32 &processedSize);
+  bool SetEndOfFile();
+  bool SetLength(UInt64 length);
+};
+
+}}}
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/C/Windows/StdAfx.h squashfs-tools-patched/LZMA/lzmadaptive/C/Windows/StdAfx.h
--- squashfs-tools/LZMA/lzmadaptive/C/Windows/StdAfx.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/C/Windows/StdAfx.h	2022-01-01 15:08:47.901171449 +0800
@@ -0,0 +1,9 @@
+// StdAfx.h
+
+#ifndef __STDAFX_H
+#define __STDAFX_H
+
+#include "../Common/MyWindows.h"
+#include "../Common/NewHandler.h"
+
+#endif 
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/CPL.html squashfs-tools-patched/LZMA/lzmadaptive/CPL.html
--- squashfs-tools/LZMA/lzmadaptive/CPL.html	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/CPL.html	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,224 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<HTML><HEAD><TITLE>Common Public License - v 1.0</TITLE>
+<META http-equiv=Content-Type content="text/html; charset=ISO-8859-1">
+<BODY vLink=#800000 bgColor=#ffffff>
+<P align=center><B>Common Public License - v 1.0</B> 
+<P><B></B><FONT size=3></FONT>
+<P><FONT size=3></FONT><FONT size=2>THE ACCOMPANYING PROGRAM IS PROVIDED UNDER 
+THE TERMS OF THIS COMMON PUBLIC LICENSE ("AGREEMENT"). ANY USE, REPRODUCTION OR 
+DISTRIBUTION OF THE PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS 
+AGREEMENT.</FONT> 
+<P><FONT size=2></FONT>
+<P><FONT size=2><B>1. DEFINITIONS</B></FONT> 
+<P><FONT size=2>"Contribution" means:</FONT> 
+<UL><FONT size=2>a) in the case of the initial Contributor, the initial code 
+  and documentation distributed under this Agreement, and<BR clear=left>b) in 
+  the case of each subsequent Contributor:</FONT></UL>
+<UL><FONT size=2>i) changes to the Program, and</FONT></UL>
+<UL><FONT size=2>ii) additions to the Program;</FONT></UL>
+<UL><FONT size=2>where such changes and/or additions to the Program originate 
+  from and are distributed by that particular Contributor. </FONT><FONT size=2>A 
+  Contribution 'originates' from a Contributor if it was added to the Program by 
+  such Contributor itself or anyone acting on such Contributor's behalf. 
+  </FONT><FONT size=2>Contributions do not include additions to the Program 
+  which: (i) are separate modules of software distributed in conjunction with 
+  the Program under their own license agreement, and (ii) are not derivative 
+  works of the Program. </FONT></UL>
+<P><FONT size=2></FONT>
+<P><FONT size=2>"Contributor" means any person or entity that distributes the 
+Program.</FONT> 
+<P><FONT size=2></FONT><FONT size=2></FONT>
+<P><FONT size=2>"Licensed Patents " mean patent claims licensable by a 
+Contributor which are necessarily infringed by the use or sale of its 
+Contribution alone or when combined with the Program. </FONT>
+<P><FONT size=2></FONT><FONT size=2></FONT>
+<P><FONT size=2></FONT><FONT size=2>"Program" means the Contributions 
+distributed in accordance with this Agreement.</FONT> 
+<P><FONT size=2></FONT>
+<P><FONT size=2>"Recipient" means anyone who receives the Program under this 
+Agreement, including all Contributors.</FONT> 
+<P><FONT size=2><B></B></FONT>
+<P><FONT size=2><B>2. GRANT OF RIGHTS</B></FONT> 
+<UL><FONT size=2></FONT><FONT size=2>a) </FONT><FONT size=2>Subject to the 
+  terms of this Agreement, each Contributor hereby grants</FONT><FONT size=2> 
+  Recipient a non-exclusive, worldwide, royalty-free copyright license 
+  to</FONT><FONT color=#ff0000 size=2> </FONT><FONT size=2>reproduce, prepare 
+  derivative works of, publicly display, publicly perform, distribute and 
+  sublicense the Contribution of such Contributor, if any, and such derivative 
+  works, in source code and object code form.</FONT></UL>
+<UL><FONT size=2></FONT></UL>
+<UL><FONT size=2></FONT><FONT size=2>b) Subject to the terms of this 
+  Agreement, each Contributor hereby grants </FONT><FONT size=2>Recipient a 
+  non-exclusive, worldwide,</FONT><FONT color=#008000 size=2> </FONT><FONT 
+  size=2>royalty-free patent license under Licensed Patents to make, use, sell, 
+  offer to sell, import and otherwise transfer the Contribution of such 
+  Contributor, if any, in source code and object code form. This patent license 
+  shall apply to the combination of the Contribution and the Program if, at the 
+  time the Contribution is added by the Contributor, such addition of the 
+  Contribution causes such combination to be covered by the Licensed Patents. 
+  The patent license shall not apply to any other combinations which include the 
+  Contribution. No hardware per se is licensed hereunder. </FONT></UL>
+<UL><FONT size=2></FONT></UL>
+<UL><FONT size=2>c) Recipient understands that although each Contributor 
+  grants the licenses to its Contributions set forth herein, no assurances are 
+  provided by any Contributor that the Program does not infringe the patent or 
+  other intellectual property rights of any other entity. Each Contributor 
+  disclaims any liability to Recipient for claims brought by any other entity 
+  based on infringement of intellectual property rights or otherwise. As a 
+  condition to exercising the rights and licenses granted hereunder, each 
+  Recipient hereby assumes sole responsibility to secure any other intellectual 
+  property rights needed, if any. For example, if a third party patent license 
+  is required to allow Recipient to distribute the Program, it is Recipient's 
+  responsibility to acquire that license before distributing the 
+Program.</FONT></UL>
+<UL><FONT size=2></FONT></UL>
+<UL><FONT size=2>d) Each Contributor represents that to its knowledge it has 
+  sufficient copyright rights in its Contribution, if any, to grant the 
+  copyright license set forth in this Agreement. </FONT></UL>
+<UL><FONT size=2></FONT></UL>
+<P><FONT size=2><B>3. REQUIREMENTS</B></FONT> 
+<P><FONT size=2><B></B>A Contributor may choose to distribute the Program in 
+object code form under its own license agreement, provided that:</FONT> 
+<UL><FONT size=2>a) it complies with the terms and conditions of this 
+  Agreement; and</FONT></UL>
+<UL><FONT size=2>b) its license agreement:</FONT></UL>
+<UL><FONT size=2>i) effectively disclaims</FONT><FONT size=2> on behalf of all 
+  Contributors all warranties and conditions, express and implied, including 
+  warranties or conditions of title and non-infringement, and implied warranties 
+  or conditions of merchantability and fitness for a particular purpose; 
+</FONT></UL>
+<UL><FONT size=2>ii) effectively excludes on behalf of all Contributors all 
+  liability for damages, including direct, indirect, special, incidental and 
+  consequential damages, such as lost profits; </FONT></UL>
+<UL><FONT size=2>iii)</FONT><FONT size=2> states that any provisions which 
+  differ from this Agreement are offered by that Contributor alone and not by 
+  any other party; and</FONT></UL>
+<UL><FONT size=2>iv) states that source code for the Program is available from 
+  such Contributor, and informs licensees how to obtain it in a reasonable 
+  manner on or through a medium customarily used for software 
+  exchange.</FONT><FONT color=#0000ff size=2> </FONT><FONT color=#ff0000 
+  size=2></FONT></UL>
+<UL><FONT color=#ff0000 size=2></FONT><FONT size=2></FONT></UL>
+<P><FONT size=2>When the Program is made available in source code form:</FONT> 
+<UL><FONT size=2>a) it must be made available under this Agreement; and 
+</FONT></UL>
+<UL><FONT size=2>b) a copy of this Agreement must be included with each copy 
+  of the Program. </FONT></UL>
+<P><FONT size=2></FONT><FONT color=#0000ff size=2><STRIKE></STRIKE></FONT>
+<P><FONT color=#0000ff size=2><STRIKE></STRIKE></FONT><FONT size=2>Contributors 
+may not remove or alter any copyright notices contained within the Program. 
+</FONT>
+<P><FONT size=2></FONT>
+<P><FONT size=2>Each Contributor must identify itself as the originator of its 
+Contribution, if any, in a manner that reasonably allows subsequent Recipients 
+to identify the originator of the Contribution. </FONT>
+<P><FONT size=2></FONT>
+<P><FONT size=2><B>4. COMMERCIAL DISTRIBUTION</B></FONT> 
+<P><FONT size=2>Commercial distributors of software may accept certain 
+responsibilities with respect to end users, business partners and the like. 
+While this license is intended to facilitate the commercial use of the Program, 
+the Contributor who includes the Program in a commercial product offering should 
+do so in a manner which does not create potential liability for other 
+Contributors. Therefore, if a Contributor includes the Program in a commercial 
+product offering, such Contributor ("Commercial Contributor") hereby agrees to 
+defend and indemnify every other Contributor ("Indemnified Contributor") against 
+any losses, damages and costs (collectively "Losses") arising from claims, 
+lawsuits and other legal actions brought by a third party against the 
+Indemnified Contributor to the extent caused by the acts or omissions of such 
+Commercial Contributor in connection with its distribution of the Program in a 
+commercial product offering. The obligations in this section do not apply to any 
+claims or Losses relating to any actual or alleged intellectual property 
+infringement. In order to qualify, an Indemnified Contributor must: a) promptly 
+notify the Commercial Contributor in writing of such claim, and b) allow the 
+Commercial Contributor to control, and cooperate with the Commercial Contributor 
+in, the defense and any related settlement negotiations. The Indemnified 
+Contributor may participate in any such claim at its own expense.</FONT> 
+<P><FONT size=2></FONT>
+<P><FONT size=2>For example, a Contributor might include the Program in a 
+commercial product offering, Product X. That Contributor is then a Commercial 
+Contributor. If that Commercial Contributor then makes performance claims, or 
+offers warranties related to Product X, those performance claims and warranties 
+are such Commercial Contributor's responsibility alone. Under this section, the 
+Commercial Contributor would have to defend claims against the other 
+Contributors related to those performance claims and warranties, and if a court 
+requires any other Contributor to pay any damages as a result, the Commercial 
+Contributor must pay those damages.</FONT> 
+<P><FONT size=2></FONT><FONT color=#0000ff size=2></FONT>
+<P><FONT color=#0000ff size=2></FONT><FONT size=2><B>5. NO WARRANTY</B></FONT> 
+<P><FONT size=2>EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, THE PROGRAM IS 
+PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
+EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR 
+CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A 
+PARTICULAR PURPOSE. Each Recipient is</FONT><FONT size=2> solely responsible for 
+determining the appropriateness of using and distributing </FONT><FONT 
+size=2>the Program</FONT><FONT size=2> and assumes all risks associated with its 
+exercise of rights under this Agreement</FONT><FONT size=2>, including but not 
+limited to the risks and costs of program errors, compliance with applicable 
+laws, damage to or loss of data, </FONT><FONT size=2>programs or equipment, and 
+unavailability or interruption of operations</FONT><FONT size=2>. </FONT><FONT 
+size=2></FONT>
+<P><FONT size=2></FONT>
+<P><FONT size=2></FONT><FONT size=2><B>6. DISCLAIMER OF LIABILITY</B></FONT> 
+<P><FONT size=2></FONT><FONT size=2>EXCEPT AS EXPRESSLY SET FORTH IN THIS 
+AGREEMENT, NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+</FONT><FONT size=2>(INCLUDING WITHOUT LIMITATION LOST PROFITS),</FONT><FONT 
+size=2> HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
+OUT OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS 
+GRANTED HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</FONT> 
+<P><FONT size=2></FONT><FONT size=2></FONT>
+<P><FONT size=2><B>7. GENERAL</B></FONT> 
+<P><FONT size=2></FONT><FONT size=2>If any provision of this Agreement is 
+invalid or unenforceable under applicable law, it shall not affect the validity 
+or enforceability of the remainder of the terms of this Agreement, and without 
+further action by the parties hereto, such provision shall be reformed to the 
+minimum extent necessary to make such provision valid and enforceable.</FONT> 
+<P><FONT size=2></FONT>
+<P><FONT size=2>If Recipient institutes patent litigation against a Contributor 
+with respect to a patent applicable to software (including a cross-claim or 
+counterclaim in a lawsuit), then any patent licenses granted by that Contributor 
+to such Recipient under this Agreement shall terminate as of the date such 
+litigation is filed. In addition, if Recipient institutes patent litigation 
+against any entity (including a cross-claim or counterclaim in a lawsuit) 
+alleging that the Program itself (excluding combinations of the Program with 
+other software or hardware) infringes such Recipient's patent(s), then such 
+Recipient's rights granted under Section 2(b) shall terminate as of the date 
+such litigation is filed. </FONT><FONT size=2></FONT>
+<P><FONT size=2></FONT>
+<P><FONT size=2>All Recipient's rights under this Agreement shall terminate if 
+it fails to comply with any of the material terms or conditions of this 
+Agreement and does not cure such failure in a reasonable period of time after 
+becoming aware of such noncompliance. If all Recipient's rights under this 
+Agreement terminate, Recipient agrees to cease use and distribution of the 
+Program as soon as reasonably practicable. However, Recipient's obligations 
+under this Agreement and any licenses granted by Recipient relating to the 
+Program shall continue and survive. </FONT><FONT size=2></FONT>
+<P><FONT size=2></FONT>
+<P><FONT size=2></FONT><FONT size=2>Everyone is permitted to copy and distribute 
+copies of this Agreement, but in order to avoid inconsistency the Agreement is 
+copyrighted and may only be modified in the following manner. The Agreement 
+Steward reserves the right to </FONT><FONT size=2>publish new versions 
+(including revisions) of this Agreement from time to </FONT><FONT size=2>time. 
+No one other than the Agreement Steward has the right to modify this Agreement. 
+IBM is the initial Agreement Steward. IBM may assign the responsibility to serve 
+as the Agreement Steward to a suitable separate entity. </FONT><FONT size=2>Each 
+new version of the Agreement will be given a distinguishing version number. The 
+Program (including Contributions) may always be distributed subject to the 
+version of the Agreement under which it was received. In addition, after a new 
+version of the Agreement is published, Contributor may elect to distribute the 
+Program (including its Contributions) under the new </FONT><FONT size=2>version. 
+</FONT><FONT size=2>Except as expressly stated in Sections 2(a) and 2(b) above, 
+Recipient receives no rights or licenses to the intellectual property of any 
+Contributor under this Agreement, whether expressly, </FONT><FONT size=2>by 
+implication, estoppel or otherwise</FONT><FONT size=2>.</FONT><FONT size=2> All 
+rights in the Program not expressly granted under this Agreement are 
+reserved.</FONT> 
+<P><FONT size=2></FONT>
+<P><FONT size=2>This Agreement is governed by the laws of the State of New York 
+and the intellectual property laws of the United States of America. No party to 
+this Agreement will bring a legal action under this Agreement more than one year 
+after the cause of action arose. Each party waives its rights to a jury trial in 
+any resulting litigation.</FONT> 
+<P><FONT size=2></FONT><FONT size=2></FONT>
+<P><FONT size=2></FONT></P></BODY></HTML>
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/history.txt squashfs-tools-patched/LZMA/lzmadaptive/history.txt
--- squashfs-tools/LZMA/lzmadaptive/history.txt	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/history.txt	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,147 @@
+HISTORY of the LZMA SDK
+-----------------------
+
+  Version 4.32                2005-12-09
+  --------------------------------------
+    - Java version of LZMA SDK was included
+
+
+  Version 4.30                2005-11-20
+  --------------------------------------
+    - Compression ratio was improved in -a2 mode
+    - Speed optimizations for compressing in -a2 mode
+    - -fb switch now supports values up to 273
+    - Bug in 7z_C (7zIn.c) was fixed:
+      It used Alloc/Free functions from different memory pools.
+      So if program used two memory pools, it worked incorrectly.
+    - 7z_C: .7z format supporting was improved
+    - LZMA# SDK (C#.NET version) was included
+
+
+  Version 4.27 (Updated)      2005-09-21
+  --------------------------------------
+   - Some GUIDs/interfaces in C++ were changed.
+     IStream.h:
+       ISequentialInStream::Read now works as old ReadPart
+       ISequentialOutStream::Write now works as old WritePart
+
+  
+  Version 4.27                2005-08-07
+  --------------------------------------
+    - Bug in LzmaDecodeSize.c was fixed:
+       if _LZMA_IN_CB and _LZMA_OUT_READ were defined,
+       decompressing worked incorrectly.
+
+
+  Version 4.26                2005-08-05
+  --------------------------------------
+    - Fixes in 7z_C code and LzmaTest.c:
+      previous versions could work incorrectly,
+      if malloc(0) returns 0
+
+
+  Version 4.23                2005-06-29
+  --------------------------------------
+    - Small fixes in C++ code
+
+
+  Version 4.22                2005-06-10
+  --------------------------------------
+    - Small fixes
+
+
+  Version 4.21                2005-06-08
+  --------------------------------------
+    - Interfaces for ANSI-C LZMA Decoder (LzmaDecode.c) were changed
+    - New additional version of ANSI-C LZMA Decoder with zlib-like interface:
+        - LzmaStateDecode.h
+        - LzmaStateDecode.c
+        - LzmaStateTest.c
+    - ANSI-C LZMA Decoder now can decompress files larger than 4 GB
+
+  
+  Version 4.17                2005-04-18
+  --------------------------------------
+    - New example for RAM->RAM compressing/decompressing: 
+      LZMA + BCJ (filter for x86 code):
+        - LzmaRam.h
+        - LzmaRam.cpp
+        - LzmaRamDecode.h
+        - LzmaRamDecode.c
+        - -f86 switch for lzma.exe
+
+  
+  Version 4.16                2005-03-29
+  --------------------------------------
+    - Bug was fixed in LzmaDecode.c (ANSI-C LZMA Decoder): 
+       If _LZMA_OUT_READ was defined, and if encoded stream was corrupted,
+       decoder could access memory outside of allocated range.
+    - Speed optimization of ANSI-C LZMA Decoder (now it's about 20% faster).
+      Old version of LZMA Decoder now is in file LzmaDecodeSize.c. 
+      LzmaDecodeSize.c can provide slightly smaller code than LzmaDecode.c
+    - Small speed optimization in LZMA C++ code
+    - filter for SPARC's code was added
+    - Simplified version of .7z ANSI-C Decoder was included
+
+
+  Version 4.06                2004-09-05
+  --------------------------------------
+    - Bug in v4.05 was fixed:
+        LZMA-Encoder didn't release output stream in some cases.
+
+
+  Version 4.05                2004-08-25
+  --------------------------------------
+    - Source code of filters for x86, IA-64, ARM, ARM-Thumb 
+      and PowerPC code was included to SDK
+    - Some internal minor changes
+
+
+  Version 4.04                2004-07-28
+  --------------------------------------
+    - More compatibility with some C++ compilers
+
+
+  Version 4.03                2004-06-18
+  --------------------------------------
+    - "Benchmark" command was added. It measures compressing 
+      and decompressing speed and shows rating values. 
+      Also it checks hardware errors.
+
+
+  Version 4.02                2004-06-10
+  --------------------------------------
+    - C++ LZMA Encoder/Decoder code now is more portable
+      and it can be compiled by GCC on Linux.
+
+
+  Version 4.01                2004-02-15
+  --------------------------------------
+    - Some detection of data corruption was enabled.
+        LzmaDecode.c / RangeDecoderReadByte
+        .....
+        {
+          rd->ExtraBytes = 1;
+          return 0xFF;
+        }
+
+
+  Version 4.00                2004-02-13
+  --------------------------------------
+    - Original version of LZMA SDK
+
+
+
+HISTORY of the LZMA
+-------------------
+  2001-2004:  Improvements to LZMA compressing/decompressing code, 
+              keeping compatibility with original LZMA format
+  1996-2001:  Development of LZMA compression format
+
+  Some milestones:
+
+  2001-08-30: LZMA compression was added to 7-Zip
+  1999-01-02: First version of 7-Zip was released
+  
+
+End of document
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/LGPL.txt squashfs-tools-patched/LZMA/lzmadaptive/LGPL.txt
--- squashfs-tools/LZMA/lzmadaptive/LGPL.txt	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/LGPL.txt	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,504 @@
+      GNU LESSER GENERAL PUBLIC LICENSE
+           Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+          Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+      GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+          NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+         END OF TERMS AND CONDITIONS
+
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/lzma.txt squashfs-tools-patched/LZMA/lzmadaptive/lzma.txt
--- squashfs-tools/LZMA/lzmadaptive/lzma.txt	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/lzma.txt	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,637 @@
+LZMA SDK 4.32
+-------------
+
+LZMA SDK 4.32  Copyright (C) 1999-2005 Igor Pavlov
+
+LZMA SDK provides the documentation, samples, header files, libraries, 
+and tools you need to develop applications that use LZMA compression.
+
+LZMA is default and general compression method of 7z format
+in 7-Zip compression program (www.7-zip.org). LZMA provides high 
+compression ratio and very fast decompression.
+
+LZMA is an improved version of famous LZ77 compression algorithm. 
+It was improved in way of maximum increasing of compression ratio,
+keeping high decompression speed and low memory requirements for 
+decompressing.
+
+
+
+LICENSE
+-------
+
+LZMA SDK is available under any of the following licenses:
+
+1) GNU Lesser General Public License (GNU LGPL)
+2) Common Public License (CPL)
+3) Simplified license for unmodified code (read SPECIAL EXCEPTION) 
+4) Proprietary license 
+
+It means that you can select one of these four options and follow rules of that license.
+
+
+1,2) GNU LGPL and CPL licenses are pretty similar and both these
+licenses are classified as 
+ - "Free software licenses" at http://www.gnu.org/ 
+ - "OSI-approved" at http://www.opensource.org/
+
+
+3) SPECIAL EXCEPTION
+
+Igor Pavlov, as the author of this code, expressly permits you 
+to statically or dynamically link your code (or bind by name) 
+to the files from LZMA SDK without subjecting your linked 
+code to the terms of the CPL or GNU LGPL. 
+Any modifications or additions to files from LZMA SDK, however, 
+are subject to the GNU LGPL or CPL terms.
+
+SPECIAL EXCEPTION allows you to use LZMA SDK in applications with closed code, 
+while you keep LZMA SDK code unmodified.
+
+
+SPECIAL EXCEPTION #2: Igor Pavlov, as the author of this code, expressly permits 
+you to use this code under the same terms and conditions contained in the License 
+Agreement you have for any previous version of LZMA SDK developed by Igor Pavlov.
+
+SPECIAL EXCEPTION #2 allows owners of proprietary licenses to use latest version 
+of LZMA SDK as update for previous versions.
+
+
+SPECIAL EXCEPTION #3: Igor Pavlov, as the author of this code, expressly permits 
+you to use code of examples (LzmaTest.c, LzmaStateTest.c, LzmaAlone.cpp, 
+LzmaAlone.cs, LzmaAlone.java) as public domain code. 
+
+
+4) Proprietary license
+
+LZMA SDK also can be available under a proprietary license which 
+can include:
+
+1) Right to modify code without subjecting modified code to the 
+terms of the CPL or GNU LGPL
+2) Technical support for code
+
+To request such proprietary license or any additional consultations,
+send email message from that page:
+http://www.7-zip.org/support.html
+
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+You should have received a copy of the Common Public License
+along with this library.
+
+
+LZMA SDK Contents
+-----------------
+
+LZMA SDK includes:
+
+  - C++ source code of LZMA compressing and decompressing
+  - ANSI-C compatible source code for LZMA decompressing
+  - C# source code for LZMA compressing and decompressing
+  - Java source code for LZMA compressing and decompressing
+  - Compiled file->file LZMA compressing/decompressing program for Windows system
+
+ANSI-C LZMA decompression code was ported from original C++ sources to C.
+Also it was simplified and optimized for code size. 
+But it is fully compatible with LZMA from 7-Zip.
+
+
+UNIX/Linux version 
+------------------
+To compile C++ version of file->file LZMA, go to directory
+C/7zip/Compress/LZMA_Alone 
+and type "make" or "make clean all" to recompile all.
+
+In some UNIX/Linux versions you must compile LZMA with static libraries.
+To compile with static libraries, change string in makefile
+LIB = -lm
+to string  
+LIB = -lm -static
+
+
+Files
+---------------------
+C        - C / CPP source code
+CS       - C# source code
+Java     - Java source code
+lzma.txt - LZMA SDK description (this file)
+7zFormat.txt - 7z Format description
+7zC.txt  - 7z ANSI-C Decoder description (this file)
+methods.txt  - Compression method IDs for .7z
+LGPL.txt - GNU Lesser General Public License
+CPL.html - Common Public License
+lzma.exe - Compiled file->file LZMA encoder/decoder for Windows
+history.txt - history of the LZMA SDK
+
+
+Source code structure
+---------------------
+
+C  - C / CPP files
+  Common  - common files for C++ projects
+  Windows - common files for Windows related code
+  7zip    - files related to 7-Zip Project
+    Common   - common files for 7-Zip
+    Compress - files related to compression/decompression
+      LZ     - files related to LZ (Lempel-Ziv) compression algorithm
+        BinTree    - Binary Tree Match Finder for LZ algorithm
+        HashChain  - Hash Chain Match Finder for LZ algorithm
+        Patricia   - Patricia Match Finder for LZ algorithm
+      RangeCoder   - Range Coder (special code of compression/decompression)
+      LZMA         - LZMA compression/decompression on C++
+      LZMA_Alone   - file->file LZMA compression/decompression
+      LZMA_C       - ANSI-C compatible LZMA decompressor
+        LzmaDecode.h  - interface for LZMA decoding on ANSI-C
+        LzmaDecode.c      - LZMA decoding on ANSI-C (new fastest version)
+        LzmaDecodeSize.c  - LZMA decoding on ANSI-C (old size-optimized version)
+        LzmaTest.c        - test application that decodes LZMA encoded file
+        LzmaStateDecode.h - interface for LZMA decoding (State version)
+        LzmaStateDecode.c - LZMA decoding on ANSI-C (State version)
+        LzmaStateTest.c   - test application (State version)
+      Branch       - Filters for x86, IA-64, ARM, ARM-Thumb, PowerPC and SPARC code
+    Archive - files related to archiving
+      7z_C     - 7z ANSI-C Decoder
+
+CS - C# files
+  7zip
+    Common   - some common files for 7-Zip
+    Compress - files related to compression/decompression
+      LZ     - files related to LZ (Lempel-Ziv) compression algorithm
+      LZMA         - LZMA compression/decompression
+      LzmaAlone    - file->file LZMA compression/decompression
+      RangeCoder   - Range Coder (special code of compression/decompression)
+
+Java  - Java files
+  SevenZip
+    Compression    - files related to compression/decompression
+      LZ           - files related to LZ (Lempel-Ziv) compression algorithm
+      LZMA         - LZMA compression/decompression
+      RangeCoder   - Range Coder (special code of compression/decompression)
+
+C/C++ source code of LZMA SDK is part of 7-Zip project.
+
+You can find ANSI-C LZMA decompressing code at folder 
+  C/7zip/Compress/LZMA_C
+7-Zip doesn't use that ANSI-C LZMA code and that code was developed 
+specially for this SDK. And files from LZMA_C do not need files from 
+other directories of SDK for compiling.
+
+7-Zip source code can be downloaded from 7-Zip's SourceForge page:
+
+  http://sourceforge.net/projects/sevenzip/
+
+
+LZMA Decompression features
+---------------------------
+  - Variable dictionary size (up to 256 MB)
+  - Estimated compressing speed: about 500 KB/s on 1 GHz CPU
+  - Estimated decompressing speed: 
+      - 8-12 MB/s on 1 GHz Intel Pentium 3 or AMD Athlon
+      - 500-1000 KB/s on 100 MHz ARM, MIPS, PowerPC or other simple RISC
+  - Small memory requirements for decompressing (8-32 KB + DictionarySize)
+  - Small code size for decompressing: 2-8 KB (depending from 
+    speed optimizations) 
+
+LZMA decoder uses only integer operations and can be 
+implemented in any modern 32-bit CPU (or on 16-bit CPU with some conditions).
+
+Some critical operations that affect to speed of LZMA decompression:
+  1) 32*16 bit integer multiply
+  2) Misspredicted branches (penalty mostly depends from pipeline length)
+  3) 32-bit shift and arithmetic operations
+
+Speed of LZMA decompressing mostly depends from CPU speed.
+Memory speed has no big meaning. But if your CPU has small data cache, 
+overall weight of memory speed will slightly increase.
+
+
+How To Use
+----------
+
+Using LZMA encoder/decoder executable
+--------------------------------------
+
+Usage:  LZMA <e|d> inputFile outputFile [<switches>...]
+
+  e: encode file
+
+  d: decode file
+
+  b: Benchmark. There are two tests: compressing and decompressing 
+     with LZMA method. Benchmark shows rating in MIPS (million 
+     instructions per second). Rating value is calculated from 
+     measured speed and it is normalized with AMD Athlon XP CPU
+     results. Also Benchmark checks possible hardware errors (RAM 
+     errors in most cases). Benchmark uses these settings:
+     (-a1, -d21, -fb32, -mfbt4). You can change only -d. Also you 
+     can change number of iterations. Example for 30 iterations:
+	LZMA b 30
+     Default number of iterations is 10.
+
+<Switches>
+  
+
+  -a{N}:  set compression mode 0 = fast, 1 = normal, 2 = max
+          default: 2 (max)
+
+  d{N}:   Sets Dictionary size - [0, 28], default: 23 (8MB)
+          The maximum value for dictionary size is 256 MB = 2^28 bytes.
+          Dictionary size is calculated as DictionarySize = 2^N bytes. 
+          For decompressing file compressed by LZMA method with dictionary 
+          size D = 2^N you need about D bytes of memory (RAM).
+
+  -fb{N}: set number of fast bytes - [5, 273], default: 128
+          Usually big number gives a little bit better compression ratio 
+          and slower compression process.
+
+  -lc{N}: set number of literal context bits - [0, 8], default: 3
+          Sometimes lc=4 gives gain for big files.
+
+  -lp{N}: set number of literal pos bits - [0, 4], default: 0
+          lp switch is intended for periodical data when period is 
+          equal 2^N. For example, for 32-bit (4 bytes) 
+          periodical data you can use lp=2. Often it's better to set lc0, 
+          if you change lp switch.
+
+  -pb{N}: set number of pos bits - [0, 4], default: 2
+          pb switch is intended for periodical data 
+          when period is equal 2^N.
+
+  -mf{MF_ID}: set Match Finder. Default: bt4. 
+              Compression ratio for all bt* and pat* almost the same.
+              Algorithms from hc* group doesn't provide good compression 
+              ratio, but they often works pretty fast in combination with 
+              fast mode (-a0). Methods from bt* group require less memory 
+              than methods from pat* group. Usually bt4 works faster than 
+              any pat*, but for some types of files pat* can work faster. 
+
+              Memory requirements depend from dictionary size 
+              (parameter "d" in table below). 
+
+               MF_ID     Memory                   Description
+
+                bt2    d*9.5 +  1MB  Binary Tree with 2 bytes hashing.
+                bt3    d*9.5 + 65MB  Binary Tree with 2-3(full) bytes hashing.
+                bt4    d*9.5 +  6MB  Binary Tree with 2-3-4 bytes hashing.
+                bt4b   d*9.5 + 34MB  Binary Tree with 2-3-4(big) bytes hashing.
+                pat2r  d*26  +  1MB  Patricia Tree with 2-bits nodes, removing.
+                pat2   d*38  +  1MB  Patricia Tree with 2-bits nodes.
+                pat2h  d*38  + 77MB  Patricia Tree with 2-bits nodes, 2-3 bytes hashing.
+                pat3h  d*62  + 85MB  Patricia Tree with 3-bits nodes, 2-3 bytes hashing.
+                pat4h  d*110 +101MB  Patricia Tree with 4-bits nodes, 2-3 bytes hashing.
+                hc3    d*5.5 +  1MB  Hash Chain with 2-3 bytes hashing.
+                hc4    d*5.5 +  6MB  Hash Chain with 2-3-4 bytes hashing.
+
+  -eos:   write End Of Stream marker. By default LZMA doesn't write 
+          eos marker, since LZMA decoder knows uncompressed size 
+          stored in .lzma file header.
+
+  -si:    Read data from stdin (it will write End Of Stream marker).
+  -so:    Write data to stdout
+
+
+Examples:
+
+1) LZMA e file.bin file.lzma -d16 -lc0 
+
+compresses file.bin to file.lzma with 64 KB dictionary (2^16=64K)  
+and 0 literal context bits. -lc0 allows to reduce memory requirements 
+for decompression.
+
+
+2) LZMA e file.bin file.lzma -lc0 -lp2
+
+compresses file.bin to file.lzma with settings suitable 
+for 32-bit periodical data (for example, ARM or MIPS code).
+
+3) LZMA d file.lzma file.bin
+
+decompresses file.lzma to file.bin.
+
+
+Compression ratio hints
+-----------------------
+
+Recommendations
+---------------
+
+To increase compression ratio for LZMA compressing it's desirable 
+to have aligned data (if it's possible) and also it's desirable to locate
+data in such order, where code is grouped in one place and data is 
+grouped in other place (it's better than such mixing: code, data, code,
+data, ...).
+
+
+Using Filters
+-------------
+You can increase compression ratio for some data types, using
+special filters before compressing. For example, it's possible to 
+increase compression ratio on 5-10% for code for those CPU ISAs: 
+x86, IA-64, ARM, ARM-Thumb, PowerPC, SPARC.
+
+You can find C/C++ source code of such filters in folder "7zip/Compress/Branch"
+
+You can check compression ratio gain of these filters with such 
+7-Zip commands (example for ARM code):
+No filter:
+  7z a a1.7z a.bin -m0=lzma
+
+With filter for little-endian ARM code:
+  7z a a2.7z a.bin -m0=bc_arm -m1=lzma        
+
+With filter for big-endian ARM code (using additional Swap4 filter):
+  7z a a3.7z a.bin -m0=swap4 -m1=bc_arm -m2=lzma
+
+It works in such manner:
+Compressing    = Filter_encoding + LZMA_encoding
+Decompressing  = LZMA_decoding + Filter_decoding
+
+Compressing and decompressing speed of such filters is very high,
+so it will not increase decompressing time too much.
+Moreover, it reduces decompression time for LZMA_decoding, 
+since compression ratio with filtering is higher.
+
+These filters convert CALL (calling procedure) instructions 
+from relative offsets to absolute addresses, so such data becomes more 
+compressible. Source code of these CALL filters is pretty simple
+(about 20 lines of C++), so you can convert it from C++ version yourself.
+
+For some ISAs (for example, for MIPS) it's impossible to get gain from such filter.
+
+
+LZMA compressed file format
+---------------------------
+Offset Size Description
+  0     1   Special LZMA properties for compressed data
+  1     4   Dictionary size (little endian)
+  5     8   Uncompressed size (little endian). -1 means unknown size
+ 13         Compressed data
+
+
+ANSI-C LZMA Decoder
+~~~~~~~~~~~~~~~~~~~
+
+To compile ANSI-C LZMA Decoder you can use one of the following files sets:
+1) LzmaDecode.h + LzmaDecode.c + LzmaTest.c  (fastest version)
+2) LzmaDecode.h + LzmaDecodeSize.c + LzmaTest.c  (old size-optimized version)
+3) LzmaStateDecode.h + LzmaStateDecode.c + LzmaStateTest.c  (zlib-like interface)
+
+
+Memory requirements for LZMA decoding
+-------------------------------------
+
+LZMA decoder doesn't allocate memory itself, so you must 
+allocate memory and send it to LZMA.
+
+Stack usage of LZMA decoding function for local variables is not 
+larger than 200 bytes.
+
+How To decompress data
+----------------------
+
+LZMA Decoder (ANSI-C version) now supports 5 interfaces:
+1) Single-call Decompressing
+2) Single-call Decompressing with input stream callback
+3) Multi-call Decompressing with output buffer
+4) Multi-call Decompressing with input callback and output buffer
+5) Multi-call State Decompressing (zlib-like interface)
+
+Variant-5 is similar to Variant-4, but Variant-5 doesn't use callback functions.
+
+Decompressing steps
+-------------------
+
+1) read LZMA properties (5 bytes):
+   unsigned char properties[LZMA_PROPERTIES_SIZE];
+
+2) read uncompressed size (8 bytes, little-endian)
+
+3) Decode properties:
+
+  CLzmaDecoderState state;  /* it's 24-140 bytes structure, if int is 32-bit */
+
+  if (LzmaDecodeProperties(&state.Properties, properties, LZMA_PROPERTIES_SIZE) != LZMA_RESULT_OK)
+    return PrintError(rs, "Incorrect stream properties");
+
+4) Allocate memory block for internal Structures:
+
+  state.Probs = (CProb *)malloc(LzmaGetNumProbs(&state.Properties) * sizeof(CProb));
+  if (state.Probs == 0)
+    return PrintError(rs, kCantAllocateMessage);
+
+  LZMA decoder uses array of CProb variables as internal structure.
+  By default, CProb is unsigned_short. But you can define _LZMA_PROB32 to make 
+  it unsigned_int. It can increase speed on some 32-bit CPUs, but memory 
+  usage will be doubled in that case.
+
+
+5) Main Decompressing
+
+You must use one of the following interfaces:
+
+5.1 Single-call Decompressing
+-----------------------------
+When to use: RAM->RAM decompressing
+Compile files: LzmaDecode.h, LzmaDecode.c
+Compile defines: no defines
+Memory Requirements:
+  - Input buffer: compressed size
+  - Output buffer: uncompressed size
+  - LZMA Internal Structures (~16 KB for default settings) 
+
+Interface:
+  int res = LzmaDecode(&state, 
+      inStream, compressedSize, &inProcessed,
+      outStream, outSize, &outProcessed);
+
+
+5.2 Single-call Decompressing with input stream callback
+--------------------------------------------------------
+When to use: File->RAM or Flash->RAM decompressing.
+Compile files: LzmaDecode.h, LzmaDecode.c
+Compile defines: _LZMA_IN_CB
+Memory Requirements:
+  - Buffer for input stream: any size (for example, 16 KB)
+  - Output buffer: uncompressed size
+  - LZMA Internal Structures (~16 KB for default settings) 
+
+Interface:
+  typedef struct _CBuffer
+  {
+    ILzmaInCallback InCallback;
+    FILE *File;
+    unsigned char Buffer[kInBufferSize];
+  } CBuffer;
+
+  int LzmaReadCompressed(void *object, const unsigned char **buffer, SizeT *size)
+  {
+    CBuffer *bo = (CBuffer *)object;
+    *buffer = bo->Buffer;
+    *size = MyReadFile(bo->File, bo->Buffer, kInBufferSize);
+    return LZMA_RESULT_OK;
+  }
+
+  CBuffer g_InBuffer;
+
+  g_InBuffer.File = inFile;
+  g_InBuffer.InCallback.Read = LzmaReadCompressed;
+  int res = LzmaDecode(&state, 
+      &g_InBuffer.InCallback,
+      outStream, outSize, &outProcessed);
+
+
+5.3 Multi-call decompressing with output buffer
+-----------------------------------------------
+When to use: RAM->File decompressing 
+Compile files: LzmaDecode.h, LzmaDecode.c
+Compile defines: _LZMA_OUT_READ
+Memory Requirements:
+ - Input buffer: compressed size
+ - Buffer for output stream: any size (for example, 16 KB)
+ - LZMA Internal Structures (~16 KB for default settings) 
+ - LZMA dictionary (dictionary size is encoded in stream properties)
+ 
+Interface:
+
+  state.Dictionary = (unsigned char *)malloc(state.Properties.DictionarySize);
+
+  LzmaDecoderInit(&state);
+  do
+  {
+    LzmaDecode(&state,
+      inBuffer, inAvail, &inProcessed,
+      g_OutBuffer, outAvail, &outProcessed);
+    inAvail -= inProcessed;
+    inBuffer += inProcessed;
+  }
+  while you need more bytes
+
+  see LzmaTest.c for more details.
+
+
+5.4 Multi-call decompressing with input callback and output buffer
+------------------------------------------------------------------
+When to use: File->File decompressing 
+Compile files: LzmaDecode.h, LzmaDecode.c
+Compile defines: _LZMA_IN_CB, _LZMA_OUT_READ
+Memory Requirements:
+ - Buffer for input stream: any size (for example, 16 KB)
+ - Buffer for output stream: any size (for example, 16 KB)
+ - LZMA Internal Structures (~16 KB for default settings) 
+ - LZMA dictionary (dictionary size is encoded in stream properties)
+ 
+Interface:
+
+  state.Dictionary = (unsigned char *)malloc(state.Properties.DictionarySize);
+ 
+  LzmaDecoderInit(&state);
+  do
+  {
+    LzmaDecode(&state,
+      &bo.InCallback,
+      g_OutBuffer, outAvail, &outProcessed);
+  }
+  while you need more bytes
+
+  see LzmaTest.c for more details:
+
+
+5.5 Multi-call State Decompressing (zlib-like interface)
+------------------------------------------------------------------
+When to use: file->file decompressing 
+Compile files: LzmaStateDecode.h, LzmaStateDecode.c
+Compile defines:
+Memory Requirements:
+ - Buffer for input stream: any size (for example, 16 KB)
+ - Buffer for output stream: any size (for example, 16 KB)
+ - LZMA Internal Structures (~16 KB for default settings) 
+ - LZMA dictionary (dictionary size is encoded in stream properties)
+ 
+Interface:
+
+  state.Dictionary = (unsigned char *)malloc(state.Properties.DictionarySize);
+
+  
+  LzmaDecoderInit(&state);
+  do
+  {
+    res = LzmaDecode(&state,
+      inBuffer, inAvail, &inProcessed,
+      g_OutBuffer, outAvail, &outProcessed,
+      finishDecoding);
+    inAvail -= inProcessed;
+    inBuffer += inProcessed;
+  }
+  while you need more bytes
+
+  see LzmaStateTest.c for more details:
+
+
+6) Free all allocated blocks
+
+
+Note
+----
+LzmaDecodeSize.c is size-optimized version of LzmaDecode.c.
+But compiled code of LzmaDecodeSize.c can be larger than 
+compiled code of LzmaDecode.c. So it's better to use 
+LzmaDecode.c in most cases.
+
+
+EXIT codes
+-----------
+
+LZMA decoder can return one of the following codes:
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+If you use callback function for input data and you return some 
+error code, LZMA Decoder also returns that code.
+
+
+
+LZMA Defines
+------------
+
+_LZMA_IN_CB    - Use callback for input data
+
+_LZMA_OUT_READ - Use read function for output data
+
+_LZMA_LOC_OPT  - Enable local speed optimizations inside code.
+                 _LZMA_LOC_OPT is only for LzmaDecodeSize.c (size-optimized version).
+                 _LZMA_LOC_OPT doesn't affect LzmaDecode.c (speed-optimized version)
+                 and LzmaStateDecode.c
+
+_LZMA_PROB32   - It can increase speed on some 32-bit CPUs, 
+                 but memory usage will be doubled in that case
+
+_LZMA_UINT32_IS_ULONG  - Define it if int is 16-bit on your compiler
+                         and long is 32-bit.
+
+_LZMA_SYSTEM_SIZE_T  - Define it if you want to use system's size_t.
+                       You can use it to enable 64-bit sizes supporting
+
+
+
+C++ LZMA Encoder/Decoder 
+~~~~~~~~~~~~~~~~~~~~~~~~
+C++ LZMA code use COM-like interfaces. So if you want to use it, 
+you can study basics of COM/OLE.
+
+By default, LZMA Encoder contains all Match Finders.
+But for compressing it's enough to have just one of them.
+So for reducing size of compressing code you can define:
+  #define COMPRESS_MF_BT
+  #define COMPRESS_MF_BT4
+and it will use only bt4 match finder.
+
+
+---
+
+http://www.7-zip.org
+http://www.7-zip.org/support.html
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmadaptive/Methods.txt squashfs-tools-patched/LZMA/lzmadaptive/Methods.txt
--- squashfs-tools/LZMA/lzmadaptive/Methods.txt	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmadaptive/Methods.txt	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,114 @@
+Compression method IDs (4.27)
+-----------------------------
+
+Each compression method in 7z has unique binary value (ID).
+The length of ID in bytes is arbitrary but it can not exceed 15 bytes.
+
+List of defined IDs
+-------------------
+      
+00 - Copy
+01 - Reserved
+02 - Common
+   03 Swap
+      - 2 Swap2
+      - 4 Swap4
+   04 Delta (subject to change)
+
+03 - 7z
+   01 - LZMA
+      01 - Version
+  
+   03 - Branch
+      01 - x86
+         03  - BCJ
+         1B  - BCJ2
+      02 - PPC
+         05 - BC_PPC_B (Big Endian)
+      03 - Alpha
+         01 - BC_Alpha
+      04 - IA64
+         01 - BC_IA64
+      05 - ARM
+         01 - BC_ARM
+      06 - M68
+         05 - BC_M68_B (Big Endian)
+      07 - ARM Thumb
+         01 - BC_ARMThumb
+      08 - SPARC
+         05 - BC_SPARC
+
+   04 - PPMD
+      01 - Version
+
+04 - Misc
+   00 - Reserved
+   01 - Zip
+      00 - Copy (not used). Use {00} instead
+      01 - Shrink
+      06 - Implode
+      08 - Deflate
+      09 - Deflate64
+      12 - BZip2 (not used). Use {04 02 02} instead
+   02 - BZip
+      02 - BZip2
+   03 - Rar
+      01 - Rar15
+      02 - Rar20
+      03 - Rar29
+   04 - Arj
+      01 - Arj (1,2,3)
+      02 - Arj 4
+   05 - Z
+   06 - Lzh
+   07 - Reserved for 7z
+   08 - Cab
+
+
+06 - Crypto 
+   00 - 
+   01 - AES
+      0x - AES-128
+      4x - AES-192
+      8x - AES-256
+
+      x0 - ECB
+      x1 - CBC
+      x2 - CFB
+      x3 - OFB
+
+   07 - Reserved
+   0F - Reserved
+
+   F0 - Misc Ciphers (Real Ciphers without hashing algo)
+
+   F1 - Misc Ciphers (Combine)
+      01 - Zip
+         01 - Main Zip crypto algo
+      03 - RAR
+         02 - 
+         03 - Rar29 AES-128 + (modified SHA-1)
+      07 - 7z
+         01 - AES-256 + SHA-256
+
+07 - Hash (subject to change)
+   00 - 
+   01 - CRC
+   02 - SHA-1
+   03 - SHA-256
+   04 - SHA-384
+   05 - SHA-512
+
+   F0 - Misc Hash
+
+   F1 - Misc
+      03 - RAR
+         03 - Rar29 Password Hashing (modified SHA1)
+      07 - 7z 
+         01 - SHA-256 Password Hashing
+    
+   
+
+
+---
+End of document
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmalt/7zlzma.c squashfs-tools-patched/LZMA/lzmalt/7zlzma.c
--- squashfs-tools/LZMA/lzmalt/7zlzma.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmalt/7zlzma.c	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,58 @@
+#include "lzmalt.h"
+
+#include "stdio.h"
+#include "string.h"
+#include "stdlib.h"
+
+#include "LZMADecoder.h"
+
+
+static LzmaDecoder   cc;
+ISequentialInStream  in_stream;
+ISequentialOutStream out_stream;
+int decompress_lzma_alt( unsigned char* in_data, 
+                          unsigned in_size, 
+                          unsigned char* out_data, 
+                          unsigned out_size,
+                          int offset) {
+//		LzmaDecoder cc;
+        int RC;
+	UINT64 in_size_l  = in_size;
+	UINT64 out_size_l = out_size;
+
+
+        InStreamInit(in_data+offset, in_size-offset);
+
+	OutStreamInit((char *)out_data, out_size);
+
+        LzmaDecoderConstructor(&cc);
+
+        if ((RC = LzmaDecoderReadCoderProperties(&cc)) != S_OK)
+        {
+		return RC;
+        }
+
+	if (LzmaDecoderCode(&cc, &in_size_l, &out_size_l) != S_OK)
+        {
+		return -2;
+        }
+
+	if (out_stream.size != out_size)
+        {
+		return -3;
+        }
+
+        if ( out_stream.overflow )
+        {
+            return -4;
+        }
+
+	return 0;
+}
+
+//BRCM modification
+#ifdef __KERNEL__
+EXPORT_SYMBOL(decompress_lzma_7z);
+#endif
+
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmalt/AriBitCoder.h squashfs-tools-patched/LZMA/lzmalt/AriBitCoder.h
--- squashfs-tools/LZMA/lzmalt/AriBitCoder.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmalt/AriBitCoder.h	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,51 @@
+#ifndef __COMPRESSION_BITCODER_H
+#define __COMPRESSION_BITCODER_H
+
+#include "RangeCoder.h"
+
+#define kNumBitModelTotalBits  11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+
+#define kNumMoveReducingBits 2
+
+
+typedef UINT32 CBitDecoder;
+
+INLINE  void BitDecoderInit(CBitDecoder *bitDecoder)
+  { 
+    *bitDecoder = kBitModelTotal / 2; 
+  }
+
+#if 0
+UINT32 BitDecode(ISequentialInStream *in_stream, CBitDecoder *bitDecoder, CRangeDecoder *aRangeDecoder);
+#else
+INLINE  UINT32 BitDecode(ISequentialInStream *in_stream, CBitDecoder *bitDecoder, CRangeDecoder *aRangeDecoder)
+  {
+    UINT32 aNewBound = (aRangeDecoder->m_Range >> kNumBitModelTotalBits) * (*bitDecoder);
+    if (aRangeDecoder->m_Code < aNewBound)
+    {
+      aRangeDecoder->m_Range = aNewBound;
+      *bitDecoder += (kBitModelTotal - *bitDecoder) >> kNumMoveBits;
+      if (aRangeDecoder->m_Range < kTopValue)
+      {
+        aRangeDecoder->m_Code = (aRangeDecoder->m_Code << 8) | InStreamReadByte(in_stream);
+        aRangeDecoder->m_Range <<= 8;
+      }
+      return 0;
+    }
+    else
+    {
+      aRangeDecoder->m_Range -= aNewBound;
+      aRangeDecoder->m_Code -= aNewBound;
+      *bitDecoder -= (*bitDecoder) >> kNumMoveBits;
+      if (aRangeDecoder->m_Range < kTopValue)
+      {
+        aRangeDecoder->m_Code = (aRangeDecoder->m_Code << 8) | InStreamReadByte(in_stream);
+        aRangeDecoder->m_Range <<= 8;
+      }
+      return 1;
+    }
+  }
+#endif
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmalt/BitTreeCoder.h squashfs-tools-patched/LZMA/lzmalt/BitTreeCoder.h
--- squashfs-tools/LZMA/lzmalt/BitTreeCoder.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmalt/BitTreeCoder.h	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,160 @@
+#ifndef __BITTREECODER_H
+#define __BITTREECODER_H
+
+#include "AriBitCoder.h"
+#include "RCDefs.h"
+
+//BRCM modification start
+#ifdef _HOST_TOOL
+#include "stdio.h"
+#include "stdlib.h"
+#include "malloc.h" 
+#endif
+
+#ifdef _CFE_
+#include "lib_malloc.h"
+#include "lib_printf.h"
+#define malloc(x) KMALLOC(x, 0)
+#endif
+
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#define printf printk
+//#define malloc(x) kmalloc(x,GFP_KERNEL)
+#define malloc(x) vmalloc(x)
+#define free(x) vfree(x)
+#endif
+//BRCM modification end
+
+//////////////////////////
+// CBitTreeDecoder
+
+typedef struct CBitTreeDecoder
+{
+  UINT32       m_NumBitLevels;
+  CBitDecoder *m_Models;
+} CBitTreeDecoder;
+
+//  ~CBitTreeDecoder() { free(m_Models); }
+INLINE void BitTreeDecoderInit(CBitTreeDecoder *bitTreeDecoder, UINT32 aNumBitLevels)
+  {
+    int i;
+    bitTreeDecoder->m_NumBitLevels = aNumBitLevels;
+    bitTreeDecoder->m_Models       = (CBitDecoder *)malloc( sizeof(CBitDecoder) * (1 << bitTreeDecoder->m_NumBitLevels));
+    //BRCM modification
+    //printf("malloc in BitTreeDecoderInit=%d\n",sizeof(CBitDecoder) * (1 << bitTreeDecoder->m_NumBitLevels));
+    if (!bitTreeDecoder->m_Models) {
+	    printf("Error in allocating memory for bitTreeDecoder!\n");
+	    return;
+    }	    
+    for(i = 1; i < (1 << aNumBitLevels); i++)
+      BitDecoderInit(&bitTreeDecoder->m_Models[i]);
+  }
+INLINE UINT32 BitTreeDecode(ISequentialInStream *in_stream, CBitTreeDecoder *bitTreeDecoder, CRangeDecoder *aRangeDecoder)
+  {
+    UINT32 aModelIndex = 1;
+    UINT32 aRange = aRangeDecoder->m_Range;
+    UINT32 aCode = aRangeDecoder->m_Code;
+    UINT32 aBitIndex;
+    for(aBitIndex = bitTreeDecoder->m_NumBitLevels; aBitIndex > 0; aBitIndex--)
+    {
+      RC_GETBIT(kNumMoveBits, bitTreeDecoder->m_Models[aModelIndex], aModelIndex)
+    }
+    aRangeDecoder->m_Range = aRange;
+    aRangeDecoder->m_Code = aCode;
+    return aModelIndex - (1 << bitTreeDecoder->m_NumBitLevels);
+  }
+
+
+////////////////////////////////
+// CReverseBitTreeDecoder2
+
+typedef struct CReverseBitTreeDecoder2
+{
+  UINT32       m_NumBitLevels;
+  CBitDecoder *m_Models;
+} CReverseBitTreeDecoder2;
+
+//  CReverseBitTreeDecoder2(): m_Models(0) { }
+//  ~CReverseBitTreeDecoder2() { free(m_Models); }
+INLINE BOOL ReverseBitTreeDecoder2Create(CReverseBitTreeDecoder2 *reverseBitTreeDecoder2, UINT32 aNumBitLevels)
+  {
+    reverseBitTreeDecoder2->m_NumBitLevels = aNumBitLevels;
+    reverseBitTreeDecoder2->m_Models       = (CBitDecoder *)malloc( sizeof(CBitDecoder) * (1 << reverseBitTreeDecoder2->m_NumBitLevels));
+    //printf("malloc in ReverseBitTreeDecoder2Create=%d\n",sizeof(CBitDecoder) * (1 << reverseBitTreeDecoder2->m_NumBitLevels));
+    if (!reverseBitTreeDecoder2->m_Models) {
+	    printf("Error in allocating memory for reverseBitTreeDecoder2!\n");
+	    return 0;
+    }	    
+    return (reverseBitTreeDecoder2->m_Models != 0);
+  }
+INLINE void ReverseBitTreeDecoder2Init(CReverseBitTreeDecoder2 *reverseBitTreeDecoder2)
+  {
+    UINT32 aNumModels = 1 << reverseBitTreeDecoder2->m_NumBitLevels;
+    UINT32 i;
+    for(i = 1; i < aNumModels; i++)
+      BitDecoderInit(&reverseBitTreeDecoder2->m_Models[i]);
+  }
+INLINE UINT32 ReverseBitTreeDecoder2Decode(ISequentialInStream *in_stream, CReverseBitTreeDecoder2 *reverseBitTreeDecoder2, CRangeDecoder *aRangeDecoder)
+  {
+    UINT32 aModelIndex = 1;
+    UINT32 aSymbol = 0;
+    UINT32 aRange = aRangeDecoder->m_Range;
+    UINT32 aCode = aRangeDecoder->m_Code;
+    UINT32 aBitIndex;
+    for(aBitIndex = 0; aBitIndex < reverseBitTreeDecoder2->m_NumBitLevels; aBitIndex++)
+    {
+      RC_GETBIT2(kNumMoveBits, reverseBitTreeDecoder2->m_Models[aModelIndex], aModelIndex, ; , aSymbol |= (1 << aBitIndex))
+    }
+    aRangeDecoder->m_Range = aRange;
+    aRangeDecoder->m_Code = aCode;
+    return aSymbol;
+  }
+
+
+////////////////////////////
+// CReverseBitTreeDecoder
+
+typedef struct CReverseBitTreeDecoder
+{
+  UINT32        m_NumBitLevels;
+  CBitDecoder  *m_Models;
+} CReverseBitTreeDecoder;
+
+//    CReverseBitTreeDecoder(): m_Models(0) { }
+//    ~CReverseBitTreeDecoder() { free(m_Models); }
+INLINE void ReverseBitTreeDecoderInit(CReverseBitTreeDecoder *reverseBitTreeDecoder, UINT32 aNumBitLevels)
+  {
+    int i;
+    reverseBitTreeDecoder->m_NumBitLevels = aNumBitLevels;
+    reverseBitTreeDecoder->m_Models       = (CBitDecoder *)malloc( sizeof(CBitDecoder) * (1 << reverseBitTreeDecoder->m_NumBitLevels));
+    //printf("malloc in ReverseBitTreeDecoderInit=%d\n",sizeof(CBitDecoder) * (1 << reverseBitTreeDecoder->m_NumBitLevels));
+    if (!reverseBitTreeDecoder->m_Models) {
+	    printf("Error in allocating memory for reverseBitTreeDecoder!\n");
+	    return;
+    }	    
+    for(i = 1; i < (1 << reverseBitTreeDecoder->m_NumBitLevels); i++)
+      BitDecoderInit(&reverseBitTreeDecoder->m_Models[i]);
+  }
+
+INLINE UINT32 ReverseBitTreeDecoderDecode(ISequentialInStream *in_stream, CReverseBitTreeDecoder *reverseBitTreeDecoder, CRangeDecoder *aRangeDecoder)
+  {
+    UINT32 aModelIndex = 1;
+    UINT32 aSymbol = 0;
+    UINT32 aRange = aRangeDecoder->m_Range;
+    UINT32 aCode = aRangeDecoder->m_Code;
+    UINT32 aBitIndex;
+    for(aBitIndex = 0; aBitIndex < reverseBitTreeDecoder->m_NumBitLevels; aBitIndex++)
+    {
+      RC_GETBIT2(kNumMoveBits, reverseBitTreeDecoder->m_Models[aModelIndex], aModelIndex, ; , aSymbol |= (1 << aBitIndex))
+    }
+    aRangeDecoder->m_Range = aRange;
+    aRangeDecoder->m_Code = aCode;
+    return aSymbol;
+  }
+
+
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmalt/IInOutStreams.c squashfs-tools-patched/LZMA/lzmalt/IInOutStreams.c
--- squashfs-tools/LZMA/lzmalt/IInOutStreams.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmalt/IInOutStreams.c	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,39 @@
+#include "stdlib.h"
+#include "IInOutStreams.h"
+// BRCM modification 
+static void *lib_memcpy(void *dest,const void *src,size_t cnt);
+static void *lib_memcpy(void *dest,const void *src,size_t cnt)
+{
+    unsigned char *d;
+    const unsigned char *s;
+
+    d = (unsigned char *) dest;
+    s = (const unsigned char *) src;
+
+    while (cnt) {
+	*d++ = *s++;
+	cnt--;
+	}
+
+    return dest;
+}
+
+HRESULT InStreamRead(void *aData, UINT32 aSize, UINT32* aProcessedSize) {
+    	if (aSize > in_stream.remainingBytes)
+    		aSize = in_stream.remainingBytes;
+    	*aProcessedSize = aSize;
+    	lib_memcpy(aData, in_stream.data, aSize); // brcm modification
+    	in_stream.remainingBytes -= aSize;
+    	in_stream.data += aSize;
+    	return S_OK;
+    }
+
+#if 0
+BYTE InStreamReadByte()
+    {
+        if (in_stream.remainingBytes == 0)
+            return 0x0;
+        in_stream.remainingBytes--;
+        return (BYTE) *in_stream.data++;
+    }
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmalt/IInOutStreams.h squashfs-tools-patched/LZMA/lzmalt/IInOutStreams.h
--- squashfs-tools/LZMA/lzmalt/IInOutStreams.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmalt/IInOutStreams.h	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,62 @@
+#ifndef __IINOUTSTREAMS_H
+#define __IINOUTSTREAMS_H
+
+#include "Portable.h"
+
+typedef struct ISequentialInStream
+{
+	unsigned char* data;
+	unsigned       remainingBytes;
+} ISequentialInStream;
+
+extern ISequentialInStream in_stream;
+
+INLINE void InStreamInit(unsigned char * Adata, unsigned Asize)
+    {
+        in_stream.data           = Adata;
+        in_stream.remainingBytes = Asize;
+    }
+
+HRESULT InStreamRead(void *aData, UINT32 aSize, UINT32* aProcessedSize);
+
+#if 0
+BYTE InStreamReadByte();
+#else
+INLINE BYTE InStreamReadByte(ISequentialInStream *in_stream)
+    {
+        if (in_stream->remainingBytes == 0)
+            return 0x0;
+        in_stream->remainingBytes--;
+        return (BYTE) *in_stream->data++;
+    }
+#endif
+
+
+
+typedef struct ISequentialOutStream
+{
+	char*       data;
+	unsigned    size;
+	BOOL        overflow;
+	unsigned    total;
+} ISequentialOutStream;
+
+extern ISequentialOutStream out_stream;
+
+#define OutStreamInit(Adata, Asize) \
+{ \
+    out_stream.data = Adata; \
+    out_stream.size = Asize; \
+    out_stream.overflow = FALSE; \
+    out_stream.total = 0; \
+}
+
+#define OutStreamSizeSet(newsize) \
+    { \
+        out_stream.total = newsize; \
+        if (out_stream.total > out_stream.size) \
+            out_stream.overflow = TRUE; \
+    }
+
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmalt/LenCoder.h squashfs-tools-patched/LZMA/lzmalt/LenCoder.h
--- squashfs-tools/LZMA/lzmalt/LenCoder.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmalt/LenCoder.h	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,75 @@
+#ifndef __LENCODER_H
+#define __LENCODER_H
+
+#include "BitTreeCoder.h"
+
+
+#define kNumPosStatesBitsMax 4
+#define kNumPosStatesMax 16
+
+
+#define kNumPosStatesBitsEncodingMax 4
+#define kNumPosStatesEncodingMax 16
+
+
+//#define kNumMoveBits 5
+
+#define kNumLenBits 3
+#define kNumLowSymbols (1 << kNumLenBits)
+
+#define kNumMidBits 3
+#define kNumMidSymbols (1 << kNumMidBits)
+
+#define kNumHighBits 8
+
+#define kNumSymbolsTotal (kNumLowSymbols + kNumMidSymbols + (1 << kNumHighBits))
+
+typedef struct LenDecoder
+{
+  CBitDecoder       m_Choice;
+  CBitDecoder       m_Choice2;
+  CBitTreeDecoder   m_LowCoder[kNumPosStatesMax];
+  CBitTreeDecoder   m_MidCoder[kNumPosStatesMax];
+  CBitTreeDecoder   m_HighCoder; 
+  UINT32            m_NumPosStates;
+} LenDecoder;
+
+INLINE void LenDecoderCreate(LenDecoder *lenCoder, UINT32 aNumPosStates)
+  { 
+    lenCoder->m_NumPosStates = aNumPosStates; 
+  }
+
+INLINE void LenDecoderInit(LenDecoder *lenCoder)
+  {
+    UINT32 aPosState;
+    BitDecoderInit(&lenCoder->m_Choice);
+    for (aPosState = 0; aPosState < lenCoder->m_NumPosStates; aPosState++)
+    {
+      BitTreeDecoderInit(&lenCoder->m_LowCoder[aPosState],kNumLenBits);
+      BitTreeDecoderInit(&lenCoder->m_MidCoder[aPosState],kNumMidBits);
+    }
+    BitTreeDecoderInit(&lenCoder->m_HighCoder,kNumHighBits);
+    BitDecoderInit(&lenCoder->m_Choice2);
+  }
+
+INLINE UINT32 LenDecode(ISequentialInStream *in_stream, LenDecoder *lenCoder, CRangeDecoder *aRangeDecoder, UINT32 aPosState)
+  {
+    if(BitDecode(in_stream, &lenCoder->m_Choice, aRangeDecoder) == 0)
+      return BitTreeDecode(in_stream, &lenCoder->m_LowCoder[aPosState],aRangeDecoder);
+    else
+    {
+      UINT32 aSymbol = kNumLowSymbols;
+      if(BitDecode(in_stream, &lenCoder->m_Choice2, aRangeDecoder) == 0)
+        aSymbol += BitTreeDecode(in_stream, &lenCoder->m_MidCoder[aPosState],aRangeDecoder);
+      else
+      {
+        aSymbol += kNumMidSymbols;
+        aSymbol += BitTreeDecode(in_stream, &lenCoder->m_HighCoder,aRangeDecoder);
+      }
+      return aSymbol;
+    }
+  }
+
+
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmalt/LiteralCoder.h squashfs-tools-patched/LZMA/lzmalt/LiteralCoder.h
--- squashfs-tools/LZMA/lzmalt/LiteralCoder.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmalt/LiteralCoder.h	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,146 @@
+#ifndef __LITERALCODER_H
+#define __LITERALCODER_H
+
+#include "AriBitCoder.h"
+#include "RCDefs.h"
+
+//BRCM modification start
+#ifdef _HOST_TOOL
+#include "stdio.h"
+#include "malloc.h" 
+#endif
+
+#ifdef _CFE_
+#include "lib_malloc.h"
+#include "lib_printf.h"
+#define malloc(x) KMALLOC(x, 0)
+#define free(x) KFREE(x)
+#endif
+
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#define printf  printk
+//#define malloc(x)  kmalloc(x,GFP_KERNEL)
+#define malloc(x)  vmalloc(x)
+#define free(x) vfree(x)
+#endif
+//BRCM modification end
+
+//#define kNumMoveBits 5
+
+typedef struct LitDecoder2
+{
+  CBitDecoder m_Decoders[3][1 << 8];
+} LitDecoder2;
+
+
+INLINE void LitDecoder2Init(LitDecoder2 *litDecoder2)
+  {
+    int i, j;
+    for (i = 0; i < 3; i++)
+      for (j = 1; j < (1 << 8); j++)
+        BitDecoderInit(&litDecoder2->m_Decoders[i][j]);
+  }
+
+INLINE BYTE LitDecoder2DecodeNormal(ISequentialInStream *in_stream, LitDecoder2 *litDecoder2, CRangeDecoder *aRangeDecoder)
+  {
+    UINT32 aSymbol = 1;
+    UINT32 aRange = aRangeDecoder->m_Range;
+    UINT32 aCode = aRangeDecoder->m_Code;        
+    do
+    {
+      RC_GETBIT(kNumMoveBits, litDecoder2->m_Decoders[0][aSymbol], aSymbol)
+    }
+    while (aSymbol < 0x100);
+    aRangeDecoder->m_Range = aRange;
+    aRangeDecoder->m_Code = aCode;
+    return aSymbol;
+  }
+
+INLINE BYTE LitDecoder2DecodeWithMatchByte(ISequentialInStream *in_stream, LitDecoder2 *litDecoder2, CRangeDecoder *aRangeDecoder, BYTE aMatchByte)
+  {
+    UINT32 aSymbol = 1;
+    UINT32 aRange = aRangeDecoder->m_Range;
+    UINT32 aCode = aRangeDecoder->m_Code;        
+    do
+    {
+      UINT32 aBit;
+      UINT32 aMatchBit = (aMatchByte >> 7) & 1;
+      aMatchByte <<= 1;
+      RC_GETBIT2(kNumMoveBits, litDecoder2->m_Decoders[1 + aMatchBit][aSymbol], aSymbol, 
+          aBit = 0, aBit = 1)
+      if (aMatchBit != aBit)
+      {
+        while (aSymbol < 0x100)
+        {
+          RC_GETBIT(kNumMoveBits, litDecoder2->m_Decoders[0][aSymbol], aSymbol)
+        }
+        break;
+      }
+    }
+    while (aSymbol < 0x100);
+    aRangeDecoder->m_Range = aRange;
+    aRangeDecoder->m_Code = aCode;
+    return aSymbol;
+  }
+
+
+typedef struct LitDecoder
+{
+  LitDecoder2 *m_Coders;
+  UINT32 m_NumPrevBits;
+  UINT32 m_NumPosBits;
+  UINT32 m_PosMask;
+} LitDecoder;
+
+
+//  LitDecoder(): m_Coders(0) {}
+//  ~LitDecoder()  { Free(); }
+
+/*
+INLINE void LitDecoderFree(LitDecoder *litDecoder)
+  { 
+    free( (char *) litDecoder->m_Coders );
+    litDecoder->m_Coders = 0;
+  }
+*/
+
+INLINE void LitDecoderCreate(LitDecoder *litDecoder, UINT32 aNumPosBits, UINT32 aNumPrevBits)
+  {
+//    LitDecoderFree(litDecoder);
+    UINT32 aNumStates;
+    litDecoder->m_NumPosBits = aNumPosBits;
+    litDecoder->m_PosMask = (1 << aNumPosBits) - 1;
+    litDecoder->m_NumPrevBits = aNumPrevBits;
+    aNumStates = 1 << (aNumPrevBits + aNumPosBits);
+    litDecoder->m_Coders = (LitDecoder2*) malloc( sizeof( LitDecoder2 ) * aNumStates );
+    //printf("malloc in LitDecoderCreate=%d\n",sizeof( LitDecoder2 ) * aNumStates);
+    if (litDecoder->m_Coders == 0)
+        printf( "Error allocating memory for LitDecoder m_Coders!\n" );
+  }
+
+INLINE void LitDecoderInit(LitDecoder *litDecoder)
+  {
+    UINT32 i;
+    UINT32 aNumStates = 1 << (litDecoder->m_NumPrevBits + litDecoder->m_NumPosBits);
+    for (i = 0; i < aNumStates; i++)
+      LitDecoder2Init(&litDecoder->m_Coders[i]);
+  }
+
+INLINE UINT32 LitDecoderGetState(LitDecoder *litDecoder, UINT32 aPos, BYTE aPrevByte)
+  { 
+    return ((aPos & litDecoder->m_PosMask) << litDecoder->m_NumPrevBits) + (aPrevByte >> (8 - litDecoder->m_NumPrevBits)); 
+  }
+
+INLINE BYTE LitDecodeNormal(ISequentialInStream *in_stream, LitDecoder *litDecoder, CRangeDecoder *aRangeDecoder, UINT32 aPos, BYTE aPrevByte)
+  { 
+    return LitDecoder2DecodeNormal(in_stream, &litDecoder->m_Coders[LitDecoderGetState(litDecoder, aPos, aPrevByte)], aRangeDecoder); 
+  }
+
+INLINE BYTE LitDecodeWithMatchByte(ISequentialInStream *in_stream, LitDecoder *litDecoder, CRangeDecoder *aRangeDecoder, UINT32 aPos, BYTE aPrevByte, BYTE aMatchByte)
+  { 
+      return LitDecoder2DecodeWithMatchByte(in_stream, &litDecoder->m_Coders[LitDecoderGetState(litDecoder, aPos, aPrevByte)], aRangeDecoder, aMatchByte); 
+  }
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmalt/LZMADecoder.c squashfs-tools-patched/LZMA/lzmalt/LZMADecoder.c
--- squashfs-tools/LZMA/lzmalt/LZMADecoder.c	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmalt/LZMADecoder.c	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,417 @@
+#include "Portable.h"
+#include "stdio.h"
+#include "stdlib.h"
+#include "LZMADecoder.h"
+
+
+//#define RETURN_E_OUTOFMEMORY_IF_FALSE(x) { if (!(x)) return E_OUTOFMEMORY; }
+
+
+static UINT32    kDistStart[kDistTableSizeMax];
+struct WindowOut out_window;
+
+/*
+ * BRCM modification: free all the allocated buffer by malloc
+ *
+ */
+static void LzmaDecoderFreeBuffer(LzmaDecoder  *lzmaDecoder)
+{
+  int i,aPosState;
+  
+  //printf("free lzmaDecoder->m_LiteralDecoder\n");
+  free((&lzmaDecoder->m_LiteralDecoder)->m_Coders);
+
+  for (i = 0; i < kNumLenToPosStates; i++) {
+      //printf("free lzmaDecoder->m_PosSlotDecoder\n");
+      free((&lzmaDecoder->m_PosSlotDecoder[i])->m_Models);
+  }
+  // from LenDecoderInit(&lzmaDecoder->m_LenDecoder;
+  for (aPosState = 0; aPosState < (&lzmaDecoder->m_LenDecoder)->m_NumPosStates; aPosState++) {
+      //printf("free lzmaDecoder->m_PosSlotDecoder\n");
+      free( (&(&lzmaDecoder->m_LenDecoder)->m_LowCoder[aPosState])->m_Models );
+      //printf("free lzmaDecoder->m_PosSlotDecoder\n");
+      free( (&(&lzmaDecoder->m_LenDecoder)->m_MidCoder[aPosState])->m_Models );
+   }
+  //printf("free lzmaDecoder->m_PosSlotDecoder\n");
+  free( (&(&lzmaDecoder->m_LenDecoder)->m_HighCoder)->m_Models );
+
+
+  // from LenDecoderInit(&lzmaDecoder->m_RepMatchLenDecoder);
+  for (aPosState = 0; aPosState < (&lzmaDecoder->m_RepMatchLenDecoder)->m_NumPosStates; aPosState++) {
+      //printf("free lzmaDecoder->m_PosSlotDecoder\n");
+      free( (&(&lzmaDecoder->m_RepMatchLenDecoder)->m_LowCoder[aPosState])->m_Models );
+      //printf("free lzmaDecoder->m_PosSlotDecoder\n");
+      free( (&(&lzmaDecoder->m_RepMatchLenDecoder)->m_MidCoder[aPosState])->m_Models );
+  }
+  //printf("free lzmaDecoder->m_PosSlotDecoder\n");
+  free( (&(&lzmaDecoder->m_RepMatchLenDecoder)->m_HighCoder)->m_Models );
+
+    
+  //printf("free lzmaDecoder->m_PosAlignDecoder\n");
+  free((&lzmaDecoder->m_PosAlignDecoder)->m_Models);
+
+  for(i = 0; i < kNumPosModels; i++) {
+      //printf("free lzmaDecoder->m_PosDecoders\n");
+      free((&lzmaDecoder->m_PosDecoders[i])->m_Models);
+  }
+  
+}
+
+HRESULT LzmaDecoderSetDictionarySize(
+    LzmaDecoder  *lzmaDecoder, 
+    UINT32        aDictionarySize)
+{
+  if (aDictionarySize > (1 << kDicLogSizeMax))
+    return E_INVALIDARG;
+  
+//  UINT32 aWindowReservSize = MyMax(aDictionarySize, UINT32(1 << 21));
+
+  if (lzmaDecoder->m_DictionarySize != aDictionarySize)
+  {
+    lzmaDecoder->m_DictionarySize = aDictionarySize;
+  }
+  return S_OK;
+}
+
+HRESULT LzmaDecoderSetLiteralProperties( 
+    LzmaDecoder  *lzmaDecoder,
+    UINT32        aLiteralPosStateBits, 
+    UINT32        aLiteralContextBits)
+{
+  if (aLiteralPosStateBits > 8)
+    return E_INVALIDARG;
+  if (aLiteralContextBits > 8)
+    return E_INVALIDARG;
+  LitDecoderCreate(&lzmaDecoder->m_LiteralDecoder, aLiteralPosStateBits, aLiteralContextBits);
+  return S_OK;
+}
+
+HRESULT LzmaDecoderSetPosBitsProperties(
+    LzmaDecoder *lzmaDecoder, 
+    UINT32       aNumPosStateBits)
+{
+  UINT32 aNumPosStates;
+  if (aNumPosStateBits > (UINT32) kNumPosStatesBitsMax)
+    return E_INVALIDARG;
+  aNumPosStates = 1 << aNumPosStateBits;
+  LenDecoderCreate(&lzmaDecoder->m_LenDecoder, aNumPosStates);
+  LenDecoderCreate(&lzmaDecoder->m_RepMatchLenDecoder, aNumPosStates);
+  lzmaDecoder->m_PosStateMask = aNumPosStates - 1;
+  return S_OK;
+}
+
+
+void LzmaDecoderConstructor(LzmaDecoder *lzmaDecoder)
+{
+  lzmaDecoder->m_DictionarySize = ((UINT32)-1);
+  LzmaDecoderCreate(lzmaDecoder);
+}
+
+HRESULT LzmaDecoderCreate(LzmaDecoder *lzmaDecoder)
+{
+  int i;
+  for(i = 0; i < kNumPosModels; i++)
+  {
+    if (!(ReverseBitTreeDecoder2Create(&lzmaDecoder->m_PosDecoders[i],kDistDirectBits[kStartPosModelIndex + i])))
+        return E_OUTOFMEMORY;;
+  }
+  return S_OK;
+}
+
+
+HRESULT LzmaDecoderInit(LzmaDecoder *lzmaDecoder)
+{
+  int    i;
+  UINT32 j;
+
+  RangeDecoderInit(&in_stream, &lzmaDecoder->m_RangeDecoder);
+
+  OutWindowInit();
+
+  for(i = 0; i < kNumStates; i++)
+  {
+    for (j = 0; j <= lzmaDecoder->m_PosStateMask; j++)
+    {
+      BitDecoderInit(&lzmaDecoder->m_MainChoiceDecoders[i][j]);
+      BitDecoderInit(&lzmaDecoder->m_MatchRepShortChoiceDecoders[i][j]);
+    }
+    BitDecoderInit(&lzmaDecoder->m_MatchChoiceDecoders[i]);
+    BitDecoderInit(&lzmaDecoder->m_MatchRepChoiceDecoders[i]);
+    BitDecoderInit(&lzmaDecoder->m_MatchRep1ChoiceDecoders[i]);
+    BitDecoderInit(&lzmaDecoder->m_MatchRep2ChoiceDecoders[i]);
+  }
+  
+  LitDecoderInit(&lzmaDecoder->m_LiteralDecoder);
+   
+  for (i = 0; i < (int) kNumLenToPosStates; i++)
+    BitTreeDecoderInit(&lzmaDecoder->m_PosSlotDecoder[i],kNumPosSlotBits);
+
+  for(i = 0; i < kNumPosModels; i++)
+    ReverseBitTreeDecoder2Init(&lzmaDecoder->m_PosDecoders[i]);
+  
+  LenDecoderInit(&lzmaDecoder->m_LenDecoder);
+  LenDecoderInit(&lzmaDecoder->m_RepMatchLenDecoder);
+
+  ReverseBitTreeDecoderInit(&lzmaDecoder->m_PosAlignDecoder, kNumAlignBits);
+  return S_OK;
+
+}
+
+HRESULT LzmaDecoderCodeReal( 
+    LzmaDecoder     *lzmaDecoder, 
+    UINT64          *anInSize, 
+    UINT64          *anOutSize)
+{
+  BOOL                  aPeviousIsMatch         = FALSE;
+  BYTE                  aPreviousByte           = 0;
+  UINT32                aRepDistances[kNumRepDistances];
+  int                   i;
+  UINT64                aNowPos64               = 0;
+  UINT64                aSize                   = *anOutSize;
+  ISequentialInStream   my_in_stream;
+//  WindowOut             out_window;
+  CState                aState;
+
+  CStateInit(&aState);
+
+  if (anOutSize == NULL)
+  {
+      // CJH: Be quiet.
+      //printf("CodeReal: invalid argument %x\n", (UINT32) anOutSize );
+      return E_INVALIDARG;
+  }
+
+
+  LzmaDecoderInit(lzmaDecoder);
+
+  my_in_stream.data           = in_stream.data;
+  my_in_stream.remainingBytes = in_stream.remainingBytes;
+
+  for(i = 0 ; i < (int) kNumRepDistances; i++)
+    aRepDistances[i] = 0;
+
+  //while(aNowPos64 < aSize)
+  while(my_in_stream.remainingBytes > 0)
+  {
+    UINT64 aNext = MyMin(aNowPos64 + (1 << 18), aSize);
+    while(aNowPos64 < aNext)
+    {
+      UINT32 aPosState = (UINT32)(aNowPos64) & lzmaDecoder->m_PosStateMask;
+      if (BitDecode(&my_in_stream, 
+                    &lzmaDecoder->m_MainChoiceDecoders[aState][aPosState], 
+                    &lzmaDecoder->m_RangeDecoder) == (UINT32) kMainChoiceLiteralIndex)
+      {
+        CStateUpdateChar(&aState);
+        if(aPeviousIsMatch)
+        {
+          BYTE aMatchByte = OutWindowGetOneByte(0 - aRepDistances[0] - 1);
+          aPreviousByte = LitDecodeWithMatchByte(&my_in_stream, 
+                                                 &lzmaDecoder->m_LiteralDecoder, 
+                                                 &lzmaDecoder->m_RangeDecoder, 
+                                                 (UINT32)(aNowPos64), 
+                                                 aPreviousByte, 
+                                                 aMatchByte);
+          aPeviousIsMatch = FALSE;
+        }
+        else
+          aPreviousByte = LitDecodeNormal(&my_in_stream, 
+                                          &lzmaDecoder->m_LiteralDecoder, 
+                                          &lzmaDecoder->m_RangeDecoder, 
+                                         (UINT32)(aNowPos64), 
+                                          aPreviousByte);
+        OutWindowPutOneByte(aPreviousByte);
+        aNowPos64++;
+      }
+      else             
+      {
+        UINT32 aDistance, aLen;
+        aPeviousIsMatch = TRUE;
+        if(BitDecode(&my_in_stream, 
+                     &lzmaDecoder->m_MatchChoiceDecoders[aState], 
+                     &lzmaDecoder->m_RangeDecoder) == (UINT32) kMatchChoiceRepetitionIndex)
+        {
+          if(BitDecode(&my_in_stream, 
+                       &lzmaDecoder->m_MatchRepChoiceDecoders[aState], 
+                       &lzmaDecoder->m_RangeDecoder) == 0)
+          {
+            if(BitDecode(&my_in_stream, 
+                         &lzmaDecoder->m_MatchRepShortChoiceDecoders[aState][aPosState], 
+                         &lzmaDecoder->m_RangeDecoder) == 0)
+            {
+              CStateUpdateShortRep(&aState);
+              aPreviousByte = OutWindowGetOneByte(0 - aRepDistances[0] - 1);
+              OutWindowPutOneByte(aPreviousByte);
+              aNowPos64++;
+              continue;
+            }
+            aDistance = aRepDistances[0];
+          }
+          else
+          {
+            if(BitDecode(&my_in_stream, 
+                         &lzmaDecoder->m_MatchRep1ChoiceDecoders[aState], 
+                         &lzmaDecoder->m_RangeDecoder) == 0)
+            {
+              aDistance = aRepDistances[1];
+              aRepDistances[1] = aRepDistances[0];
+            }
+            else 
+            {
+              if (BitDecode(&my_in_stream, 
+                            &lzmaDecoder->m_MatchRep2ChoiceDecoders[aState], 
+                            &lzmaDecoder->m_RangeDecoder) == 0)
+              {
+                aDistance = aRepDistances[2];
+              }
+              else
+              {
+                aDistance = aRepDistances[3];
+                aRepDistances[3] = aRepDistances[2];
+              }
+              aRepDistances[2] = aRepDistances[1];
+              aRepDistances[1] = aRepDistances[0];
+            }
+            aRepDistances[0] = aDistance;
+          }
+          aLen = LenDecode(&my_in_stream, 
+                           &lzmaDecoder->m_RepMatchLenDecoder, 
+                           &lzmaDecoder->m_RangeDecoder, 
+                           aPosState) + kMatchMinLen;
+          CStateUpdateRep(&aState);
+        }
+        else
+        {
+          UINT32 aPosSlot;
+          aLen = kMatchMinLen + LenDecode(&my_in_stream, 
+                                          &lzmaDecoder->m_LenDecoder, 
+                                          &lzmaDecoder->m_RangeDecoder, 
+                                          aPosState);
+          CStateUpdateMatch(&aState);
+          aPosSlot = BitTreeDecode(&my_in_stream, 
+                                   &lzmaDecoder->m_PosSlotDecoder[GetLenToPosState(aLen)],
+                                   &lzmaDecoder->m_RangeDecoder);
+          if (aPosSlot >= (UINT32) kStartPosModelIndex)
+          {
+            aDistance = kDistStart[aPosSlot];
+            if (aPosSlot < (UINT32) kEndPosModelIndex)
+              aDistance += ReverseBitTreeDecoder2Decode(&my_in_stream, 
+                                                        &lzmaDecoder->m_PosDecoders[aPosSlot - kStartPosModelIndex],
+                                                        &lzmaDecoder->m_RangeDecoder);
+            else
+            {
+              aDistance += (RangeDecodeDirectBits(&my_in_stream, 
+                                                  &lzmaDecoder->m_RangeDecoder, 
+                                                  kDistDirectBits[aPosSlot] - kNumAlignBits) << kNumAlignBits);
+              aDistance += ReverseBitTreeDecoderDecode(&my_in_stream, 
+                                                       &lzmaDecoder->m_PosAlignDecoder, 
+                                                       &lzmaDecoder->m_RangeDecoder);
+            }
+          }
+          else
+            aDistance = aPosSlot;
+
+          
+          aRepDistances[3] = aRepDistances[2];
+          aRepDistances[2] = aRepDistances[1];
+          aRepDistances[1] = aRepDistances[0];
+          
+          aRepDistances[0] = aDistance;
+        }
+        if (aDistance >= aNowPos64)
+        {
+            // CJH: Be quiet.
+            //printf("CodeReal: invalid data\n" );
+            return E_INVALIDDATA;
+        }
+        OutWindowCopyBackBlock(aDistance, aLen);
+        aNowPos64 += aLen;
+        aPreviousByte = OutWindowGetOneByte(0 - 1);
+      }
+    }
+  }
+  
+  //BRCM modification
+  LzmaDecoderFreeBuffer(lzmaDecoder);
+  
+  OutWindowFlush();
+  return S_OK;
+}
+
+HRESULT LzmaDecoderCode(
+    LzmaDecoder *lzmaDecoder,
+    UINT64 *anInSize, 
+    UINT64 *anOutSize)
+{
+
+    UINT32 aStartValue = 0;
+    int i;
+    
+    for (i = 0; i < kDistTableSizeMax; i++)
+    {
+        kDistStart[i] = aStartValue;
+        aStartValue += (1 << kDistDirectBits[i]);
+    }
+    return LzmaDecoderCodeReal( 
+        lzmaDecoder, 
+        anInSize, 
+        anOutSize);
+}
+
+HRESULT LzmaDecoderReadCoderProperties(LzmaDecoder *lzmaDecoder)
+{
+  UINT32 aNumPosStateBits;
+  UINT32 aLiteralPosStateBits;
+  UINT32 aLiteralContextBits;
+  UINT32 aDictionarySize;
+  BYTE   aRemainder;
+  UINT32 aProcessesedSize;
+
+  BYTE aByte;
+  RETURN_IF_NOT_S_OK(InStreamRead(&aByte, 
+                                  sizeof(aByte), 
+                                  &aProcessesedSize));
+
+  if (aProcessesedSize != sizeof(aByte))
+    return E_INVALIDARG;
+
+  aLiteralContextBits   = aByte % 9;
+  aRemainder            = aByte / 9;
+  aLiteralPosStateBits  = aRemainder % 5;
+  aNumPosStateBits      = aRemainder / 5;
+
+  // CJH: Debug.
+  //printf("aLiteralContextBits (lc): %d\n", aLiteralContextBits);
+  //printf("aLiteralPosStateBits (lp): %d\n", aLiteralPosStateBits);
+  //printf("aNumPosStateBits (pb): %d\n", aNumPosStateBits);
+
+  // CJH: Validate LZMA properties before continuing
+  if(!aLiteralContextBits && !aLiteralPosStateBits && !aNumPosStateBits)
+  {
+      return -1;
+  }
+  if(aLiteralContextBits > 4 ||
+     aLiteralPosStateBits > 4 ||
+     aNumPosStateBits > 4 ||
+     (aLiteralContextBits + aLiteralPosStateBits) > 4)
+  {
+      return -1;
+  }
+
+  RETURN_IF_NOT_S_OK(InStreamRead(&aDictionarySize, 
+                                  sizeof(aDictionarySize), 
+                                  &aProcessesedSize));
+
+  if (aProcessesedSize != sizeof(aDictionarySize))
+    return E_INVALIDARG;
+
+  RETURN_IF_NOT_S_OK( LzmaDecoderSetDictionarySize(lzmaDecoder, 
+                                                   aDictionarySize) );
+  RETURN_IF_NOT_S_OK( LzmaDecoderSetLiteralProperties(lzmaDecoder, 
+                                                      aLiteralPosStateBits, 
+                                                      aLiteralContextBits) );
+  RETURN_IF_NOT_S_OK( LzmaDecoderSetPosBitsProperties(lzmaDecoder, 
+                                                      aNumPosStateBits) );
+
+  return S_OK;
+}
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmalt/LZMADecoder.h squashfs-tools-patched/LZMA/lzmalt/LZMADecoder.h
--- squashfs-tools/LZMA/lzmalt/LZMADecoder.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmalt/LZMADecoder.h	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,60 @@
+#ifndef __LZARITHMETIC_DECODER_H
+#define __LZARITHMETIC_DECODER_H
+
+#include "WindowOut.h"
+#include "LZMA.h"
+#include "LenCoder.h"
+#include "LiteralCoder.h"
+
+
+typedef struct LzmaDecoder
+{
+  CRangeDecoder m_RangeDecoder;
+
+  CBitDecoder m_MainChoiceDecoders[kNumStates][kNumPosStatesMax];
+  CBitDecoder m_MatchChoiceDecoders[kNumStates];
+  CBitDecoder m_MatchRepChoiceDecoders[kNumStates];
+  CBitDecoder m_MatchRep1ChoiceDecoders[kNumStates];
+  CBitDecoder m_MatchRep2ChoiceDecoders[kNumStates];
+  CBitDecoder m_MatchRepShortChoiceDecoders[kNumStates][kNumPosStatesMax];
+
+  CBitTreeDecoder               m_PosSlotDecoder[kNumLenToPosStates];
+
+  CReverseBitTreeDecoder2       m_PosDecoders[kNumPosModels];
+  CReverseBitTreeDecoder        m_PosAlignDecoder;
+  
+  LenDecoder m_LenDecoder;
+  LenDecoder m_RepMatchLenDecoder;
+
+  LitDecoder m_LiteralDecoder;
+
+  UINT32 m_DictionarySize;
+  
+  UINT32 m_PosStateMask;
+} LzmaDecoder;
+
+  HRESULT LzmaDecoderCreate(LzmaDecoder *lzmaDecoder);
+
+  HRESULT LzmaDecoderInit(LzmaDecoder *lzmaDecoder);
+
+//static inline  HRESULT LzmaDecoderFlush() { return OutWindowFlush(); }
+
+  HRESULT LzmaDecoderCodeReal( 
+      LzmaDecoder           *lzmaDecoder, 
+//      ISequentialInStream   *in_stream, 
+      UINT64                *anInSize, 
+//      WindowOut             *out_window,
+      UINT64                *anOutSize);
+
+
+  void LzmaDecoderConstructor( LzmaDecoder *lzmaDecoder );
+  
+  HRESULT LzmaDecoderCode( LzmaDecoder *lzmaDecoder, UINT64 *anInSize, UINT64 *anOutSize);
+  HRESULT LzmaDecoderReadCoderProperties(LzmaDecoder *lzmaDecoder );
+
+  HRESULT LzmaDecoderSetDictionarySize(LzmaDecoder *lzmaDecoder, UINT32 aDictionarySize);
+  HRESULT LzmaDecoderSetLiteralProperties(LzmaDecoder *lzmaDecoder, UINT32 aLiteralPosStateBits, UINT32 aLiteralContextBits);
+  HRESULT LzmaDecoderSetPosBitsProperties(LzmaDecoder *lzmaDecoder, UINT32 aNumPosStateBits);
+
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmalt/LZMA.h squashfs-tools-patched/LZMA/lzmalt/LZMA.h
--- squashfs-tools/LZMA/lzmalt/LZMA.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmalt/LZMA.h	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,83 @@
+#include "LenCoder.h"
+
+#ifndef __LZMA_H
+#define __LZMA_H
+
+
+#define kNumRepDistances 4
+
+#define kNumStates 12
+
+static const BYTE kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
+static const BYTE kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
+static const BYTE kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
+static const BYTE kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};
+
+typedef BYTE CState;
+
+INLINE void CStateInit(CState *m_Index)
+    { *m_Index = 0; }
+INLINE void CStateUpdateChar(CState *m_Index)
+    { *m_Index = kLiteralNextStates[*m_Index]; }
+INLINE void CStateUpdateMatch(CState *m_Index)
+    { *m_Index = kMatchNextStates[*m_Index]; }
+INLINE void CStateUpdateRep(CState *m_Index)
+    { *m_Index = kRepNextStates[*m_Index]; }
+INLINE void CStateUpdateShortRep(CState *m_Index)
+    { *m_Index = kShortRepNextStates[*m_Index]; }
+
+
+#define kNumPosSlotBits 6
+#define kDicLogSizeMax 28
+#define kDistTableSizeMax 56
+
+//extern UINT32 kDistStart[kDistTableSizeMax];
+static const BYTE kDistDirectBits[kDistTableSizeMax] = 
+{
+  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,
+  10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 
+  20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26 
+};
+
+#define kNumLenToPosStates 4
+INLINE UINT32 GetLenToPosState(UINT32 aLen)
+{
+  aLen -= 2;
+  if (aLen < kNumLenToPosStates)
+    return aLen;
+  return kNumLenToPosStates - 1;
+}
+
+#define kMatchMinLen 2
+
+#define kMatchMaxLen (kMatchMinLen + kNumSymbolsTotal - 1)
+
+#define kNumAlignBits 4
+#define kAlignTableSize 16
+#define kAlignMask 15
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumPosModels 10
+
+#define kNumFullDistances (1 << (kEndPosModelIndex / 2))
+
+
+#define kMainChoiceLiteralIndex 0
+#define kMainChoiceMatchIndex 1
+
+#define kMatchChoiceDistanceIndex0
+#define kMatchChoiceRepetitionIndex 1
+
+#define kNumMoveBitsForMainChoice 5
+#define kNumMoveBitsForPosCoders 5
+
+#define kNumMoveBitsForAlignCoders 5
+
+#define kNumMoveBitsForPosSlotCoder 5
+
+#define kNumLitPosStatesBitsEncodingMax 4
+#define kNumLitContextBitsMax 8
+
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmalt/lzmalt.h squashfs-tools-patched/LZMA/lzmalt/lzmalt.h
--- squashfs-tools/LZMA/lzmalt/lzmalt.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmalt/lzmalt.h	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,16 @@
+#ifndef __7Z_H
+#define __7Z_H
+
+#if defined __cplusplus
+extern "C"
+{
+#endif
+
+int decompress_lzma_alt(unsigned char* in_data, unsigned in_size, unsigned char* out_data, unsigned out_size, int offset);
+
+#if defined __cplusplus
+}
+#endif
+
+#endif
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmalt/Makefile squashfs-tools-patched/LZMA/lzmalt/Makefile
--- squashfs-tools/LZMA/lzmalt/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmalt/Makefile	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,10 @@
+INCLUDEDIR = .
+
+CC=gcc
+
+CFLAGS := -I$(INCLUDEDIR) -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -O2
+
+all:7zlzma.o  IInOutStreams.o  LZMADecoder.o
+
+clean :
+	rm -f *.o
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmalt/Portable.h squashfs-tools-patched/LZMA/lzmalt/Portable.h
--- squashfs-tools/LZMA/lzmalt/Portable.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmalt/Portable.h	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,59 @@
+#ifndef __PORTABLE_H
+#define __PORTABLE_H
+
+//BRCM modification
+#ifdef _HOST_TOOL
+#include <string.h>
+#endif
+
+#ifdef _CFE_
+#include <string.h>
+#endif
+
+#ifdef __KERNEL__
+#include <linux/string.h>
+#endif
+
+//bcm
+//#ifdef __GNUC__   
+//#include <types/vxTypesOld.h>
+//#define INLINE static inline
+//#else
+typedef char INT8;
+typedef unsigned char UINT8;
+typedef short INT16;
+typedef unsigned short UINT16;
+typedef int INT32;
+typedef unsigned int UINT32;
+typedef int BOOL;
+#define INLINE static inline
+//#define INLINE static __inline__
+//#endif
+typedef long long INT64;           // %%%% Changed from "long long"
+typedef unsigned long long UINT64; // %%%% Changed from "long long"
+
+typedef UINT8 BYTE;
+typedef UINT16 WORD;
+typedef UINT32 DWORD;
+
+typedef unsigned UINT_PTR;
+#define FALSE 0
+#define TRUE 1
+
+#define HRESULT int
+#define S_OK 0
+#define E_INVALIDARG -1
+#define E_OUTOFMEMORY -2
+#define E_FAIL -3
+#define E_INTERNAL_ERROR -4
+#define E_INVALIDDATA -5
+
+#define MyMin( a, b ) ( a < b ? a : b )
+
+#define MyMax( a, b ) ( a > b ? a : b )
+
+#define kNumMoveBits 5
+
+#define RETURN_IF_NOT_S_OK(x) { HRESULT __aResult_ = (x); if(__aResult_ != S_OK) return __aResult_; }
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmalt/RangeCoder.h squashfs-tools-patched/LZMA/lzmalt/RangeCoder.h
--- squashfs-tools/LZMA/lzmalt/RangeCoder.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmalt/RangeCoder.h	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,56 @@
+#ifndef __COMPRESSION_RANGECODER_H
+#define __COMPRESSION_RANGECODER_H
+
+#include "IInOutStreams.h"
+
+#define kNumTopBits 24
+#define kTopValue (1 << kNumTopBits)
+
+typedef struct CRangeDecoder
+{
+  UINT32  m_Range;
+  UINT32  m_Code;
+} CRangeDecoder;
+
+
+
+INLINE void RangeDecoderInit(
+    ISequentialInStream *in_stream, 
+    CRangeDecoder *rangeDecoder)
+  {
+    int i;
+    rangeDecoder->m_Code = 0;
+    rangeDecoder->m_Range = (UINT32)(-1);
+    for(i = 0; i < 5; i++)
+      rangeDecoder->m_Code = (rangeDecoder->m_Code << 8) | InStreamReadByte(in_stream);
+  }
+
+INLINE UINT32 RangeDecodeDirectBits(
+    ISequentialInStream *in_stream, 
+    CRangeDecoder *rangeDecoder, 
+    UINT32 aNumTotalBits)
+  {
+    UINT32 aRange = rangeDecoder->m_Range;
+    UINT32 aCode = rangeDecoder->m_Code;        
+    UINT32 aResult = 0;
+    UINT32 i;
+    for (i = aNumTotalBits; i > 0; i--)
+    {
+      UINT32 t;
+      aRange >>= 1;
+      t = (aCode - aRange) >> 31;
+      aCode -= aRange & (t - 1);
+      aResult = (aResult << 1) | (1 - t);
+
+      if (aRange < kTopValue)
+      {
+        aCode = (aCode << 8) | InStreamReadByte(in_stream);
+        aRange <<= 8; 
+      }
+    }
+    rangeDecoder->m_Range = aRange;
+    rangeDecoder->m_Code = aCode;
+    return aResult;
+  }
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmalt/RCDefs.h squashfs-tools-patched/LZMA/lzmalt/RCDefs.h
--- squashfs-tools/LZMA/lzmalt/RCDefs.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmalt/RCDefs.h	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,43 @@
+#ifndef __RCDEFS_H
+#define __RCDEFS_H
+
+#include "AriBitCoder.h"
+
+/*
+#define RC_INIT_VAR                            \
+  UINT32 aRange = aRangeDecoder->m_Range;      \
+  UINT32 aCode = aRangeDecoder->m_Code;        
+
+#define RC_FLUSH_VAR                          \
+  aRangeDecoder->m_Range = aRange;            \
+  aRangeDecoder->m_Code = aCode;
+*/
+
+
+#if 1
+#define RC_GETBIT2(aNumMoveBits, aProb, aModelIndex, Action0, Action1)                        \
+    {UINT32 aNewBound = (aRange >> kNumBitModelTotalBits) * aProb; \
+    if (aCode < aNewBound)                               \
+    {                                                             \
+      Action0;                                                    \
+      aRange = aNewBound;                                         \
+      aProb += (kBitModelTotal - aProb) >> aNumMoveBits;          \
+      aModelIndex <<= 1;                                          \
+    }                                                             \
+    else                                                          \
+    {                                                             \
+      Action1;                                                    \
+      aRange -= aNewBound;                                        \
+      aCode -= aNewBound;                                          \
+      aProb -= (aProb) >> aNumMoveBits;                           \
+      aModelIndex = (aModelIndex << 1) + 1;                       \
+    }}                                                             \
+    if (aRange < kTopValue)               \
+    {                                                              \
+      aCode = (aCode << 8) | InStreamReadByte(in_stream);   \
+      aRange <<= 8; }
+
+#define RC_GETBIT(aNumMoveBits, aProb, aModelIndex) RC_GETBIT2(aNumMoveBits, aProb, aModelIndex, ; , ;)               
+#endif
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmalt/vxTypesOld.h squashfs-tools-patched/LZMA/lzmalt/vxTypesOld.h
--- squashfs-tools/LZMA/lzmalt/vxTypesOld.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmalt/vxTypesOld.h	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,289 @@
+/* vxTypesOld.h - old VxWorks type definition header */
+
+/* Copyright 1984-1997 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+02c,15aug97,cym  added simnt support.
+02d,26mar97,cdp  added Thumb (ARM7TDMI_T) support.
+02c,28nov96,cdp  added ARM support.
+02b,28sep95,ms	 removed "static __inline__" (SPR #4500)
+02b,12jul95,ism  added simsolaris support
+02a,19mar95,dvs  removed tron references.
+01z,01sep94,ism  fixed comment as per SPR# 1512.
+01y,02dec93,pme  added Am29K family support.
+01x,12jun93,rrr  vxsim.
+02a,26may94,yao  added PPC support.
+01w,09jun93,hdn  added support for I80X86
+01v,12feb93,srh  added C++ versions of FUNCPTR, et al.
+01u,13nov92,dnw  added definition of VOID (SPR #1781)
+01t,02oct92,srh  replaced conditional around volatile, const, and signed so
+                 they won't be elided when __STDC__ is defined.
+                 added __cplusplus to __STDC__ condition.
+01s,22sep92,rrr  added support for c++
+01r,08sep92,smb  made some additions for the MIPS.
+01q,07sep92,smb  added __STDC__ and modes to maintain compatibility with 5.0
+01p,07jul92,rrr  moved STACK_GROW and ENDIAN to vxArch.h
+01o,03jul92,smb  changed name from vxTypes.h.
+01n,26may92,rrr  the tree shuffle
+01m,25nov91,llk  included sys/types.h.
+01l,04oct91,rrr  passed through the ansification filter
+		  -fixed #else and #endif
+		  -removed TINY and UTINY
+		  -changed VOID to void
+		  -changed ASMLANGUAGE to _ASMLANGUAGE
+		  -changed copyright notice
+01k,01oct91,jpb  fixed MIPS conditional for undefined CPU_FAMILY.
+01j,20sep91,wmd  conditionalized out defines for const, unsigned and volatile
+		 for the MIPS architecture.
+01i,02aug91,ajm  added support for MIPS_R3k.
+01h,15may91,gae  added define for "signed" when not available for pre-ANSI.
+01g,29apr91,hdn  added defines and macros for TRON architecture.
+01f,28apr91,del  added defines of __volatile__ and __const__ if !_STDC_
+		 && _GNUC__
+01f,24mar91,del  added INSTR * define for I960.
+01e,28jan91,kdl  added DBLFUNCPTR and FLTFUNCPTR.
+01d,25oct90,dnw  changed void to void except when linting.
+01c,05oct90,shl  added copyright notice.
+                 made #endif ANSI style.
+01b,10aug90,dnw  added VOIDFUNCPTR
+01a,29may90,del  written.
+*/
+
+/*
+DESCRIPTION
+This header file contains a mixture of stuff.
+1) the old style typedefs (ie. POSIX now says they must end with _t).
+   These will be phased out gradually.
+2) a mechanism for getting rid of const warning which are produced by the
+   GNU C compiler. Hopefully, this will be removed in the future.
+3) macros that are so longer needed for vxWorks source code but maybe needed
+   by some customer applications and are therefore provided for backward
+   compatability.
+4) system III typedefs (used by netinet) which do not fit in anywhere else.
+
+*/
+
+#ifndef __INCvxTypesOldh
+#define __INCvxTypesOldh
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "sys/types.h"
+
+/* vxWorks types */
+
+typedef	char		INT8;
+typedef	short		INT16;
+typedef	int		INT32;
+
+typedef	unsigned char	UINT8;
+typedef	unsigned short	UINT16;
+typedef	unsigned int	UINT32;
+
+typedef	unsigned char	UCHAR;
+typedef unsigned short	USHORT;
+typedef	unsigned int	UINT;
+typedef unsigned long	ULONG;
+
+typedef	int		BOOL;
+typedef	int		STATUS;
+typedef int 		ARGINT;
+
+typedef void		VOID;
+
+#ifdef __cplusplus
+typedef int 		(*FUNCPTR) (...);     /* ptr to function returning int */
+typedef void 		(*VOIDFUNCPTR) (...); /* ptr to function returning void */
+typedef double 		(*DBLFUNCPTR) (...);  /* ptr to function returning double*/
+typedef float 		(*FLTFUNCPTR) (...);  /* ptr to function returning float */
+#else
+typedef int 		(*FUNCPTR) ();	   /* ptr to function returning int */
+typedef void 		(*VOIDFUNCPTR) (); /* ptr to function returning void */
+typedef double 		(*DBLFUNCPTR) ();  /* ptr to function returning double*/
+typedef float 		(*FLTFUNCPTR) ();  /* ptr to function returning float */
+#endif			/* _cplusplus */
+
+
+/* This structure and the following definitions are needed to get rid
+   of const warning produced by the GNU C compiler.
+ */
+
+#if defined(__STDC__) || defined(__cplusplus)
+typedef union
+    {
+    long pm_int;
+    void *pm_v;
+    const void *pm_cv;
+    char *pm_c;
+    unsigned char *pm_uc;
+
+    signed char *pm_sc;
+    const char *pm_cc;
+    const unsigned char *pm_cuc;
+    const signed char *pm_csc;
+    short *pm_s;
+    ushort_t *pm_us;
+    const short *pm_cs;
+    const ushort_t *pm_cus;
+    int *pm_i;
+    uint_t *pm_ui;
+    const int *pm_ci;
+    const uint_t *pm_cui;
+    long *pm_l;
+    ulong_t *pm_ul;
+    const long *pm_cl;
+    const ulong_t *pm_cul;
+
+    int8_t *pm_i8;
+    uint8_t *pm_ui8;
+    const int8_t *pm_ci8;
+    const uint8_t *pm_cui8;
+    int16_t *pm_i16;
+    uint16_t *pm_ui16;
+    const int16_t *pm_ci16;
+    const uint16_t *pm_cui16;
+    int32_t *pm_i32;
+    uint32_t *pm_ui32;
+    const int32_t *pm_ci32;
+    const uint32_t *pm_cui32;
+#if _ARCH_MOVE_SIZE > 4
+    int64_t *pm_i64;
+    const int64_t *pm_ci64;
+#if _ARCH_MOVE_SIZE > 8
+    int128_t *pm_i128;
+    const int128_t *pm_ci128;
+#endif
+#endif
+    } pointer_mix_t;
+
+#define CHAR_FROM_CONST(x)	(char *)(x)
+#define VOID_FROM_CONST(x)	(void *)(x)
+
+#endif /* __STDC__ */
+
+#define STACK_DIR		_ARCH_STACK_DIR
+#define ALIGN_MEMORY		_ARCH_ALIGN_MEMORY
+#define ALIGN_STACK		_ARCH_ALIGN_STACK
+#define ALIGN_REGS		_ARCH_ALIGN_REGS
+
+#define	NBBY	8		/* number of bits in a byte */
+
+/* modes - must match O_RDONLY/O_WRONLY/O_RDWR in ioLib.h! */
+
+#define READ            0
+#define WRITE           1
+#define UPDATE          2
+
+/* Select uses bit masks of file descriptors in longs.
+ * These macros manipulate such bit fields (the filesystem macros use chars).
+ * FD_SETSIZE may be defined by the user, but the default here
+ * should be >= maxFiles parameter in iosInit call found in usrConfig.c.
+ * If this define is changed, recompile the source, or else select() will
+ * not work.
+ */
+
+#ifndef	FD_SETSIZE
+#define	FD_SETSIZE	256
+#endif	/* FD_SETSIZE */
+
+typedef long	fd_mask;
+#define NFDBITS	(sizeof(fd_mask) * NBBY)	/* bits per mask */
+#ifndef howmany
+#define	howmany(x, y)	((unsigned int)(((x)+((y)-1)))/(unsigned int)(y))
+#endif	/* howmany */
+
+typedef	struct fd_set
+    {
+    fd_mask	fds_bits[howmany(FD_SETSIZE, NFDBITS)];
+    } fd_set;
+
+#define	FD_SET(n, p)	((p)->fds_bits[(n)/NFDBITS] |= (1 << ((n) % NFDBITS)))
+#define	FD_CLR(n, p)	((p)->fds_bits[(n)/NFDBITS] &= ~(1 << ((n) % NFDBITS)))
+#define	FD_ISSET(n, p)	((p)->fds_bits[(n)/NFDBITS] & (1 << ((n) % NFDBITS)))
+#define FD_ZERO(p)	bzero((char *)(p), sizeof(*(p)))
+
+
+/* system III  typedefs (used by netinet) */
+
+typedef	unsigned char	u_char;
+typedef	unsigned short	u_short;
+typedef	unsigned int	u_int;
+typedef	unsigned long	u_long;
+typedef	unsigned short	ushort;
+
+
+/* historical definitions - now obsolete */
+
+typedef char		TBOOL;		/* obsolete */
+
+
+/* architecture dependent typedefs */
+
+#ifdef	CPU_FAMILY
+
+#if	CPU_FAMILY==MC680X0 
+typedef unsigned short INSTR;		/* word-aligned instructions */
+#endif	/* CPU_FAMILY==MC680X0 */
+
+#if	CPU_FAMILY==SPARC || CPU_FAMILY==MIPS || CPU_FAMILY==SIMSPARCSUNOS || CPU_FAMILY==SIMHPPA || CPU_FAMILY==SIMSPARCSOLARIS
+typedef unsigned long INSTR;		/* 32 bit word-aligned instructions */
+#endif	/* CPU_FAMILY==SPARC || CPU_FAMILY==MIPS || CPU_FAMILY==SIMSPARCSUNOS || CPU_FAMILY==SIMHPPA || CPU_FAMILY==SIMSPARCSOLARIS */
+
+#if	CPU_FAMILY==I960
+typedef	unsigned long INSTR;		/* 32 bit word-aligned instructions */
+#endif	/* CPU_FAMILY==I960 */
+
+#if	CPU_FAMILY==I80X86 || CPU_FAMILY==SIMNT
+typedef	unsigned char INSTR;		/* char instructions */
+#endif	/* CPU_FAMILY==I80X86 || CPU_FAMILY==SIMNT */
+
+#if	CPU_FAMILY==AM29XXX
+typedef	unsigned long INSTR;		/* 32 bit word-aligned instructions */
+#endif	/* CPU_FAMILY==AM29XXX */
+
+#if     (CPU_FAMILY==PPC)
+typedef unsigned long INSTR;            /* 32 bit word-aligned instructions */
+#endif  /* (CPU_FAMILY==PPC) */
+
+#if     CPU_FAMILY==ARM
+#if	CPU==ARM7TDMI_T
+typedef unsigned short INSTR;           /* 16 bit instructions */
+#else
+typedef unsigned long INSTR;            /* 32 bit word-aligned instructions */
+#endif
+#endif  /* CPU_FAMILY==ARM */
+
+#endif	/* CPU_FAMILY */
+
+/* ANSI type qualifiers */
+
+#if !defined(__STDC__) && !defined(__cplusplus)
+
+#ifdef  __GNUC__
+#define	volatile	__volatile__
+#define	const		__const__
+#define	signed		__signed__
+#else
+#if     !(defined(CPU_FAMILY) && CPU_FAMILY==MIPS)
+#define	volatile
+#define	const
+#define	signed
+#endif	/* !(defined(CPU_FAMILY) && CPU_FAMILY==MIPS) */
+#endif	/* __GNUC__ */
+
+#endif	/* !defined(__STDC__) && !defined(__cplusplus) */
+
+#if     CPU_FAMILY==MIPS
+#define CHAR_FROM_CONST(x)	(char *)(x)
+#define VOID_FROM_CONST(x)	(void *)(x)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __INCvxTypesOldh */
diff --color --strip-trailing-cr -NBbaur squashfs-tools/LZMA/lzmalt/WindowOut.h squashfs-tools-patched/LZMA/lzmalt/WindowOut.h
--- squashfs-tools/LZMA/lzmalt/WindowOut.h	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/LZMA/lzmalt/WindowOut.h	2022-01-01 15:08:47.905171449 +0800
@@ -0,0 +1,52 @@
+#ifndef __STREAM_WINDOWOUT_H
+#define __STREAM_WINDOWOUT_H
+
+#include "IInOutStreams.h"
+
+typedef struct WindowOut
+{
+  BYTE  *Buffer;
+  UINT32 Pos;
+} WindowOut;
+
+extern WindowOut out_window;
+
+#define OutWindowInit() \
+  { \
+    out_window.Buffer = (BYTE *) out_stream.data; \
+    out_window.Pos = 0; \
+  }
+
+#define OutWindowFlush() \
+  { \
+    OutStreamSizeSet( out_window.Pos ); \
+  } 
+
+// BRCM modification 
+INLINE void OutWindowCopyBackBlock(UINT32 aDistance, UINT32 aLen)
+  {
+    BYTE   *p = out_window.Buffer + out_window.Pos;
+    UINT32  i;
+    aDistance++;
+    for(i = 0; i < aLen; i++)
+      /*
+       * CJH: The freddy77 patch to prevent segfaults in 64 bit.
+       *      http://www.neufbox4.org/forum/viewtopic.php?pid=11019
+       */
+      //p[i] = p[i - aDistance];
+      p[i] = *(p+i-aDistance);
+    out_window.Pos += aLen;
+  }
+
+
+#define OutWindowPutOneByte(aByte) \
+  { \
+    out_window.Buffer[out_window.Pos++] = aByte; \
+  } 
+
+#define OutWindowGetOneByte(anIndex) \
+     (out_window.Buffer[out_window.Pos + anIndex])
+
+
+
+#endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/lzma_wrapper.c squashfs-tools-patched/lzma_wrapper.c
--- squashfs-tools/lzma_wrapper.c	2014-03-09 13:31:58.000000000 +0800
+++ squashfs-tools-patched/lzma_wrapper.c	2022-01-01 15:08:47.909171449 +0800
@@ -27,14 +27,21 @@
 #include "squashfs_fs.h"
 #include "compressor.h"
 
+// CJH: Added these includes
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "error.h"
+#include "lzmalt.h"
+#include "lzmadaptive.h"
+
 #define LZMA_HEADER_SIZE	(LZMA_PROPS_SIZE + 8)
 
 static int lzma_compress(void *strm, void *dest, void *src, int size, int block_size,
 		int *error)
 {
 	unsigned char *d = dest;
-	size_t props_size = LZMA_PROPS_SIZE,
-		outlen = block_size - LZMA_HEADER_SIZE;
+	size_t props_size = LZMA_PROPS_SIZE, outlen = block_size - LZMA_HEADER_SIZE;
 	int res;
 
 	res = LzmaCompress(dest + LZMA_HEADER_SIZE, &outlen, src, size, dest,
@@ -78,8 +85,8 @@
 	return outlen + LZMA_HEADER_SIZE;
 }
 
-
-static int lzma_uncompress(void *dest, void *src, int size, int outsize,
+// CJH: s/lzma_uncompress/lzma_standard_uncompress/
+static int lzma_standard_uncompress(void *dest, void *src, int size, int outsize,
 	int *error)
 {
 	unsigned char *s = src;
@@ -91,13 +98,23 @@
 		(s[LZMA_PROPS_SIZE + 2] << 16) |
 		(s[LZMA_PROPS_SIZE + 3] << 24);
 
-	if(outlen > outsize) {
+	if(outlen > outsize)
+    {
+        /* CJH: Don't consider this an error, as some implementations omit the size field from the LZMA header
 		*error = 0;
 		return -1;
-	}
+        */		
+
+        outlen = outsize;
+        inlen = size - LZMA_PROPS_SIZE;
+        TRACE("lzma_standard_uncompress: lzma data block does not appear to contain a valid size field\n");
 
-	res = LzmaUncompress(dest, &outlen, src + LZMA_HEADER_SIZE, &inlen, src,
-		LZMA_PROPS_SIZE);
+	    res = LzmaUncompress(dest, &outlen, src + LZMA_PROPS_SIZE, &inlen, src, LZMA_PROPS_SIZE);
+	}
+    else
+    {
+	    res = LzmaUncompress(dest, &outlen, src + LZMA_HEADER_SIZE, &inlen, src, LZMA_PROPS_SIZE);
+    }
 	
 	if(res == SZ_OK)
 		return outlen;
@@ -107,11 +124,242 @@
 	}
 }
 
+// CJH: lzma_alt variant decompressor
+static int lzma_alt_uncompress(void *dest, void *src, int size, int outsize, int *error)
+{
+    int i = 0, retval = -1;
+    /*
+     * Found some Squashfsv1.0 images that have 4 bytes 
+     * of cruft at the beginning of each comressed data block.
+     */
+    int common_offsets[2] = { 0, 4 };
+
+    for(i=0; i<2; i++)
+    {
+        if((retval = decompress_lzma_alt((unsigned char *) src, 
+                                         (unsigned int) size, 
+                                         (unsigned char *) dest, 
+                                         (unsigned int) outsize, 
+                                         common_offsets[i])) == 0)
+        {
+            TRACE("decompress_lzma_alt succeeded in decompressing %d bytes!\n", outsize);
+            return outsize;
+        }
+    }
+            
+    *error = retval;
+    TRACE("decompress_lzma_alt failed with error code %d\n", *error);
+    return -1;
+}
+
+/*
+ * CJH: lzmawrt varient decompressor, generally unused ATM as 
+ * lzmadaptive takes care of DD-WRT images.
+ */
+static int lzma_wrt_uncompress(void *dest, void *src, int size, int outsize, int *error)
+{
+    int retval = -1;
+    uLongf ulong_outsize = (uLongf) outsize;
+
+    if((retval = lzmawrt_uncompress((Bytef *) dest, &ulong_outsize, (const Bytef *) src, (uLong) size)) != 0)
+    {
+        *error = retval;
+        retval = -1;
+        TRACE("lzmawrt_uncompress failed with error code %d\n", *error);
+    }
+    else
+    {
+        outsize = (int) ulong_outsize;
+        TRACE("lzmawrt_uncompress succeeded: [%d] [%d]\n", retval, outsize);
+        retval = outsize;
+    }
+
+    return retval;
+}
+
+// CJH: An adaptive LZMA decompressor
+#define LZMA_MAX_LC     4
+#define LZMA_MAX_LP     4
+#define LZMA_MAX_PB     4
+#define LZMA_MAX_OFFSET 10 // CJH: Experimentally determined. Maybe more?
+struct lzma_props
+{
+    int lc;
+    int lp;
+    int pb;
+    int dictionary_size;
+    int offset;
+    int detected;
+};
+struct lzma_props properties = { 0 };
+extern struct override_table override;
+static int lzma_adaptive_uncompress(void *dest, void *src, int size, int outsize, int *error)
+{
+    int lc, lp, pb, i, offset;
+    unsigned char *tmp_buf = NULL;
+    int retval = -1, expected_outsize = 0, dictionary_size = -1;
+
+    expected_outsize = outsize;
+
+    if(override.dictionary_size.set)
+    {
+        dictionary_size = override.dictionary_size.value;
+    }
+
+    // Properties already detected? Do it.
+    if(properties.detected)
+    {
+        uLongf ulong_outsize = (uLongf) outsize;
+        retval = lzmaspec_uncompress((Bytef *) dest, 
+                                     &ulong_outsize, 
+                                     (const Bytef *) src, 
+                                     (uLong) size,
+                                     properties.lc,
+                                     properties.lp,
+                                     properties.pb,
+                                     properties.dictionary_size, 
+                                     properties.offset);
+    
+        outsize = (int) ulong_outsize;
+
+        if(retval == 0)
+        {
+            return outsize;
+        }
+    }
+
+    /*
+     * Providing a larger than required buffer is important when brute-forcing the LZMA options;
+     * if the data decompresses to something larger than expected, then the selected options are
+     * incorrect, so we must provide enough room in the destination buffer to detect this.
+     */
+    tmp_buf = malloc(expected_outsize * 2);
+    if(!tmp_buf)
+    {
+        perror("malloc");
+        return -1;
+    }
+
+    /*
+     * Go through all possible combinations of lp, lc, pb and common LZMA data offsets.
+     * Take the first valid decompression we can get.
+     *
+     * Sometimes the LZMA data doesn't start at the beginning of src.
+     * This can be due to a variety of reasons, usually because the
+     * LZMA vendor implementation encoded the compression properties
+     * into the first few bytes.
+     */
+    for(i=0; i<=LZMA_MAX_OFFSET; i++)
+    {
+        // override.offset overrides the current offset
+        if(override.offset.set)
+        {
+            offset = override.offset.value;
+            // If an override value was specified, just do the loop once
+            if(i > 0) break;
+        }
+        else
+        {
+            offset = i;
+        }
+
+        for(lc=0; lc<=LZMA_MAX_LC; lc++)
+        {
+            if(override.lc.set && override.lc.value != lc) continue;
+
+            for(lp=0; lp<=LZMA_MAX_LP; lp++)
+            {
+                if(override.lp.set && override.lp.value != lp) continue;
+
+                for(pb=0; pb<=LZMA_MAX_PB; pb++)
+                {
+                    if(override.pb.set && override.pb.value != pb) continue;
+
+                    TRACE("Attempting to decompress: [0x%.2X 0x%.2X 0x%.2X 0x%.2X 0x%.2X 0x%.2X 0x%.2X 0x%.2X]\n",
+                                    (uint8_t) ((unsigned char *) src)[offset+0],
+                                    (uint8_t) ((unsigned char *) src)[offset+1],
+                                    (uint8_t) ((unsigned char *) src)[offset+2],
+                                    (uint8_t) ((unsigned char *) src)[offset+3],
+                                    (uint8_t) ((unsigned char *) src)[offset+4],
+                                    (uint8_t) ((unsigned char *) src)[offset+5],
+                                    (uint8_t) ((unsigned char *) src)[offset+6],
+                                    (uint8_t) ((unsigned char *) src)[offset+7]);
+                            
+                    TRACE("Trying LZMA settings [lc: %d, lp: %d, pb: %d, dict size: 0x%.8X offset: %d], ", lc,
+                                                                                                           lp,
+                                                                                                           pb,
+                                                                                                           dictionary_size,
+                                                                                                           offset);
+
+                    // tmp_buf was malloc'd as expected_outsize*2
+                    outsize = expected_outsize * 2;
+                    uLongf ulong_outsize = (uLongf) outsize;
+
+                    retval = lzmaspec_uncompress((Bytef *) tmp_buf, 
+                                                 &ulong_outsize,
+                                                 (const Bytef *) src, 
+                                                 (uLong) size,
+                                                 lc,
+                                                 lp,
+                                                 pb,
+                                                 dictionary_size,
+                                                 offset);
+
+                    outsize = (int) ulong_outsize;
+                    TRACE("retval = %d, outsize = %d/%d\n\n", retval, outsize, expected_outsize);
+
+                    /*
+                     * If the decompression was successful, and if the expected decompressed
+                     * size matches the expected decompressed size, then these decompression
+                     * settings are likely valid.
+                     *
+                     * Note that for some data blocks, the code doesn't know the exact size
+                     * beforehand, and simply sets the expected size to some known maximum
+                     * value (SQUASHFS_FILE_SIZE, SQUASHFS_METADATA_SIZE, etc). The first
+                     * things to be decompressed however are the fragment/inode/directory tables,
+                     * and those have known sizes, making this a reasonably predictable way
+                     * of recovering the LZMA compression options so long as the same options
+                     * are used for all decompressed blocks (DD-WRT, for example, uses different
+                     * options for each compressed block, but I've never seen it anywhere else).
+                     */
+                    if(retval == 0 &&
+                       expected_outsize >= outsize &&
+                       (expected_outsize == SQUASHFS_METADATA_SIZE ||
+                        expected_outsize == SQUASHFS_FILE_SIZE ||
+                        expected_outsize == outsize))
+                    {
+                        properties.lc = lc;
+                        properties.lp = lp;
+                        properties.pb = pb;
+                        properties.dictionary_size = dictionary_size;
+                        properties.offset = offset;
+                        properties.detected = 1;
+                        memcpy(dest, tmp_buf, outsize);
+
+                        TRACE("Detected LZMA settings [lc: %d, lp: %d, pb: %d, dict size: 0x%.8X offset: %d], ", properties.lc,
+                                                                                                                 properties.lp,
+                                                                                                                 properties.pb,
+                                                                                                                 properties.dictionary_size,
+                                                                                                                 properties.offset);
+                        TRACE("decompressed %d/%d bytes\n", outsize, expected_outsize);
+
+                        free(tmp_buf);
+                        return outsize;
+                    }
+                }
+            }
+        }
+    }
+
+    if(tmp_buf) free(tmp_buf);
+    *error = retval;
+    return -1;
+}
 
 struct compressor lzma_comp_ops = {
 	.init = NULL,
 	.compress = lzma_compress,
-	.uncompress = lzma_uncompress,
+	.uncompress = lzma_standard_uncompress,
 	.options = NULL,
 	.usage = NULL,
 	.id = LZMA_COMPRESSION,
@@ -119,3 +367,36 @@
 	.supported = 1
 };
 
+struct compressor lzma_alt_comp_ops = {
+	.init = NULL,
+	.compress = lzma_compress,
+	.uncompress = lzma_alt_uncompress,
+	.options = NULL,
+	.usage = NULL,
+	.id = LZMA_ALT_COMPRESSION,
+	.name = "lzma-alt",
+	.supported = 1
+};
+
+struct compressor lzma_adaptive_comp_ops = {
+	.init = NULL,
+	.compress = lzma_compress,
+	.uncompress = lzma_adaptive_uncompress,
+	.options = NULL,
+	.usage = NULL,
+	.id = LZMA_ADAPTIVE_COMPRESSION,
+	.name = "lzma-adaptive",
+	.supported = 1
+};
+
+struct compressor lzma_wrt_comp_ops = {
+	.init = NULL,
+	.compress = lzma_compress,
+	.uncompress = lzma_wrt_uncompress,
+	.options = NULL,
+	.usage = NULL,
+	.id = LZMA_WRT_COMPRESSION,
+	.name = "lzma-ddwrt",
+	.supported = 1
+};
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/Makefile squashfs-tools-patched/Makefile
--- squashfs-tools/Makefile	2014-05-12 02:56:00.000000000 +0800
+++ squashfs-tools-patched/Makefile	2022-01-01 15:10:53.601176620 +0800
@@ -26,7 +26,7 @@
 # To build using XZ Utils liblzma - install the library and uncomment
 # the XZ_SUPPORT line below.
 #
-#XZ_SUPPORT = 1
+XZ_SUPPORT = 1
 
 
 ############ Building LZO support ##############
@@ -37,7 +37,7 @@
 # LZO_SUPPORT line below. If needed, uncomment and set LZO_DIR to the
 # installation prefix.
 #
-#LZO_SUPPORT = 1
+LZO_SUPPORT = 1
 #LZO_DIR = /usr/local
 
 
@@ -72,8 +72,13 @@
 # and uncomment the LZMA_SUPPORT line below.
 #
 #LZMA_XZ_SUPPORT = 1
-#LZMA_SUPPORT = 1
-#LZMA_DIR = ../../../../LZMA/lzma465
+LZMA_SUPPORT = 1
+# CJH: Added LZMA_BASE_DIR
+LZMA_BASE_DIR = ./LZMA
+LZMA_DIR = $(LZMA_BASE_DIR)/lzma465
+# CJH: Added these too...
+LZMA_ALT_DIR = $(LZMA_BASE_DIR)/lzmalt
+LZMA_ADAPT_DIR = $(LZMA_BASE_DIR)/lzmadaptive/C/7zip/Compress/LZMA_Lib
 
 ######## Specifying default compression ########
 #
@@ -117,10 +122,11 @@
 UNSQUASHFS_OBJS = unsquashfs.o unsquash-1.o unsquash-2.o unsquash-3.o \
 	unsquash-4.o swap.o compressor.o unsquashfs_info.o
 
-CFLAGS ?= -O2
+# CJH: Added -g, -Werror and -DSQUASHFS_TRACE
+CFLAGS ?= -g -O2
 CFLAGS += $(EXTRA_CFLAGS) $(INCLUDEDIR) -D_FILE_OFFSET_BITS=64 \
 	-D_LARGEFILE_SOURCE -D_GNU_SOURCE -DCOMP_DEFAULT=\"$(COMP_DEFAULT)\" \
-	-Wall
+	-Wall #-DSQUASHFS_TRACE
 
 LIBS = -lpthread -lm
 ifeq ($(GZIP_SUPPORT),1)
@@ -132,13 +138,18 @@
 endif
 
 ifeq ($(LZMA_SUPPORT),1)
+# CJH: Added -llzmalib
+LIBS += -L$(LZMA_ADAPT_DIR) -llzmalib 
 LZMA_OBJS = $(LZMA_DIR)/C/Alloc.o $(LZMA_DIR)/C/LzFind.o \
 	$(LZMA_DIR)/C/LzmaDec.o $(LZMA_DIR)/C/LzmaEnc.o $(LZMA_DIR)/C/LzmaLib.o
-INCLUDEDIR += -I$(LZMA_DIR)/C
+# CJH: Added LZMA variant directories
+INCLUDEDIR += -I$(LZMA_DIR)/C -I$(LZMA_ALT_DIR) -I$(LZMA_ADAPT_DIR)
 CFLAGS += -DLZMA_SUPPORT
 MKSQUASHFS_OBJS += lzma_wrapper.o $(LZMA_OBJS)
 UNSQUASHFS_OBJS += lzma_wrapper.o $(LZMA_OBJS)
 COMPRESSORS += lzma
+# CJH: Added LZMA_EXTRA_OBJS
+LZMA_EXTRA_OBJS = $(LZMA_ALT_DIR)/*.o
 endif
 
 ifeq ($(LZMA_XZ_SUPPORT),1)
@@ -222,10 +233,12 @@
 endif
 
 .PHONY: all
-all: mksquashfs unsquashfs
+# CJH: Made sasquatch the default target
+all: sasquatch 
 
+# CJH: Added LZMA_EXTRA_OBJS
 mksquashfs: $(MKSQUASHFS_OBJS)
-	$(CC) $(LDFLAGS) $(EXTRA_LDFLAGS) $(MKSQUASHFS_OBJS) $(LIBS) -o $@
+	$(CC) $(LDFLAGS) $(EXTRA_LDFLAGS) $(LZMA_EXTRA_OBJS) $(MKSQUASHFS_OBJS) $(LIBS) -o $@
 
 mksquashfs.o: Makefile mksquashfs.c squashfs_fs.h squashfs_swap.h mksquashfs.h \
 	sort.h pseudo.h compressor.h xattr.h action.h error.h progressbar.h \
@@ -265,7 +278,8 @@
 
 gzip_wrapper.o: gzip_wrapper.c squashfs_fs.h gzip_wrapper.h compressor.h
 
-lzma_wrapper.o: lzma_wrapper.c compressor.h squashfs_fs.h
+# CJH: Added lzmalt, lzmadaptive
+lzma_wrapper.o: lzma_wrapper.c compressor.h squashfs_fs.h lzmalt lzmadaptive
 
 lzma_xz_wrapper.o: lzma_xz_wrapper.c compressor.h squashfs_fs.h
 
@@ -275,8 +289,13 @@
 
 xz_wrapper.o: xz_wrapper.c squashfs_fs.h xz_wrapper.h compressor.h
 
+# CJH: Added LZMA_EXTRA_OBJS
 unsquashfs: $(UNSQUASHFS_OBJS)
-	$(CC) $(LDFLAGS) $(EXTRA_LDFLAGS) $(UNSQUASHFS_OBJS) $(LIBS) -o $@
+	$(CC) $(LDFLAGS) $(EXTRA_LDFLAGS) $(UNSQUASHFS_OBJS) $(LZMA_EXTRA_OBJS) $(LIBS) -o $@
+
+# CJH: Added sasquatch target
+sasquatch: $(UNSQUASHFS_OBJS)
+	$(CXX) $(LDFLAGS) $(EXTRA_LDFLAGS) $(LZMA_EXTRA_OBJS) $(UNSQUASHFS_OBJS) $(LIBS) -o $@
 
 unsquashfs.o: unsquashfs.h unsquashfs.c squashfs_fs.h squashfs_swap.h \
 	squashfs_compat.h xattr.h read_fs.h compressor.h
@@ -294,12 +313,22 @@
 
 unsquashfs_info.o: unsquashfs.h squashfs_fs.h
 
+# CJH: Added lzmalt, lzmadaptive
+.PHONY: lzmalt lzmadaptive
+lzmalt:
+	make -C $(LZMA_ALT_DIR)
+lzmadaptive:
+	make -C $(LZMA_ADAPT_DIR)
+
+# CJH: Added lzmalt, lzmadaptive
 .PHONY: clean
 clean:
-	-rm -f *.o mksquashfs unsquashfs
+	-rm -f *.o $(LZMA_OBJS) mksquashfs unsquashfs sasquatch
+	make -C $(LZMA_ADAPT_DIR) clean
+	make -C $(LZMA_ALT_DIR) clean
 
+# CJH: Added cp sasquatch
 .PHONY: install
-install: mksquashfs unsquashfs
+install: sasquatch
 	mkdir -p $(INSTALL_DIR)
-	cp mksquashfs $(INSTALL_DIR)
-	cp unsquashfs $(INSTALL_DIR)
+	cp sasquatch $(INSTALL_DIR)
diff --color --strip-trailing-cr -NBbaur squashfs-tools/process_fragments.c squashfs-tools-patched/process_fragments.c
--- squashfs-tools/process_fragments.c	2014-05-10 12:54:13.000000000 +0800
+++ squashfs-tools-patched/process_fragments.c	2022-01-01 15:08:47.909171449 +0800
@@ -192,9 +192,10 @@
 
 		res = compressor_uncompress(comp, buffer->data, data, size,
 			block_size, &error);
-		if(res == -1)
-			BAD_ERROR("%s uncompress failed with error code %d\n",
-				comp->name, error);
+        // CJH: Decompression errors are displayed elsewhere
+		//if(res == -1)
+		//	BAD_ERROR("%s uncompress failed with error code %d\n",
+		//		comp->name, error);
 	} else if(compressed_buffer)
 		memcpy(buffer->data, compressed_buffer->data, size);
 	else {
diff --color --strip-trailing-cr -NBbaur squashfs-tools/read_fs.c squashfs-tools-patched/read_fs.c
--- squashfs-tools/read_fs.c	2014-05-10 12:54:13.000000000 +0800
+++ squashfs-tools-patched/read_fs.c	2022-01-01 15:08:47.909171449 +0800
@@ -87,8 +87,9 @@
 		res = compressor_uncompress(comp, block, buffer, c_byte,
 			outlen, &error);
 		if(res == -1) {
-			ERROR("%s uncompress failed with error code %d\n",
-				comp->name, error);
+            // CJH: Decompression errors are displayed elsewhere
+			//ERROR("%s uncompress failed with error code %d\n",
+			//	comp->name, error);
 			return 0;
 		}
 	} else {
diff --color --strip-trailing-cr -NBbaur squashfs-tools/README.md squashfs-tools-patched/README.md
--- squashfs-tools/README.md	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/README.md	2022-01-01 15:08:47.909171449 +0800
@@ -0,0 +1,2 @@
+This is the raw, patched source code for squashfs-tools. It is included in this repository for documentation and administrative purposes only. Any bugs or patches not directly related to the modifications made by the sasquatch patches should be reported to the squashfs-tools project.
+
diff --color --strip-trailing-cr -NBbaur squashfs-tools/squashfs_fs.h squashfs-tools-patched/squashfs_fs.h
--- squashfs-tools/squashfs_fs.h	2014-05-10 12:54:13.000000000 +0800
+++ squashfs-tools-patched/squashfs_fs.h	2022-01-01 15:08:47.909171449 +0800
@@ -277,6 +277,22 @@
 #define LZO_COMPRESSION		3
 #define XZ_COMPRESSION		4
 #define LZ4_COMPRESSION		5
+// CJH: Added #defines for additional decompressors
+#define LZMA_WRT_COMPRESSION        6
+#define LZMA_ADAPTIVE_COMPRESSION   7
+#define LZMA_ALT_COMPRESSION        8
+
+// CJH: A generic super block structure used for auto-detecting endianess
+#include <stdint.h>
+#define SQUASHFS_MIN_VERSION 1
+#define SQUASHFS_MAX_VERSION 4
+struct squashfs_generic_super_block {
+    uint32_t s_magic;
+    uint32_t inodes;
+    uint8_t  filler[20];
+    uint16_t s_major;
+    uint16_t s_minor;
+} __attribute__ ((packed));
 
 struct squashfs_super_block {
 	unsigned int		s_magic;
@@ -488,4 +504,21 @@
 	unsigned int		unused;
 };
 
+// CJH: Override structures (see usage)
+struct lzma_override_property
+{
+    int set;
+    int value;
+};
+struct override_table
+{
+    int s_major;
+    int s_minor;
+    struct lzma_override_property lc;
+    struct lzma_override_property lp;
+    struct lzma_override_property pb;
+    struct lzma_override_property dictionary_size;
+    struct lzma_override_property offset;
+};
+
 #endif
diff --color --strip-trailing-cr -NBbaur squashfs-tools/unsquashfs.c squashfs-tools-patched/unsquashfs.c
--- squashfs-tools/unsquashfs.c	2014-05-13 06:18:35.000000000 +0800
+++ squashfs-tools-patched/unsquashfs.c	2022-01-01 15:10:10.625174852 +0800
@@ -33,6 +33,7 @@
 
 #include <sys/sysinfo.h>
 #include <sys/types.h>
+#include <sys/sysmacros.h>
 #include <sys/time.h>
 #include <sys/resource.h>
 #include <limits.h>
@@ -44,13 +45,19 @@
 pthread_mutex_t	fragment_mutex;
 
 /* user options that control parallelisation */
-int processors = -1;
+//int processors = -1;
+// CJH: Temporarily set the default processor count to 1 to prevent threading bug
+//      until a proper fix is implemented.
+int processors = 1;
 
 struct super_block sBlk;
 squashfs_operations s_ops;
-struct compressor *comp;
-
-int bytes = 0, swap, file_count = 0, dir_count = 0, sym_count = 0,
+// CJH: Initialize to NULL
+struct compressor *comp = NULL;
+// CJH: Add override struct
+struct override_table override = { 0 };
+// CJH: Initialize swap to -1
+int bytes = 0, swap = -1, file_count = 0, dir_count = 0, sym_count = 0,
 	dev_count = 0, fifo_count = 0;
 char *inode_table = NULL, *directory_table = NULL;
 struct hash_table_entry *inode_table_hash[65536], *directory_table_hash[65536];
@@ -75,6 +82,7 @@
 int inode_number = 1;
 int no_xattrs = XATTR_DEF;
 int user_xattrs = FALSE;
+int verbose;
 
 int lookup_type[] = {
 	0,
@@ -701,8 +709,9 @@
 			outlen, &error);
 
 		if(res == -1) {
-			ERROR("%s uncompress failed with error code %d\n",
-				comp->name, error);
+            // CJH: Compression errors are displayed elsewhere
+			//ERROR("%s uncompress failed with error code %d\n",
+			//	comp->name, error);
 			goto failed;
 		}
 	} else {
@@ -720,7 +729,10 @@
 	 * is of the expected size
 	 */
 	if(expected && expected != res)
+    {
+        ERROR("Decompressed size did not match the expected size! [%d != %d]\n", res, expected);
 		return 0;
+    }
 	else
 		return res;
 
@@ -747,8 +759,9 @@
 			block_size, &error);
 
 		if(res == -1) {
-			ERROR("%s uncompress failed with error code %d\n",
-				comp->name, error);
+            // CJH: Compression errors are displayed elsewhere
+			//ERROR("%s uncompress failed with error code %d\n",
+			//	comp->name, error);
 			goto failed;
 		}
 
@@ -1622,7 +1635,7 @@
 	dir_count ++;
 }
 
-
+// CJH: s/TRACE/printf/g
 void squashfs_stat(char *source)
 {
 	time_t mkfs_time = (time_t) sBlk.s.mkfs_time;
@@ -1640,9 +1653,10 @@
 
 	printf("Creation or last append time %s", mkfs_str ? mkfs_str :
 		"failed to get time\n");
-	printf("Filesystem size %.2f Kbytes (%.2f Mbytes)\n",
-		sBlk.s.bytes_used / 1024.0, sBlk.s.bytes_used /
-		(1024.0 * 1024.0));
+    // CJH: Added bytes output
+	printf("Filesystem size %.2f Kbytes (%.2f Mbytes) (%lld [0x%llX] bytes)\n",
+		(sBlk.s.bytes_used / 1024.0), (sBlk.s.bytes_used / (1024.0 * 1024.0)), 
+        sBlk.s.bytes_used, sBlk.s.bytes_used);
 
 	if(sBlk.s.s_major == 4) {
 		printf("Compression %s\n", comp->name);
@@ -1714,25 +1728,25 @@
 		printf("Number of gids %d\n", sBlk.no_guids);
 	}
 
-	TRACE("sBlk.s.inode_table_start 0x%llx\n", sBlk.s.inode_table_start);
-	TRACE("sBlk.s.directory_table_start 0x%llx\n",
+	printf("sBlk.s.inode_table_start 0x%llx\n", sBlk.s.inode_table_start);
+	printf("sBlk.s.directory_table_start 0x%llx\n",
 		sBlk.s.directory_table_start);
 
 	if(sBlk.s.s_major > 1)
-		TRACE("sBlk.s.fragment_table_start 0x%llx\n\n",
+		printf("sBlk.s.fragment_table_start 0x%llx\n",
 			sBlk.s.fragment_table_start);
 
 	if(sBlk.s.s_major > 2)
-		TRACE("sBlk.s.lookup_table_start 0x%llx\n\n",
+		printf("sBlk.s.lookup_table_start 0x%llx\n",
 			sBlk.s.lookup_table_start);
 
 	if(sBlk.s.s_major == 4) {
-		TRACE("sBlk.s.id_table_start 0x%llx\n", sBlk.s.id_table_start);
-		TRACE("sBlk.s.xattr_id_table_start 0x%llx\n",
+		printf("sBlk.s.id_table_start 0x%llx\n", sBlk.s.id_table_start);
+		printf("sBlk.s.xattr_id_table_start 0x%llx\n",
 			sBlk.s.xattr_id_table_start);
 	} else {
-		TRACE("sBlk.uid_start 0x%llx\n", sBlk.uid_start);
-		TRACE("sBlk.guid_start 0x%llx\n", sBlk.guid_start);
+		printf("sBlk.uid_start 0x%llx\n", sBlk.uid_start);
+		printf("sBlk.guid_start 0x%llx\n", sBlk.guid_start);
 	}
 }
 
@@ -1745,9 +1759,11 @@
 	if(!comp->supported) {
 		ERROR("Filesystem uses %s compression, this is "
 			"unsupported by this version\n", comp->name);
-		ERROR("Decompressors available:\n");
-		display_compressors("", "");
-		return 0;
+        // CJH: Try to continue anyway
+		//ERROR("Decompressors available:\n");
+		//display_compressors("", "");
+		//return 0;
+        return 1;
 	}
 
 	/*
@@ -1777,17 +1793,74 @@
 {
 	squashfs_super_block_3 sBlk_3;
 	struct squashfs_super_block sBlk_4;
+    // CJH: Added this structure for auto-swap detection
+    struct squashfs_generic_super_block generic = { 0 };
+
+    // CJH: Perform swap auto-detection
+    if(swap == -1)
+    {
+        read_fs_bytes(fd, SQUASHFS_START, sizeof(struct squashfs_generic_super_block),
+            &generic);
+        /*
+         * If the major version is greater than or less than the min/max version numbers
+         * or if the least significant bytes of the inode count field is 0, then the
+         * image endianess is probably opposite of the host system.
+         *
+         * Note that these are the only fields besides s_magic that are common among 
+         * all versions of the SquashFS super block structures, and s_magic cannot
+         * be relied on as it is commonly mucked with by vendors.
+         */
+        if(generic.s_major < SQUASHFS_MIN_VERSION ||
+           generic.s_major > SQUASHFS_MAX_VERSION ||
+           (generic.inodes & 0xFF) == 0)
+        {
+            ERROR("SquashFS version [%d.%d] / inode count [%d] suggests a SquashFS image "
+                  "of a different endianess\n", generic.s_major, generic.s_minor, generic.inodes);
+            swap = 1;
+        }
+        else
+        {
+            ERROR("SquashFS version [%d.%d] / inode count [%d] suggests a SquashFS image "
+                  "of the same endianess\n", generic.s_major, generic.s_minor, generic.inodes);
+            swap = 0;
+        }
+    }
+    
+    // CJH: Warn if SquashFS magic doesn't look correct
+    if(generic.s_magic != SQUASHFS_MAGIC && generic.s_magic != SQUASHFS_MAGIC_SWAP)
+    {
+        ERROR("Non-standard SquashFS Magic: %.4s\n", (char *) &generic.s_magic);
+    }
+
+    // CJH: Notify if endianess is different
+    if(swap)
+        ERROR("Reading a different endian SQUASHFS filesystem on %s\n", source);
 
 	/*
 	 * Try to read a Squashfs 4 superblock
 	 */
 	read_fs_bytes(fd, SQUASHFS_START, sizeof(struct squashfs_super_block),
 		&sBlk_4);
-	swap = sBlk_4.s_magic != SQUASHFS_MAGIC;
+	// CJH: swap detection already done generically above
+    //swap = sBlk_4.s_magic != SQUASHFS_MAGIC;
 	SQUASHFS_INSWAP_SUPER_BLOCK(&sBlk_4);
 
+    /*
+     * CJH: Don't consider it an error if SQUASHFS_MAGIC doesn't match
 	if(sBlk_4.s_magic == SQUASHFS_MAGIC && sBlk_4.s_major == 4 &&
 			sBlk_4.s_minor == 0) {
+     */
+
+     // CJH: Added s_major override
+     if((sBlk_4.s_major == 4 && sBlk_4.s_minor == 0) ||
+        (override.s_major == 4)) {
+
+        // CJH: Update super struct with override values
+        if(override.s_major)
+            sBlk_4.s_major = override.s_major;
+        if(override.s_minor)
+            sBlk_4.s_minor = override.s_minor;
+
 		s_ops.squashfs_opendir = squashfs_opendir_4;
 		s_ops.read_fragment = read_fragment_4;
 		s_ops.read_fragment_table = read_fragment_table_4;
@@ -1799,7 +1872,11 @@
 		/*
 		 * Check the compression type
 		 */
+        // CJH: Check to see if comp has alredy been defined
+		if(!comp)
+        {
 		comp = lookup_compressor_id(sBlk.s.compression);
+        }
 		return TRUE;
 	}
 
@@ -1813,6 +1890,9 @@
 	/*
 	 * Check it is a SQUASHFS superblock
 	 */
+	/*
+	 * CJH: swap detection already done generically above
+     *
 	swap = 0;
 	if(sBlk_3.s_magic != SQUASHFS_MAGIC) {
 		if(sBlk_3.s_magic == SQUASHFS_MAGIC_SWAP) {
@@ -1828,6 +1908,13 @@
 			goto failed_mount;
 		}
 	}
+    */
+    if(swap)
+    {
+        squashfs_super_block_3 sblk;
+        SQUASHFS_SWAP_SUPER_BLOCK_3(&sblk, &sBlk_3);
+        memcpy(&sBlk_3, &sblk, sizeof(squashfs_super_block_3));
+    }
 
 	sBlk.s.s_magic = sBlk_3.s_magic;
 	sBlk.s.inodes = sBlk_3.inodes;
@@ -1850,14 +1937,22 @@
 	sBlk.guid_start = sBlk_3.guid_start;
 	sBlk.s.xattr_id_table_start = SQUASHFS_INVALID_BLK;
 
+    // CJH: Update super struct with override values
+    if(override.s_major)
+        sBlk.s.s_major = override.s_major;
+    if(override.s_minor)
+        sBlk.s.s_minor = override.s_minor;
+
 	/* Check the MAJOR & MINOR versions */
-	if(sBlk.s.s_major == 1 || sBlk.s.s_major == 2) {
+    // CJH: Added s_major override
+	if((sBlk.s.s_major == 1 || sBlk.s.s_major == 2)) {
 		sBlk.s.bytes_used = sBlk_3.bytes_used_2;
 		sBlk.uid_start = sBlk_3.uid_start_2;
 		sBlk.guid_start = sBlk_3.guid_start_2;
 		sBlk.s.inode_table_start = sBlk_3.inode_table_start_2;
 		sBlk.s.directory_table_start = sBlk_3.directory_table_start_2;
 		
+        // CJH: Added s_major override
 		if(sBlk.s.s_major == 1) {
 			sBlk.s.block_size = sBlk_3.block_size_1;
 			sBlk.s.fragment_table_start = sBlk.uid_start;
@@ -1893,7 +1988,11 @@
 	/*
 	 * 1.x, 2.x and 3.x filesystems use gzip compression.
 	 */
+    // CJH: Check to see if comp has alredy been defined
+    if(!comp)
+    {
 	comp = lookup_compressor("gzip");
+    }
 	return TRUE;
 
 failed_mount:
@@ -2106,11 +2205,15 @@
 			SQUASHFS_COMPRESSED_SIZE_BLOCK(entry->size), block_size,
 			&error);
 
+        /* CJH: Compression errors are displayed elsewhere
 		if(res == -1)
 			ERROR("%s uncompress failed with error code %d\n",
 				comp->name, error);
 		else
 			memcpy(entry->data, tmp, res);
+        */
+        if(res != -1)
+            memcpy(entry->data, tmp, res);
 
 		/*
 		 * block has been either successfully decompressed, or an error
@@ -2505,6 +2608,9 @@
 	int fragment_buffer_size = FRAGMENT_BUFFER_DEFAULT;
 	int data_buffer_size = DATA_BUFFER_DEFAULT;
 
+    // CJH: Initialize verbosity to FALSE
+    verbose = FALSE;
+
 	pthread_mutex_init(&screen_mutex, NULL);
 	root_process = geteuid() == 0;
 	if(root_process)
@@ -2611,6 +2717,83 @@
 		} else if(strcmp(argv[i], "-regex") == 0 ||
 				strcmp(argv[i], "-r") == 0)
 			use_regex = TRUE;
+        // CJH: Added -comp, -be, -le, -major, -minor options
+        else if(strcmp(argv[i], "-c") == 0 ||
+                strcmp(argv[i], "-comp") == 0) {
+            if(++i == argc) {
+                fprintf(stderr, "%s: -comp missing compression option\n",
+                    argv[0]);
+                exit(1);
+            }
+            comp = lookup_compressor(argv[i]);
+        } else if(strcmp(argv[i], "-major") == 0) {
+            if(++i == argc) {
+                fprintf(stderr, "%s: -major missing version option\n",
+                    argv[0]);
+                exit(1);
+            }
+            override.s_major = atoi(argv[i]);
+        } else if(strcmp(argv[i], "-minor") == 0) {
+            if(++i == argc) {
+                fprintf(stderr, "%s: -minor missing version option\n",
+                    argv[0]);
+                exit(1);
+            }
+            override.s_minor = atoi(argv[i]);
+        } else if(strcmp(argv[i], "-lc") == 0) {
+            if(++i == argc) {
+                fprintf(stderr, "%s: -lc missing value option\n",
+                    argv[0]);
+                exit(1);
+            }
+            override.lc.value = atoi(argv[i]);
+            override.lc.set = TRUE;
+        } else if(strcmp(argv[i], "-lp") == 0) {
+            if(++i == argc) {
+                fprintf(stderr, "%s: -lp missing value option\n",
+                    argv[0]);
+                exit(1);
+            }
+            override.lp.value = atoi(argv[i]);
+            override.lp.set = TRUE;
+        } else if(strcmp(argv[i], "-pb") == 0) {
+            if(++i == argc) {
+                fprintf(stderr, "%s: -pb missing value option\n",
+                    argv[0]);
+                exit(1);
+            }
+            override.pb.value = atoi(argv[i]);
+            override.pb.set = TRUE;
+        } else if(strcmp(argv[i], "-dict") == 0) {
+            if(++i == argc) {
+                fprintf(stderr, "%s: -dict missing value option\n",
+                    argv[0]);
+                exit(1);
+            }
+            override.dictionary_size.value = atoi(argv[i]);
+            override.dictionary_size.set = TRUE;
+        } else if(strcmp(argv[i], "-lzma-offset") == 0) {
+            if(++i == argc) {
+                fprintf(stderr, "%s: -lzma-offset missing value option\n",
+                    argv[0]);
+                exit(1);
+            }
+            override.offset.value = atoi(argv[i]);
+            override.offset.set = TRUE;
+        } else if(strcmp(argv[i], "-be") == 0)
+#if __BYTE_ORDER == __BIG_ENDIAN
+            swap = 0;
+#else
+            swap = 1;
+#endif
+        else if(strcmp(argv[i], "-le") == 0)
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+            swap = 0;
+#else
+            swap = 1;
+#endif
+        else if(strcmp(argv[i], "-trace") == 0)
+            verbose = TRUE;
 		else
 			goto options;
 	}
@@ -2674,6 +2857,22 @@
 				"regular expressions\n");
 			ERROR("\t\t\t\trather than use the default shell "
 				"wildcard\n\t\t\t\texpansion (globbing)\n");
+            // CJH: Added -comp, -be, -le, -major, -minor, -trace and lzma options help output
+            ERROR("\n");
+            ERROR("\t-trace\t\t\tEnable verbose trace output\n");
+            ERROR("\t-lc <value>\t\tSet the lzma-adaptive lc parameter [0-4]\n");
+            ERROR("\t-lp <value>\t\tSet the lzma-adaptive lp parameter [0-4]\n");
+            ERROR("\t-pb <value>\t\tSet the lzma-adaptive pb parameter [0-8]\n");
+            ERROR("\t-dict <value>\t\tSet the lzma-adaptive dictionary size\n");
+            ERROR("\t-lzma-offset <value>\tSet the lzma-adaptive LZMA data offset\n");
+            ERROR("\t-major <version>\tManually set the SquashFS major "
+                "version number\n");
+            ERROR("\t-minor <version>\tManually set the SquashFS minor "
+                "version number\n");
+            ERROR("\t-be\t\t\tTreat the filesystem as big endian\n");
+            ERROR("\t-le\t\t\tTreat the filesystem as little endian\n");
+			ERROR("\t-c[omp] <decompressor>\tSpecify the "
+				"decompressor to use\n");
 			ERROR("\nDecompressors available:\n");
 			display_compressors("", "");
 		}
diff --color --strip-trailing-cr -NBbaur squashfs-tools/unsquashfs.c.orig squashfs-tools-patched/unsquashfs.c.orig
--- squashfs-tools/unsquashfs.c.orig	1970-01-01 08:00:00.000000000 +0800
+++ squashfs-tools-patched/unsquashfs.c.orig	2014-05-13 06:18:35.000000000 +0800
@@ -0,0 +1,2814 @@
+/*
+ * Unsquash a squashfs filesystem.  This is a highly compressed read only
+ * filesystem.
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,
+ * 2012, 2013, 2014
+ * Phillip Lougher <phillip@squashfs.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * unsquashfs.c
+ */
+
+#include "unsquashfs.h"
+#include "squashfs_swap.h"
+#include "squashfs_compat.h"
+#include "compressor.h"
+#include "xattr.h"
+#include "unsquashfs_info.h"
+#include "stdarg.h"
+
+#include <sys/sysinfo.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <limits.h>
+#include <ctype.h>
+
+struct cache *fragment_cache, *data_cache;
+struct queue *to_reader, *to_inflate, *to_writer, *from_writer;
+pthread_t *thread, *inflator_thread;
+pthread_mutex_t	fragment_mutex;
+
+/* user options that control parallelisation */
+int processors = -1;
+
+struct super_block sBlk;
+squashfs_operations s_ops;
+struct compressor *comp;
+
+int bytes = 0, swap, file_count = 0, dir_count = 0, sym_count = 0,
+	dev_count = 0, fifo_count = 0;
+char *inode_table = NULL, *directory_table = NULL;
+struct hash_table_entry *inode_table_hash[65536], *directory_table_hash[65536];
+int fd;
+unsigned int *uid_table, *guid_table;
+unsigned int cached_frag = SQUASHFS_INVALID_FRAG;
+char *fragment_data;
+char *file_data;
+char *data;
+unsigned int block_size;
+unsigned int block_log;
+int lsonly = FALSE, info = FALSE, force = FALSE, short_ls = TRUE;
+int use_regex = FALSE;
+char **created_inode;
+int root_process;
+int columns;
+int rotate = 0;
+pthread_mutex_t	screen_mutex;
+int progress = TRUE, progress_enabled = FALSE;
+unsigned int total_blocks = 0, total_files = 0, total_inodes = 0;
+unsigned int cur_blocks = 0;
+int inode_number = 1;
+int no_xattrs = XATTR_DEF;
+int user_xattrs = FALSE;
+
+int lookup_type[] = {
+	0,
+	S_IFDIR,
+	S_IFREG,
+	S_IFLNK,
+	S_IFBLK,
+	S_IFCHR,
+	S_IFIFO,
+	S_IFSOCK,
+	S_IFDIR,
+	S_IFREG,
+	S_IFLNK,
+	S_IFBLK,
+	S_IFCHR,
+	S_IFIFO,
+	S_IFSOCK
+};
+
+struct test table[] = {
+	{ S_IFMT, S_IFSOCK, 0, 's' },
+	{ S_IFMT, S_IFLNK, 0, 'l' },
+	{ S_IFMT, S_IFBLK, 0, 'b' },
+	{ S_IFMT, S_IFDIR, 0, 'd' },
+	{ S_IFMT, S_IFCHR, 0, 'c' },
+	{ S_IFMT, S_IFIFO, 0, 'p' },
+	{ S_IRUSR, S_IRUSR, 1, 'r' },
+	{ S_IWUSR, S_IWUSR, 2, 'w' },
+	{ S_IRGRP, S_IRGRP, 4, 'r' },
+	{ S_IWGRP, S_IWGRP, 5, 'w' },
+	{ S_IROTH, S_IROTH, 7, 'r' },
+	{ S_IWOTH, S_IWOTH, 8, 'w' },
+	{ S_IXUSR | S_ISUID, S_IXUSR | S_ISUID, 3, 's' },
+	{ S_IXUSR | S_ISUID, S_ISUID, 3, 'S' },
+	{ S_IXUSR | S_ISUID, S_IXUSR, 3, 'x' },
+	{ S_IXGRP | S_ISGID, S_IXGRP | S_ISGID, 6, 's' },
+	{ S_IXGRP | S_ISGID, S_ISGID, 6, 'S' },
+	{ S_IXGRP | S_ISGID, S_IXGRP, 6, 'x' },
+	{ S_IXOTH | S_ISVTX, S_IXOTH | S_ISVTX, 9, 't' },
+	{ S_IXOTH | S_ISVTX, S_ISVTX, 9, 'T' },
+	{ S_IXOTH | S_ISVTX, S_IXOTH, 9, 'x' },
+	{ 0, 0, 0, 0}
+};
+
+void progress_bar(long long current, long long max, int columns);
+
+#define MAX_LINE 16384
+
+void prep_exit()
+{
+}
+
+
+void sigwinch_handler()
+{
+	struct winsize winsize;
+
+	if(ioctl(1, TIOCGWINSZ, &winsize) == -1) {
+		if(isatty(STDOUT_FILENO))
+			ERROR("TIOCGWINSZ ioctl failed, defaulting to 80 "
+				"columns\n");
+		columns = 80;
+	} else
+		columns = winsize.ws_col;
+}
+
+
+void sigalrm_handler()
+{
+	rotate = (rotate + 1) % 4;
+}
+
+
+int add_overflow(int a, int b)
+{
+	return (INT_MAX - a) < b;
+}
+
+
+int shift_overflow(int a, int shift)
+{
+	return (INT_MAX >> shift) < a;
+}
+
+ 
+int multiply_overflow(int a, int multiplier)
+{
+	return (INT_MAX / multiplier) < a;
+}
+
+
+struct queue *queue_init(int size)
+{
+	struct queue *queue = malloc(sizeof(struct queue));
+
+	if(queue == NULL)
+		EXIT_UNSQUASH("Out of memory in queue_init\n");
+
+	if(add_overflow(size, 1) ||
+				multiply_overflow(size + 1, sizeof(void *)))
+		EXIT_UNSQUASH("Size too large in queue_init\n");
+
+	queue->data = malloc(sizeof(void *) * (size + 1));
+	if(queue->data == NULL)
+		EXIT_UNSQUASH("Out of memory in queue_init\n");
+
+	queue->size = size + 1;
+	queue->readp = queue->writep = 0;
+	pthread_mutex_init(&queue->mutex, NULL);
+	pthread_cond_init(&queue->empty, NULL);
+	pthread_cond_init(&queue->full, NULL);
+
+	return queue;
+}
+
+
+void queue_put(struct queue *queue, void *data)
+{
+	int nextp;
+
+	pthread_mutex_lock(&queue->mutex);
+
+	while((nextp = (queue->writep + 1) % queue->size) == queue->readp)
+		pthread_cond_wait(&queue->full, &queue->mutex);
+
+	queue->data[queue->writep] = data;
+	queue->writep = nextp;
+	pthread_cond_signal(&queue->empty);
+	pthread_mutex_unlock(&queue->mutex);
+}
+
+
+void *queue_get(struct queue *queue)
+{
+	void *data;
+	pthread_mutex_lock(&queue->mutex);
+
+	while(queue->readp == queue->writep)
+		pthread_cond_wait(&queue->empty, &queue->mutex);
+
+	data = queue->data[queue->readp];
+	queue->readp = (queue->readp + 1) % queue->size;
+	pthread_cond_signal(&queue->full);
+	pthread_mutex_unlock(&queue->mutex);
+
+	return data;
+}
+
+
+void dump_queue(struct queue *queue)
+{
+	pthread_mutex_lock(&queue->mutex);
+
+	printf("Max size %d, size %d%s\n", queue->size - 1,  
+		queue->readp <= queue->writep ? queue->writep - queue->readp :
+			queue->size - queue->readp + queue->writep,
+		queue->readp == queue->writep ? " (EMPTY)" :
+			((queue->writep + 1) % queue->size) == queue->readp ?
+			" (FULL)" : "");
+
+	pthread_mutex_unlock(&queue->mutex);
+}
+
+
+/* Called with the cache mutex held */
+void insert_hash_table(struct cache *cache, struct cache_entry *entry)
+{
+	int hash = CALCULATE_HASH(entry->block);
+
+	entry->hash_next = cache->hash_table[hash];
+	cache->hash_table[hash] = entry;
+	entry->hash_prev = NULL;
+	if(entry->hash_next)
+		entry->hash_next->hash_prev = entry;
+}
+
+
+/* Called with the cache mutex held */
+void remove_hash_table(struct cache *cache, struct cache_entry *entry)
+{
+	if(entry->hash_prev)
+		entry->hash_prev->hash_next = entry->hash_next;
+	else
+		cache->hash_table[CALCULATE_HASH(entry->block)] =
+			entry->hash_next;
+	if(entry->hash_next)
+		entry->hash_next->hash_prev = entry->hash_prev;
+
+	entry->hash_prev = entry->hash_next = NULL;
+}
+
+
+/* Called with the cache mutex held */
+void insert_free_list(struct cache *cache, struct cache_entry *entry)
+{
+	if(cache->free_list) {
+		entry->free_next = cache->free_list;
+		entry->free_prev = cache->free_list->free_prev;
+		cache->free_list->free_prev->free_next = entry;
+		cache->free_list->free_prev = entry;
+	} else {
+		cache->free_list = entry;
+		entry->free_prev = entry->free_next = entry;
+	}
+}
+
+
+/* Called with the cache mutex held */
+void remove_free_list(struct cache *cache, struct cache_entry *entry)
+{
+	if(entry->free_prev == NULL || entry->free_next == NULL)
+		/* not in free list */
+		return;
+	else if(entry->free_prev == entry && entry->free_next == entry) {
+		/* only this entry in the free list */
+		cache->free_list = NULL;
+	} else {
+		/* more than one entry in the free list */
+		entry->free_next->free_prev = entry->free_prev;
+		entry->free_prev->free_next = entry->free_next;
+		if(cache->free_list == entry)
+			cache->free_list = entry->free_next;
+	}
+
+	entry->free_prev = entry->free_next = NULL;
+}
+
+
+struct cache *cache_init(int buffer_size, int max_buffers)
+{
+	struct cache *cache = malloc(sizeof(struct cache));
+
+	if(cache == NULL)
+		EXIT_UNSQUASH("Out of memory in cache_init\n");
+
+	cache->max_buffers = max_buffers;
+	cache->buffer_size = buffer_size;
+	cache->count = 0;
+	cache->used = 0;
+	cache->free_list = NULL;
+	memset(cache->hash_table, 0, sizeof(struct cache_entry *) * 65536);
+	cache->wait_free = FALSE;
+	cache->wait_pending = FALSE;
+	pthread_mutex_init(&cache->mutex, NULL);
+	pthread_cond_init(&cache->wait_for_free, NULL);
+	pthread_cond_init(&cache->wait_for_pending, NULL);
+
+	return cache;
+}
+
+
+struct cache_entry *cache_get(struct cache *cache, long long block, int size)
+{
+	/*
+	 * Get a block out of the cache.  If the block isn't in the cache
+ 	 * it is added and queued to the reader() and inflate() threads for
+ 	 * reading off disk and decompression.  The cache grows until max_blocks
+ 	 * is reached, once this occurs existing discarded blocks on the free
+ 	 * list are reused
+ 	 */
+	int hash = CALCULATE_HASH(block);
+	struct cache_entry *entry;
+
+	pthread_mutex_lock(&cache->mutex);
+
+	for(entry = cache->hash_table[hash]; entry; entry = entry->hash_next)
+		if(entry->block == block)
+			break;
+
+	if(entry) {
+		/*
+ 		 * found the block in the cache.  If the block is currently unused
+		 * remove it from the free list and increment cache used count.
+ 		 */
+		if(entry->used == 0) {
+			cache->used ++;
+			remove_free_list(cache, entry);
+		}
+		entry->used ++;
+		pthread_mutex_unlock(&cache->mutex);
+	} else {
+		/*
+ 		 * not in the cache
+		 *
+		 * first try to allocate new block
+		 */
+		if(cache->count < cache->max_buffers) {
+			entry = malloc(sizeof(struct cache_entry));
+			if(entry == NULL)
+				EXIT_UNSQUASH("Out of memory in cache_get\n");
+			entry->data = malloc(cache->buffer_size);
+			if(entry->data == NULL)
+				EXIT_UNSQUASH("Out of memory in cache_get\n");
+			entry->cache = cache;
+			entry->free_prev = entry->free_next = NULL;
+			cache->count ++;
+		} else {
+			/*
+			 * try to get from free list
+			 */
+			while(cache->free_list == NULL) {
+				cache->wait_free = TRUE;
+				pthread_cond_wait(&cache->wait_for_free,
+					&cache->mutex);
+			}
+			entry = cache->free_list;
+			remove_free_list(cache, entry);
+			remove_hash_table(cache, entry);
+		}
+
+		/*
+		 * Initialise block and insert into the hash table.
+		 * Increment used which tracks how many buffers in the
+		 * cache are actively in use (the other blocks, count - used,
+		 * are in the cache and available for lookup, but can also be
+		 * re-used).
+		 */
+		entry->block = block;
+		entry->size = size;
+		entry->used = 1;
+		entry->error = FALSE;
+		entry->pending = TRUE;
+		insert_hash_table(cache, entry);
+		cache->used ++;
+
+		/*
+		 * queue to read thread to read and ultimately (via the
+		 * decompress threads) decompress the buffer
+ 		 */
+		pthread_mutex_unlock(&cache->mutex);
+		queue_put(to_reader, entry);
+	}
+
+	return entry;
+}
+
+	
+void cache_block_ready(struct cache_entry *entry, int error)
+{
+	/*
+	 * mark cache entry as being complete, reading and (if necessary)
+ 	 * decompression has taken place, and the buffer is valid for use.
+ 	 * If an error occurs reading or decompressing, the buffer also 
+ 	 * becomes ready but with an error...
+ 	 */
+	pthread_mutex_lock(&entry->cache->mutex);
+	entry->pending = FALSE;
+	entry->error = error;
+
+	/*
+	 * if the wait_pending flag is set, one or more threads may be waiting
+	 * on this buffer
+	 */
+	if(entry->cache->wait_pending) {
+		entry->cache->wait_pending = FALSE;
+		pthread_cond_broadcast(&entry->cache->wait_for_pending);
+	}
+
+	pthread_mutex_unlock(&entry->cache->mutex);
+}
+
+
+void cache_block_wait(struct cache_entry *entry)
+{
+	/*
+	 * wait for this cache entry to become ready, when reading and (if
+	 * necessary) decompression has taken place
+	 */
+	pthread_mutex_lock(&entry->cache->mutex);
+
+	while(entry->pending) {
+		entry->cache->wait_pending = TRUE;
+		pthread_cond_wait(&entry->cache->wait_for_pending,
+			&entry->cache->mutex);
+	}
+
+	pthread_mutex_unlock(&entry->cache->mutex);
+}
+
+
+void cache_block_put(struct cache_entry *entry)
+{
+	/*
+	 * finished with this cache entry, once the usage count reaches zero it
+ 	 * can be reused and is put onto the free list.  As it remains
+ 	 * accessible via the hash table it can be found getting a new lease of
+ 	 * life before it is reused.
+ 	 */
+	pthread_mutex_lock(&entry->cache->mutex);
+
+	entry->used --;
+	if(entry->used == 0) {
+		insert_free_list(entry->cache, entry);
+		entry->cache->used --;
+
+		/*
+		 * if the wait_free flag is set, one or more threads may be
+		 * waiting on this buffer
+		 */
+		if(entry->cache->wait_free) {
+			entry->cache->wait_free = FALSE;
+			pthread_cond_broadcast(&entry->cache->wait_for_free);
+		}
+	}
+
+	pthread_mutex_unlock(&entry->cache->mutex);
+}
+
+
+void dump_cache(struct cache *cache)
+{
+	pthread_mutex_lock(&cache->mutex);
+
+	printf("Max buffers %d, Current size %d, Used %d,  %s\n",
+		cache->max_buffers, cache->count, cache->used,
+		cache->free_list ?  "Free buffers" : "No free buffers");
+
+	pthread_mutex_unlock(&cache->mutex);
+}
+
+
+char *modestr(char *str, int mode)
+{
+	int i;
+
+	strcpy(str, "----------");
+
+	for(i = 0; table[i].mask != 0; i++) {
+		if((mode & table[i].mask) == table[i].value)
+			str[table[i].position] = table[i].mode;
+	}
+
+	return str;
+}
+
+
+#define TOTALCHARS  25
+int print_filename(char *pathname, struct inode *inode)
+{
+	char str[11], dummy[12], dummy2[12]; /* overflow safe */
+	char *userstr, *groupstr;
+	int padchars;
+	struct passwd *user;
+	struct group *group;
+	struct tm *t;
+
+	if(short_ls) {
+		printf("%s\n", pathname);
+		return 1;
+	}
+
+	user = getpwuid(inode->uid);
+	if(user == NULL) {
+		int res = snprintf(dummy, 12, "%d", inode->uid);
+		if(res < 0)
+			EXIT_UNSQUASH("snprintf failed in print_filename()\n");
+		else if(res >= 12)
+			/* unsigned int shouldn't ever need more than 11 bytes
+			 * (including terminating '\0') to print in base 10 */
+			userstr = "*";
+		else
+			userstr = dummy;
+	} else
+		userstr = user->pw_name;
+		 
+	group = getgrgid(inode->gid);
+	if(group == NULL) {
+		int res = snprintf(dummy2, 12, "%d", inode->gid);
+		if(res < 0)
+			EXIT_UNSQUASH("snprintf failed in print_filename()\n");
+		else if(res >= 12)
+			/* unsigned int shouldn't ever need more than 11 bytes
+			 * (including terminating '\0') to print in base 10 */
+			groupstr = "*";
+		else
+			groupstr = dummy2;
+	} else
+		groupstr = group->gr_name;
+
+	printf("%s %s/%s ", modestr(str, inode->mode), userstr, groupstr);
+
+	switch(inode->mode & S_IFMT) {
+		case S_IFREG:
+		case S_IFDIR:
+		case S_IFSOCK:
+		case S_IFIFO:
+		case S_IFLNK:
+			padchars = TOTALCHARS - strlen(userstr) -
+				strlen(groupstr);
+
+			printf("%*lld ", padchars > 0 ? padchars : 0,
+				inode->data);
+			break;
+		case S_IFCHR:
+		case S_IFBLK:
+			padchars = TOTALCHARS - strlen(userstr) -
+				strlen(groupstr) - 7; 
+
+			printf("%*s%3d,%3d ", padchars > 0 ? padchars : 0, " ",
+				(int) inode->data >> 8, (int) inode->data &
+				0xff);
+			break;
+	}
+
+	t = localtime(&inode->time);
+
+	printf("%d-%02d-%02d %02d:%02d %s", t->tm_year + 1900, t->tm_mon + 1,
+		t->tm_mday, t->tm_hour, t->tm_min, pathname);
+	if((inode->mode & S_IFMT) == S_IFLNK)
+		printf(" -> %s", inode->symlink);
+	printf("\n");
+		
+	return 1;
+}
+	
+
+void add_entry(struct hash_table_entry *hash_table[], long long start,
+	int bytes)
+{
+	int hash = CALCULATE_HASH(start);
+	struct hash_table_entry *hash_table_entry;
+
+	hash_table_entry = malloc(sizeof(struct hash_table_entry));
+	if(hash_table_entry == NULL)
+		EXIT_UNSQUASH("Out of memory in add_entry\n");
+
+	hash_table_entry->start = start;
+	hash_table_entry->bytes = bytes;
+	hash_table_entry->next = hash_table[hash];
+	hash_table[hash] = hash_table_entry;
+}
+
+
+int lookup_entry(struct hash_table_entry *hash_table[], long long start)
+{
+	int hash = CALCULATE_HASH(start);
+	struct hash_table_entry *hash_table_entry;
+
+	for(hash_table_entry = hash_table[hash]; hash_table_entry;
+				hash_table_entry = hash_table_entry->next)
+
+		if(hash_table_entry->start == start)
+			return hash_table_entry->bytes;
+
+	return -1;
+}
+
+
+int read_fs_bytes(int fd, long long byte, int bytes, void *buff)
+{
+	off_t off = byte;
+	int res, count;
+
+	TRACE("read_bytes: reading from position 0x%llx, bytes %d\n", byte,
+		bytes);
+
+	if(lseek(fd, off, SEEK_SET) == -1) {
+		ERROR("Lseek failed because %s\n", strerror(errno));
+		return FALSE;
+	}
+
+	for(count = 0; count < bytes; count += res) {
+		res = read(fd, buff + count, bytes - count);
+		if(res < 1) {
+			if(res == 0) {
+				ERROR("Read on filesystem failed because "
+					"EOF\n");
+				return FALSE;
+			} else if(errno != EINTR) {
+				ERROR("Read on filesystem failed because %s\n",
+						strerror(errno));
+				return FALSE;
+			} else
+				res = 0;
+		}
+	}
+
+	return TRUE;
+}
+
+
+int read_block(int fd, long long start, long long *next, int expected,
+								void *block)
+{
+	unsigned short c_byte;
+	int offset = 2, res, compressed;
+	int outlen = expected ? expected : SQUASHFS_METADATA_SIZE;
+	
+	if(swap) {
+		if(read_fs_bytes(fd, start, 2, &c_byte) == FALSE)
+			goto failed;
+		c_byte = (c_byte >> 8) | ((c_byte & 0xff) << 8);
+	} else 
+		if(read_fs_bytes(fd, start, 2, &c_byte) == FALSE)
+			goto failed;
+
+	TRACE("read_block: block @0x%llx, %d %s bytes\n", start,
+		SQUASHFS_COMPRESSED_SIZE(c_byte), SQUASHFS_COMPRESSED(c_byte) ?
+		"compressed" : "uncompressed");
+
+	if(SQUASHFS_CHECK_DATA(sBlk.s.flags))
+		offset = 3;
+
+	compressed = SQUASHFS_COMPRESSED(c_byte);
+	c_byte = SQUASHFS_COMPRESSED_SIZE(c_byte);
+
+	/*
+	 * The block size should not be larger than
+	 * the uncompressed size (or max uncompressed size if
+	 * expected is 0)
+	 */
+	if(c_byte > outlen)
+		return 0;
+
+	if(compressed) {
+		char buffer[c_byte];
+		int error;
+
+		res = read_fs_bytes(fd, start + offset, c_byte, buffer);
+		if(res == FALSE)
+			goto failed;
+
+		res = compressor_uncompress(comp, block, buffer, c_byte,
+			outlen, &error);
+
+		if(res == -1) {
+			ERROR("%s uncompress failed with error code %d\n",
+				comp->name, error);
+			goto failed;
+		}
+	} else {
+		res = read_fs_bytes(fd, start + offset, c_byte, block);
+		if(res == FALSE)
+			goto failed;
+		res = c_byte;
+	}
+
+	if(next)
+		*next = start + offset + c_byte;
+
+	/*
+	 * if expected, then check the (uncompressed) return data
+	 * is of the expected size
+	 */
+	if(expected && expected != res)
+		return 0;
+	else
+		return res;
+
+failed:
+	ERROR("read_block: failed to read block @0x%llx\n", start);
+	return FALSE;
+}
+
+
+int read_data_block(long long start, unsigned int size, char *block)
+{
+	int error, res;
+	int c_byte = SQUASHFS_COMPRESSED_SIZE_BLOCK(size);
+
+	TRACE("read_data_block: block @0x%llx, %d %s bytes\n", start,
+		c_byte, SQUASHFS_COMPRESSED_BLOCK(size) ? "compressed" :
+		"uncompressed");
+
+	if(SQUASHFS_COMPRESSED_BLOCK(size)) {
+		if(read_fs_bytes(fd, start, c_byte, data) == FALSE)
+			goto failed;
+
+		res = compressor_uncompress(comp, block, data, c_byte,
+			block_size, &error);
+
+		if(res == -1) {
+			ERROR("%s uncompress failed with error code %d\n",
+				comp->name, error);
+			goto failed;
+		}
+
+		return res;
+	} else {
+		if(read_fs_bytes(fd, start, c_byte, block) == FALSE)
+			goto failed;
+
+		return c_byte;
+	}
+
+failed:
+	ERROR("read_data_block: failed to read block @0x%llx, size %d\n", start,
+		c_byte);
+	return FALSE;
+}
+
+
+int read_inode_table(long long start, long long end)
+{
+	int size = 0, bytes = 0, res;
+
+	TRACE("read_inode_table: start %lld, end %lld\n", start, end);
+
+	while(start < end) {
+		if(size - bytes < SQUASHFS_METADATA_SIZE) {
+			inode_table = realloc(inode_table, size +=
+				SQUASHFS_METADATA_SIZE);
+			if(inode_table == NULL) {
+				ERROR("Out of memory in read_inode_table");
+				goto failed;
+			}
+		}
+
+		add_entry(inode_table_hash, start, bytes);
+
+		res = read_block(fd, start, &start, 0, inode_table + bytes);
+		if(res == 0) {
+			ERROR("read_inode_table: failed to read block\n");
+			goto failed;
+		}
+		bytes += res;
+
+		/*
+		 * If this is not the last metadata block in the inode table
+		 * then it should be SQUASHFS_METADATA_SIZE in size.
+		 * Note, we can't use expected in read_block() above for this
+		 * because we don't know if this is the last block until
+		 * after reading.
+		 */
+		if(start != end && res != SQUASHFS_METADATA_SIZE) {
+			ERROR("read_inode_table: metadata block should be %d "
+				"bytes in length, it is %d bytes\n",
+				SQUASHFS_METADATA_SIZE, res);
+			
+			goto failed;
+		}
+	}
+
+	return TRUE;
+
+failed:
+	free(inode_table);
+	return FALSE;
+}
+
+
+int set_attributes(char *pathname, int mode, uid_t uid, gid_t guid, time_t time,
+	unsigned int xattr, unsigned int set_mode)
+{
+	struct utimbuf times = { time, time };
+
+	write_xattr(pathname, xattr);
+
+	if(utime(pathname, &times) == -1) {
+		ERROR("set_attributes: failed to set time on %s, because %s\n",
+			pathname, strerror(errno));
+		return FALSE;
+	}
+
+	if(root_process) {
+		if(chown(pathname, uid, guid) == -1) {
+			ERROR("set_attributes: failed to change uid and gids "
+				"on %s, because %s\n", pathname,
+				strerror(errno));
+			return FALSE;
+		}
+	} else
+		mode &= ~07000;
+
+	if((set_mode || (mode & 07000)) && chmod(pathname, (mode_t) mode) == -1) {
+		ERROR("set_attributes: failed to change mode %s, because %s\n",
+			pathname, strerror(errno));
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+
+int write_bytes(int fd, char *buff, int bytes)
+{
+	int res, count;
+
+	for(count = 0; count < bytes; count += res) {
+		res = write(fd, buff + count, bytes - count);
+		if(res == -1) {
+			if(errno != EINTR) {
+				ERROR("Write on output file failed because "
+					"%s\n", strerror(errno));
+				return -1;
+			}
+			res = 0;
+		}
+	}
+
+	return 0;
+}
+
+
+int lseek_broken = FALSE;
+char *zero_data = NULL;
+
+int write_block(int file_fd, char *buffer, int size, long long hole, int sparse)
+{
+	off_t off = hole;
+
+	if(hole) {
+		if(sparse && lseek_broken == FALSE) {
+			 int error = lseek(file_fd, off, SEEK_CUR);
+			 if(error == -1)
+				/* failed to seek beyond end of file */
+				lseek_broken = TRUE;
+		}
+
+		if((sparse == FALSE || lseek_broken) && zero_data == NULL) {
+			if((zero_data = malloc(block_size)) == NULL)
+				EXIT_UNSQUASH("write_block: failed to alloc "
+					"zero data block\n");
+			memset(zero_data, 0, block_size);
+		}
+
+		if(sparse == FALSE || lseek_broken) {
+			int blocks = (hole + block_size -1) / block_size;
+			int avail_bytes, i;
+			for(i = 0; i < blocks; i++, hole -= avail_bytes) {
+				avail_bytes = hole > block_size ? block_size :
+					hole;
+				if(write_bytes(file_fd, zero_data, avail_bytes)
+						== -1)
+					goto failure;
+			}
+		}
+	}
+
+	if(write_bytes(file_fd, buffer, size) == -1)
+		goto failure;
+
+	return TRUE;
+
+failure:
+	return FALSE;
+}
+
+
+pthread_mutex_t open_mutex = PTHREAD_MUTEX_INITIALIZER;
+pthread_cond_t open_empty = PTHREAD_COND_INITIALIZER;
+int open_unlimited, open_count;
+#define OPEN_FILE_MARGIN 10
+
+
+void open_init(int count)
+{
+	open_count = count;
+	open_unlimited = count == -1;
+}
+
+
+int open_wait(char *pathname, int flags, mode_t mode)
+{
+	if (!open_unlimited) {
+		pthread_mutex_lock(&open_mutex);
+		while (open_count == 0)
+			pthread_cond_wait(&open_empty, &open_mutex);
+		open_count --;
+		pthread_mutex_unlock(&open_mutex);
+	}
+
+	return open(pathname, flags, mode);
+}
+
+
+void close_wake(int fd)
+{
+	close(fd);
+
+	if (!open_unlimited) {
+		pthread_mutex_lock(&open_mutex);
+		open_count ++;
+		pthread_cond_signal(&open_empty);
+		pthread_mutex_unlock(&open_mutex);
+	}
+}
+
+
+void queue_file(char *pathname, int file_fd, struct inode *inode)
+{
+	struct squashfs_file *file = malloc(sizeof(struct squashfs_file));
+	if(file == NULL)
+		EXIT_UNSQUASH("queue_file: unable to malloc file\n");
+
+	file->fd = file_fd;
+	file->file_size = inode->data;
+	file->mode = inode->mode;
+	file->gid = inode->gid;
+	file->uid = inode->uid;
+	file->time = inode->time;
+	file->pathname = strdup(pathname);
+	file->blocks = inode->blocks + (inode->frag_bytes > 0);
+	file->sparse = inode->sparse;
+	file->xattr = inode->xattr;
+	queue_put(to_writer, file);
+}
+
+
+void queue_dir(char *pathname, struct dir *dir)
+{
+	struct squashfs_file *file = malloc(sizeof(struct squashfs_file));
+	if(file == NULL)
+		EXIT_UNSQUASH("queue_dir: unable to malloc file\n");
+
+	file->fd = -1;
+	file->mode = dir->mode;
+	file->gid = dir->guid;
+	file->uid = dir->uid;
+	file->time = dir->mtime;
+	file->pathname = strdup(pathname);
+	file->xattr = dir->xattr;
+	queue_put(to_writer, file);
+}
+
+
+int write_file(struct inode *inode, char *pathname)
+{
+	unsigned int file_fd, i;
+	unsigned int *block_list;
+	int file_end = inode->data / block_size;
+	long long start = inode->start;
+
+	TRACE("write_file: regular file, blocks %d\n", inode->blocks);
+
+	file_fd = open_wait(pathname, O_CREAT | O_WRONLY |
+		(force ? O_TRUNC : 0), (mode_t) inode->mode & 0777);
+	if(file_fd == -1) {
+		ERROR("write_file: failed to create file %s, because %s\n",
+			pathname, strerror(errno));
+		return FALSE;
+	}
+
+	block_list = malloc(inode->blocks * sizeof(unsigned int));
+	if(block_list == NULL)
+		EXIT_UNSQUASH("write_file: unable to malloc block list\n");
+
+	s_ops.read_block_list(block_list, inode->block_ptr, inode->blocks);
+
+	/*
+	 * the writer thread is queued a squashfs_file structure describing the
+ 	 * file.  If the file has one or more blocks or a fragment they are
+ 	 * queued separately (references to blocks in the cache).
+ 	 */
+	queue_file(pathname, file_fd, inode);
+
+	for(i = 0; i < inode->blocks; i++) {
+		int c_byte = SQUASHFS_COMPRESSED_SIZE_BLOCK(block_list[i]);
+		struct file_entry *block = malloc(sizeof(struct file_entry));
+
+		if(block == NULL)
+			EXIT_UNSQUASH("write_file: unable to malloc file\n");
+		block->offset = 0;
+		block->size = i == file_end ? inode->data & (block_size - 1) :
+			block_size;
+		if(block_list[i] == 0) /* sparse block */
+			block->buffer = NULL;
+		else {
+			block->buffer = cache_get(data_cache, start,
+				block_list[i]);
+			start += c_byte;
+		}
+		queue_put(to_writer, block);
+	}
+
+	if(inode->frag_bytes) {
+		int size;
+		long long start;
+		struct file_entry *block = malloc(sizeof(struct file_entry));
+
+		if(block == NULL)
+			EXIT_UNSQUASH("write_file: unable to malloc file\n");
+		s_ops.read_fragment(inode->fragment, &start, &size);
+		block->buffer = cache_get(fragment_cache, start, size);
+		block->offset = inode->offset;
+		block->size = inode->frag_bytes;
+		queue_put(to_writer, block);
+	}
+
+	free(block_list);
+	return TRUE;
+}
+
+
+int create_inode(char *pathname, struct inode *i)
+{
+	TRACE("create_inode: pathname %s\n", pathname);
+
+	if(created_inode[i->inode_number - 1]) {
+		TRACE("create_inode: hard link\n");
+		if(force)
+			unlink(pathname);
+
+		if(link(created_inode[i->inode_number - 1], pathname) == -1) {
+			ERROR("create_inode: failed to create hardlink, "
+				"because %s\n", strerror(errno));
+			return FALSE;
+		}
+
+		return TRUE;
+	}
+
+	switch(i->type) {
+		case SQUASHFS_FILE_TYPE:
+		case SQUASHFS_LREG_TYPE:
+			TRACE("create_inode: regular file, file_size %lld, "
+				"blocks %d\n", i->data, i->blocks);
+
+			if(write_file(i, pathname))
+				file_count ++;
+			break;
+		case SQUASHFS_SYMLINK_TYPE:
+		case SQUASHFS_LSYMLINK_TYPE:
+			TRACE("create_inode: symlink, symlink_size %lld\n",
+				i->data);
+
+			if(force)
+				unlink(pathname);
+
+			if(symlink(i->symlink, pathname) == -1) {
+				ERROR("create_inode: failed to create symlink "
+					"%s, because %s\n", pathname,
+					strerror(errno));
+				break;
+			}
+
+			write_xattr(pathname, i->xattr);
+	
+			if(root_process) {
+				if(lchown(pathname, i->uid, i->gid) == -1)
+					ERROR("create_inode: failed to change "
+						"uid and gids on %s, because "
+						"%s\n", pathname,
+						strerror(errno));
+			}
+
+			sym_count ++;
+			break;
+ 		case SQUASHFS_BLKDEV_TYPE:
+	 	case SQUASHFS_CHRDEV_TYPE:
+ 		case SQUASHFS_LBLKDEV_TYPE:
+	 	case SQUASHFS_LCHRDEV_TYPE: {
+			int chrdev = i->type == SQUASHFS_CHRDEV_TYPE;
+			TRACE("create_inode: dev, rdev 0x%llx\n", i->data);
+
+			if(root_process) {
+				if(force)
+					unlink(pathname);
+
+				if(mknod(pathname, chrdev ? S_IFCHR : S_IFBLK,
+						makedev((i->data >> 8) & 0xff,
+						i->data & 0xff)) == -1) {
+					ERROR("create_inode: failed to create "
+						"%s device %s, because %s\n",
+						chrdev ? "character" : "block",
+						pathname, strerror(errno));
+					break;
+				}
+				set_attributes(pathname, i->mode, i->uid,
+					i->gid, i->time, i->xattr, TRUE);
+				dev_count ++;
+			} else
+				ERROR("create_inode: could not create %s "
+					"device %s, because you're not "
+					"superuser!\n", chrdev ? "character" :
+					"block", pathname);
+			break;
+		}
+		case SQUASHFS_FIFO_TYPE:
+		case SQUASHFS_LFIFO_TYPE:
+			TRACE("create_inode: fifo\n");
+
+			if(force)
+				unlink(pathname);
+
+			if(mknod(pathname, S_IFIFO, 0) == -1) {
+				ERROR("create_inode: failed to create fifo %s, "
+					"because %s\n", pathname,
+					strerror(errno));
+				break;
+			}
+			set_attributes(pathname, i->mode, i->uid, i->gid,
+				i->time, i->xattr, TRUE);
+			fifo_count ++;
+			break;
+		case SQUASHFS_SOCKET_TYPE:
+		case SQUASHFS_LSOCKET_TYPE:
+			TRACE("create_inode: socket\n");
+			ERROR("create_inode: socket %s ignored\n", pathname);
+			break;
+		default:
+			ERROR("Unknown inode type %d in create_inode_table!\n",
+				i->type);
+			return FALSE;
+	}
+
+	created_inode[i->inode_number - 1] = strdup(pathname);
+
+	return TRUE;
+}
+
+
+int read_directory_table(long long start, long long end)
+{
+	int bytes = 0, size = 0, res;
+
+	TRACE("read_directory_table: start %lld, end %lld\n", start, end);
+
+	while(start < end) {
+		if(size - bytes < SQUASHFS_METADATA_SIZE) {
+			directory_table = realloc(directory_table, size +=
+				SQUASHFS_METADATA_SIZE);
+			if(directory_table == NULL) {
+				ERROR("Out of memory in "
+						"read_directory_table\n");
+				goto failed;
+			}
+		}
+
+		add_entry(directory_table_hash, start, bytes);
+
+		res = read_block(fd, start, &start, 0, directory_table + bytes);
+		if(res == 0) {
+			ERROR("read_directory_table: failed to read block\n");
+			goto failed;
+		}
+
+		bytes += res;
+
+		/*
+		 * If this is not the last metadata block in the directory table
+		 * then it should be SQUASHFS_METADATA_SIZE in size.
+		 * Note, we can't use expected in read_block() above for this
+		 * because we don't know if this is the last block until
+		 * after reading.
+		 */
+		if(start != end && res != SQUASHFS_METADATA_SIZE) {
+			ERROR("read_directory_table: metadata block "
+				"should be %d bytes in length, it is %d "
+				"bytes\n", SQUASHFS_METADATA_SIZE, res);
+			goto failed;
+		}
+	}
+
+	return TRUE;
+
+failed:
+	free(directory_table);
+	return FALSE;
+}
+
+
+int squashfs_readdir(struct dir *dir, char **name, unsigned int *start_block,
+unsigned int *offset, unsigned int *type)
+{
+	if(dir->cur_entry == dir->dir_count)
+		return FALSE;
+
+	*name = dir->dirs[dir->cur_entry].name;
+	*start_block = dir->dirs[dir->cur_entry].start_block;
+	*offset = dir->dirs[dir->cur_entry].offset;
+	*type = dir->dirs[dir->cur_entry].type;
+	dir->cur_entry ++;
+
+	return TRUE;
+}
+
+
+void squashfs_closedir(struct dir *dir)
+{
+	free(dir->dirs);
+	free(dir);
+}
+
+
+char *get_component(char *target, char **targname)
+{
+	char *start;
+
+	while(*target == '/')
+		target ++;
+
+	start = target;
+	while(*target != '/' && *target != '\0')
+		target ++;
+
+	*targname = strndup(start, target - start);
+
+	while(*target == '/')
+		target ++;
+
+	return target;
+}
+
+
+void free_path(struct pathname *paths)
+{
+	int i;
+
+	for(i = 0; i < paths->names; i++) {
+		if(paths->name[i].paths)
+			free_path(paths->name[i].paths);
+		free(paths->name[i].name);
+		if(paths->name[i].preg) {
+			regfree(paths->name[i].preg);
+			free(paths->name[i].preg);
+		}
+	}
+
+	free(paths);
+}
+
+
+struct pathname *add_path(struct pathname *paths, char *target, char *alltarget)
+{
+	char *targname;
+	int i, error;
+
+	TRACE("add_path: adding \"%s\" extract file\n", target);
+
+	target = get_component(target, &targname);
+
+	if(paths == NULL) {
+		paths = malloc(sizeof(struct pathname));
+		if(paths == NULL)
+			EXIT_UNSQUASH("failed to allocate paths\n");
+
+		paths->names = 0;
+		paths->name = NULL;
+	}
+
+	for(i = 0; i < paths->names; i++)
+		if(strcmp(paths->name[i].name, targname) == 0)
+			break;
+
+	if(i == paths->names) {
+		/*
+		 * allocate new name entry
+		 */
+		paths->names ++;
+		paths->name = realloc(paths->name, (i + 1) *
+			sizeof(struct path_entry));
+		if(paths->name == NULL)
+			EXIT_UNSQUASH("Out of memory in add_path\n");	
+		paths->name[i].name = targname;
+		paths->name[i].paths = NULL;
+		if(use_regex) {
+			paths->name[i].preg = malloc(sizeof(regex_t));
+			if(paths->name[i].preg == NULL)
+				EXIT_UNSQUASH("Out of memory in add_path\n");
+			error = regcomp(paths->name[i].preg, targname,
+				REG_EXTENDED|REG_NOSUB);
+			if(error) {
+				char str[1024]; /* overflow safe */
+
+				regerror(error, paths->name[i].preg, str, 1024);
+				EXIT_UNSQUASH("invalid regex %s in export %s, "
+					"because %s\n", targname, alltarget,
+					str);
+			}
+		} else
+			paths->name[i].preg = NULL;
+
+		if(target[0] == '\0')
+			/*
+			 * at leaf pathname component
+			*/
+			paths->name[i].paths = NULL;
+		else
+			/*
+			 * recurse adding child components
+			 */
+			paths->name[i].paths = add_path(NULL, target, alltarget);
+	} else {
+		/*
+		 * existing matching entry
+		 */
+		free(targname);
+
+		if(paths->name[i].paths == NULL) {
+			/*
+			 * No sub-directory which means this is the leaf
+			 * component of a pre-existing extract which subsumes
+			 * the extract currently being added, in which case stop
+			 * adding components
+			 */
+		} else if(target[0] == '\0') {
+			/*
+			 * at leaf pathname component and child components exist
+			 * from more specific extracts, delete as they're
+			 * subsumed by this extract
+			 */
+			free_path(paths->name[i].paths);
+			paths->name[i].paths = NULL;
+		} else
+			/*
+			 * recurse adding child components
+			 */
+			add_path(paths->name[i].paths, target, alltarget);
+	}
+
+	return paths;
+}
+
+
+struct pathnames *init_subdir()
+{
+	struct pathnames *new = malloc(sizeof(struct pathnames));
+	if(new == NULL)
+		EXIT_UNSQUASH("Out of memory in init_subdir\n");
+	new->count = 0;
+	return new;
+}
+
+
+struct pathnames *add_subdir(struct pathnames *paths, struct pathname *path)
+{
+	if(paths->count % PATHS_ALLOC_SIZE == 0) {
+		paths = realloc(paths, sizeof(struct pathnames *) +
+			(paths->count + PATHS_ALLOC_SIZE) *
+			sizeof(struct pathname *));
+		if(paths == NULL)
+			EXIT_UNSQUASH("Out of memory in add_subdir\n");
+	}
+
+	paths->path[paths->count++] = path;
+	return paths;
+}
+
+
+void free_subdir(struct pathnames *paths)
+{
+	free(paths);
+}
+
+
+int matches(struct pathnames *paths, char *name, struct pathnames **new)
+{
+	int i, n;
+
+	if(paths == NULL) {
+		*new = NULL;
+		return TRUE;
+	}
+
+	*new = init_subdir();
+
+	for(n = 0; n < paths->count; n++) {
+		struct pathname *path = paths->path[n];
+		for(i = 0; i < path->names; i++) {
+			int match = use_regex ?
+				regexec(path->name[i].preg, name, (size_t) 0,
+				NULL, 0) == 0 : fnmatch(path->name[i].name,
+				name, FNM_PATHNAME|FNM_PERIOD|FNM_EXTMATCH) ==
+				0;
+			if(match && path->name[i].paths == NULL)
+				/*
+				 * match on a leaf component, any subdirectories
+				 * will implicitly match, therefore return an
+				 * empty new search set
+				 */
+				goto empty_set;
+
+			if(match)
+				/*
+				 * match on a non-leaf component, add any
+				 * subdirectories to the new set of
+				 * subdirectories to scan for this name
+				 */
+				*new = add_subdir(*new, path->name[i].paths);
+		}
+	}
+
+	if((*new)->count == 0) {
+		/*
+		 * no matching names found, delete empty search set, and return
+		 * FALSE
+		 */
+		free_subdir(*new);
+		*new = NULL;
+		return FALSE;
+	}
+
+	/*
+	 * one or more matches with sub-directories found (no leaf matches),
+	 * return new search set and return TRUE
+	 */
+	return TRUE;
+
+empty_set:
+	/*
+	 * found matching leaf exclude, return empty search set and return TRUE
+	 */
+	free_subdir(*new);
+	*new = NULL;
+	return TRUE;
+}
+
+
+void pre_scan(char *parent_name, unsigned int start_block, unsigned int offset,
+	struct pathnames *paths)
+{
+	unsigned int type;
+	char *name;
+	struct pathnames *new;
+	struct inode *i;
+	struct dir *dir = s_ops.squashfs_opendir(start_block, offset, &i);
+
+	if(dir == NULL)
+		return;
+
+	while(squashfs_readdir(dir, &name, &start_block, &offset, &type)) {
+		struct inode *i;
+		char *pathname;
+		int res;
+
+		TRACE("pre_scan: name %s, start_block %d, offset %d, type %d\n",
+			name, start_block, offset, type);
+
+		if(!matches(paths, name, &new))
+			continue;
+
+		res = asprintf(&pathname, "%s/%s", parent_name, name);
+		if(res == -1)
+			EXIT_UNSQUASH("asprintf failed in dir_scan\n");
+
+		if(type == SQUASHFS_DIR_TYPE)
+			pre_scan(parent_name, start_block, offset, new);
+		else if(new == NULL) {
+			if(type == SQUASHFS_FILE_TYPE ||
+					type == SQUASHFS_LREG_TYPE) {
+				i = s_ops.read_inode(start_block, offset);
+				if(created_inode[i->inode_number - 1] == NULL) {
+					created_inode[i->inode_number - 1] =
+						(char *) i;
+					total_blocks += (i->data +
+						(block_size - 1)) >> block_log;
+				}
+				total_files ++;
+			}
+			total_inodes ++;
+		}
+
+		free_subdir(new);
+		free(pathname);
+	}
+
+	squashfs_closedir(dir);
+}
+
+
+void dir_scan(char *parent_name, unsigned int start_block, unsigned int offset,
+	struct pathnames *paths)
+{
+	unsigned int type;
+	char *name;
+	struct pathnames *new;
+	struct inode *i;
+	struct dir *dir = s_ops.squashfs_opendir(start_block, offset, &i);
+
+	if(dir == NULL) {
+		ERROR("dir_scan: failed to read directory %s, skipping\n",
+			parent_name);
+		return;
+	}
+
+	if(lsonly || info)
+		print_filename(parent_name, i);
+
+	if(!lsonly) {
+		/*
+		 * Make directory with default User rwx permissions rather than
+		 * the permissions from the filesystem, as these may not have
+		 * write/execute permission.  These are fixed up later in
+		 * set_attributes().
+		 */
+		int res = mkdir(parent_name, S_IRUSR|S_IWUSR|S_IXUSR);
+		if(res == -1) {
+			/*
+			 * Skip directory if mkdir fails, unless we're
+			 * forcing and the error is -EEXIST
+			 */
+			if(!force || errno != EEXIST) {
+				ERROR("dir_scan: failed to make directory %s, "
+					"because %s\n", parent_name,
+					strerror(errno));
+				squashfs_closedir(dir);
+				return;
+			} 
+
+			/*
+			 * Try to change permissions of existing directory so
+			 * that we can write to it
+			 */
+			res = chmod(parent_name, S_IRUSR|S_IWUSR|S_IXUSR);
+			if (res == -1)
+				ERROR("dir_scan: failed to change permissions "
+					"for directory %s, because %s\n",
+					parent_name, strerror(errno));
+		}
+	}
+
+	while(squashfs_readdir(dir, &name, &start_block, &offset, &type)) {
+		char *pathname;
+		int res;
+
+		TRACE("dir_scan: name %s, start_block %d, offset %d, type %d\n",
+			name, start_block, offset, type);
+
+
+		if(!matches(paths, name, &new))
+			continue;
+
+		res = asprintf(&pathname, "%s/%s", parent_name, name);
+		if(res == -1)
+			EXIT_UNSQUASH("asprintf failed in dir_scan\n");
+
+		if(type == SQUASHFS_DIR_TYPE) {
+			dir_scan(pathname, start_block, offset, new);
+			free(pathname);
+		} else if(new == NULL) {
+			update_info(pathname);
+
+			i = s_ops.read_inode(start_block, offset);
+
+			if(lsonly || info)
+				print_filename(pathname, i);
+
+			if(!lsonly)
+				create_inode(pathname, i);
+
+			if(i->type == SQUASHFS_SYMLINK_TYPE ||
+					i->type == SQUASHFS_LSYMLINK_TYPE)
+				free(i->symlink);
+		} else
+			free(pathname);
+
+		free_subdir(new);
+	}
+
+	if(!lsonly)
+		queue_dir(parent_name, dir);
+
+	squashfs_closedir(dir);
+	dir_count ++;
+}
+
+
+void squashfs_stat(char *source)
+{
+	time_t mkfs_time = (time_t) sBlk.s.mkfs_time;
+	char *mkfs_str = ctime(&mkfs_time);
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+	printf("Found a valid %sSQUASHFS %d:%d superblock on %s.\n",
+		sBlk.s.s_major == 4 ? "" : swap ? "little endian " :
+		"big endian ", sBlk.s.s_major, sBlk.s.s_minor, source);
+#else
+	printf("Found a valid %sSQUASHFS %d:%d superblock on %s.\n",
+		sBlk.s.s_major == 4 ? "" : swap ? "big endian " :
+		"little endian ", sBlk.s.s_major, sBlk.s.s_minor, source);
+#endif
+
+	printf("Creation or last append time %s", mkfs_str ? mkfs_str :
+		"failed to get time\n");
+	printf("Filesystem size %.2f Kbytes (%.2f Mbytes)\n",
+		sBlk.s.bytes_used / 1024.0, sBlk.s.bytes_used /
+		(1024.0 * 1024.0));
+
+	if(sBlk.s.s_major == 4) {
+		printf("Compression %s\n", comp->name);
+
+		if(SQUASHFS_COMP_OPTS(sBlk.s.flags)) {
+			char buffer[SQUASHFS_METADATA_SIZE] __attribute__ ((aligned));
+			int bytes;
+
+			bytes = read_block(fd, sizeof(sBlk.s), NULL, 0, buffer);
+			if(bytes == 0) {
+				ERROR("Failed to read compressor options\n");
+				return;
+			}
+
+			compressor_display_options(comp, buffer, bytes);
+		}
+	}
+
+	printf("Block size %d\n", sBlk.s.block_size);
+	printf("Filesystem is %sexportable via NFS\n",
+		SQUASHFS_EXPORTABLE(sBlk.s.flags) ? "" : "not ");
+	printf("Inodes are %scompressed\n",
+		SQUASHFS_UNCOMPRESSED_INODES(sBlk.s.flags) ? "un" : "");
+	printf("Data is %scompressed\n",
+		SQUASHFS_UNCOMPRESSED_DATA(sBlk.s.flags) ? "un" : "");
+
+	if(sBlk.s.s_major > 1) {
+		if(SQUASHFS_NO_FRAGMENTS(sBlk.s.flags))
+			printf("Fragments are not stored\n");
+		else {
+			printf("Fragments are %scompressed\n",
+				SQUASHFS_UNCOMPRESSED_FRAGMENTS(sBlk.s.flags) ?
+				"un" : "");
+			printf("Always-use-fragments option is %sspecified\n",
+				SQUASHFS_ALWAYS_FRAGMENTS(sBlk.s.flags) ? "" :
+				"not ");
+		}
+	}
+
+	if(sBlk.s.s_major == 4) {
+		if(SQUASHFS_NO_XATTRS(sBlk.s.flags))
+			printf("Xattrs are not stored\n");
+		else
+			printf("Xattrs are %scompressed\n",
+				SQUASHFS_UNCOMPRESSED_XATTRS(sBlk.s.flags) ?
+				"un" : "");
+	}
+
+	if(sBlk.s.s_major < 4)
+			printf("Check data is %spresent in the filesystem\n",
+				SQUASHFS_CHECK_DATA(sBlk.s.flags) ? "" :
+				"not ");
+
+	if(sBlk.s.s_major > 1)
+		printf("Duplicates are %sremoved\n",
+			SQUASHFS_DUPLICATES(sBlk.s.flags) ? "" : "not ");
+	else
+		printf("Duplicates are removed\n");
+
+	if(sBlk.s.s_major > 1)
+		printf("Number of fragments %d\n", sBlk.s.fragments);
+
+	printf("Number of inodes %d\n", sBlk.s.inodes);
+
+	if(sBlk.s.s_major == 4)
+		printf("Number of ids %d\n", sBlk.s.no_ids);
+	else {
+		printf("Number of uids %d\n", sBlk.no_uids);
+		printf("Number of gids %d\n", sBlk.no_guids);
+	}
+
+	TRACE("sBlk.s.inode_table_start 0x%llx\n", sBlk.s.inode_table_start);
+	TRACE("sBlk.s.directory_table_start 0x%llx\n",
+		sBlk.s.directory_table_start);
+
+	if(sBlk.s.s_major > 1)
+		TRACE("sBlk.s.fragment_table_start 0x%llx\n\n",
+			sBlk.s.fragment_table_start);
+
+	if(sBlk.s.s_major > 2)
+		TRACE("sBlk.s.lookup_table_start 0x%llx\n\n",
+			sBlk.s.lookup_table_start);
+
+	if(sBlk.s.s_major == 4) {
+		TRACE("sBlk.s.id_table_start 0x%llx\n", sBlk.s.id_table_start);
+		TRACE("sBlk.s.xattr_id_table_start 0x%llx\n",
+			sBlk.s.xattr_id_table_start);
+	} else {
+		TRACE("sBlk.uid_start 0x%llx\n", sBlk.uid_start);
+		TRACE("sBlk.guid_start 0x%llx\n", sBlk.guid_start);
+	}
+}
+
+
+int check_compression(struct compressor *comp)
+{
+	int res, bytes = 0;
+	char buffer[SQUASHFS_METADATA_SIZE] __attribute__ ((aligned));
+
+	if(!comp->supported) {
+		ERROR("Filesystem uses %s compression, this is "
+			"unsupported by this version\n", comp->name);
+		ERROR("Decompressors available:\n");
+		display_compressors("", "");
+		return 0;
+	}
+
+	/*
+	 * Read compression options from disk if present, and pass to
+	 * the compressor to ensure we know how to decompress a filesystem
+	 * compressed with these compression options.
+	 *
+	 * Note, even if there is no compression options we still call the
+	 * compressor because some compression options may be mandatory
+	 * for some compressors.
+	 */
+	if(SQUASHFS_COMP_OPTS(sBlk.s.flags)) {
+		bytes = read_block(fd, sizeof(sBlk.s), NULL, 0, buffer);
+		if(bytes == 0) {
+			ERROR("Failed to read compressor options\n");
+			return 0;
+		}
+	}
+
+	res = compressor_check_options(comp, sBlk.s.block_size, buffer, bytes);
+
+	return res != -1;
+}
+
+
+int read_super(char *source)
+{
+	squashfs_super_block_3 sBlk_3;
+	struct squashfs_super_block sBlk_4;
+
+	/*
+	 * Try to read a Squashfs 4 superblock
+	 */
+	read_fs_bytes(fd, SQUASHFS_START, sizeof(struct squashfs_super_block),
+		&sBlk_4);
+	swap = sBlk_4.s_magic != SQUASHFS_MAGIC;
+	SQUASHFS_INSWAP_SUPER_BLOCK(&sBlk_4);
+
+	if(sBlk_4.s_magic == SQUASHFS_MAGIC && sBlk_4.s_major == 4 &&
+			sBlk_4.s_minor == 0) {
+		s_ops.squashfs_opendir = squashfs_opendir_4;
+		s_ops.read_fragment = read_fragment_4;
+		s_ops.read_fragment_table = read_fragment_table_4;
+		s_ops.read_block_list = read_block_list_2;
+		s_ops.read_inode = read_inode_4;
+		s_ops.read_uids_guids = read_uids_guids_4;
+		memcpy(&sBlk, &sBlk_4, sizeof(sBlk_4));
+
+		/*
+		 * Check the compression type
+		 */
+		comp = lookup_compressor_id(sBlk.s.compression);
+		return TRUE;
+	}
+
+	/*
+ 	 * Not a Squashfs 4 superblock, try to read a squashfs 3 superblock
+ 	 * (compatible with 1 and 2 filesystems)
+ 	 */
+	read_fs_bytes(fd, SQUASHFS_START, sizeof(squashfs_super_block_3),
+		&sBlk_3);
+
+	/*
+	 * Check it is a SQUASHFS superblock
+	 */
+	swap = 0;
+	if(sBlk_3.s_magic != SQUASHFS_MAGIC) {
+		if(sBlk_3.s_magic == SQUASHFS_MAGIC_SWAP) {
+			squashfs_super_block_3 sblk;
+			ERROR("Reading a different endian SQUASHFS filesystem "
+				"on %s\n", source);
+			SQUASHFS_SWAP_SUPER_BLOCK_3(&sblk, &sBlk_3);
+			memcpy(&sBlk_3, &sblk, sizeof(squashfs_super_block_3));
+			swap = 1;
+		} else  {
+			ERROR("Can't find a SQUASHFS superblock on %s\n",
+				source);
+			goto failed_mount;
+		}
+	}
+
+	sBlk.s.s_magic = sBlk_3.s_magic;
+	sBlk.s.inodes = sBlk_3.inodes;
+	sBlk.s.mkfs_time = sBlk_3.mkfs_time;
+	sBlk.s.block_size = sBlk_3.block_size;
+	sBlk.s.fragments = sBlk_3.fragments;
+	sBlk.s.block_log = sBlk_3.block_log;
+	sBlk.s.flags = sBlk_3.flags;
+	sBlk.s.s_major = sBlk_3.s_major;
+	sBlk.s.s_minor = sBlk_3.s_minor;
+	sBlk.s.root_inode = sBlk_3.root_inode;
+	sBlk.s.bytes_used = sBlk_3.bytes_used;
+	sBlk.s.inode_table_start = sBlk_3.inode_table_start;
+	sBlk.s.directory_table_start = sBlk_3.directory_table_start;
+	sBlk.s.fragment_table_start = sBlk_3.fragment_table_start;
+	sBlk.s.lookup_table_start = sBlk_3.lookup_table_start;
+	sBlk.no_uids = sBlk_3.no_uids;
+	sBlk.no_guids = sBlk_3.no_guids;
+	sBlk.uid_start = sBlk_3.uid_start;
+	sBlk.guid_start = sBlk_3.guid_start;
+	sBlk.s.xattr_id_table_start = SQUASHFS_INVALID_BLK;
+
+	/* Check the MAJOR & MINOR versions */
+	if(sBlk.s.s_major == 1 || sBlk.s.s_major == 2) {
+		sBlk.s.bytes_used = sBlk_3.bytes_used_2;
+		sBlk.uid_start = sBlk_3.uid_start_2;
+		sBlk.guid_start = sBlk_3.guid_start_2;
+		sBlk.s.inode_table_start = sBlk_3.inode_table_start_2;
+		sBlk.s.directory_table_start = sBlk_3.directory_table_start_2;
+		
+		if(sBlk.s.s_major == 1) {
+			sBlk.s.block_size = sBlk_3.block_size_1;
+			sBlk.s.fragment_table_start = sBlk.uid_start;
+			s_ops.squashfs_opendir = squashfs_opendir_1;
+			s_ops.read_fragment_table = read_fragment_table_1;
+			s_ops.read_block_list = read_block_list_1;
+			s_ops.read_inode = read_inode_1;
+			s_ops.read_uids_guids = read_uids_guids_1;
+		} else {
+			sBlk.s.fragment_table_start =
+				sBlk_3.fragment_table_start_2;
+			s_ops.squashfs_opendir = squashfs_opendir_1;
+			s_ops.read_fragment = read_fragment_2;
+			s_ops.read_fragment_table = read_fragment_table_2;
+			s_ops.read_block_list = read_block_list_2;
+			s_ops.read_inode = read_inode_2;
+			s_ops.read_uids_guids = read_uids_guids_1;
+		}
+	} else if(sBlk.s.s_major == 3) {
+		s_ops.squashfs_opendir = squashfs_opendir_3;
+		s_ops.read_fragment = read_fragment_3;
+		s_ops.read_fragment_table = read_fragment_table_3;
+		s_ops.read_block_list = read_block_list_2;
+		s_ops.read_inode = read_inode_3;
+		s_ops.read_uids_guids = read_uids_guids_1;
+	} else {
+		ERROR("Filesystem on %s is (%d:%d), ", source, sBlk.s.s_major,
+			sBlk.s.s_minor);
+		ERROR("which is a later filesystem version than I support!\n");
+		goto failed_mount;
+	}
+
+	/*
+	 * 1.x, 2.x and 3.x filesystems use gzip compression.
+	 */
+	comp = lookup_compressor("gzip");
+	return TRUE;
+
+failed_mount:
+	return FALSE;
+}
+
+
+struct pathname *process_extract_files(struct pathname *path, char *filename)
+{
+	FILE *fd;
+	char buffer[MAX_LINE + 1]; /* overflow safe */
+	char *name;
+
+	fd = fopen(filename, "r");
+	if(fd == NULL)
+		EXIT_UNSQUASH("Failed to open extract file \"%s\" because %s\n",
+			filename, strerror(errno));
+
+	while(fgets(name = buffer, MAX_LINE + 1, fd) != NULL) {
+		int len = strlen(name);
+
+		if(len == MAX_LINE && name[len - 1] != '\n')
+			/* line too large */
+			EXIT_UNSQUASH("Line too long when reading "
+				"extract file \"%s\", larger than %d "
+				"bytes\n", filename, MAX_LINE);
+
+		/*
+		 * Remove '\n' terminator if it exists (the last line
+		 * in the file may not be '\n' terminated)
+		 */
+		if(len && name[len - 1] == '\n')
+			name[len - 1] = '\0';
+
+		/* Skip any leading whitespace */
+		while(isspace(*name))
+			name ++;
+
+		/* if comment line, skip */
+		if(*name == '#')
+			continue;
+
+		/* check for initial backslash, to accommodate
+		 * filenames with leading space or leading # character
+		 */
+		if(*name == '\\')
+			name ++;
+
+		/* if line is now empty after skipping characters, skip it */
+		if(*name == '\0')
+			continue;
+
+		path = add_path(path, name, name);
+	}
+
+	if(ferror(fd))
+		EXIT_UNSQUASH("Reading extract file \"%s\" failed because %s\n",
+			filename, strerror(errno));
+
+	fclose(fd);
+	return path;
+}
+		
+
+/*
+ * reader thread.  This thread processes read requests queued by the
+ * cache_get() routine.
+ */
+void *reader(void *arg)
+{
+	while(1) {
+		struct cache_entry *entry = queue_get(to_reader);
+		int res = read_fs_bytes(fd, entry->block,
+			SQUASHFS_COMPRESSED_SIZE_BLOCK(entry->size),
+			entry->data);
+
+		if(res && SQUASHFS_COMPRESSED_BLOCK(entry->size))
+			/*
+			 * queue successfully read block to the inflate
+			 * thread(s) for further processing
+ 			 */
+			queue_put(to_inflate, entry);
+		else
+			/*
+			 * block has either been successfully read and is
+			 * uncompressed, or an error has occurred, clear pending
+			 * flag, set error appropriately, and wake up any
+			 * threads waiting on this buffer
+			 */
+			cache_block_ready(entry, !res);
+	}
+}
+
+
+/*
+ * writer thread.  This processes file write requests queued by the
+ * write_file() routine.
+ */
+void *writer(void *arg)
+{
+	int i;
+
+	while(1) {
+		struct squashfs_file *file = queue_get(to_writer);
+		int file_fd;
+		long long hole = 0;
+		int failed = FALSE;
+		int error;
+
+		if(file == NULL) {
+			queue_put(from_writer, NULL);
+			continue;
+		} else if(file->fd == -1) {
+			/* write attributes for directory file->pathname */
+			set_attributes(file->pathname, file->mode, file->uid,
+				file->gid, file->time, file->xattr, TRUE);
+			free(file->pathname);
+			free(file);
+			continue;
+		}
+
+		TRACE("writer: regular file, blocks %d\n", file->blocks);
+
+		file_fd = file->fd;
+
+		for(i = 0; i < file->blocks; i++, cur_blocks ++) {
+			struct file_entry *block = queue_get(to_writer);
+
+			if(block->buffer == 0) { /* sparse file */
+				hole += block->size;
+				free(block);
+				continue;
+			}
+
+			cache_block_wait(block->buffer);
+
+			if(block->buffer->error)
+				failed = TRUE;
+
+			if(failed)
+				continue;
+
+			error = write_block(file_fd, block->buffer->data +
+				block->offset, block->size, hole, file->sparse);
+
+			if(error == FALSE) {
+				ERROR("writer: failed to write data block %d\n",
+					i);
+				failed = TRUE;
+			}
+
+			hole = 0;
+			cache_block_put(block->buffer);
+			free(block);
+		}
+
+		if(hole && failed == FALSE) {
+			/*
+			 * corner case for hole extending to end of file
+			 */
+			if(file->sparse == FALSE ||
+					lseek(file_fd, hole, SEEK_CUR) == -1) {
+				/*
+				 * for files which we don't want to write
+				 * sparsely, or for broken lseeks which cannot
+				 * seek beyond end of file, write_block will do
+				 * the right thing
+				 */
+				hole --;
+				if(write_block(file_fd, "\0", 1, hole,
+						file->sparse) == FALSE) {
+					ERROR("writer: failed to write sparse "
+						"data block\n");
+					failed = TRUE;
+				}
+			} else if(ftruncate(file_fd, file->file_size) == -1) {
+				ERROR("writer: failed to write sparse data "
+					"block\n");
+				failed = TRUE;
+			}
+		}
+
+		close_wake(file_fd);
+		if(failed == FALSE)
+			set_attributes(file->pathname, file->mode, file->uid,
+				file->gid, file->time, file->xattr, force);
+		else {
+			ERROR("Failed to write %s, skipping\n", file->pathname);
+			unlink(file->pathname);
+		}
+		free(file->pathname);
+		free(file);
+
+	}
+}
+
+
+/*
+ * decompress thread.  This decompresses buffers queued by the read thread
+ */
+void *inflator(void *arg)
+{
+	char tmp[block_size];
+
+	while(1) {
+		struct cache_entry *entry = queue_get(to_inflate);
+		int error, res;
+
+		res = compressor_uncompress(comp, tmp, entry->data,
+			SQUASHFS_COMPRESSED_SIZE_BLOCK(entry->size), block_size,
+			&error);
+
+		if(res == -1)
+			ERROR("%s uncompress failed with error code %d\n",
+				comp->name, error);
+		else
+			memcpy(entry->data, tmp, res);
+
+		/*
+		 * block has been either successfully decompressed, or an error
+ 		 * occurred, clear pending flag, set error appropriately and
+ 		 * wake up any threads waiting on this block
+ 		 */ 
+		cache_block_ready(entry, res == -1);
+	}
+}
+
+
+void *progress_thread(void *arg)
+{
+	struct timespec requested_time, remaining;
+	struct itimerval itimerval;
+	struct winsize winsize;
+
+	if(ioctl(1, TIOCGWINSZ, &winsize) == -1) {
+		if(isatty(STDOUT_FILENO))
+			ERROR("TIOCGWINSZ ioctl failed, defaulting to 80 "
+				"columns\n");
+		columns = 80;
+	} else
+		columns = winsize.ws_col;
+	signal(SIGWINCH, sigwinch_handler);
+	signal(SIGALRM, sigalrm_handler);
+
+	itimerval.it_value.tv_sec = 0;
+	itimerval.it_value.tv_usec = 250000;
+	itimerval.it_interval.tv_sec = 0;
+	itimerval.it_interval.tv_usec = 250000;
+	setitimer(ITIMER_REAL, &itimerval, NULL);
+
+	requested_time.tv_sec = 0;
+	requested_time.tv_nsec = 250000000;
+
+	while(1) {
+		int res = nanosleep(&requested_time, &remaining);
+
+		if(res == -1 && errno != EINTR)
+			EXIT_UNSQUASH("nanosleep failed in progress thread\n");
+
+		if(progress_enabled) {
+			pthread_mutex_lock(&screen_mutex);
+			progress_bar(sym_count + dev_count +
+				fifo_count + cur_blocks, total_inodes -
+				total_files + total_blocks, columns);
+			pthread_mutex_unlock(&screen_mutex);
+		}
+	}
+}
+
+
+void initialise_threads(int fragment_buffer_size, int data_buffer_size)
+{
+	struct rlimit rlim;
+	int i, max_files, res;
+	sigset_t sigmask, old_mask;
+
+	/* block SIGQUIT and SIGHUP, these are handled by the info thread */
+	sigemptyset(&sigmask);
+	sigaddset(&sigmask, SIGQUIT);
+	sigaddset(&sigmask, SIGHUP);
+	if(pthread_sigmask(SIG_BLOCK, &sigmask, NULL) == -1)
+		EXIT_UNSQUASH("Failed to set signal mask in initialise_threads"
+			"\n");
+
+	/*
+	 * temporarily block these signals so the created sub-threads will
+	 * ignore them, ensuring the main thread handles them
+	 */
+	sigemptyset(&sigmask);
+	sigaddset(&sigmask, SIGINT);
+	sigaddset(&sigmask, SIGTERM);
+	if(pthread_sigmask(SIG_BLOCK, &sigmask, &old_mask) == -1)
+		EXIT_UNSQUASH("Failed to set signal mask in initialise_threads"
+			"\n");
+
+	if(processors == -1) {
+#ifndef linux
+		int mib[2];
+		size_t len = sizeof(processors);
+
+		mib[0] = CTL_HW;
+#ifdef HW_AVAILCPU
+		mib[1] = HW_AVAILCPU;
+#else
+		mib[1] = HW_NCPU;
+#endif
+
+		if(sysctl(mib, 2, &processors, &len, NULL, 0) == -1) {
+			ERROR("Failed to get number of available processors.  "
+				"Defaulting to 1\n");
+			processors = 1;
+		}
+#else
+		processors = sysconf(_SC_NPROCESSORS_ONLN);
+#endif
+	}
+
+	if(add_overflow(processors, 3) ||
+			multiply_overflow(processors + 3, sizeof(pthread_t)))
+		EXIT_UNSQUASH("Processors too large\n");
+
+	thread = malloc((3 + processors) * sizeof(pthread_t));
+	if(thread == NULL)
+		EXIT_UNSQUASH("Out of memory allocating thread descriptors\n");
+	inflator_thread = &thread[3];
+
+	/*
+	 * dimensioning the to_reader and to_inflate queues.  The size of
+	 * these queues is directly related to the amount of block
+	 * read-ahead possible.  To_reader queues block read requests to
+	 * the reader thread and to_inflate queues block decompression
+	 * requests to the inflate thread(s) (once the block has been read by
+	 * the reader thread).  The amount of read-ahead is determined by
+	 * the combined size of the data_block and fragment caches which
+	 * determine the total number of blocks which can be "in flight"
+	 * at any one time (either being read or being decompressed)
+	 *
+	 * The maximum file open limit, however, affects the read-ahead
+	 * possible, in that for normal sizes of the fragment and data block
+	 * caches, where the incoming files have few data blocks or one fragment
+	 * only, the file open limit is likely to be reached before the
+	 * caches are full.  This means the worst case sizing of the combined
+	 * sizes of the caches is unlikely to ever be necessary.  However, is is
+	 * obvious read-ahead up to the data block cache size is always possible
+	 * irrespective of the file open limit, because a single file could
+	 * contain that number of blocks.
+	 *
+	 * Choosing the size as "file open limit + data block cache size" seems
+	 * to be a reasonable estimate.  We can reasonably assume the maximum
+	 * likely read-ahead possible is data block cache size + one fragment
+	 * per open file.
+	 *
+	 * dimensioning the to_writer queue.  The size of this queue is
+	 * directly related to the amount of block read-ahead possible.
+	 * However, unlike the to_reader and to_inflate queues, this is
+	 * complicated by the fact the to_writer queue not only contains
+	 * entries for fragments and data_blocks but it also contains
+	 * file entries, one per open file in the read-ahead.
+	 *
+	 * Choosing the size as "2 * (file open limit) +
+	 * data block cache size" seems to be a reasonable estimate.
+	 * We can reasonably assume the maximum likely read-ahead possible
+	 * is data block cache size + one fragment per open file, and then
+	 * we will have a file_entry for each open file.
+	 */
+	res = getrlimit(RLIMIT_NOFILE, &rlim);
+	if (res == -1) {
+		ERROR("failed to get open file limit!  Defaulting to 1\n");
+		rlim.rlim_cur = 1;
+	}
+
+	if (rlim.rlim_cur != RLIM_INFINITY) {
+		/*
+		 * leave OPEN_FILE_MARGIN free (rlim_cur includes fds used by
+		 * stdin, stdout, stderr and filesystem fd
+		 */
+		if (rlim.rlim_cur <= OPEN_FILE_MARGIN)
+			/* no margin, use minimum possible */
+			max_files = 1;
+		else
+			max_files = rlim.rlim_cur - OPEN_FILE_MARGIN;
+	} else
+		max_files = -1;
+
+	/* set amount of available files for use by open_wait and close_wake */
+	open_init(max_files);
+
+	/*
+	 * allocate to_reader, to_inflate and to_writer queues.  Set based on
+	 * open file limit and cache size, unless open file limit is unlimited,
+	 * in which case set purely based on cache limits
+	 *
+	 * In doing so, check that the user supplied values do not overflow
+	 * a signed int
+	 */
+	if (max_files != -1) {
+		if(add_overflow(data_buffer_size, max_files) ||
+				add_overflow(data_buffer_size, max_files * 2))
+			EXIT_UNSQUASH("Data queue size is too large\n");
+
+		to_reader = queue_init(max_files + data_buffer_size);
+		to_inflate = queue_init(max_files + data_buffer_size);
+		to_writer = queue_init(max_files * 2 + data_buffer_size);
+	} else {
+		int all_buffers_size;
+
+		if(add_overflow(fragment_buffer_size, data_buffer_size))
+			EXIT_UNSQUASH("Data and fragment queues combined are"
+							" too large\n");
+
+		all_buffers_size = fragment_buffer_size + data_buffer_size;
+
+		if(add_overflow(all_buffers_size, all_buffers_size))
+			EXIT_UNSQUASH("Data and fragment queues combined are"
+							" too large\n");
+
+		to_reader = queue_init(all_buffers_size);
+		to_inflate = queue_init(all_buffers_size);
+		to_writer = queue_init(all_buffers_size * 2);
+	}
+
+	from_writer = queue_init(1);
+
+	fragment_cache = cache_init(block_size, fragment_buffer_size);
+	data_cache = cache_init(block_size, data_buffer_size);
+	pthread_create(&thread[0], NULL, reader, NULL);
+	pthread_create(&thread[1], NULL, writer, NULL);
+	pthread_create(&thread[2], NULL, progress_thread, NULL);
+	init_info();
+	pthread_mutex_init(&fragment_mutex, NULL);
+
+	for(i = 0; i < processors; i++) {
+		if(pthread_create(&inflator_thread[i], NULL, inflator, NULL) !=
+				 0)
+			EXIT_UNSQUASH("Failed to create thread\n");
+	}
+
+	printf("Parallel unsquashfs: Using %d processor%s\n", processors,
+			processors == 1 ? "" : "s");
+
+	if(pthread_sigmask(SIG_SETMASK, &old_mask, NULL) == -1)
+		EXIT_UNSQUASH("Failed to set signal mask in initialise_threads"
+			"\n");
+}
+
+
+void enable_progress_bar()
+{
+	pthread_mutex_lock(&screen_mutex);
+	progress_enabled = progress;
+	pthread_mutex_unlock(&screen_mutex);
+}
+
+
+void disable_progress_bar()
+{
+	pthread_mutex_lock(&screen_mutex);
+	if(progress_enabled) {
+		progress_bar(sym_count + dev_count + fifo_count + cur_blocks,
+			total_inodes - total_files + total_blocks, columns);
+		printf("\n");
+	}
+	progress_enabled = FALSE;
+	pthread_mutex_unlock(&screen_mutex);
+}
+
+
+void progressbar_error(char *fmt, ...)
+{
+	va_list ap;
+
+	pthread_mutex_lock(&screen_mutex);
+
+	if(progress_enabled)
+		fprintf(stderr, "\n");
+
+	va_start(ap, fmt);
+	vfprintf(stderr, fmt, ap);
+	va_end(ap);
+
+	pthread_mutex_unlock(&screen_mutex);
+}
+
+
+void progressbar_info(char *fmt, ...)
+{
+	va_list ap;
+
+	pthread_mutex_lock(&screen_mutex);
+
+	if(progress_enabled)
+		printf("\n");
+
+	va_start(ap, fmt);
+	vprintf(fmt, ap);
+	va_end(ap);
+
+	pthread_mutex_unlock(&screen_mutex);
+}
+
+void progress_bar(long long current, long long max, int columns)
+{
+	char rotate_list[] = { '|', '/', '-', '\\' };
+	int max_digits, used, hashes, spaces;
+	static int tty = -1;
+
+	if(max == 0)
+		return;
+
+	max_digits = floor(log10(max)) + 1;
+	used = max_digits * 2 + 11;
+	hashes = (current * (columns - used)) / max;
+	spaces = columns - used - hashes;
+
+	if((current > max) || (columns - used < 0))
+		return;
+
+	if(tty == -1)
+		tty = isatty(STDOUT_FILENO);
+	if(!tty) {
+		static long long previous = -1;
+
+		/*
+		 * Updating much more frequently than this results in huge
+		 * log files.
+		 */
+		if((current % 100) != 0 && current != max)
+			return;
+		/* Don't update just to rotate the spinner. */
+		if(current == previous)
+			return;
+		previous = current;
+	}
+
+	printf("\r[");
+
+	while (hashes --)
+		putchar('=');
+
+	putchar(rotate_list[rotate]);
+
+	while(spaces --)
+		putchar(' ');
+
+	printf("] %*lld/%*lld", max_digits, current, max_digits, max);
+	printf(" %3lld%%", current * 100 / max);
+	fflush(stdout);
+}
+
+
+int parse_number(char *arg, int *res)
+{
+	char *b;
+	long number = strtol(arg, &b, 10);
+
+	/* check for trailing junk after number */
+	if(*b != '\0')
+		return 0;
+
+	/*
+	 * check for strtol underflow or overflow in conversion.
+	 * Note: strtol can validly return LONG_MIN and LONG_MAX
+	 * if the user entered these values, but, additional code
+	 * to distinguish this scenario is unnecessary, because for
+	 * our purposes LONG_MIN and LONG_MAX are too large anyway
+	 */
+	if(number == LONG_MIN || number == LONG_MAX)
+		return 0;
+
+	/* reject negative numbers as invalid */
+	if(number < 0)
+		return 0;
+
+	/* check if long result will overflow signed int */
+	if(number > INT_MAX)
+		return 0;
+
+	*res = number;
+	return 1;
+}
+
+
+#define VERSION() \
+	printf("unsquashfs version 4.3 (2014/05/12)\n");\
+	printf("copyright (C) 2014 Phillip Lougher "\
+		"<phillip@squashfs.org.uk>\n\n");\
+    	printf("This program is free software; you can redistribute it and/or"\
+		"\n");\
+	printf("modify it under the terms of the GNU General Public License"\
+		"\n");\
+	printf("as published by the Free Software Foundation; either version "\
+		"2,\n");\
+	printf("or (at your option) any later version.\n\n");\
+	printf("This program is distributed in the hope that it will be "\
+		"useful,\n");\
+	printf("but WITHOUT ANY WARRANTY; without even the implied warranty of"\
+		"\n");\
+	printf("MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the"\
+		"\n");\
+	printf("GNU General Public License for more details.\n");
+int main(int argc, char *argv[])
+{
+	char *dest = "squashfs-root";
+	int i, stat_sys = FALSE, version = FALSE;
+	int n;
+	struct pathnames *paths = NULL;
+	struct pathname *path = NULL;
+	long long directory_table_end;
+	int fragment_buffer_size = FRAGMENT_BUFFER_DEFAULT;
+	int data_buffer_size = DATA_BUFFER_DEFAULT;
+
+	pthread_mutex_init(&screen_mutex, NULL);
+	root_process = geteuid() == 0;
+	if(root_process)
+		umask(0);
+	
+	for(i = 1; i < argc; i++) {
+		if(*argv[i] != '-')
+			break;
+		if(strcmp(argv[i], "-version") == 0 ||
+				strcmp(argv[i], "-v") == 0) {
+			VERSION();
+			version = TRUE;
+		} else if(strcmp(argv[i], "-info") == 0 ||
+				strcmp(argv[i], "-i") == 0)
+			info = TRUE;
+		else if(strcmp(argv[i], "-ls") == 0 ||
+				strcmp(argv[i], "-l") == 0)
+			lsonly = TRUE;
+		else if(strcmp(argv[i], "-no-progress") == 0 ||
+				strcmp(argv[i], "-n") == 0)
+			progress = FALSE;
+		else if(strcmp(argv[i], "-no-xattrs") == 0 ||
+				strcmp(argv[i], "-no") == 0)
+			no_xattrs = TRUE;
+		else if(strcmp(argv[i], "-xattrs") == 0 ||
+				strcmp(argv[i], "-x") == 0)
+			no_xattrs = FALSE;
+		else if(strcmp(argv[i], "-user-xattrs") == 0 ||
+				strcmp(argv[i], "-u") == 0) {
+			user_xattrs = TRUE;
+			no_xattrs = FALSE;
+		} else if(strcmp(argv[i], "-dest") == 0 ||
+				strcmp(argv[i], "-d") == 0) {
+			if(++i == argc) {
+				fprintf(stderr, "%s: -dest missing filename\n",
+					argv[0]);
+				exit(1);
+			}
+			dest = argv[i];
+		} else if(strcmp(argv[i], "-processors") == 0 ||
+				strcmp(argv[i], "-p") == 0) {
+			if((++i == argc) || 
+					!parse_number(argv[i],
+						&processors)) {
+				ERROR("%s: -processors missing or invalid "
+					"processor number\n", argv[0]);
+				exit(1);
+			}
+			if(processors < 1) {
+				ERROR("%s: -processors should be 1 or larger\n",
+					argv[0]);
+				exit(1);
+			}
+		} else if(strcmp(argv[i], "-data-queue") == 0 ||
+					 strcmp(argv[i], "-da") == 0) {
+			if((++i == argc) ||
+					!parse_number(argv[i],
+						&data_buffer_size)) {
+				ERROR("%s: -data-queue missing or invalid "
+					"queue size\n", argv[0]);
+				exit(1);
+			}
+			if(data_buffer_size < 1) {
+				ERROR("%s: -data-queue should be 1 Mbyte or "
+					"larger\n", argv[0]);
+				exit(1);
+			}
+		} else if(strcmp(argv[i], "-frag-queue") == 0 ||
+					strcmp(argv[i], "-fr") == 0) {
+			if((++i == argc) ||
+					!parse_number(argv[i],
+						&fragment_buffer_size)) {
+				ERROR("%s: -frag-queue missing or invalid "
+					"queue size\n", argv[0]);
+				exit(1);
+			}
+			if(fragment_buffer_size < 1) {
+				ERROR("%s: -frag-queue should be 1 Mbyte or "
+					"larger\n", argv[0]);
+				exit(1);
+			}
+		} else if(strcmp(argv[i], "-force") == 0 ||
+				strcmp(argv[i], "-f") == 0)
+			force = TRUE;
+		else if(strcmp(argv[i], "-stat") == 0 ||
+				strcmp(argv[i], "-s") == 0)
+			stat_sys = TRUE;
+		else if(strcmp(argv[i], "-lls") == 0 ||
+				strcmp(argv[i], "-ll") == 0) {
+			lsonly = TRUE;
+			short_ls = FALSE;
+		} else if(strcmp(argv[i], "-linfo") == 0 ||
+				strcmp(argv[i], "-li") == 0) {
+			info = TRUE;
+			short_ls = FALSE;
+		} else if(strcmp(argv[i], "-ef") == 0 ||
+				strcmp(argv[i], "-e") == 0) {
+			if(++i == argc) {
+				fprintf(stderr, "%s: -ef missing filename\n",
+					argv[0]);
+				exit(1);
+			}
+			path = process_extract_files(path, argv[i]);
+		} else if(strcmp(argv[i], "-regex") == 0 ||
+				strcmp(argv[i], "-r") == 0)
+			use_regex = TRUE;
+		else
+			goto options;
+	}
+
+	if(lsonly || info)
+		progress = FALSE;
+
+#ifdef SQUASHFS_TRACE
+	/*
+	 * Disable progress bar if full debug tracing is enabled.
+	 * The progress bar in this case just gets in the way of the
+	 * debug trace output
+	 */
+	progress = FALSE;
+#endif
+
+	if(i == argc) {
+		if(!version) {
+options:
+			ERROR("SYNTAX: %s [options] filesystem [directories or "
+				"files to extract]\n", argv[0]);
+			ERROR("\t-v[ersion]\t\tprint version, licence and "
+				"copyright information\n");
+			ERROR("\t-d[est] <pathname>\tunsquash to <pathname>, "
+				"default \"squashfs-root\"\n");
+			ERROR("\t-n[o-progress]\t\tdon't display the progress "
+				"bar\n");
+			ERROR("\t-no[-xattrs]\t\tdon't extract xattrs in file system"
+				NOXOPT_STR"\n");
+			ERROR("\t-x[attrs]\t\textract xattrs in file system"
+				XOPT_STR "\n");
+			ERROR("\t-u[ser-xattrs]\t\tonly extract user xattrs in "
+				"file system.\n\t\t\t\tEnables extracting "
+				"xattrs\n");
+			ERROR("\t-p[rocessors] <number>\tuse <number> "
+				"processors.  By default will use\n");
+			ERROR("\t\t\t\tnumber of processors available\n");
+			ERROR("\t-i[nfo]\t\t\tprint files as they are "
+				"unsquashed\n");
+			ERROR("\t-li[nfo]\t\tprint files as they are "
+				"unsquashed with file\n");
+			ERROR("\t\t\t\tattributes (like ls -l output)\n");
+			ERROR("\t-l[s]\t\t\tlist filesystem, but don't unsquash"
+				"\n");
+			ERROR("\t-ll[s]\t\t\tlist filesystem with file "
+				"attributes (like\n");
+			ERROR("\t\t\t\tls -l output), but don't unsquash\n");
+			ERROR("\t-f[orce]\t\tif file already exists then "
+				"overwrite\n");
+			ERROR("\t-s[tat]\t\t\tdisplay filesystem superblock "
+				"information\n");
+			ERROR("\t-e[f] <extract file>\tlist of directories or "
+				"files to extract.\n\t\t\t\tOne per line\n");
+			ERROR("\t-da[ta-queue] <size>\tSet data queue to "
+				"<size> Mbytes.  Default %d\n\t\t\t\tMbytes\n",
+				DATA_BUFFER_DEFAULT);
+			ERROR("\t-fr[ag-queue] <size>\tSet fragment queue to "
+				"<size> Mbytes.  Default\n\t\t\t\t%d Mbytes\n",
+				FRAGMENT_BUFFER_DEFAULT);
+			ERROR("\t-r[egex]\t\ttreat extract names as POSIX "
+				"regular expressions\n");
+			ERROR("\t\t\t\trather than use the default shell "
+				"wildcard\n\t\t\t\texpansion (globbing)\n");
+			ERROR("\nDecompressors available:\n");
+			display_compressors("", "");
+		}
+		exit(1);
+	}
+
+	for(n = i + 1; n < argc; n++)
+		path = add_path(path, argv[n], argv[n]);
+
+	if((fd = open(argv[i], O_RDONLY)) == -1) {
+		ERROR("Could not open %s, because %s\n", argv[i],
+			strerror(errno));
+		exit(1);
+	}
+
+	if(read_super(argv[i]) == FALSE)
+		exit(1);
+
+	if(stat_sys) {
+		squashfs_stat(argv[i]);
+		exit(0);
+	}
+
+	if(!check_compression(comp))
+		exit(1);
+
+	block_size = sBlk.s.block_size;
+	block_log = sBlk.s.block_log;
+
+	/*
+	 * Sanity check block size and block log.
+	 *
+	 * Check they're within correct limits
+	 */
+	if(block_size > SQUASHFS_FILE_MAX_SIZE ||
+					block_log > SQUASHFS_FILE_MAX_LOG)
+		EXIT_UNSQUASH("Block size or block_log too large."
+			"  File system is corrupt.\n");
+
+	/*
+	 * Check block_size and block_log match
+	 */
+	if(block_size != (1 << block_log))
+		EXIT_UNSQUASH("Block size and block_log do not match."
+			"  File system is corrupt.\n");
+
+	/*
+	 * convert from queue size in Mbytes to queue size in
+	 * blocks.
+	 *
+	 * In doing so, check that the user supplied values do not
+	 * overflow a signed int
+	 */
+	if(shift_overflow(fragment_buffer_size, 20 - block_log))
+		EXIT_UNSQUASH("Fragment queue size is too large\n");
+	else
+		fragment_buffer_size <<= 20 - block_log;
+
+	if(shift_overflow(data_buffer_size, 20 - block_log))
+		EXIT_UNSQUASH("Data queue size is too large\n");
+	else
+		data_buffer_size <<= 20 - block_log;
+
+	initialise_threads(fragment_buffer_size, data_buffer_size);
+
+	fragment_data = malloc(block_size);
+	if(fragment_data == NULL)
+		EXIT_UNSQUASH("failed to allocate fragment_data\n");
+
+	file_data = malloc(block_size);
+	if(file_data == NULL)
+		EXIT_UNSQUASH("failed to allocate file_data");
+
+	data = malloc(block_size);
+	if(data == NULL)
+		EXIT_UNSQUASH("failed to allocate data\n");
+
+	created_inode = malloc(sBlk.s.inodes * sizeof(char *));
+	if(created_inode == NULL)
+		EXIT_UNSQUASH("failed to allocate created_inode\n");
+
+	memset(created_inode, 0, sBlk.s.inodes * sizeof(char *));
+
+	if(s_ops.read_uids_guids() == FALSE)
+		EXIT_UNSQUASH("failed to uid/gid table\n");
+
+	if(s_ops.read_fragment_table(&directory_table_end) == FALSE)
+		EXIT_UNSQUASH("failed to read fragment table\n");
+
+	if(read_inode_table(sBlk.s.inode_table_start,
+				sBlk.s.directory_table_start) == FALSE)
+		EXIT_UNSQUASH("failed to read inode table\n");
+
+	if(read_directory_table(sBlk.s.directory_table_start,
+				directory_table_end) == FALSE)
+		EXIT_UNSQUASH("failed to read directory table\n");
+
+	if(no_xattrs)
+		sBlk.s.xattr_id_table_start = SQUASHFS_INVALID_BLK;
+
+	if(read_xattrs_from_disk(fd, &sBlk.s) == 0)
+		EXIT_UNSQUASH("failed to read the xattr table\n");
+
+	if(path) {
+		paths = init_subdir();
+		paths = add_subdir(paths, path);
+	}
+
+	pre_scan(dest, SQUASHFS_INODE_BLK(sBlk.s.root_inode),
+		SQUASHFS_INODE_OFFSET(sBlk.s.root_inode), paths);
+
+	memset(created_inode, 0, sBlk.s.inodes * sizeof(char *));
+	inode_number = 1;
+
+	printf("%d inodes (%d blocks) to write\n\n", total_inodes,
+		total_inodes - total_files + total_blocks);
+
+	enable_progress_bar();
+
+	dir_scan(dest, SQUASHFS_INODE_BLK(sBlk.s.root_inode),
+		SQUASHFS_INODE_OFFSET(sBlk.s.root_inode), paths);
+
+	queue_put(to_writer, NULL);
+	queue_get(from_writer);
+
+	disable_progress_bar();
+
+	if(!lsonly) {
+		printf("\n");
+		printf("created %d files\n", file_count);
+		printf("created %d directories\n", dir_count);
+		printf("created %d symlinks\n", sym_count);
+		printf("created %d devices\n", dev_count);
+		printf("created %d fifos\n", fifo_count);
+	}
+
+	return 0;
+}
